<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0CCh Blog</title>
  
  
  <link href="http://0cch.com/atom.xml" rel="self"/>
  
  <link href="http://0cch.com/"/>
  <updated>2021-10-11T02:45:35.983Z</updated>
  <id>http://0cch.com/</id>
  
  <author>
    <name>0CCh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《现代C++语言核心特性解析》上架感言</title>
    <link href="http://0cch.com/2021/10/07/moderncpp42/"/>
    <id>http://0cch.com/2021/10/07/moderncpp42/</id>
    <published>2021-10-07T01:44:05.000Z</published>
    <updated>2021-10-11T02:45:35.983Z</updated>
    
    <content type="html"><![CDATA[<p>还记得2015年的时候，在下班回家的地铁上跟好朋友聊起C++11标准引入的一系列新特性，当时我已经学习过一阵这些有趣的新功能了，所以聊天的时候也是信手拈来，也就是这个时候朋友跟我提了一句，要不你去写一本书吧。虽然当时并没有把这句话放在心上，但是也算是在心中埋藏了一颗种子。</p><p>时间一晃就到了2017年，随着C++17标准的发布，C++又引入了一大批新特性，很多特性结合在一起甚至能写出“不太像C++代码”的错觉。另外，当时的国外已经诞生一批用新标准规范写的开源代码，这让我感觉到我们是不是有些落后了。于是乎，诞生了一个写一本有关C++新标准书籍的想法。其实，作为一个读书人，写一本书的一直都有，但是就是没有好的主题，当然动力有所不足。这次似乎是一个挺好的机会，那就动笔吧。就这样从2017年到2019年，每天都会在工作之余抽出一点点时间写写文字。因为第一次写书，所以刚开始写的时候文笔非常生硬，后面慢慢的熟练起来，不过目录的顺序并不是当时写书的顺序，所以读的时候会发现有的章节写的尚可，有的读起来生硬无比。虽然后来经过了一番修改，但是书中的问题肯定还是不少（发售之后也能找到不少拼写和错别字错误）。就这样，一直写到了C++20标准的草案接近完成，当时我就在想，总不能辛辛苦苦写的书，还没到发售就已经过时了吧？这可不行，于是改变计划，加入了C++20的内容。这一加，就写到了2020年的8月。</p><p>2020年8月，书的最后一个章节编写完毕。面对整篇书稿的完工，一方面是高兴兴奋，另一方面却也非常惶恐，因为要面临找出版社的考验了。虽然我对书的内容比较有信心，但是现在C++实在不是一门流行的技术了，至少招人方面已经很难招到合适的了。一个印象很深刻的事情是，我们家在饭桌讨论找出版社的事情，我的父母都表示肯定很难，让我如果找不到也不要伤心。我的爱人鼓励我说，“即使找不到出版社，这本书咱们自己花钱也要出出来”，这也是我当时的想法，不能让心血白费了，至少得有个结果。事实情况其实比我们想象的好很多，我在9月就找了国内一家计算机方面知名的出版社分社，开始讨论了一番以后发现对方对这本书的内容并没有太大兴趣，于是和这个出版社的联系就断了。10月份的时候找到另外一家知名出版社，也就是本书现在的出版社人民邮电出版社。当时出版社的陈编辑非常热情的给我介绍了如何申报图书出版的步骤，我也按照要求把资料提供了上去，大概过了一两周的样子，编辑告诉我出版社决定出版这本书，当时可把我高兴坏了。</p><p>从2020年10月到2021年9月，出版这本书整整花了一年的时候，从一审到三审，从一校到三校，还有申请ISBN编号，每一步我都想催着陈编辑快点做完，虽然每次催都特别不好意思，但是控制不住自己啊。幸好陈编辑每次都挺耐心的，真的很nice的人。在这一年期间，我遇到另外一个贵人是《软件调试》的作者张银奎老师，我和张老师认识的挺早的，大概就是《软件调试》刚刚出版后搞的一次书友会上认识的，有过一些交流，那个时候就记住了他的邮箱地址。这个邮箱地址可就发挥的重要作用了，当这本书需要一篇序的时候，我是第一时间想到了张银奎老师，想到了这个邮箱，于是就厚着脸皮发了一份邮件，请求张老师为本书作序，没想到的是张老师爽快的答应了，并且还邀请我做了一个课程。</p><p>就是这样，《现代C++语言核心特性解析》这本书在2021年的中秋节前上架了，一时感触非常多，想感谢很多人很多事，但是不知从哪里开始怎么开始，想来想去还是写一篇文章简单记录一下这段宝贵的过程好了，于是就有了这篇文章，大概就是这样了。</p><p><img src="/uploads/2021/10/85a4c8598523e22e24ec83ca7c0d83a.jpg" alt="moderncpp"></p><p><a href="https://www.epubit.com/bookDetails?id=UB77e5a81975b11">《现代C++语言核心特性解析》的出版社链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;还记得2015年的时候，在下班回家的地铁上跟好朋友聊起C++11标准引入的一系列新特性，当时我已经学习过一阵这些有趣的新功能了，所以聊天的时候也是信手拈来，也就是这个时候朋友跟我提了一句，要不你去写一本书吧。虽然当时并没有把这句话放在心上，但是也算是在心中埋藏了一颗种子。&lt;</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>QMutex中的优化小细节</title>
    <link href="http://0cch.com/2021/09/12/optimization-details-in-qmutex/"/>
    <id>http://0cch.com/2021/09/12/optimization-details-in-qmutex/</id>
    <published>2021-09-12T11:46:53.000Z</published>
    <updated>2021-07-22T07:48:11.270Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我们要讨论的并不是<code>QMutex</code>的原理或者是应该如何使用，而是<code>QMutex</code>中一个很少被提到的优化细节。</p><p>我们知道在QT中，<code>QMutex</code>通常会和<code>QMutexLocker</code>一起使用，主要的用途是保护一个对象、数据结构或代码段，以便一次只让一个线程可以访问它们。 这一点对于多线程程序来说非常重要，而如今的程序已经离不开多线程，所以<code>QMutex</code>的使用场景也是越来越多，为了提高<code>QMutex</code>的使用效率，QT在<code>QMutex</code>的实现上加入了一个优化细节，这是<code>std::mutex</code>没有的，让我们来看看这个优化具体是什么。</p><p><code>QMutex</code>的基类<code>QBasicMutex</code>有一个类型为<code>QBasicAtomicPointer&lt;QMutexData&gt;</code>成员，这里可以先忽略<code>QBasicAtomicPointer</code>，它只是保证对指针的原子操作，正在发挥作用的是<code>QMutexData*</code>。<code>QMutexData</code>类型也没有什么特殊之处，真正的优化是在它的派生类<code>QMutexPrivate</code>，来看一段<code>QMutexPrivate</code>的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QMutexPrivate</span> :</span> <span class="keyword">public</span> QMutexData</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!refCount.<span class="built_in">deref</span>())</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QMutexPrivate::release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freelist</span>()-&gt;<span class="built_in">release</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当引用计数为0的时候调用的<code>release</code>函数并没有真正释放互斥体对象，而是调用了一个<code>freelist</code>的<code>release</code>函数。追踪<code>freelist()</code>会发现这样一段代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FreeListConstants</span> :</span> QFreeListDefaultConstants &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> BlockCount = <span class="number">4</span>, MaxIndex=<span class="number">0xffff</span> &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Sizes[BlockCount];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FreeListConstants::Sizes[FreeListConstants::BlockCount] = &#123;</span><br><span class="line">    <span class="number">16</span>,</span><br><span class="line">    <span class="number">128</span>,</span><br><span class="line">    <span class="number">1024</span>,</span><br><span class="line">    FreeListConstants::MaxIndex - (<span class="number">16</span> + <span class="number">128</span> + <span class="number">1024</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> QFreeList&lt;QMutexPrivate, FreeListConstants&gt; FreeList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> FreeList freeList_;</span><br><span class="line"><span class="function">FreeList *<span class="title">freelist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;freeList_;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下就豁然开朗了，<code>QFreeList</code>可以被认为是缓存池，用于维护<code>QMutexPrivate</code>的内存，当<code>QMutexPrivate</code>调用<code>release</code>函数的时候，QT并不会真的释放对象，而是将其加入到缓存池中，以便后续代码申请使用。这样不但可以减少内存反复分配带来的开销，也可以减少反复分配内核对象代码的开销，对于程序的性能是有所帮助的。</p><p>具体<code>QFreeList</code>的实现并不复杂，大家可以参考QT中的源代码<code>qtbase\src\corelib\tools\qfreelist_p.h</code>，另外除了<code>QMutex</code>以外，<code>QRecursiveMutex</code>和<code>QReadWriteLock</code>也用到了相同的技术。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在这篇文章中，我们要讨论的并不是&lt;code&gt;QMutex&lt;/code&gt;的原理或者是应该如何使用，而是&lt;code&gt;QMutex&lt;/code&gt;中一个很少被提到的优化细节。&lt;/p&gt;
&lt;p&gt;我们知道在QT中，&lt;code&gt;QMutex&lt;/code&gt;通常会和&lt;code&gt;QMutexLo</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>指向实现的指针Pointer to implementation</title>
    <link href="http://0cch.com/2021/08/05/pointer-to-implementation/"/>
    <id>http://0cch.com/2021/08/05/pointer-to-implementation/</id>
    <published>2021-08-05T13:25:52.000Z</published>
    <updated>2021-03-31T13:25:55.548Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章缘于我的一个朋友的故事：</p><blockquote><p>插件业务部门线上发布插件，发布之后经过用户反馈得知用户那更新插件后出现程序崩溃。检查原因是某个基础模块用导出类的方式导出接口，但是基础部门最近改动了基础模块某个类的内存布局，即头文件中类的定义发生了变化。</p></blockquote><p>导出类作为接口是一个比较考验编程经验的事情，随意的导出类很容易导致二进制兼容性问题。对于有经验的程序员一般会想到2中可行方案：</p><ol><li>定义纯虚类，实现派生类并且将所有的细节全部隐藏在派生类中，然后通过工厂类输出基类指针。典型的应用场景如Windows导出的COM接口。</li><li>使用指向实现的指针（pimpl），即这篇文章的主题。典型的应用场景如Qt。</li></ol><p>当然，使用pimpl优点并不限于上面提到的这一种，总体说来包括：</p><ol><li>解决二进制兼容性问题；</li><li>减少头文件依赖，给项目编译提速；</li><li>提供的接口文件中可以隐藏实现细节；</li><li>对于移动语义非常友好。</li></ol><p>pimpl也是有缺点的，比如：</p><ol><li>需要从额外从堆中分配内存；</li><li><code>const</code>声明会被忽略；</li></ol><p>当然这些问题都是通过一些列方法改善的。但是说到底，实现pimpl有一些细节需要特殊小心。好了，现在让我们从头开始介绍pimpl。</p><h2 id="需要隐藏的实现细节"><a href="#需要隐藏的实现细节" class="headerlink" title="需要隐藏的实现细节"></a>需要隐藏的实现细节</h2><p> 从C语言开始头文件（.h）就一直作为接口文件提供给用户，那个时候的头文件可以很轻松的隐藏实现细节，因为它们只需要对外暴露函数即可：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span> <span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>但是到了C++，头文件就很难隐藏实现细节了，因为需要将数据成员定义在类中，导致细节暴露：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// someclass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;someclass.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_someData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码暴露了类的数据成员。另外一个问题是，如果<code>SomeClass</code>引用了其他对象，那么可能需要<code>include</code>更多头文件，这样做的代价是降低了编译效率：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;A&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;B&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;C&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">    AClass m_aClass;</span><br><span class="line">    BClass m_bClass;</span><br><span class="line">    CClass m_cClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为C++的预处理器是直接用替换的方式将头文件<code>A</code>、<code>B</code>和<code>C</code>加到<code>someclass.h</code>中的。另外，无论这些头文件中哪个发生变动，都会导致任何引用<code>someclass.h</code>的源文件重新编译，非常的低效。当然，有一种解决方案是前置声明类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">    AClass *m_aClass;</span><br><span class="line">    BClass *m_bClass;</span><br><span class="line">    CClass *m_cClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样确实可以解决以上编译相关的问题，但是引入的新问题是它需要多次访问堆来分配内存，对于代码的运行效率是不利的。此外，它也没法解决暴露细节的问题。所以我们需要pimpl来帮助我们解决上述这些问题。</p><h2 id="pimpl的简单实现"><a href="#pimpl的简单实现" class="headerlink" title="pimpl的简单实现"></a>pimpl的简单实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClassPrivate</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SomeClass</span>();</span><br><span class="line">    ~<span class="built_in">SomeClass</span>();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SomeClassPrivate *m_pimpl = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// someclass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;someclass.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;A&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;B&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;C&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClassPrivate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_someData; &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">    AClass m_aClass;</span><br><span class="line">    BClass m_bClass;</span><br><span class="line">    CClass m_cClass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeClass::<span class="built_in">SomeClass</span>() : <span class="built_in">m_pimpl</span>(<span class="keyword">new</span> SomeClassPrivate) &#123;&#125;</span><br><span class="line"></span><br><span class="line">SomeClass::~<span class="built_in">SomeClass</span>() &#123; <span class="keyword">delete</span> m_pimpl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pimpl-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将之前头文件中的所有细节隐藏到<code>SomeClassPrivate</code>之中，用户对于<code>SomeClassPrivate</code>可以是一无所知的，无论怎么修改<code>SomeClassPrivate</code>的内存布局，都不会影响用户对<code>SomeClass</code>的使用，也不会存在兼容性问题。另外由于没有引入额外头文件，不会发生宏展开，对<code>A</code>、<code>B</code>和<code>C</code>头文件的修改只会让<code>someclass.cpp</code>重新编译，并不会影响其他引用<code>someclass.h</code>的源文件。又因为<code>m_aClass</code>、<code>m_bClass</code>和<code>m_cClass</code>会一次性随着<code>SomeClassPrivate</code>从堆中分配，这样就减少了两次堆访问，提高的运行效率。最后，这样的结构对移动语义非常友好：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">SomeClass</span>(SomeClass&amp;&amp; other);</span><br><span class="line">    SomeClass&amp; SomeClass::<span class="keyword">operator</span>=(SomeClass&amp;&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SomeClassPrivate *m_pimpl = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// someclass.cpp</span></span><br><span class="line">SomeClass::<span class="built_in">SomeClass</span>(SomeClass&amp;&amp; other) : <span class="built_in">m_pimpl</span>(other.m_pimpl) &#123; </span><br><span class="line">    other.m_pimpl = <span class="literal">nullptr</span>; </span><br><span class="line">&#125;</span><br><span class="line">SomeClass&amp; SomeClass::<span class="keyword">operator</span>=(SomeClass&amp;&amp; other) &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(m_pimpl, other.m_pimpl);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决pimpl存在的问题"><a href="#解决pimpl存在的问题" class="headerlink" title="解决pimpl存在的问题"></a>解决pimpl存在的问题</h2><p>上文我们提到过pimpl存在的2个问题，现在让我们看看它们是什么，并且如何解决这2个问题。</p><h3 id="额外从堆中分配内存"><a href="#额外从堆中分配内存" class="headerlink" title="额外从堆中分配内存"></a>额外从堆中分配内存</h3><p>这个问题其实容易解决，为了提高效率我们可以采用内存池来管理内存分配。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SomeClass::<span class="built_in">SomeClass</span>() : <span class="built_in">m_pimpl</span>(</span><br><span class="line">    <span class="built_in"><span class="keyword">new</span></span>(somePool::<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SomeClassPrivate))) SomeClassPrivate) &#123;&#125;</span><br><span class="line">SomeClass::~<span class="built_in">SomeClass</span>() &#123;</span><br><span class="line">    m_pimpl-&gt;~<span class="built_in">SomeClassPrivate</span>();</span><br><span class="line">    somePool::<span class="built_in">free</span>(m_pimpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const声明被忽略"><a href="#const声明被忽略" class="headerlink" title="const声明被忽略"></a><code>const</code>声明被忽略</h3><p>这是一个比较有趣的问题，让我们看看以下代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pimpl-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这里<code>foo()</code>函数被声明为<code>const</code>，说明函数中<code>this</code>的类型是<code>const SomeClass*</code>，但是这只能表示<code>m_pimpl</code>是一个<code>SomeClass * const</code>，也就是说<code>m_pimpl</code>是一个指针常量，而不是一个指向常量的指针。这导致<code>const</code>对<code>m_pimpl-&gt;foo()</code>没有任何约束能力。</p><p>为了解决这个问题，我们可以想到两种方法。</p><p>首先可以仿造Qt的代码实现两个代理函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> SomeClassPrivate * <span class="title">SomeClass::d_func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_pimpl; &#125;</span><br><span class="line"><span class="function">SomeClassPrivate * <span class="title">SomeClass::d_func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_pimpl; &#125;</span><br></pre></td></tr></table></figure><p>通过这种方式获取对象指针能传递将函数的<code>const</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClassPrivate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_someData; &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">d_func</span>()-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Qt中有一个宏来实现这个方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_PRIVATE(Class) \</span></span><br><span class="line"><span class="meta">    inline Class##Private* d_func() \</span></span><br><span class="line"><span class="meta">    &#123; Q_CAST_IGNORE_ALIGN(return reinterpret_cast<span class="meta-string">&lt;Class##Private *&gt;</span>(qGetPtrHelper(d_ptr));) &#125; \</span></span><br><span class="line"><span class="meta">    inline const Class##Private* d_func() const \</span></span><br><span class="line"><span class="meta">    &#123; Q_CAST_IGNORE_ALIGN(return reinterpret_cast<span class="meta-string">&lt;const Class##Private *&gt;</span>(qGetPtrHelper(d_ptr));) &#125; \</span></span><br><span class="line"><span class="meta">    friend class Class##Private;</span></span><br></pre></td></tr></table></figure><p>另外一个方法是使用<code>std::experimental::propagate_const</code>，不过该方法还在C ++库基础技术规范第二版（ C++ <em>Library Fundamentals</em> Technical Specification V2）中，还没有正式加入STL。不过原理非常简单：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">propagate_const</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">propagate_const</span><span class="params">( T * t )</span> : p( t ) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">const</span> T &amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *p; &#125;</span><br><span class="line">    T &amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *p; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> T * <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">    T * <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    propagate_const&lt;SomeClassPrivate&gt; m_pimpl</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方式比<code>d_func</code>要繁琐一些，但有一个好处是程序员无法直接使用原生的<code>SomeClassPrivate*</code>，而<code>d_func</code>却没法控制，必须依靠代码规范约束每个程序员。</p><h2 id="一个使用pimpl值得注意的问题"><a href="#一个使用pimpl值得注意的问题" class="headerlink" title="一个使用pimpl值得注意的问题"></a>一个使用pimpl值得注意的问题</h2><p>当使用pimpl的时候如果有<code>SomeClassPrivate</code>中调用<code>SomeClass</code>成员函数的需求，需要将<code>SomeClass</code>的<code>this</code>指针传入<code>SomeClassPrivate</code>。这很简单啊！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;someclass.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClassPrivate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SomeClassPrivate</span>(SomeClass* p) : <span class="built_in">m_pub</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_someData; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123; m_pub-&gt;<span class="built_in">bar</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">    SomeClass* m_pub = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeClass::<span class="built_in">SomeClass</span>() : <span class="built_in">m_pimpl</span>(<span class="keyword">new</span> <span class="built_in">SomeClassPrivate</span>(<span class="keyword">this</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">SomeClass::~<span class="built_in">SomeClass</span>() &#123; <span class="keyword">delete</span> m_pimpl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pimpl-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错！请记住，当<code>SomeClass</code>正在构造的时候，传递<code>this</code>指针是非常不安全的，可能造成未定义的行为。正确的做法是在初始化列表完成以后再给<code>m_pub</code>赋值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;someclass.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClassPrivate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SomeClassPrivate</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_someData; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123; m_pub-&gt;<span class="built_in">bar</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(SomeClass* p)</span> </span>&#123; m_pub = p; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">    SomeClass* m_pub = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeClass::<span class="built_in">SomeClass</span>() : <span class="built_in">m_pimpl</span>(<span class="keyword">new</span> SomeClassPrivate) &#123;</span><br><span class="line">    m_pimpl-&gt;<span class="built_in">init</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SomeClass::~<span class="built_in">SomeClass</span>() &#123; <span class="keyword">delete</span> m_pimpl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pimpl-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>m_pimpl</code>一样，<code>m_pub</code>也应该用<code>propagate_const</code>来包装。当然也可以实现类似<code>d_func</code>的函数。比如Qt就是通过定义一组<code>q_func</code>来实现的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_PUBLIC(Class)                                    \</span></span><br><span class="line"><span class="meta">    inline Class* q_func() &#123; return static_cast<span class="meta-string">&lt;Class *&gt;</span>(q_ptr); &#125; \</span></span><br><span class="line"><span class="meta">    inline const Class* q_func() const &#123; return static_cast<span class="meta-string">&lt;const Class *&gt;</span>(q_ptr); &#125; \</span></span><br><span class="line"><span class="meta">    friend class Class;</span></span><br></pre></td></tr></table></figure><p>好了，关于pimpl的内容我要写的就这么多了，如果pimpl还有其他有趣的技巧欢迎发邮件与我交流。最后说一句：“基础部门赶紧把二进制兼容问题解决掉呀！”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写这篇文章缘于我的一个朋友的故事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;插件业务部门线上发布插件，发布之后经过用户反馈得知用户那更新插件后出现程序崩溃。检查原因是某个基础模块用导出类的方式导出接口，但是基础部门最近改动了基础模块某个类的内存布局，即头文件中类的定义发生了</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>Qt的隐式共享和写时拷贝</title>
    <link href="http://0cch.com/2021/07/11/qt-implicit-sharing-copy-on-write/"/>
    <id>http://0cch.com/2021/07/11/qt-implicit-sharing-copy-on-write/</id>
    <published>2021-07-11T10:18:12.000Z</published>
    <updated>2021-03-30T10:19:05.573Z</updated>
    
    <content type="html"><![CDATA[<p>不得不说Qt为了提高代码的运行效率做了很多伟大的工作，引入隐式共享和写时拷贝技术就是其中之一。该技术十分值得我们学习，一方面是因为它也可以运用到我们的代码中提高代码的运行效率，另一方面我们在理解其原理之后才能够更加高效的使用Qt。</p><p>Qt中的隐式共享是指类中存在一个共享数据块指针，改数据块由数据和引用技术组成。</p><ul><li>当类型对象被创建时，共享数据块也被创建，并且设置引用技术为1。</li><li>当类型对象发生拷贝时，共享数据块共享其指针，并且递增引用计数（+1）。</li><li>当类型对象销毁时，共享数据块引用技术递减（-1），当引用计数归零时销毁数据块。</li><li>当类型对象调用方法有可能被修改时，采用写时拷贝机制，创建真正对象副本。</li></ul><p>使用隐式共享和写时拷贝的好处非常明显，在只读的情况下，拷贝对象的内存和CPU计算成本非常低。只有在真正修改对象的时候，才会发生对象拷贝。除了Qt中的普通类型以外，Qt的容器类型也大量采用了这种技术，这也是Qt容器和STL容器的一个显著的区别。</p><p>来看一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class QPenPrivate *d</span></span><br><span class="line"></span><br><span class="line">QPen::<span class="built_in">QPen</span>(<span class="keyword">const</span> QPen &amp;p) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    d = p.d;</span><br><span class="line">    <span class="keyword">if</span> (d)</span><br><span class="line">        d-&gt;ref.<span class="built_in">ref</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QPen::~<span class="built_in">QPen</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &amp;&amp; !d-&gt;ref.<span class="built_in">deref</span>())</span><br><span class="line">        <span class="keyword">delete</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QPen::detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ref.<span class="built_in">loadRelaxed</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    QPenData *x = <span class="keyword">new</span> <span class="built_in">QPenData</span>(*<span class="keyword">static_cast</span>&lt;QPenData *&gt;(d));</span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;ref.<span class="built_in">deref</span>())</span><br><span class="line">        <span class="keyword">delete</span> d;</span><br><span class="line">    x-&gt;ref.<span class="built_in">storeRelaxed</span>(<span class="number">1</span>);</span><br><span class="line">    d = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QPen::setStyle</span><span class="params">(Qt::PenStyle s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;style == s)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">detach</span>();</span><br><span class="line">    d-&gt;style = s;</span><br><span class="line">    QPenData *dd = <span class="keyword">static_cast</span>&lt;QPenData *&gt;(d);</span><br><span class="line">    dd-&gt;dashPattern.<span class="built_in">clear</span>();</span><br><span class="line">    dd-&gt;dashOffset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>Pen</code>的拷贝构造函数只是将共享数据块指针从<code>p</code>赋值到当前对象，然后增加其引用计数。当对象析构时，首先减少引用计数，然后判断引用计数是否归零，如果条件成立则释放对象。当调用<code>setStyle</code>函数修改对象的时候，函数调用了一个<code>detach</code>函数，这个<code>detach</code>函数检查当前的引用计数，若引用计数为1，证明没有共享数据块，可以直接修改数据。反之引用计数不为1，则证明存在共享改数据块的类，无法直接修改数据，需要拷贝一份新的数据。</p><p>现在看来，Qt似乎已经为我们考虑的十分周到了，不调用修改对象的函数是不会发生真正的拷贝的。那么需要我们做什么呢？答案是，Qt的使用者应该尽可能的避免误操作导致的数据拷贝。前面提到过，Qt认为可能发生写对象的操作都会真实的拷贝对象，其中要给典型的情况是：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line"><span class="keyword">int</span>* p = test2.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure><p>这里看起来并没有发生对象的写操作，但是数据拷贝还是发生了，因为Qt认为这是一个可能发生写数据的操作，所以在调用<code>data()</code>的时候就调用了<code>detach()</code>函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> T *<span class="title">data</span><span class="params">()</span> </span>&#123; <span class="built_in">detach</span>(); <span class="keyword">return</span> d-&gt;<span class="built_in">begin</span>(); &#125;</span><br></pre></td></tr></table></figure><p>如果确定不会修改对象的数据应该明确告知编译器：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test3 = test1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = test2.<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* q = test3.<span class="built_in">constData</span>();</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T *<span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d-&gt;<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T *<span class="title">constData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d-&gt;<span class="built_in">begin</span>(); &#125;</span><br></pre></td></tr></table></figure><p>它们都不会调用<code>detach</code>函数拷贝对象。还是C++编程老生常谈那句话：在确定不修改对象的时候总是使用<code>const</code>来声明它，以便编译器对其做优化处理。</p><p>有时候我们并不是完全弄清楚编程环境中具体发生了什么，比如你可能不知道Qt的隐式共享和写时拷贝，但是保持良好的编程习惯，比如对于不修改的对象声明为<code>const</code>，有时候可以在不经意间优化了编写的代码，何乐而不为呢。</p><p>值得注意的是，我们应该尽量避免直接引用并通过引用修改Qt容器中的对象。千万不要这么做，因为可能会得到你不想看到的结果，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line"><span class="keyword">int</span>&amp; v = test1[<span class="number">1</span>];</span><br><span class="line">v = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>这份代码不会出现问题，因为当表达式<code>test2 = test1</code>运行时，共享数据的引用计数递增为2，当调用<code>operator []</code>的时候由于<code>test1</code>不是<code>const</code>，所以会为<code>test1</code>拷贝一份副本。最后结果是：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">test1[<span class="number">1</span>] == <span class="number">20</span>;</span><br><span class="line">test2[<span class="number">1</span>] == <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这样看来没有问题，但不幸的是我们有时候也会这样写：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>&amp; v = test1[<span class="number">1</span>];</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line">v = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>上面这份代码会带来一个意想不到的结果：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">test1[<span class="number">1</span>] == <span class="number">20</span>;</span><br><span class="line">test2[<span class="number">1</span>] == <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>因为在运行<code>int&amp; v = test1[1];</code>这句代码的时候，数据块的引用计数为1，<code>detach</code>函数认为数据块没有共享，所以无需拷贝数据。当执行<code>test2 = test1</code>的时候，Qt并不知道之前发生了什么，所以仅仅增加了引用计数，所以修改<code>v</code>同时修改了<code>test1</code>和<code>test2</code>。这不是我们想看到的结果，所以我们应该怎么做？注意代码执行的顺序么？得了吧，即使能保证自己会注意到代码的执行顺序问题，也不能保证其他人修改你的代码时会怎么做，最好的做法是告诉大家，我们的项目有一条规则——禁止直接引用并通过引用修改Qt容器中的对象！或者干脆，使用STL的容器吧。</p><p>最后，如果觉得Qt的隐式共享和写时拷贝技术很不错，碰巧你的项目的编写环境中也有Qt，那么使用<code>QSharedData</code>和<code>QSharedDataPointer</code>会让你的工作轻松很多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不得不说Qt为了提高代码的运行效率做了很多伟大的工作，引入隐式共享和写时拷贝技术就是其中之一。该技术十分值得我们学习，一方面是因为它也可以运用到我们的代码中提高代码的运行效率，另一方面我们在理解其原理之后才能够更加高效的使用Qt。&lt;/p&gt;
&lt;p&gt;Qt中的隐式共享是指类中存在</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Q_DECLARE_TYPEINFO让Qt优化容器算法</title>
    <link href="http://0cch.com/2021/06/15/use-Q_DECLARE_TYPEINFO-to-optimize-the-container/"/>
    <id>http://0cch.com/2021/06/15/use-Q_DECLARE_TYPEINFO-to-optimize-the-container/</id>
    <published>2021-06-15T03:39:02.000Z</published>
    <updated>2021-03-30T03:39:36.834Z</updated>
    
    <content type="html"><![CDATA[<p>如果需要使用Qt容器，那么使用<code>Q_DECLARE_TYPEINFO</code>让Qt了解容器内元素的类型特征是一个不错的做法。因为Qt可以通过识别<code>Q_DECLARE_TYPEINFO</code>给定的类型特征，在容器中采用不同的算法和内存模型以达到计算速度和内存使用上的优化。</p><p><code>Q_DECLARE_TYPEINFO(Type, Flags)</code>的使用非常简单，在定义了数据结构之后，通过指定类型名和枚举标识来指定这个类型特征，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(Point2D, Q_PRIMITIVE_TYPE);</span><br></pre></td></tr></table></figure><ul><li><code>Q_PRIMITIVE_TYPE</code>指定Type是没有构造函数或析构函数的POD(plain old data) 类型，并且<code>memcpy()</code>可以这种类型创建有效的独立副本的对象。</li><li><code>Q_MOVABLE_TYPE</code>指定Type具有构造函数或析构函数，但可以使用<code>memcpy()</code>在内存中移动。注意：尽管有叫做move，但是这个和移动构造函数或移动语义无关。</li><li><code>Q_COMPLEX_TYPE</code>（默认值）指定Type具有构造函数和析构函数，并且可能不会在内存中移动。</li></ul><p>再来看看<code>Q_DECLARE_TYPEINFO</code>的具体实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QTypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        isSpecialized = std::is_enum&lt;T&gt;::value, <span class="comment">// don&#x27;t require every enum to be marked manually</span></span><br><span class="line">        isPointer = <span class="literal">false</span>,</span><br><span class="line">        isIntegral = std::is_integral&lt;T&gt;::value,</span><br><span class="line">        isComplex = !qIsTrivial&lt;T&gt;(),</span><br><span class="line">        isStatic = <span class="literal">true</span>,</span><br><span class="line">        isRelocatable = qIsRelocatable&lt;T&gt;(),</span><br><span class="line">        isLarge = (<span class="built_in"><span class="keyword">sizeof</span></span>(T)&gt;<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*)),</span><br><span class="line">        isDummy = <span class="literal">false</span>, </span><br><span class="line">        sizeOf = <span class="built_in"><span class="keyword">sizeof</span></span>(T)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_TYPEINFO_BODY(TYPE, FLAGS) \</span></span><br><span class="line"><span class="meta">class QTypeInfo<span class="meta-string">&lt;TYPE &gt;</span> \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    enum &#123; \</span></span><br><span class="line"><span class="meta">        isSpecialized = true, \</span></span><br><span class="line"><span class="meta">        isComplex = (((FLAGS) &amp; Q_PRIMITIVE_TYPE) == 0) &amp;&amp; !qIsTrivial<span class="meta-string">&lt;TYPE&gt;</span>(), \</span></span><br><span class="line"><span class="meta">        isStatic = (((FLAGS) &amp; (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), \</span></span><br><span class="line"><span class="meta">        isRelocatable = !isStatic || ((FLAGS) &amp; Q_RELOCATABLE_TYPE) || qIsRelocatable<span class="meta-string">&lt;TYPE&gt;</span>(), \</span></span><br><span class="line"><span class="meta">        isLarge = (sizeof(TYPE)&gt;sizeof(void*)), \</span></span><br><span class="line"><span class="meta">        isPointer = false, \</span></span><br><span class="line"><span class="meta">        isIntegral = std::is_integral<span class="meta-string">&lt; TYPE &gt;</span>::value, \</span></span><br><span class="line"><span class="meta">        isDummy = (((FLAGS) &amp; Q_DUMMY_TYPE) != 0), \</span></span><br><span class="line"><span class="meta">        sizeOf = sizeof(TYPE) \</span></span><br><span class="line"><span class="meta">    &#125;; \</span></span><br><span class="line"><span class="meta">    static inline const char *name() &#123; return #TYPE; &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_TYPEINFO(TYPE, FLAGS) \</span></span><br><span class="line"><span class="meta">template<span class="meta-string">&lt;&gt;</span> \</span></span><br><span class="line"><span class="meta">Q_DECLARE_TYPEINFO_BODY(TYPE, FLAGS)</span></span><br></pre></td></tr></table></figure><p>可以看出<code>Q_DECLARE_TYPEINFO</code>是一个典型的模板特化和模板enum hack结合的例子，代码使用宏<code>Q_DECLARE_TYPEINFO_BODY</code>定义了一个<code>QTypeInfo</code>的特化版本<code>class QTypeInfo&lt;TYPE &gt;</code>，并且使用定义给定的标志，计算出了一系列枚举值，例如<code>isComplex</code>、<code>isStatic</code>等。</p><p>Qt预定义了自己类型的<code>QTypeInfo</code>以便让它们在容器中获得更高的处理效率，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">bool</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">char</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">signed</span> <span class="keyword">char</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(uchar, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">short</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(ushort, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">int</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(uint, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">long</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(ulong, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(qint64, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(quint64, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">float</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">double</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">long</span> <span class="keyword">double</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">char16_t</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">char32_t</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">wchar_t</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">long</span> <span class="keyword">double</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QFileSystemWatcherPathKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QLoggingRule, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QProcEnvKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QProcEnvValue, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QResourceRoot, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QConfFileCustomFormat, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsIniKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsIniSection, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsGroup, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QModelIndex, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QItemSelectionRange, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QBasicTimer, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(pollfd, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSocketNotifierSetUNIX, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(Variable, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QMetaMethod, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QMetaEnum, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QMetaClassInfo, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QArgumentType, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QCustomTypeInfo, Q_MOVABLE_TYPE);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Qt容器类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QList);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QVector);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QQueue);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QStack);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QSet);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QMap);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QMultiMap);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QHash);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QMultiHash);</span><br></pre></td></tr></table></figure><p>最后让我们来看看Qt容器如何利用<code>QTypeInfo</code>来优化容器算法的。以我们之前介绍过的<code>QList</code>为例，<code>QList</code>会因为类型大小的不同采用不同的内存布局和构造方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Q_INLINE_TEMPLATE <span class="keyword">void</span> QList&lt;T&gt;::<span class="built_in">node_construct</span>(Node *n, <span class="keyword">const</span> T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) n-&gt;v = <span class="keyword">new</span> <span class="built_in">T</span>(t);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isComplex) <span class="built_in"><span class="keyword">new</span></span> (n) <span class="built_in">T</span>(t);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__IBMCPP__)) &amp;&amp; !defined(__OPTIMIZE__)</span></span><br><span class="line">    <span class="keyword">else</span> *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(n) = t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">else</span> ::<span class="built_in">memcpy</span>(n, <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;(&amp;t), <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Q_INLINE_TEMPLATE <span class="keyword">void</span> QList&lt;T&gt;::<span class="built_in">node_destruct</span>(Node *n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) <span class="keyword">delete</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(n-&gt;v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isComplex) <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(n)-&gt;~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Q_INLINE_TEMPLATE <span class="keyword">void</span> QList&lt;T&gt;::<span class="built_in">node_copy</span>(Node *from, Node *to, Node *src)</span><br><span class="line">&#123;</span><br><span class="line">    Node *current = from;</span><br><span class="line">    <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) &#123;</span><br><span class="line">        QT_TRY &#123;</span><br><span class="line">            <span class="keyword">while</span>(current != to) &#123;</span><br><span class="line">                current-&gt;v = <span class="keyword">new</span> <span class="built_in">T</span>(*<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(src-&gt;v));</span><br><span class="line">                ++current;</span><br><span class="line">                ++src;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">QT_CATCH</span>(...) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current-- != from)</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(current-&gt;v);</span><br><span class="line">            QT_RETHROW;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isComplex) &#123;</span><br><span class="line">        QT_TRY &#123;</span><br><span class="line">            <span class="keyword">while</span>(current != to) &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">new</span></span> (current) <span class="built_in">T</span>(*<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(src));</span><br><span class="line">                ++current;</span><br><span class="line">                ++src;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">QT_CATCH</span>(...) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current-- != from)</span><br><span class="line">                (<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(current))-&gt;~<span class="built_in">T</span>();</span><br><span class="line">            QT_RETHROW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (src != from &amp;&amp; to - from &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(from, src, (to - from) * <span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上代码可以看出，<code>QList</code>根据<code>QTypeInfo</code>中<code>isLarge</code>、<code>isStatic</code>和<code>isComplex</code>的不同采用不同的构造析构和拷贝方法。以构造为例，当表达式<code>QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic</code>计算结果为<code>true</code>时，<code>QList</code>从堆里分配新内存并且构造对象存储在<code>node</code>中。当<code>QTypeInfo&lt;T&gt;::isComplex</code>的计算结果为<code>true</code>时，<code>QList</code>采用Placement new的方式直接使用<code>node</code>内存构造对象。除此之外则简单粗暴的拷贝内存到<code>node</code>内存上。析构和拷贝也有相似处理，阅读代码很容易理解其中的含义。</p><p>我们应该怎么做？Qt默认情况下会认为类型特征<code>isStatic</code>为<code>true</code>，这会导致一些不必要的性能下降，例如<code>QList</code>会无视类型大小，采用从堆重新分配内存构造对象。所以我们应该做的是充分理解我们的对象类型是否可以安全的移动，如果可以移动请使用<code>Q_DECLARE_TYPEINFO(TYPE, Q_MOVABLE_TYPE);</code>告知Qt，这样当对象长度小于指针长度的时候，Qt可以避免访问堆来分配内存，并且直接利用已有内存，对于频繁发生的小尺寸对象的操作这种优化是非常巨大的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Run on (8 X 3600 MHz CPU s)</span><br><span class="line">CPU Caches:</span><br><span class="line">  L1 Data 32 KiB (x4)</span><br><span class="line">  L1 Instruction 32 KiB (x4)</span><br><span class="line">  L2 Unified 256 KiB (x4)</span><br><span class="line">  L3 Unified 8192 KiB (x1)</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Benchmark                                         Time             CPU   Iterations</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">BM_QListPushString/iterations:10000000          152 ns          150 ns     10000000</span><br><span class="line">BM_QVectorPushString/iterations:10000000        102 ns          102 ns     10000000</span><br><span class="line">BM_QListPushChar/iterations:10000000           12.2 ns         12.5 ns     10000000</span><br><span class="line">BM_QVectorPushChar/iterations:10000000         4.92 ns         4.69 ns     10000000</span><br></pre></td></tr></table></figure><p>详细可以阅读前面的文章《<code>QList</code> 的工作原理和运行效率浅析》。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果需要使用Qt容器，那么使用&lt;code&gt;Q_DECLARE_TYPEINFO&lt;/code&gt;让Qt了解容器内元素的类型特征是一个不错的做法。因为Qt可以通过识别&lt;code&gt;Q_DECLARE_TYPEINFO&lt;/code&gt;给定的类型特征，在容器中采用不同的算法和内存模型以达</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>QList 的工作原理和运行效率浅析</title>
    <link href="http://0cch.com/2021/05/29/the-working-principle-of-qlist/"/>
    <id>http://0cch.com/2021/05/29/the-working-principle-of-qlist/</id>
    <published>2021-05-29T09:34:16.000Z</published>
    <updated>2021-03-29T09:35:29.427Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道Qt为了在一些没有STL的环境中运作，开发了一套相对完整的容器。大部分Qt的容器我们都能够招到对应STL容器，例如<code>QVector</code>对应<code>std::vector</code>, <code>QMap</code>对应<code>std::map</code>，不过这其中也有一些特例，例如<code>QList</code>在STL中就没有应该的容器，<code>std::list</code>对应的Qt容器实际上是<code>QLinkedList</code>。所以在使用<code>QList</code>的时候请务必弄清楚这一点，否则可能会导致程序的运行效率的低下，让我们先看一份代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;benchmark/benchmark.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qlist&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qvector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> std::string test_buffer&#123; <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ITER_COUNTS = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QListPushString</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QList&lt;std::string&gt; test_qlist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qlist.<span class="built_in">push_back</span>(test_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QListPushString)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QVectorPushString</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QVector&lt;std::string&gt; test_qvector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qvector.<span class="built_in">push_back</span>(test_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QVectorPushString)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QListPushChar</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QList&lt;<span class="keyword">char</span>&gt; test_qlist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qlist.<span class="built_in">push_back</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QListPushChar)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QVectorPushChar</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QVector&lt;<span class="keyword">char</span>&gt; test_qvector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qvector.<span class="built_in">push_back</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QVectorPushChar)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK_MAIN</span>();</span><br></pre></td></tr></table></figure><p>以上代码使用google benchmark统计<code>QList</code>和<code>QVector</code>的运行效率，代码采用的最简单的<code>push_back</code>函数测试两种容器对于小数据和相对较大数据的处理性能。结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Run on (8 X 3600 MHz CPU s)</span><br><span class="line">CPU Caches:</span><br><span class="line">  L1 Data 32 KiB (x4)</span><br><span class="line">  L1 Instruction 32 KiB (x4)</span><br><span class="line">  L2 Unified 256 KiB (x4)</span><br><span class="line">  L3 Unified 8192 KiB (x1)</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Benchmark                                         Time             CPU   Iterations</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">BM_QListPushString/iterations:10000000          152 ns          150 ns     10000000</span><br><span class="line">BM_QVectorPushString/iterations:10000000        102 ns          102 ns     10000000</span><br><span class="line">BM_QListPushChar/iterations:10000000           12.2 ns         12.5 ns     10000000</span><br><span class="line">BM_QVectorPushChar/iterations:10000000         4.92 ns         4.69 ns     10000000</span><br></pre></td></tr></table></figure><p>可以发现<code>QVector</code>在两种情况下的性能都占优，尤其是<code>PushChar</code>的情况优势更加明显。原因就要从<code>QList</code>的原理说起了。前面说过<code>QList</code>并不是一个链表链接的结构，它的实际结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       QListData                                 +--------------------+</span><br><span class="line">                                                 |                    |</span><br><span class="line">+------------------------+                       |      obj buffer 1  |</span><br><span class="line">|                        |                       |                    |</span><br><span class="line">|      ptr to buffer 1   +-----------------------&gt;                    |</span><br><span class="line">|                        |                       +--------------------+</span><br><span class="line">+------------------------+</span><br><span class="line">|                        |                       +--------------------+</span><br><span class="line">|      ptr to buffer 2   |                       |                    |</span><br><span class="line">|                        +-----------------------&gt;      obj buffer 2  |</span><br><span class="line">+------------------------+                       |                    |</span><br><span class="line">|                        |                       |                    |</span><br><span class="line">|           .            |                       +--------------------+</span><br><span class="line">|           .            |</span><br><span class="line">|           .            |</span><br><span class="line">|                        |</span><br><span class="line">+------------------------+</span><br><span class="line">|                        |                       +--------------------+</span><br><span class="line">|                        |                       |                    |</span><br><span class="line">|      ptr to buffer N   +-----------------------&gt;                    |</span><br><span class="line">|                        |                       |      obj buffer N  |</span><br><span class="line">+------------------------+                       |                    |</span><br><span class="line">                                                 +--------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它的内部维护了一个指针（void*）的数组，该数组指向了真正的对象，它就像是一个<code>vector</code>和<code>list</code>的结合体一样。在对象占用内存大的时候（大于<code>sizeof(void*)</code>），它每次会从堆中分配内存。然后将内存的起始地址放入数组中。相对于<code>QVector</code>慢的原因是它每次都要经过堆分配内存，而<code>QVector</code>可以预分配内存从而提高<code>push_back</code>的运行效率。而对于小内存对象，他直接将其存储到数组中，这样不需要经过堆分配内存，所以相对于大内存<code>QList</code>本身也有很大的性能提升，但是由于它每次需要用到<code>sizeof(void*)</code>的内存，也会导致更多的内存分配，所以运行效率还是不如<code>QVector</code>。</p><p>当然，<code>QList</code>也有自己的优势，例如当对占用大内存对象进行重新排续的时候，<code>QVector</code>只能进行大量内存移动，而<code>QList</code>则只需要移动对象指针即可。相对于<code>std::list</code>，<code>QList</code>在单纯的<code>push_back</code>和枚举的时候也有不错的表现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道Qt为了在一些没有STL的环境中运作，开发了一套相对完整的容器。大部分Qt的容器我们都能够招到对应STL容器，例如&lt;code&gt;QVector&lt;/code&gt;对应&lt;code&gt;std::vector&lt;/code&gt;, &lt;code&gt;QMap&lt;/code&gt;对应&lt;code&gt;std</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>STL中并行算法</title>
    <link href="http://0cch.com/2021/04/05/parallel-algorithm-in-stl/"/>
    <id>http://0cch.com/2021/04/05/parallel-algorithm-in-stl/</id>
    <published>2021-04-05T03:04:49.000Z</published>
    <updated>2021-02-04T03:35:21.021Z</updated>
    
    <content type="html"><![CDATA[<p>C++17标准的一个重大突破是让标准库中的部分算法支持了并行计算，这对于无处不在的多线程环境来说无疑是一个非常不错的消息。具体支持并行计算的算法可以参考提案文档<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html#algorithms.parallel.overloads">p0024r2</a>。</p><p>接下来将会选取两个典型算法函数对STL的并行算法进行介绍：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::for_each(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">            val *= val;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是一个最简单的并行计算例子，例子中使用了<code>for_each</code>函数，该函数并不是新加入到标准库的。只不过现在多了一个并行计算的版本，其中第一个参数是并行计算的策略。实际上，大部分并行计算的算法都是在原有算法的基础做了新增，它们的共同特点是第一个参数改为了并行计算策略，当然老的算法也依然存在。在这个例子中，策略<code>std::execution::par</code>是并行计算其中的一种策略。在这个策略中函数会使用多线程执行算法，并且线程在执行算法的单个步骤是不会被打断的。为了看清线程的执行情况，我们可以将线程id输出到控制台：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::for_each(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            val *= val;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这份代码就会发现线程id交替输出到控制台上，可见确实是多线程执行<code>for_each</code>函数。让我们再看看排序函数<code>std::sort</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; val2) &#123;</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这份代码同样的会发现多个线程交替输出线程id到控制台上，实际上它们正在并行计算排续该容器。并行计算的优势在数据量足够大的时候是非常明显的，比如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::<span class="built_in">sort</span>(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; val2) &#123;</span><br><span class="line">            <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; diff = end - start;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;elapsed time = &quot;</span> &lt;&lt; diff.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向排序100000个数，使用并行算法在我的机器上消耗了0.48秒。如果删除第一个参数使用传统单线程排续，在我的机器上消耗0.89秒，并行计算性能提升近1倍。</p><p>最后来介绍一下C++17中的3种并行计算策略：</p><ul><li><p><code>std::execution::seq</code> 该策略与非并行算法一样，当前执行线程逐个元素依次执行必要的操作。 使用该策略的行为类似于使用完全不接受任何执行策略的非并行调用算法的方式。</p></li><li><p><code>std::execution::par</code> 该策略会让多个线程执行元素的必要操作。 当算法开始执行必要的操作时，它会一直执行到操作结束，不会被打断。</p></li><li><p><code>std::execution::par_unseq</code> 该策略会让多个线程执行元素的必要操作，但是与<code>std::execution::par</code>不同的是，该策略不能保证一个线程执行完该元素的所有步骤而不被打断。在提案文档中也指出了错误示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">std::for_each(std::execution::par_unseq, </span><br><span class="line">              std::<span class="built_in">begin</span>(a), std::<span class="built_in">end</span>(a), [&amp;](<span class="keyword">int</span>) &#123;</span><br><span class="line">  std::lock_guard&lt;mutex&gt; <span class="built_in">guard</span>(m); <span class="comment">// Error: lock_guard constructor calls m.lock()</span></span><br><span class="line">  ++x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里由于<code>std::execution::par_unseq</code> 无法保证执行lambda表达式的时候不被打断，可能会造成同一个线程两次次进入lambda表达式，并且调用<code>m.lock()</code>导致死锁。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++17标准的一个重大突破是让标准库中的部分算法支持了并行计算，这对于无处不在的多线程环境来说无疑是一个非常不错的消息。具体支持并行计算的算法可以参考提案文档&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/pape</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>C++在线工具</title>
    <link href="http://0cch.com/2021/03/20/intro-3-cpp-online-tools/"/>
    <id>http://0cch.com/2021/03/20/intro-3-cpp-online-tools/</id>
    <published>2021-03-20T08:15:53.000Z</published>
    <updated>2021-02-02T08:16:23.008Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客打算介绍4个C++在线工具，当手头没有设备或者没有开发环境的时候可以用它们做一些研究性质的工作。</p><ol><li><p><a href="https://wandbox.org/">https://wandbox.org/</a></p><p>该网站可以在线编辑以及编译C++源代码并且运行编译后的程序。在C++类别它支持GCC和CLANG，另外除了C++，C、C#、Java、GO等等都有支持。</p></li><li><p><a href="https://quick-bench.com/">https://quick-bench.com/</a></p><p>这也是一个可以在线编辑以及编译C++源代码并且运行编译后的程序的网站，但是与上面网站不同的是它运行程序并非用来输出结果，而是对函数做基准检测，采用的是Google Benchmark。同样它支持GCC和CLANG。</p></li><li><p><a href="https://godbolt.org/">https://godbolt.org/</a></p><p>这是我很喜欢的一个网站，它可以在线编辑和编译C++源代码，但是不可以运行程序。但是这并不能掩盖其优秀的地方，它支持C++各种编译器的各种版本，跨度非常大也非常全面。同时还可以自由设置编译器的编译参数并且查看输出的中间文件，对于研究C++编译过程十分有用。</p></li><li><p><a href="https://cppinsights.io/">https://cppinsights.io/</a></p><p>这是一个非常有趣的网站，它能够将源代码展开，使用一种容易理解的方式展示编译器做了哪些自动化工作。用它自己的话来说，就是从编译器的视角看到的源代码。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> arr[<span class="number">10</span>]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>&amp; c : arr)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被网站展开为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">const</span> <span class="params">(&amp;__range1)</span>[10] </span>= arr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * __begin1 = __range1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * __end1 = __range1 + <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">for</span>(; __begin1 != __end1; ++__begin1) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> &amp; c = *__begin1;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇博客打算介绍4个C++在线工具，当手头没有设备或者没有开发环境的时候可以用它们做一些研究性质的工作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://wandbox.org/&quot;&gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该网站可以</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>解决vs2019编译qt5.15.2的错误</title>
    <link href="http://0cch.com/2021/02/03/msvc-build-qt5.15.2-error/"/>
    <id>http://0cch.com/2021/02/03/msvc-build-qt5.15.2-error/</id>
    <published>2021-02-03T03:37:28.000Z</published>
    <updated>2021-02-04T07:21:21.449Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下编译qt-everywhere-src-5.15.2中qtwebengine遇到的问题。</p><p>第一、在windows上用vs2019编译qtwebengine的时候需要patch其中的3个文件，否则会报错。错误看起来好像是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ninja: build stopped: subcommand failed. </span><br><span class="line">NMAKE : fatal error U1077: &#x27;call&#x27; : return code &#x27;0x1&#x27;</span><br><span class="line">NMAKE : fatal error U1077: &#x27;&quot;...\nmake.exe&quot;&#x27; : return code &#x27;0x2&#x27; Stop.</span><br><span class="line">NMAKE : fatal error U1077: &#x27;(&#x27; : return code &#x27;0x2&#x27; Stop.</span><br><span class="line">NMAKE : fatal error U1077: &#x27;cd&#x27; : return code &#x27;0x2&#x27; Stop.</span><br><span class="line">NMAKE : fatal error U1077: &#x27;cd&#x27; : return code &#x27;0x2&#x27; Stop</span><br></pre></td></tr></table></figure><p>但实际问题是代码在vs2019的cl里编译出错了，C4244警告被当成错误报出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FAILED: obj/third_party/angle/angle_common/mathutil.obj</span><br><span class="line">...</span><br><span class="line">../../3rdparty/chromium/third_party/angle/src/common/mathutil.cpp(75): error C4244: &#x27;=&#x27;: conversion from &#x27;double&#x27; to &#x27;float&#x27;, possible loss of data</span><br><span class="line">../../3rdparty/chromium/third_party/angle/src/common/mathutil.cpp(77): error C4244: &#x27;=&#x27;: conversion from &#x27;double&#x27; to &#x27;float&#x27;, possible loss of data</span><br><span class="line">../../3rdparty/chromium/third_party/angle/src/common/mathutil.cpp(79): error C4244: &#x27;=&#x27;: conversion from &#x27;double&#x27; to &#x27;float&#x27;, possible loss of data</span><br></pre></td></tr></table></figure><p>所以需要打个补丁，手动修改也行吧，代码量很少：<br><a href="https://codereview.qt-project.org/c/qt/qtwebengine-chromium/+/321741">https://codereview.qt-project.org/c/qt/qtwebengine-chromium/+/321741</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From 138a7203f16cf356e9d4dac697920a22437014b0 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: Peter Varga &lt;pvarga@inf.u-szeged.hu&gt;</span><br><span class="line">Date: Fri, 13 Nov 2020 11:09:23 +0100</span><br><span class="line">Subject: [PATCH] Fix build with msvc2019 16.8.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Fixes: QTBUG-88708</span><br><span class="line">Change-Id: I3554ceec0437801b4861f68edd504d01fc01cf93</span><br><span class="line">Reviewed-by: Allan Sandfeld Jensen &lt;allan.jensen@qt.io&gt;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">diff --git a/chromium/third_party/angle/src/common/mathutil.cpp b/chromium/third_party/angle/src/common/mathutil.cpp</span><br><span class="line">index 306cde1..d4f1034 100644</span><br><span class="line">--- a/chromium/third_party/angle/src/common/mathutil.cpp</span><br><span class="line">+++ b/chromium/third_party/angle/src/common/mathutil.cpp</span><br><span class="line">@@ -72,11 +72,11 @@</span><br><span class="line">     const RGB9E5Data *inputData = reinterpret_cast&lt;const RGB9E5Data *&gt;(&amp;input);</span><br><span class="line">     *red =</span><br><span class="line">-        inputData-&gt;R * pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">+        inputData-&gt;R * (float)pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">     *green =</span><br><span class="line">-        inputData-&gt;G * pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">+        inputData-&gt;G * (float)pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">     *blue =</span><br><span class="line">-        inputData-&gt;B * pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">+        inputData-&gt;B * (float)pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  // namespace gl</span><br><span class="line">diff --git a/chromium/third_party/blink/renderer/platform/graphics/lab_color_space.h b/chromium/third_party/blink/renderer/platform/graphics/lab_color_space.h</span><br><span class="line">index 78c316e..136c796 100644</span><br><span class="line">--- a/chromium/third_party/blink/renderer/platform/graphics/lab_color_space.h</span><br><span class="line">+++ b/chromium/third_party/blink/renderer/platform/graphics/lab_color_space.h</span><br><span class="line">@@ -130,7 +130,7 @@</span><br><span class="line">   // https://en.wikipedia.org/wiki/CIELAB_color_space#Forward_transformation.</span><br><span class="line">   FloatPoint3D toXYZ(const FloatPoint3D&amp; lab) const &#123;</span><br><span class="line">     auto invf = [](float x) &#123;</span><br><span class="line">-      return x &gt; kSigma ? pow(x, 3) : 3 * kSigma2 * (x - 4.0f / 29.0f);</span><br><span class="line">+      return x &gt; kSigma ? (float)pow(x, 3) : 3 * kSigma2 * (x - 4.0f / 29.0f);</span><br><span class="line">     &#125;;</span><br><span class="line">     FloatPoint3D v = &#123;clamp(lab.X(), 0.0f, 100.0f),</span><br><span class="line">diff --git a/chromium/third_party/perfetto/src/trace_processor/timestamped_trace_piece.h b/chromium/third_party/perfetto/src/trace_processor/timestamped_trace_piece.h</span><br><span class="line">index 02363d0..8860287 100644</span><br><span class="line">--- a/chromium/third_party/perfetto/src/trace_processor/timestamped_trace_piece.h</span><br><span class="line">+++ b/chromium/third_party/perfetto/src/trace_processor/timestamped_trace_piece.h</span><br><span class="line">@@ -198,6 +198,20 @@</span><br><span class="line">     return *this;</span><br><span class="line">   &#125;</span><br><span class="line">+#if PERFETTO_BUILDFLAG(PERFETTO_COMPILER_MSVC)</span><br><span class="line">+  TimestampedTracePiece&amp; operator=(TimestampedTracePiece&amp;&amp; ttp) const</span><br><span class="line">+  &#123;</span><br><span class="line">+    if (this != &amp;ttp) &#123;</span><br><span class="line">+      // First invoke the destructor and then invoke the move constructor</span><br><span class="line">+      // inline via placement-new to implement move-assignment.</span><br><span class="line">+      this-&gt;~TimestampedTracePiece();</span><br><span class="line">+      new (const_cast&lt;TimestampedTracePiece*&gt;(this)) TimestampedTracePiece(std::move(ttp));</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    return const_cast&lt;TimestampedTracePiece&amp;&gt;(*this);</span><br><span class="line">+  &#125;</span><br><span class="line">+#endif  // PERFETTO_BUILDFLAG(PERFETTO_COMPILER_MSVC)</span><br><span class="line">+</span><br><span class="line">   ~TimestampedTracePiece() &#123;</span><br><span class="line">     switch (type) &#123;</span><br><span class="line">       case Type::kInvalid:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二、在Windows上编译blink的pch也会有些问题，报错找不到头文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qt5/qtwebengine/src/3rdparty/chromium/third_party/WebKit/Source/core/win/Precompile-core.cpp: fatal error C1083: Cannot open include file: </span><br><span class="line">&#x27;../../../../../qt5srcgit/qt5/qtwebengine/src/3rdparty/chromium/third_party/WebKit/Source/core/Precompile-core.h&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>需要patch两个文件blink/renderer/platform/BUILD.gn 和 blink/renderer/core/BUILD.gn</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/BUILD.gn</span><br><span class="line">+++ qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/BUILD.gn</span><br><span class="line">@@ -204,7 +204,7 @@</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config(&quot;blink_platform_pch&quot;) &#123;</span><br><span class="line">   if (enable_precompiled_headers) &#123;</span><br><span class="line">-    if (is_win) &#123;</span><br><span class="line">+    if (false) &#123;</span><br><span class="line">       # This is a string rather than a file GN knows about. It has to match</span><br><span class="line">       # exactly what&#x27;s in the /FI flag below, and what might appear in the</span><br><span class="line">       # source code in quotes for an #include directive.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下编译qt-everywhere-src-5.15.2中qtwebengine遇到的问题。&lt;/p&gt;
&lt;p&gt;第一、在windows上用vs2019编译qtwebengine的时候需要patch其中的3个文件，否则会报错。错误看起来好像是：&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>使用std::any代替std::shared_ptr&lt;void&gt;和void *</title>
    <link href="http://0cch.com/2021/01/03/use-any-instead-of-shared_ptr-and-void/"/>
    <id>http://0cch.com/2021/01/03/use-any-instead-of-shared_ptr-and-void/</id>
    <published>2021-01-03T04:30:07.000Z</published>
    <updated>2021-01-26T04:30:30.360Z</updated>
    
    <content type="html"><![CDATA[<p>大家在编写程序的时候应该遇到过这样一个场景，该场景需要传递某种数据，但是数据类型和数据大小并不确定，这种时候我们常用<code>void *</code>类型的变量来保存对象指针。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span> </span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="keyword">void</span>* user_data; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的结构体只是一个示例，代表有的数据是用户产生的。当用户数据是一个字符串时，可能的代码是：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SomeData sd&#123;&#125;;</span><br><span class="line">sd.user_data = <span class="keyword">new</span> std::string&#123; <span class="string">&quot;hello world&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>另外，使用<code>void*</code>存储数据需要了解数据类型，并且需要自己维护数据的生命周期：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string *str = <span class="keyword">static_cast</span>&lt;std::string *&gt;(sd.user_data);</span><br><span class="line"><span class="keyword">delete</span> str;</span><br><span class="line">str = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>使用<code>std::shared_ptr&lt;void&gt;</code>可以解决生命周期的问题：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">void</span>&gt; user_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeData sd&#123;&#125;;</span><br><span class="line">sd.user_data = std::make_shared&lt;std::string&gt;(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ud = std::static_pointer_cast&lt;std::string&gt;(sd.user_data);</span><br></pre></td></tr></table></figure><p>虽然<code>std::shared_ptr&lt;void&gt;</code>可以用于管理生命周期，但是类型安全的问题却无法解决。比如当<code>user_data</code>销毁时，由于缺乏类型信息会导致对象无法正确析构。</p><p>为了解决以上这些问题，C++17标准库引入<code>std::any</code>。顾名思义就是可以存储任意类型，我们可以将其理解为带有类型信息的<code>void*</code>。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">any</span> &#123;</span></span><br><span class="line"> <span class="keyword">void</span>* object;</span><br><span class="line"> type_info tinfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，<code>std::any</code>的实现比这个要复杂的多，我们后面再讨论类型是如何被记录下来的。先来看看<code>std::any</code>的用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;any&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::any a;</span><br><span class="line">    a = std::string&#123; <span class="string">&quot;hello world&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> str = std::any_cast&lt;std::string&gt;(a);</span><br><span class="line">    std::cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了转换为对象本身，还可以转换为引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; str1 = std::any_cast&lt;std::string&amp;&gt;(a);</span><br><span class="line"><span class="keyword">auto</span>&amp; str2 = std::any_cast&lt;<span class="keyword">const</span> std::string&amp;&gt;(a);</span><br></pre></td></tr></table></figure><p>当转换类型不正确时，<code>std::any_cast</code>会抛出异常<code>std::bad_any_cast</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; std::any_cast&lt;<span class="keyword">double</span>&gt;(a) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::bad_any_cast&amp;) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Wrong Type!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果转换的不是对象而是对象指针，那么<code>std::any_cast</code>不会抛出异常，而是返回空指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>* ptr = std::any_cast&lt;std::string&gt;(&amp;a);</span><br><span class="line"><span class="keyword">if</span>(ptr) &#123;</span><br><span class="line"> std::cout &lt;&lt; *ptr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Wrong Type!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，使用<code>std::any_cast</code>转换类型必须和<code>std::any</code>对象的存储类型完全一致，否则同样会抛出异常，即使两者是继承关系。原因很简单，<code>std::any_cast</code>是直接使用<code>type_info</code>作比较：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> type_info* <span class="keyword">const</span> _Info = _TypeInfo();</span><br><span class="line"><span class="keyword">if</span> (!_Info || *_Info != <span class="built_in"><span class="keyword">typeid</span></span>(_Decayed)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后简单描述一下<code>std::any</code>保证类型安全的原理：</p><p>首先是类型转换，刚刚已经提到了，<code>std::any</code>会记录对象的<code>type_info</code>，<code>std::any_cast</code>使用<code>type_info</code>作比较，只有完全一致才能进行转换。</p><p>其次为了保证类型正确的拷贝，移动以及生命周期结束时能够正确析构，在创建<code>std::any</code>对象时生成一些函数模板实例，这些函数模板调用了类型的拷贝，移动以及析构函数。<code>std::any</code>只需要记录这些函数模板实例的指针即可。拿析构简单举例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_impl</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;T*&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> destory_ptr = <span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">void</span>* <span class="keyword">const</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnyMetadata</span> &#123;</span></span><br><span class="line">    destory_ptr func;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_anymeta</span><span class="params">(AnyMetadata &amp;meta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    meta.func = destroy_impl&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// any构造时知道目标对象类型，此时可以保存函数指针</span></span><br><span class="line">AnyMetadata metadata;</span><br><span class="line">create_anymeta&lt;std::string&gt;(metadata);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any销毁时调用</span></span><br><span class="line">metadata.<span class="built_in">func</span>(obj);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家在编写程序的时候应该遇到过这样一个场景，该场景需要传递某种数据，但是数据类型和数据大小并不确定，这种时候我们常用&lt;code&gt;void *&lt;/code&gt;类型的变量来保存对象指针。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>使用std::sample获取随机样本</title>
    <link href="http://0cch.com/2020/12/26/use-sample-to-get-random-samples/"/>
    <id>http://0cch.com/2020/12/26/use-sample-to-get-random-samples/</id>
    <published>2020-12-26T02:16:36.000Z</published>
    <updated>2021-01-26T02:17:45.577Z</updated>
    
    <content type="html"><![CDATA[<p>C++17标准库提供了一个<code>std::sample</code>函数模板用于获取随机样本，该样本是输入全体样本的一个子集。具体例子如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sample</span>(data.<span class="built_in">begin</span>(), </span><br><span class="line">        data.<span class="built_in">end</span>(),</span><br><span class="line">        std::ostream_iterator&lt;<span class="keyword">int</span>&gt;&#123;std::cout, <span class="string">&quot;\n&quot;</span>&#125;,</span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line">        std::default_random_engine&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>std::sample</code>需要5个参数，其中前2个参数是全体样本的合计的<code>begin</code>和<code>end</code>迭代器，它定义了全体样本的范围。第3个参数则是输出迭代器，第4个参数是需要样本的数量，最后是随机数引擎。注意这里<code>std::default_random_engine</code>没有设置<code>seed</code>，这必然导致每次运行获取的样本相同。</p><p>以上代码的输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">488</span><br><span class="line">963</span><br><span class="line">1994</span><br><span class="line">2540</span><br><span class="line">2709</span><br><span class="line">2835</span><br><span class="line">3518</span><br><span class="line">5172</span><br><span class="line">7996</span><br></pre></td></tr></table></figure><p>我们可以为随机数引擎设置<code>seed</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::random_device rd;</span><br><span class="line">std::default_random_engine eng&#123; <span class="built_in">rd</span>() &#125;;</span><br><span class="line">std::<span class="built_in">sample</span>(data.<span class="built_in">begin</span>(), </span><br><span class="line">    data.<span class="built_in">end</span>(),</span><br><span class="line">    std::ostream_iterator&lt;<span class="keyword">int</span>&gt;&#123;std::cout, <span class="string">&quot;\n&quot;</span>&#125;,</span><br><span class="line">    <span class="number">10</span>,</span><br><span class="line">    eng);</span><br></pre></td></tr></table></figure><p>这样每次样本就会发生变化。另外<code>std::sample</code>是有返回值的，返回的是最后一个随机样本之后的迭代器。它的作用是确定随机样本在输出容器中的范围，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; out_data;</span><br><span class="line">    out_data.<span class="built_in">resize</span>(<span class="number">100</span>);</span><br><span class="line">    std::random_device rd;</span><br><span class="line">    std::default_random_engine eng&#123; <span class="built_in">rd</span>() &#125;;</span><br><span class="line">    <span class="keyword">auto</span> end = std::<span class="built_in">sample</span>(data.<span class="built_in">begin</span>(), </span><br><span class="line">        data.<span class="built_in">end</span>(),</span><br><span class="line">        out_data.<span class="built_in">begin</span>(),</span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line">        eng);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;coll size: &quot;</span> </span><br><span class="line">        &lt;&lt; out_data.<span class="built_in">size</span>() </span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = out_data.<span class="built_in">begin</span>(); it != end; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出结果为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">coll size: <span class="number">100</span></span><br><span class="line"><span class="number">1708</span></span><br><span class="line"><span class="number">1830</span></span><br><span class="line"><span class="number">2803</span></span><br><span class="line"><span class="number">3708</span></span><br><span class="line"><span class="number">5146</span></span><br><span class="line"><span class="number">7376</span></span><br><span class="line"><span class="number">7867</span></span><br><span class="line"><span class="number">8059</span></span><br><span class="line"><span class="number">8271</span></span><br><span class="line"><span class="number">9448</span></span><br></pre></td></tr></table></figure><p>可以看到，虽然容器的大小是100，但是我们只填充10个随机样本。最后需要说明一下<code>std::sample</code>对于两个迭代器参数的要求，首先源迭代器至少是一个输入迭代器的时候，目标迭代器至少可以是一个输出迭代器。但是当源迭代器不是一个向前迭代器，那么目标迭代器必须是一个随机迭代器。这一点很好理解，当源迭代器不能确保随机的情况下，只能将目的迭代器随机以确保样本的随机性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++17标准库提供了一个&lt;code&gt;std::sample&lt;/code&gt;函数模板用于获取随机样本，该样本是输入全体样本的一个子集。具体例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>实现一个类似std::bind的功能</title>
    <link href="http://0cch.com/2020/11/18/mybind/"/>
    <id>http://0cch.com/2020/11/18/mybind/</id>
    <published>2020-11-18T09:38:46.000Z</published>
    <updated>2021-01-25T10:15:11.704Z</updated>
    
    <content type="html"><![CDATA[<p>前两天有朋友问我<code>std::bind</code>是如何实现的，对照STL讲述原理后朋友表示还是很难理解，这可以理解，因为STL涉及到的东西太多，很难清晰的将核心部分显式出来。为了解释清楚这个问题，我自己实现了一个bind功能。当然了，比<code>std::bind</code>要简单非常非常多，缺少很多有用的特性，但是也能展示bind的核心原理了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> _Nx&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyPh</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">0</span>&gt; _0;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">1</span>&gt; _1;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">2</span>&gt; _2;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">3</span>&gt; _3;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">4</span>&gt; _4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span> ... Arg&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">MyBind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _MyBind(F f, Arg ... arg) : _MyList(arg...), _f(f) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... CallArg&gt;</span></span><br><span class="line"><span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(CallArg... arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">_MyBind&lt;R, F, CallArg...&gt; <span class="title">c</span><span class="params">(<span class="number">0</span>, arg...)</span></span>;</span><br><span class="line">        std::<span class="keyword">size_t</span> <span class="keyword">constexpr</span> tSize </span><br><span class="line">            = std::tuple_size&lt;std::tuple&lt;Arg...&gt;&gt;::value;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">call_tuple</span>(_f, _MyList, </span><br><span class="line">            c, std::make_index_sequence&lt;tSize&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Tuple, <span class="keyword">typename</span> C, <span class="keyword">size_t</span> ...S&gt;</span></span><br><span class="line"><span class="function">R <span class="title">call_tuple</span><span class="params">(F f, Tuple t, C c, std::index_sequence&lt;S...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(c[std::get&lt;S&gt;(_MyList)]...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="keyword">operator</span>[] (T &amp;t) &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt; <span class="keyword">typename</span> std::tuple_element&lt;N, </span><br><span class="line">        std::tuple&lt;Arg...&gt;&gt;::type <span class="keyword">operator</span>[] (_MyPh&lt;N&gt;) </span><br><span class="line">    &#123; </span><br><span class="line">            <span class="keyword">return</span> std::get&lt;N&gt;(_MyList);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tuple&lt;Arg...&gt; _MyList;</span><br><span class="line">    F _f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span> ... Arg&gt; </span></span><br><span class="line"><span class="function">_MyBind&lt;R, F, Arg...&gt; <span class="title">mybind</span><span class="params">(F f, Arg ... arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _MyBind&lt;R, F, Arg...&gt;(f, arg...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> myfunc = mybind&lt;<span class="keyword">int</span>&gt;(sum, _0, <span class="number">2</span>, _1)(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先占位符其实就是一个空类型，我们不需要类型里有什么，只是想要一个类型标识符。</p><p>然后看到最关键的<code>_MyBind</code>类模板，该类模板有数据成员<code>_MyList</code>和<code>_f</code>，用于存放绑定的函数和参数。在构造对象的时候数据成员会被填充，并且在调用<code>template&lt;typename ... CallArg&gt; R operator()(CallArg... arg)</code>的时候使用这两个数据成员。这里比较难理解的是<code>call_tuple</code>函数模板，该函数需要将绑定的参数列表和后续调用的参数列表传入函数，</p><p>最后使用SFINAE的技巧有选择的通过<code>operator[]</code>获取对应的值。如果<code>std::get&lt;S&gt;(_MyList)</code>返回的是绑定的具体值，那么通过<code>template&lt;typename T&gt; T operator[] (T &amp;t) &#123; return t; &#125;</code>返回值本身，注意这里的<code>t</code>是最外层<code>_MyList</code>中的元素；如果<code>std::get&lt;S&gt;(_MyList)</code>返回的是占位符，那么将通过<code>template&lt;int N&gt; typename std::tuple_element&lt;N, std::tuple&lt;Arg...&gt;&gt;::type operator[] (_MyPh&lt;N&gt;) &#123; return std::get&lt;N&gt;(_MyList); &#125;</code>返回<code>c</code>中<code>_MyList</code>的元素，请注意这里的<code>this</code>对象是<code>c</code>。</p><p>当然为了使用方便需要一个函数模板<code>mybind</code>，它只需要指定一个返回类型就可以使用了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前两天有朋友问我&lt;code&gt;std::bind&lt;/code&gt;是如何实现的，对照STL讲述原理后朋友表示还是很难理解，这可以理解，因为STL涉及到的东西太多，很难清晰的将核心部分显式出来。为了解释清楚这个问题，我自己实现了一个bind功能。当然了，比&lt;code&gt;std::bi</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>使用std::span代替数组指针传参</title>
    <link href="http://0cch.com/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/"/>
    <id>http://0cch.com/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/</id>
    <published>2020-10-02T07:52:31.000Z</published>
    <updated>2021-01-25T07:54:13.603Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道<code>std::string_view</code>可以创建<code>std::string</code>的一个视图，视图本身并不拥有实例，它只是保持视图映射的状态。在不修改实例的情况下，使用<code>std::string_view</code>会让字符串处理的性能大幅提升。实际上，对于那些连续的序列对象我们都可以创建这样一份视图，对于<code>std::vector</code>这样的对象可以提高某些操作中的性能，另外对原生数组可以提高其访问的安全性。</p><p>过去如果一个函数想接受无法确定数组长度的数组作为参数，那么一定需要声明两个参数：数组指针和长度：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_data</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">set_data</span>(buf, <span class="number">128</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种人工输入增加了编码的风险，数组长度的错误输入会引发程序的未定义行为，甚至是成为可被利用的漏洞。C++20标准库为我们提供了一个很好解决方案<code>std::span</code>，通过它可以定义一个基于连续序列对象的视图，包括原生数组，并且保留连续序列对象的大小。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;span&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_data</span><span class="params">(std::span&lt;<span class="keyword">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arr.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">set_data</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了原生数组，<code>std::vector</code>和<code>std::array</code>也在<code>std::span</code>的处理之列：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; buf1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 3&gt; buf2&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">set_data</span>(buf1);</span><br><span class="line"><span class="built_in">set_data</span>(buf2);</span><br></pre></td></tr></table></figure><p>值得注意的是，<code>std::span</code>还可以通过构造函数设置连续序列对象的长度：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">set_data</span>(&#123; buf, <span class="number">16</span> &#125;);</span><br></pre></td></tr></table></figure><p>从<code>std::string_view</code>到<code>std::span</code>，我们可以看出C++标准库很乐于这种视图设计，因为这种设计和抽象的实现可以提高C ++程序的可靠性而又不牺牲性能和可移植性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道&lt;code&gt;std::string_view&lt;/code&gt;可以创建&lt;code&gt;std::string&lt;/code&gt;的一个视图，视图本身并不拥有实例，它只是保持视图映射的状态。在不修改实例的情况下，使用&lt;code&gt;std::string_view&lt;/code&gt;会让字符</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>使用std::string_view提升字符串处理性能</title>
    <link href="http://0cch.com/2020/09/25/use-string_view-to-improve-string-processing-performance/"/>
    <id>http://0cch.com/2020/09/25/use-string_view-to-improve-string-processing-performance/</id>
    <published>2020-09-25T06:27:45.000Z</published>
    <updated>2021-01-25T07:54:02.281Z</updated>
    
    <content type="html"><![CDATA[<p>C++标准库提供了一个非常优秀的字符串处理类<code>std::string</code>，我们可以通过该类完成各种字符串操作。但是<code>std::string</code>有一个缺点，它的很多操作都是针对字符串实体，存在不必要的内存拷贝的代码，导致字符串的处理性能不尽如人意。针对这种情况C++17标准引入了<code>std::string_view</code>这个类，该类不会直接作用在字符串实体上，而是记录字符串处理的位置，这样就可以保证用最小的代价对字符串进行处理。</p><p>为了验证这个结论，下面的代码实现了一个断词器，然后针对64MB的数据做断词处理并且分别记录使用<code>std::string</code>和<code>std::string_view</code>作为基础类型时断词器运行的时间：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tokenizer</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> string_type = T;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> T::value_type;</span><br><span class="line">    <span class="built_in">tokenizer</span>(<span class="keyword">const</span> string_type&amp; str, </span><br><span class="line">        std::<span class="keyword">enable_if_t</span>&lt;std::disjunction_v&lt;</span><br><span class="line">        std::is_same&lt;string_type, std::basic_string&lt;value_type&gt;&gt;,</span><br><span class="line">        std::is_same&lt;string_type, std::basic_string_view&lt;value_type&gt;&gt;&gt;&gt;* = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">data_</span>(str), <span class="built_in">begin_</span>(<span class="number">0</span>), <span class="built_in">end_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function">string_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> value_type sep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; end_ &lt; data_.<span class="built_in">size</span>(); ++end_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data_[end_] == sep) &#123;</span><br><span class="line">                <span class="keyword">auto</span> res = data_.<span class="built_in">substr</span>(begin_, end_ - begin_);</span><br><span class="line">                begin_ = ++end_;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end_ &lt;= data_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data_.<span class="built_in">substr</span>(begin_, end_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">more</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> end_ &lt; data_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> string_type data_;</span><br><span class="line">    <span class="keyword">size_t</span> begin_, end_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">make_string_data</span><span class="params">(<span class="keyword">size_t</span> count, <span class="keyword">char</span> sep)</span> </span>&#123;</span><br><span class="line">    std::string data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + i % <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> != count)</span><br><span class="line">            data.<span class="built_in">push_back</span>(sep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string data = <span class="built_in">make_string_data</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">32</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">tokenizer&lt;std::string&gt; <span class="title">tk</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">while</span> (tk.<span class="built_in">more</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">tk</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; diff = end - start;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;elapsed time = &quot;</span> &lt;&lt; diff.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中<code>tokenizer</code>是一个断词器的类模板，接受<code>std::string</code>、<code>std::wstring</code>等<code>std::basic_string</code>模板实例化的类型，同时也能接受<code>std::string_view</code>、<code>std::wstring_view</code>等<code>std::basic_string_view</code>模板实例化的类型。这里采用了SFINAE的方法来约束<code>tokenizer</code>的模板实参必须为以上类型。如果编译环境是C++20标准，可以采用概念来约束模板实参类型。</p><p>这份代码<code>tokenizer&lt;std::string&gt;</code>运行结果是0.45秒，如果将<code>tokenizer&lt;std::string&gt;</code>替换为<code>tokenizer&lt;std::string_view&gt;</code>运行时间缩短为0.08秒，性能提升是非常明显的 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++标准库提供了一个非常优秀的字符串处理类&lt;code&gt;std::string&lt;/code&gt;，我们可以通过该类完成各种字符串操作。但是&lt;code&gt;std::string&lt;/code&gt;有一个缺点，它的很多操作都是针对字符串实体，存在不必要的内存拷贝的代码，导致字符串的处理性能</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>std::enable_shared_from_this原理浅析</title>
    <link href="http://0cch.com/2020/08/05/something-about-enable_shared_from_this/"/>
    <id>http://0cch.com/2020/08/05/something-about-enable_shared_from_this/</id>
    <published>2020-08-05T09:54:11.000Z</published>
    <updated>2021-01-25T07:53:37.389Z</updated>
    
    <content type="html"><![CDATA[<p>在解释<code>std::enable_shared_from_this</code>之前，先看一个<code>std::shared_ptr</code>典型用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; pt1&#123; <span class="keyword">new</span> <span class="keyword">int</span>&#123; <span class="number">10</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> pt2&#123; pt1 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时<code>pt1</code>和<code>pt2</code>共用了引用计数，当<code>pt1</code>和<code>pt2</code>的生命周期都结束时，<code>new int&#123;10&#125;</code>分配的内存会被释放。下面的做法会导致内存多次释放，因为它们没有使用共同的引用计数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pt&#123; <span class="keyword">new</span> <span class="keyword">int</span>&#123; <span class="number">10</span> &#125; &#125;;</span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; pt1&#123; pt &#125;;</span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; pt2&#123; pt &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我想应该也没有人这么使用<code>std::shared_ptr</code>。不过下面这个错误倒是比较常见：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要用this调用SomeAPI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这段代码需要在<code>NeedCallSomeAPI</code>函数中调用<code>SomeAPI</code>，而<code>SomeAPI</code>需要的是一个<code>std::shared_ptr&lt;SomeData&gt;</code>的实参。这个时候应该怎么做？</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(std::shared_ptr&lt;SomeData&gt;&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的做法是错误的，因为<code>SomeAPI</code>调用结束后<code>std::shared_ptr&lt;SomeData&gt;</code>对象的引用计数会降为0，导致<code>this</code>被意外释放。</p><p>这种情况下，我们需要使用<code>std::enable_shared_from_this </code>，使用方法很简单，只需要让<code>SomeData</code>继承<code>std::enable_shared_from_this&lt;SomeData&gt;</code>，然后调用<code>shared_from_this</code>吗，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>:</span>std::enable_shared_from_this&lt;SomeData&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::shared_ptr&lt;SomeData&gt; <span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::shared_ptr&lt;SomeData&gt;(<span class="keyword">new</span> SomeData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SomeData</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> d&#123; SomeData::<span class="built_in">Create</span>() &#125;;</span><br><span class="line">    d-&gt;<span class="built_in">NeedCallSomeAPI</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::enable_shared_from_this </code>的实现比较复杂，但是实现原理则比较简单。它内部使用了<code>std::weak_ptr</code>来帮助完成指针相关控制数据的同步，而这份数据是在创建<code>std::shared_ptr</code>的时候完成的。我们来重点解析这一点。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span> &#123;</span></span><br><span class="line"> <span class="keyword">mutable</span> weak_ptr&lt;T&gt; weak_this;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">shared_ptr&lt;T&gt; <span class="title">shared_from_this</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> shared_ptr&lt;T&gt;(weak_this); </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function">shared_ptr&lt;<span class="keyword">const</span> T&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> shared_ptr&lt;<span class="keyword">const</span> T&gt;(weak_this); </span><br><span class="line"> &#125;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上是摘要的<code>enable_shared_from_this</code>的代码，这份代码中有两个关键要素。首先<code>weak_this</code>被声明为<code>mutable</code>，这让<code>weak_this</code>可以在<code>const</code>的限定下修改，其次也是最关键的地方，该类声明了<code>shared_ptr</code>为友元。这意味着<code>std::shared_ptr</code>可以修改<code>weak_this</code>，并且<code>weak_this</code>被初始化的地方在<code>std::shared_ptr</code>中。进一步说，没有<code>std::shared_ptr</code>的<code>enable_shared_from_this</code>是没有灵魂的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>:</span>std::enable_shared_from_this&lt;SomeData&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> d&#123; <span class="keyword">new</span> SomeData &#125;;</span><br><span class="line">    d-&gt;<span class="built_in">NeedCallSomeAPI</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这份代码中调用<code>shared_from_this</code>会出错。</p><p>再深入一步，<code>std::shared_ptr</code>是如何判断实例化对象类型是否继承<code>std::enable_shared_from_this</code>，并且通过判断结果决定是否初始化<code>weak_this</code>的呢？答案是SFINAE(“<em>Substitution Failure Is Not An Error</em>“)。</p><p>让我们查看VS2019的STL代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> _Esft_type = enable_shared_from_this;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yty</span>, <span class="keyword">class</span> =</span> <span class="keyword">void</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Can_enable_shared</span> :</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Can_enable_shared</span>&lt;</span>_Yty, <span class="keyword">void_t</span>&lt;<span class="keyword">typename</span> _Yty::_Esft_type&gt;&gt;</span><br><span class="line">    : is_convertible&lt;<span class="keyword">remove_cv_t</span>&lt;_Yty&gt;*, <span class="keyword">typename</span> _Yty::_Esft_type*&gt;::type &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的重点是<code>_Can_enable_shared</code>，如果目标类型有内嵌类型<code>_Esft_type</code>，并且目标类型和内嵌类型的指针是可转换的，也就是有继承关系，那么类型结果为<code>true_type</code>，反之为<code>false_type</code>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ux</span>&gt;</span></span><br><span class="line">   <span class="keyword">void</span> _Set_ptr_rep_and_enable_shared(_Ux* <span class="keyword">const</span> _Px, _Ref_count_base* <span class="keyword">const</span> _Rx) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>-&gt;_Ptr = _Px;</span><br><span class="line">       <span class="keyword">this</span>-&gt;_Rep = _Rx;</span><br><span class="line">       <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(conjunction_v&lt;negation&lt;is_array&lt;_Ty&gt;&gt;, negation&lt;is_volatile&lt;_Ux&gt;&gt;, _Can_enable_shared&lt;_Ux&gt;&gt;)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (_Px &amp;&amp; _Px-&gt;_Wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">               _Px-&gt;_Wptr = shared_ptr&lt;<span class="keyword">remove_cv_t</span>&lt;_Ux&gt;&gt;(*<span class="keyword">this</span>, <span class="keyword">const_cast</span>&lt;<span class="keyword">remove_cv_t</span>&lt;_Ux&gt;*&gt;(_Px));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接下来，如果对象不是数组、不是<code>volatile</code>声明的并且<code>_Can_enable_shared</code>返回<code>true_type</code>，那么<code>_Wptr</code>才会被初始化。<code>std::shared_ptr</code>的构造函数以及<code>std::make_shared</code>函数都会调用该函数。</p><p>以上就是<code>std::enable_shared_from_this</code>实现原理中比较关键的一个部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在解释&lt;code&gt;std::enable_shared_from_this&lt;/code&gt;之前，先看一个&lt;code&gt;std::shared_ptr&lt;/code&gt;典型用法：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>使用fmtlib格式化字符串</title>
    <link href="http://0cch.com/2020/07/07/use-fmtlib-format-string/"/>
    <id>http://0cch.com/2020/07/07/use-fmtlib-format-string/</id>
    <published>2020-07-07T04:21:13.000Z</published>
    <updated>2021-01-22T04:24:33.348Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中格式化字符串的方法一直是一个备受争议的话题，无论是<code>printf</code>系列函数还是Stream IO都有各自的优缺点。本篇文章直接略过这两种方法，将目光放到fmtlib这个第三方库中，虽然是第三方库，但是C++20标准会引入该库的一部分特性。</p><p>fmtlib格式化字符串的语法和python十分相似，熟悉python的朋友掌握起来会非常迅速，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>) </span><br></pre></td></tr></table></figure><p>以上是python格式化字符串的方法，对比到fmtlib为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在python中，格式化字符串的{}是可以设定索引并且指定顺序的，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure><p>在fmtlib中也能够实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外在python中还可以使用命名的{}来格式化字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;first&#125; &#123;second&#125;&quot;</span>.<span class="built_in">format</span>(first = <span class="string">&quot;hello&quot;</span>, second = <span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure><p>不过C++中不支持指定参数名来传参，fmtlib采用了一个很巧妙的方法，它使用了自定义字面量的方法生成了一个named_arg对象：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/format.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> fmt::literals;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(</span><br><span class="line">        <span class="string">&quot;&#123;first&#125; &#123;second&#125;&quot;</span>, </span><br><span class="line">        <span class="string">&quot;first&quot;</span>_a = <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;second&quot;</span>_a = <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式化说明符的语法也是基本相同的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>)</span><br></pre></td></tr></table></figure><p>对应到fmtlib：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>, <span class="number">3.1415926</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的格式化说明符的文档见：<a href="https://fmt.dev/latest/syntax.html">链接</a></p><p>最后fmtlib还支持自定义格式化类型，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> telephone[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">fmt</span>:</span>:formatter&lt;PersonInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> fmt::<span class="function">format_parse_context::iterator </span></span><br><span class="line"><span class="function"><span class="title">parse</span><span class="params">(fmt::format_parse_context&amp; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = ctx.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> ++iter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt::<span class="function">format_context::iterator </span></span><br><span class="line"><span class="function"><span class="title">format</span><span class="params">(PersonInfo info, fmt::format_context&amp; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fmt::format_to(ctx.<span class="built_in">out</span>(), </span><br><span class="line">        <span class="string">&quot;name : &#123;&#125; | age : &#123;&#125; | tel. : &#123;&#125;&quot;</span>, </span><br><span class="line">        info.name, info.age, info.telephone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PersonInfo info&#123; <span class="string">&quot;xiaoming&quot;</span>, <span class="number">18</span>, <span class="string">&quot;1234567890&quot;</span> &#125;;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;&#125;&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C++中格式化字符串的方法一直是一个备受争议的话题，无论是&lt;code&gt;printf&lt;/code&gt;系列函数还是Stream IO都有各自的优缺点。本篇文章直接略过这两种方法，将目光放到fmtlib这个第三方库中，虽然是第三方库，但是C++20标准会引入该库的一部分特性。&lt;/</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>序列和迭代器(3)</title>
    <link href="http://0cch.com/2020/06/15/yampl-seq-and-iterator-part3/"/>
    <id>http://0cch.com/2020/06/15/yampl-seq-and-iterator-part3/</id>
    <published>2020-06-15T10:15:30.000Z</published>
    <updated>2021-01-20T02:02:36.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="list序列的更多元函数"><a href="#list序列的更多元函数" class="headerlink" title="list序列的更多元函数"></a><code>list</code>序列的更多元函数</h2><p>那么目前为止，我们完成了<code>list</code>序列7组基本元函数的调用和验证。不过我们不会就此满足，因为以上元函数能完成的工作有限，为了让序列能完成更多实用的功能，我们还需要进一步的对基础元函进行组合。有一个特别的好消息是，由于后续介绍的元函数都是由以上7组基本元函数组合而成，所以它们可以在任何正向迭代器的序列中使用。不仅如此，如果不是特别在意编译期的效率问题的话，将他们应用于双向迭代器或者随机访问迭代器的序列也是可以的。当然我并不推荐这么做，因为对于双向迭代器或者随机访问迭代器的序列，它们可以使用更灵活的方法操作和访问内部元素。</p><h3 id="push-front元函数"><a href="#push-front元函数" class="headerlink" title="push_front元函数"></a><code>push_front</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_front_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> push_back&lt;<span class="keyword">typename</span> clear&lt;T&gt;::type, U&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_front</span></span></span><br><span class="line"><span class="class">    :</span> push_front_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出<code>push_front</code>是一个极为典型的组合元函数，它使用<code>begin</code>、<code>end</code>、<code>deref</code>、<code>clear</code>和<code>push_back</code>两个元函数的组合，所以它可以用于任何正向迭代器的序列。不过达到这个目的的代价可以不小，因为这个操作从效率上来说是很低的。观察<code>push_front_impl</code>的实现可知，该元函数首先调用<code>clear</code>元函数获取一个空的序列，接着将目标元素<code>push_back</code>到新的空序列中，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> init = <span class="keyword">typename</span> push_back&lt;<span class="keyword">typename</span> clear&lt;T&gt;::type, U&gt;::type;</span><br></pre></td></tr></table></figure><p>并且使用<code>begin</code>、<code>end</code>和<code>deref</code>遍历了原始序列并且按照顺序逐个插入新序列。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br></pre></td></tr></table></figure><h3 id="pop-back和pop-front元函数"><a href="#pop-back和pop-front元函数" class="headerlink" title="pop_back和pop_front元函数"></a><code>pop_back</code>和<code>pop_front</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pop_back_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> next&lt;N&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, I, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> clear&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> next&lt;<span class="keyword">typename</span> begin&lt;T&gt;::type&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pop_back</span></span></span><br><span class="line"><span class="class">    :</span> pop_back_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pop_front_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> clear&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> next&lt;<span class="keyword">typename</span> begin&lt;T&gt;::type&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pop_front</span></span></span><br><span class="line"><span class="class">    :</span> pop_front_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>事实上，<code>pop_back</code>和<code>pop_front</code>元函数与<code>push_front</code>元函数的实现思路基本上是一样的。它们都使用<code>clear</code>元函数创建了一个空序列，然后再往空序列中填充各自的元素。唯一的区别就在于，<code>pop_back</code>元函数会检查下一个迭代器是否为结束迭代器。如果确定是结束迭代器，那么元函数就会忽略当前迭代器，直接返回当前新序列。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> next&lt;N&gt;::type, E&gt;::type;</span><br></pre></td></tr></table></figure><p>而<code>pop_front</code>则是从一开始遍历原始序列迭代器的时候就用<code>next</code>元函数忽略首个迭代器。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> next&lt;<span class="keyword">typename</span> begin&lt;T&gt;::type&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br></pre></td></tr></table></figure><h3 id="insert元函数"><a href="#insert元函数" class="headerlink" title="insert元函数"></a><code>insert</code>元函数</h3><p>上面已经介绍了三个组合而成的元函数，它们的实现虽说比较简单，但是却阐明了这类元函数的基本思路，即创建新的序列，然后遍历原始序列将需要的元素逐个插入到新序列中。现在让我们看一个较为复杂的<code>insert</code>元函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insert_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner, U, B, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, I, I, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> inner2 = <span class="keyword">typename</span> push_back&lt;inner, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner2, I, U, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, B, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, E, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">B</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> clear&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;init, U, B, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insert</span></span></span><br><span class="line"><span class="class">    :</span> insert_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, B, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码总体思路没有变化，先通过<code>clear</code>创建了新序列，难点是如何遍历原始序列并且找到目标位置插入新元素。这里让我们把注意力放在4个版本的<code>apply_impl</code>上，首先来看通常版本的元函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner, U, B, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>该元函数非常简单，通过<code>push_back</code>将原序列的元素插入到新序列中，其中<code>I</code>是迭代器。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, I, I, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> inner2 = <span class="keyword">typename</span> push_back&lt;inner, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner2, I, U, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>第二个的<code>apply_impl</code>是一个特化版本，它限定了当当前迭代器<code>I</code>与目标迭代器相同的时候，将新元素<code>U</code>插入到新序列中，然后再插入迭代器<code>I</code>的元素，这样就能完成插入目标元素<code>U</code>到指定迭代器之前的任务。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, B, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, E, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>最后两个特化版本的<code>apply_impl</code>限定了元函数的结束条件。一方面<code>apply_impl&lt;R, U, B, E, E&gt;</code>，当原序列遍历到结束迭代器时，如果插入目标位置不是结束迭代器，则插入操作直接结束，返回新序列。另一方面<code>apply_impl&lt;R, U, E, E, E&gt;</code>，当原序列遍历到结束迭代器时，如果插入目标位置正好是结束迭代器，那么就将目标元素<code>U</code>插入到新序列的末尾。</p><p>以下是一个调用<code>insert</code>元函数的示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> insert_list = list&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>, <span class="keyword">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> result_list = insert&lt;insert_list, <span class="keyword">short</span>, begin&lt;insert_list&gt;::type&gt;::type;</span><br></pre></td></tr></table></figure><p>示例代码中，<code>insert</code>元函数将<code>short</code>类型插入了<code>insert_list</code>序列的<code>begin</code>迭代器之前，于是<code>result_list</code>的结果应该是<code>list&lt;short, int, bool, char&gt;</code>。</p><h3 id="其他组合元函数"><a href="#其他组合元函数" class="headerlink" title="其他组合元函数"></a>其他组合元函数</h3><p>除了我们上面介绍的<code>push_front</code>、<code>pop_back</code>、<code>pop_front</code>和<code>insert</code>元函数以外，我们还能根据自己的需要实现其他的元函数。比如，用于删除元素的<code>erase</code>元函数，用于排重的<code>unique</code>元函数，用于逆向排序的<code>reverse</code>元函数以及用于查找元素的<code>find</code>元函数等等。它们虽然有各自不同的功能，但是实现思路上确实万变不离其宗的。有兴趣的读者不妨自己尝试动手实现一两个。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;list序列的更多元函数&quot;&gt;&lt;a href=&quot;#list序列的更多元函数&quot; class=&quot;headerlink&quot; title=&quot;list序列的更多元函数&quot;&gt;&lt;/a&gt;&lt;code&gt;list&lt;/code&gt;序列的更多元函数&lt;/h2&gt;&lt;p&gt;那么目前为止，我们完成了&lt;code</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>序列和迭代器(2)</title>
    <link href="http://0cch.com/2020/05/20/yampl-seq-and-iterator-part2/"/>
    <id>http://0cch.com/2020/05/20/yampl-seq-and-iterator-part2/</id>
    <published>2020-05-20T09:20:11.000Z</published>
    <updated>2021-01-20T02:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="list序列"><a href="#list序列" class="headerlink" title="list序列"></a>list序列</h2><p><code>list</code>序列实际上就是曾经介绍的<code>seq</code>序列的加强版，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_tag</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category_tag = forward_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> tag = list_tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，<code>list</code>序列是一个有可变模板形参的类模板，它有两个内嵌类型分别是<code>iterator_category_tag</code>和<code>tag</code>。其中<code>tag</code>指示该序列的类型是<code>list_tag</code>，<code>iterator_category_tag</code>指示<code>list</code>序列的迭代器类型是正向迭代器<code>forward_iterator_tag</code>。除了正向迭代器的<code>tag</code>，YAMPL还定义了双向和随机访问迭代器。</p><table><thead><tr><th>迭代器名称</th><th>定义</th></tr></thead><tbody><tr><td>正向迭代器</td><td><code>forward_iterator_tag</code></td></tr><tr><td>双向迭代器</td><td><code>bidirectional_iterator_tag</code></td></tr><tr><td>随机访问迭代器</td><td><code>random_access_iterator_tag</code></td></tr></tbody></table><p>正如上一节所说，要完成一个正向迭代器的序列需要实现至少7组基础元函数。接下来我们会逐一的实现这些元函数。</p><h3 id="begin-impl元函数"><a href="#begin-impl元函数" class="headerlink" title="begin_impl元函数"></a><code>begin_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">begin_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = iterator&lt;T&lt;Args...&gt;, integral_const&lt;<span class="keyword">int</span>, <span class="number">0</span>&gt;, T&lt;Args...&gt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上面的代码，让我们来详细的观察<code>begin_impl</code>的实现。首先可以看到<code>template &lt;&gt; struct begin_impl&lt;list_tag&gt;</code>是一个<code>template &lt;class Tag&gt; struct begin_impl &#123;&#125;;</code>针对<code>list_tag</code>的特化版本。它的作用就是让告知编译器在处理<code>tag</code>为<code>list_tag</code>的序列时，选用<code>template &lt;&gt; struct begin_impl&lt;list_tag&gt;</code>这个元函数。回过头来看<code>begin</code>元函数的实现，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">begin</span> :</span> begin_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>begin_impl</code>元函数调用了<code>sequence_tag</code>来获取序列的<code>tag</code>，从而让编译器能够正确选择<code>begin_impl</code>的版本。<code>sequence_tag</code>的实现很简单，就是获取类型的<code>tag</code>并返回。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sequence_tag</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> T::tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着观察<code>begin_impl&lt;typename sequence_tag&lt;T&gt;::type&gt;::template apply&lt;T&gt;</code>的<code>apply&lt;T&gt;</code>，我们发现在编译器选择了正确的<code>begin_impl</code>后，真正发挥作用的是内嵌元函数<code>template &lt;class T&gt; struct apply</code>，它的任务是处理<code>begin</code>传入的模板参数<code>T</code>，并且返回第1个迭代器。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = iterator&lt;T&lt;Args...&gt;, integral_const&lt;<span class="keyword">int</span>, <span class="number">0</span>&gt;, T&lt;Args...&gt;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>apply</code>的实现并不复杂，需要注意的是返回迭代器中模板实参的含义。第一个实参<code>T&lt;Args...&gt;</code>是记录当前迭代器所代表的元素以及该元素之后所有元素的序列，比方说现在有一个迭代器的第一个实参为<code>list&lt;int, char, double&gt;</code>，那么它的下一个迭代器的第一个实参应该是<code>list&lt;char, double&gt;</code>。第二个实参<code>integral_const&lt;int, 0&gt;</code>是用来记录当前迭代器在序列中的位置，因为<code>begin</code>返回的是序列的第一个迭代器，所有其位置应该是0。最后的实参<code>T&lt;Args...&gt;</code>对整个序列的记录，由于是首个迭代器所以这个实参看起来和第一个实参相同。另外需要注意的是在正向迭代器中，第三个实参并没有什么作用，之所以给出了这个定义是因为YAMPL还为<code>list</code>实现了一个双向迭代器的版本。</p><h3 id="end-impl元函数"><a href="#end-impl元函数" class="headerlink" title="end_impl元函数"></a><code>end_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">end_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        iterator&lt;T&lt;&gt;, integral_const&lt;<span class="keyword">int</span>, <span class="keyword">sizeof</span>...(Args)&gt;, T&lt;Args...&gt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>end_impl</code>的实现和<code>begin_impl</code>基本相同，唯一的区别是内嵌元函数<code>apply</code>返回的迭代器的定义不同，它将返回序列最后一个元素之后的迭代器。该迭代器的第一个实参为<code>T&lt;&gt;</code>，这说明该迭代器已经没有代表的元素了。第二个实参<code>integral_const&lt;int, sizeof...(Args)&gt;</code>同样表示当前迭代器在序列的位置。最后的实参<code>T&lt;Args...&gt;</code>还是对整个序列的记录。</p><h3 id="size-impl元函数"><a href="#size-impl元函数" class="headerlink" title="size_impl元函数"></a><code>size_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">size_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;<span class="keyword">int</span>, <span class="keyword">sizeof</span>...(Args)&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>size_impl</code>的内嵌元函数<code>apply</code>返回的是序列中元素的数量<code>integral_const&lt;int, sizeof...(Args)&gt;</code>。</p><h3 id="clear-impl元函数"><a href="#clear-impl元函数" class="headerlink" title="clear_impl元函数"></a><code>clear_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clear_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T&lt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>clear_impl</code>的内嵌元函数<code>apply</code>返回的是空序列<code>T&lt;&gt;</code>。</p><h3 id="push-back-impl元函数"><a href="#push-back-impl元函数" class="headerlink" title="push_back_impl元函数"></a><code>push_back_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_back_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;, U&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T&lt;Args..., U&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>push_back_impl</code>的内嵌元函数<code>apply</code>和之前我们看到的<code>apply</code>元函数有一些区别，它需要两个模板参数，这也正是<code>push_back</code>元函数所需的模板参数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_back</span></span></span><br><span class="line"><span class="class">    :</span> push_back_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>其中实参<code>T</code>是序列本身，实参U是需要插入序列的元素。最终<code>apply</code>返回的是插入新元素之后的序列<code>T&lt;Args..., U&gt;</code>。</p><h3 id="next-impl元函数"><a href="#next-impl元函数" class="headerlink" title="next_impl元函数"></a><code>next_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">next_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">B</span>,</span></span><br><span class="line"><span class="class">            <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>iterator&lt;T&lt;U, Args...&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = iterator&lt;T&lt;Args...&gt;, <span class="keyword">typename</span> N::next, B&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">B</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>iterator&lt;T&lt;U&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = iterator&lt;T&lt;&gt;, <span class="keyword">typename</span> N::next, B&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>next_impl</code>的内嵌元函数<code>apply</code>是一个针对迭代器的元函数，之前我们看到的无论是<code>begin_impl</code>还是<code>push_back_impl</code>的<code>apply</code>元函数都是针对序列本身的。这一点从<code>next</code>的定义中也能看出点端倪。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">next</span></span></span><br><span class="line"><span class="class">    :</span> next_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>我们发现，<code>next_impl</code>并没有调用<code>sequence_tag</code>获取序列<code>tag</code>，而是采用<code>iterator_sequence_tag</code>元函数获取迭代器所属序列的<code>tag</code>，所以这里<code>next</code>元函数操作的主体对象是迭代器而不是序列。</p><p>回头来看<code>next_impl</code>中<code>apply</code>的代码，可以看到<code>apply</code>有两个特化版本，首先当模板实参为<code>iterator&lt;T&lt;U, Args...&gt;, N, B&gt;</code>时，说明该迭代器不是倒数第二个迭代器，那么<code>apply</code>的返回结果应该是下个迭代器<code>iterator&lt;T&lt;Args...&gt;, typename N::next, B&gt;</code>。请注意，因为我们知道模板形参<code>N</code>是一个<code>integral_const</code>类型，所以可以直接使用<code>N::next</code>获取它的下一个整型包装类。</p><p>接下来当模板实参为<code>iterator&lt;T&lt;U&gt;, N, B&gt;</code>时，说明它是序列中倒数第二个迭代器。这时<code>apply</code>应该与<code>end</code>元函数返回一个相同的迭代器<code>iterator&lt;T&lt;&gt;, typename N::next, B&gt;</code>。</p><h3 id="deref-impl元函数"><a href="#deref-impl元函数" class="headerlink" title="deref_impl元函数"></a><code>deref_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deref_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>,</span></span><br><span class="line"><span class="class">            <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>iterator&lt;T&lt;U, Args...&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = U;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">B</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>iterator&lt;T&lt;&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = none;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>deref_impl</code>和<code>next_impl</code>一样也是针对迭代器的元函数，它对迭代器进行解引用操作，随后可以获得元素本身。观察<code>deref_impl</code>的内嵌<code>apply</code>元函数，它也有两个特化版本。当其实参的迭代器为<code>iterator&lt;T&lt;U, Args...&gt;, N, B&gt;</code>时，说明它不是最后一个迭代器，于是返回当前元素<code>U</code>。当实参的迭代器为<code>iterator&lt;T&lt;&gt;, N, B&gt;</code>时，说明这是最后一个迭代器，它不包含任何元素，所以返回<code>none</code>。这里的<code>none</code>是YAMPL专门为类似这种情况定义的类型，用来表示没有意义的结果，具体定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">none_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">none</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> tag = none_tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list序列和迭代器的基本用法"><a href="#list序列和迭代器的基本用法" class="headerlink" title="list序列和迭代器的基本用法"></a><code>list</code>序列和迭代器的基本用法</h2><p>熟悉STL的读者一定对迭代器的使用了如指掌，因为STL中关于容器的大部分函数都依赖迭代器。比如从<code>std::list</code>的容器中删除一个元素就需要使用迭代器指明元素的位置。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::list&lt;<span class="keyword">int</span>&gt; mylist&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">mylist.<span class="built_in">erase</span>(mylist.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><p>模板元编程中序列和迭代器的使用方法和STL的迭代器比较类似，只是代码的写法上有些不同，总的来说还算比较容易掌握。以下是一段调用并验证<code>yampl::list</code>基本元函数的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::boolalpha;</span><br><span class="line"><span class="keyword">using</span> my_list = list&lt;int_&lt;<span class="number">0</span>&gt;, int_&lt;<span class="number">1</span>&gt;, int_&lt;<span class="number">2</span>&gt;, int_&lt;<span class="number">3</span>&gt;, int_&lt;<span class="number">4</span>&gt;&gt;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;my_list size = &quot;</span> &lt;&lt; size&lt;my_list&gt;::type::value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> it0 = <span class="keyword">typename</span> begin&lt;my_list&gt;::type;</span><br><span class="line"><span class="keyword">using</span> elem0 = <span class="keyword">typename</span> deref&lt;it0&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;elem0 == int_&lt;0&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;elem0, int_&lt;<span class="number">0</span>&gt;&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> it1 = <span class="keyword">typename</span> next&lt;it0&gt;::type;</span><br><span class="line"><span class="keyword">using</span> elem1 = <span class="keyword">typename</span> deref&lt;it1&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;elem1 == int_&lt;1&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;elem1, int_&lt;<span class="number">1</span>&gt;&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> it2 = <span class="keyword">typename</span> next&lt;it1&gt;::type;</span><br><span class="line"><span class="keyword">using</span> it3 = <span class="keyword">typename</span> next&lt;it2&gt;::type;</span><br><span class="line"><span class="keyword">using</span> it4 = <span class="keyword">typename</span> next&lt;it3&gt;::type;</span><br><span class="line"><span class="keyword">using</span> elem4 = <span class="keyword">typename</span> deref&lt;it4&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;elem4 == int_&lt;4&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;elem4, int_&lt;<span class="number">4</span>&gt;&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;next&lt;it4&gt;::type == end&lt;my_list&gt;::type : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;<span class="keyword">typename</span> next&lt;it4&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;my_list&gt;::type&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> empty_list = <span class="keyword">typename</span> clear&lt;my_list&gt;::type;</span><br><span class="line"><span class="keyword">using</span> my_list2 = <span class="keyword">typename</span> push_back&lt;empty_list, int_&lt;<span class="number">5</span>&gt;&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;my_list2 == list&lt;int_&lt;5&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;my_list2, list&lt;int_&lt;5&gt;&gt;&gt; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>在上面的代码中，首先定义了一个<code>list</code>序列<code>my_list</code>，序列共有5个元素，它们从<code>int_&lt;0&gt;</code>递增至<code>int&lt;4&gt;</code>。使用<code>size</code>元函数可以获取<code>my_list</code>中元素个数，这里返回的是<code>int_&lt;5&gt;</code>，通过<code>::value</code>可以获取整型数字5，所以第一句<code>std::cout</code>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list size = 5</span><br></pre></td></tr></table></figure><p>接着，代码调用<code>begin</code>元函数返回了序列<code>my_list</code>的第一个迭代器<code>it0</code>，可以预见到这个迭代器解引用后的元素就是<code>int_&lt;0&gt;</code>。为了证明这一点，使用元函数<code>deref</code>可以对<code>it0</code>解引用并获得结果<code>elem0</code>，再使用<code>std::is_same_v&lt;elem0, int_&lt;0&gt;&gt;</code>验证类型是否相同，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elem0 == int_&lt;0&gt; : true</span><br></pre></td></tr></table></figure><p>为了获取下一个迭代器，可以使用元函数<code>next</code>，这样可以获取迭代器<code>it1</code>。通过同样的方式我们可以获取<code>it2</code>到<code>it4</code>，并且对它们的类型进行判断：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elem1 == int_&lt;1&gt; : true</span><br><span class="line">elem4 == int_&lt;4&gt; : true</span><br></pre></td></tr></table></figure><p><code>it4</code>的下一个迭代器是<code>my_list</code>中最后一个迭代器，应该与<code>end</code>元函数返回的结果相同。我们同样可以通过<code>std::is_same_v&lt;typename next&lt;it4&gt;::type, typename end&lt;my_list&gt;::type&gt;</code>来验证这个结论：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next&lt;it4&gt;::type == end&lt;mylist&gt;::type : true</span><br></pre></td></tr></table></figure><p>最后，代码中使用<code>clear</code>元函数返回一个空<code>list</code>序列，并且调用<code>push_back</code>将<code>int_&lt;5&gt;</code>插入到序列之中并获得序列<code>my_list2</code>。用同样的方法再次验证<code>push_back</code>和<code>clear</code>元函数的正确性，得到输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list2 == list&lt;int_&lt;5&gt; : true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;list序列&quot;&gt;&lt;a href=&quot;#list序列&quot; class=&quot;headerlink&quot; title=&quot;list序列&quot;&gt;&lt;/a&gt;list序列&lt;/h2&gt;&lt;p&gt;&lt;code&gt;list&lt;/code&gt;序列实际上就是曾经介绍的&lt;code&gt;seq&lt;/code&gt;序列的加强版，它的</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>序列和迭代器(1)</title>
    <link href="http://0cch.com/2020/04/01/yampl-seq-and-iterator-part1/"/>
    <id>http://0cch.com/2020/04/01/yampl-seq-and-iterator-part1/</id>
    <published>2020-03-31T23:36:51.000Z</published>
    <updated>2021-01-20T01:59:14.618Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的篇幅中我们已经看到了序列在模板元编程中的一部分作用。在本篇中我们将更加深入的探讨序列以及与之相关的算法，同时我们会使用建立迭代器的方法将这些算法抽象出来以方便它们运用到不同类型的序列中。在YAMPL中实现了两种类型的序列<code>list</code>和<code>vector</code>，本章中我将着重介绍<code>list</code>序列，这是因为该序列更好的使用了C++11的特性。另外本篇中介绍的算法基本上都是使用迭代器实现，所以它们可以顺利的移植到<code>vector</code>上。读者也可以将这些算法移植到自己实现的序列上，而这个移植过程也只需要实现少量代码。</p><h2 id="定义迭代器"><a href="#定义迭代器" class="headerlink" title="定义迭代器"></a>定义迭代器</h2><p>为了保证序列相关算法的通用性，我们需要将算法的实现建立在迭代器的基础之上，于是设计一个通用的迭代器就变得十分重要了。以下代码是YAMPL中通用迭代器类模板的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">B</span> =</span> <span class="keyword">void</span>, <span class="class"><span class="keyword">class</span> <span class="title">B2</span> =</span> <span class="keyword">void</span>, <span class="class"><span class="keyword">class</span> <span class="title">B3</span> =</span> <span class="keyword">void</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">  <span class="keyword">using</span> index = N;</span><br><span class="line">  <span class="keyword">using</span> backup = B;</span><br><span class="line">  <span class="keyword">using</span> backup2 = B2;</span><br><span class="line">  <span class="keyword">using</span> backup3 = B3;</span><br><span class="line">  <span class="keyword">using</span> tag = iterator_tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，迭代器<code>iterator</code>定义了5个模板形参。其中第一个形参<code>T</code>通常用于记录当前迭代器代表的元素本身或者是记录与该元素相关的序列；第二个形参<code>N</code>通常用于记录当前迭代器在序列中的位置；而剩下的3个形参可以用来记录一些额外的序列信息。</p><p>值得注意的是，以上描述是这5个形参在YAMPL序列中的惯用用法，它们并不是绝对的，所以序列的设计者可以根据序列本身的实际情况安排这5个形参的用途。比如YAMPL中的<code>list</code>使用了前3个形参，而<code>vector</code>只使用了前2个形参。</p><p>最后来说明一下内嵌类型<code>tag</code>的用途。在YAMPL中，和序列相关的类模板都有一个<code>tag</code>，比如迭代器的<code>tag</code>就是<code>iterator_tag</code>。这些<code>tag</code>的主要功能是对序列相关的类模板进行分类以方便通用算法在不同的序列上正常工作。例如YAMPL的<code>list</code>序列的<code>tag</code>为<code>list_tag</code>，那么为<code>list_tag</code>设计的基础元函数就能使用在<code>list</code>序列之上。同样的道理，若序列的设计者为了某特殊情况定义了一个<code>special_list</code>序列，并且将其<code>tag</code>定义为<code>list_tag</code>，那么为<code>list_tag</code>设计的算法就可以用于该序列了。</p><h2 id="序列和迭代器的基础元函数"><a href="#序列和迭代器的基础元函数" class="headerlink" title="序列和迭代器的基础元函数"></a>序列和迭代器的基础元函数</h2><p>为了让迭代器能顺利的移植到不同的序列上，我们需要定义几个抽象的元函数。这些元函数有些类似C++纯虚函数的概念，它们只提供一个元函数的轮廓，而具体是定义还是要由序列的设计者来实现。这些基础元函数包括：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">begin_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">begin</span> :</span> begin_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">end_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">end</span> :</span> end_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">next_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">next</span></span></span><br><span class="line"><span class="class">    :</span> next_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deref_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deref</span></span></span><br><span class="line"><span class="class">    :</span> deref_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">size_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">size</span> :</span> size_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clear_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clear</span> :</span> clear_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_back_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_back</span></span></span><br><span class="line"><span class="class">    :</span> push_back_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码展示了7组基础元函数，它们分别是<code>begin</code>、<code>end</code>、<code>next</code>、 <code>deref</code>、<code>size</code>、<code>clear</code>和<code>push_back</code>。之所以把它们列为基础元函数，是因为要让一个序列和与之相关的迭代器能正常工作这7组元函数是必不可少的。如果一个序列能实现这7组元函数，那么它的迭代器至少能完成一个正向迭代器的全部工作。</p><p>这7组元函数的功能具体为：</p><table><thead><tr><th align="left">元函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>begin</code></td><td align="left">返回序列中代表第一个元素的迭代器；</td></tr><tr><td align="left"><code>end</code></td><td align="left">返回序列中代表最后一个元素之后的迭代器；</td></tr><tr><td align="left"><code>next</code></td><td align="left">返回当前迭代器代表元素的下一个元素的迭代器；</td></tr><tr><td align="left"><code>deref</code></td><td align="left">解引用，返回当前迭代器代表的元素本身；</td></tr><tr><td align="left"><code>size</code></td><td align="left">返回序列中元素个数；</td></tr><tr><td align="left"><code>clear</code></td><td align="left">删除序列中的所有元素；</td></tr><tr><td align="left"><code>push_back</code></td><td align="left">在序列的最后新增一个元素。</td></tr></tbody></table><p>如果序列的设计者并不满足于正向迭代器的功能，那么还可以实现一个<code>prior</code>元函数的<code>_impl</code>版本来完成一个双向迭代器，<code>prior</code>元函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prior_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prior</span></span></span><br><span class="line"><span class="class">    :</span> prior_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>prior</code>函数的功能具体为：</p><table><thead><tr><th>元函数</th><th>说明</th></tr></thead><tbody><tr><td><code>prior</code></td><td>返回当前迭代器代表元素的上一个元素的迭代器。</td></tr></tbody></table><p>进一步的，如果序列的设计者希望该序列能支持一个随机访问迭代器，那么还需要实现以下2组基础元函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">advance_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">advance</span></span></span><br><span class="line"><span class="class">    :</span> advance_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T,</span><br><span class="line">                                                                            N&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">distance_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">distance</span></span></span><br><span class="line"><span class="class">    :</span> distance_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;</span><br><span class="line">          T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这2组元函数的功能具体为：</p><table><thead><tr><th>元函数</th><th>说明</th></tr></thead><tbody><tr><td><code>advance</code></td><td>返回当前迭代器代表元素的第N个递进元素的迭代器</td></tr><tr><td><code>distance</code></td><td>计算同序列中两个迭代器的间隔元素</td></tr></tbody></table><p>需要注意的是，序列需要实现的并不是<code>begin</code>、<code>end</code>、<code>next</code>这些元函数本身，而是它们间接调用的<code>_impl</code>版本的内嵌<code>apply</code>元函数。具体来说，想实现序列的<code>push_back</code>功能，那么应该对应的实现<code>push_back_impl</code>和<code>push_back_impl::apply</code>的元函数，具体的实现方法会在后面<code>list</code>序列的小节中介绍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前面的篇幅中我们已经看到了序列在模板元编程中的一部分作用。在本篇中我们将更加深入的探讨序列以及与之相关的算法，同时我们会使用建立迭代器的方法将这些算法抽象出来以方便它们运用到不同类型的序列中。在YAMPL中实现了两种类型的序列&lt;code&gt;list&lt;/code&gt;和&lt;code</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>YAMPL的基础组件(3)</title>
    <link href="http://0cch.com/2020/03/08/yampl-base-components-part3/"/>
    <id>http://0cch.com/2020/03/08/yampl-base-components-part3/</id>
    <published>2020-03-08T14:23:33.000Z</published>
    <updated>2021-01-20T01:50:53.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逻辑运算符元函数"><a href="#逻辑运算符元函数" class="headerlink" title="逻辑运算符元函数"></a>逻辑运算符元函数</h2><p>在C++中逻辑运算符可以将两个或多个关系表达式连接成一个，例如<code>&amp;&amp;</code>和<code>||</code>，也能够使表达式的逻辑反转，例如<code>!</code>。在这个小节中，我们将根据C++的逻辑运算符实现一套YAMPL可以使用的逻辑运算符元函数，除此之外我们还将结合上面的内容来完成一个元编程例子。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">and_</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> inner = and_&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value &amp;&amp; inner::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">and_</span>&lt;</span>N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value &amp;&amp; N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>观察上面的代码会发现，<code>and_</code>元函数的实现和<code>plus</code>元函数几乎相同，除了使用了不同的运算符以外，唯一的区别就是返回类型。<code>and_</code>元函数的返回类型<code>using type = integral_const&lt;value_type, N1::value &amp;&amp; inner::value&gt;;</code>固定为<code>integral_const&lt;bool, true&gt;</code>或者<code>integral_const&lt;bool, false&gt;</code>之一，也就是<code>true_type</code>或者<code>false_type</code>。这个设计正好是对应<code>&amp;&amp;</code>运算符的返回值必须是<code>true</code>或者<code>false</code>之一。说明了这个区别之后，读者可以回味一下<code>plus</code>的实现应该就能理解<code>and_</code>元函数的实现细节了，这里也不再赘述。</p><p>如<code>and_</code>元函数一样，<code>or_</code>也可以通过这样的方式实现，而且只需要修改一个运算符而已。所以这里还是用宏简化代码的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_MULTI_OP_BOOL(name, op)                                  \</span></span><br><span class="line"><span class="meta">  template <span class="meta-string">&lt;class N1, class N2, class... Nargs&gt;</span>                         \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                                         \</span></span><br><span class="line"><span class="meta">    using inner = name<span class="meta-string">&lt;N2, Nargs...&gt;</span>;                                   \</span></span><br><span class="line"><span class="meta">    using value_type = bool;                                            \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="meta-string">&lt;value_type, N1::value op inner::value&gt;</span>; \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                    \</span></span><br><span class="line"><span class="meta">  &#125;;                                                                    \</span></span><br><span class="line"><span class="meta">  template <span class="meta-string">&lt;class N1, class N2&gt;</span>                                         \</span></span><br><span class="line"><span class="meta">  struct name<span class="meta-string">&lt;N1, N2&gt;</span> &#123;                                                 \</span></span><br><span class="line"><span class="meta">    using value_type = bool;                                            \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="meta-string">&lt;value_type, (N1::value op N2::value)&gt;</span>;  \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                    \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_MULTI_OP_BOOL</span>(and_, &amp;&amp;);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP_BOOL</span>(or_, ||);</span><br></pre></td></tr></table></figure><p>以上代码实现了逻辑与和逻辑或的运算符元函数，接下来我们需要实现一个逻辑非运算符元函数，也就是在C++中常用的<code>!</code>。逻辑非运算符元函数的实现相对于前两个就单纯多了，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">not_</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, !T::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里只需要注意<code>not_</code>元函数的返回类型也是固定为<code>integral_const&lt;bool, true&gt;</code>或者<code>integral_const&lt;bool, false&gt;</code>之一，剩下的代码和取负运算符元函数的代码几乎相同很容易理解。</p><p>现在，我们要利用上面介绍的内容实现一个特殊的函数模板：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">special_func</span><span class="params">(T)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>该函数模板需要完成这样一个任务：当模板实参<code>T</code>是一个标量或者引用时，函数参数的<code>T</code>为实参本身；否则<code>T</code>为实参的引用。也就是说当<code>T</code>为<code>int</code>时，函数为<code>void special_func(int) &#123;&#125;</code>；当<code>T</code>为<code>int&amp;</code>时，函数为<code>void special_func(int&amp;) &#123;&#125;</code>；当T为<code>std::string</code>时，函数为<code>void special_func(std::string&amp;) &#123;&#125;</code>。</p><p>以下是我的一种实现方案：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func_helper</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> cond = or_&lt;<span class="keyword">typename</span> std::is_scalar&lt;T&gt;::type,</span><br><span class="line">                   <span class="keyword">typename</span> std::is_reference&lt;T&gt;::type&gt;;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> if_&lt;<span class="keyword">typename</span> cond::type, T,</span><br><span class="line">                            <span class="keyword">typename</span> std::add_lvalue_reference&lt;T&gt;::type&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">special_func</span><span class="params">(<span class="keyword">typename</span> func_helper&lt;T&gt;::type)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中实现了一个<code>func_helper</code>元函数，该元函数会针对<code>special_func</code>的模板实参进行处理以满足函数需求。在<code>func_helper</code>的实现代码中，首先调用了逻辑或元函数<code>or_</code>，用于判断<code>T</code>是否为标量或者引用类型。然后根据返回结果调用<code>if_</code>元函数。当<code>cond::type</code>的结果为<code>true_type</code>时返回<code>T</code>本身，否则调用<code>std::add_lvalue_reference</code>返回<code>T</code>的引用类型，最终<code>type</code>为要求的返回类型。</p><p>来测试一下刚刚编写的函数模板：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">special_func&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">special_func&lt;<span class="keyword">int</span>&amp;&gt;(n);</span><br><span class="line">std::string s&#123; <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">special_func&lt;std::string&gt;(s);</span><br></pre></td></tr></table></figure><p>使用<code>-fdump-tree-gimple</code>命令让GCC生成gimple的中间代码，观察代码发现这样三份中间代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">special_func&lt;int&gt; (type v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br><span class="line">special_func&lt;int&amp;&gt; (int &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br><span class="line">special_func&lt;std::__cxx11::basic_string&lt;char&gt; &gt; (struct basic_string &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当模板实参为<code>int</code>和<code>int&amp;</code>时，函数形参类型为模板实参本身，而当模板实参为<code>std::__cxx11::basic_string&lt;char&gt;</code>时，函数形参类型为<code>struct basic_string &amp;</code>，满足函数的设计要求。</p><h2 id="类型打印元函数"><a href="#类型打印元函数" class="headerlink" title="类型打印元函数"></a>类型打印元函数</h2><p>模板元程序之所以比普通C++程序更难编写主要是因为它很难调试。我们常用的调试方法在模板元程序上都没法正常使用，比如调试器只能调试动态运行的程序，但是却无法调试编译期执行的元程序。</p><p>另外打印日志的方法也许能帮上一点忙，因为C++为我们提供了<code>typeid</code>这个操作符，它返回的<code>std::type_info</code>结构中存在一个<code>const char* name()</code>的成员函数可以返回类型名称。于是我们想到可以使用以下方法打印类型信息帮助调试：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure><p>不过遗憾的是，这种方法也并不完美。首先来说，成员函数<code>name()</code>返回的类型名称在不同编译器中有不同的展现方法，比如MSVC编译出来的程序返回的是一个可读的名称，而GCC编译出来的程序返回的类型名称则需要使用特定API（例如<code>abi::__cxa_demangle</code>）将其转换为可读的名称。其次，<code>typeid</code>也无法真实的反应类型的状态，因为C++标准中说明了<code>typeid</code>会忽略类型的<code>cv</code>属性，也就是说<code>typeid(const T) == typeid(T)</code>。所以<code>typeid</code>打印日志的方法也不满足需求。</p><p>为了准确是输出类型信息，我们需要将目光从程序本身移动到编译期上，因为只有编译期才是掌握类型信息最全面的程序。于是我们可以想到使用编译期的错误信息来打印类型信息。由于错误信息往往是帮助程序员排查错误，所以类型信息会非常的全面。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">err_print_type</span>;</span></span><br><span class="line"></span><br><span class="line">err_print_type&lt;<span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type&gt;();</span><br></pre></td></tr></table></figure><p>在上面的代码中<code>err_print_type</code>是一个缺少实现的类模板，所以当编译器将其进行实例化的时候必然会报错，而错误信息正是我们想要的结果。<code>err_print_type&lt;typename minus&lt;int_&lt;10&gt;, int_&lt;2&gt;&gt;::type&gt;();</code>在MSVC中会显示错误信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error C2027: use of undefined type &#x27;err_print_type&lt;yampl::integral_const&lt;T,8&gt;&gt;&#x27;</span><br><span class="line">with</span><br><span class="line">[</span><br><span class="line">    T=int</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在GCC中显示错误信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: invalid use of incomplete type &#x27;struct err_print_type&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#x27;</span><br></pre></td></tr></table></figure><p>可以看到，无论是哪种编译器都非常详细的显示了类型信息。</p><p>现在类型信息是完整了，但这种方法还是不太好，因为错误会阻止程序的编译导致无法生成可执行程序。我们需要一种方法既能在编译期产生可用的日志，与此同时也不能阻碍程序的正常编译。于是我们想到，如果能将错误信息转换为警告信息不久好了么！在YAMPL中，打印类型信息的方法就是用这种思路实现的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__clang__)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> tmp = <span class="number">1</span> / (<span class="built_in"><span class="keyword">sizeof</span></span>(T) - <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__GNUC__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic <span class="meta-keyword">warning</span> <span class="meta-string">&quot;-Wsign-compare&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(T) &gt; <span class="number">-1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push, 3)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>以上代码实现了一个类模板<code>dbg_print_type</code>，并且分别对MSVC、GCC和CLang做了支持。当编译期时MSVC时，使用了数组大小为0的技巧促使编译期发出警告；当编译器是CLang时，使用除数为0的方式让编译器发出警告；当编译器是GCC时，使用不同符号类型比较让编译器发出警告，值得注意的是这个警告需要手动开启。</p><p>将上面示例中的<code>err_print_type</code>修改为<code>dbg_print_type</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dbg_print_type&lt;<span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type&gt;();</span><br></pre></td></tr></table></figure><p>GCC会发出这样的警告：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In instantiation of &#x27;struct yampl::DbgPrintType&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#x27;:</span><br><span class="line">required from here</span><br><span class="line">warning: comparison of integer expressions of different signedness: &#x27;long long unsigned int&#x27; and &#x27;int&#x27; [-Wsign-compare]</span><br><span class="line">   15 |   enum &#123; n = sizeof(T) &gt; -1 &#125;;</span><br></pre></td></tr></table></figure><p>MSVC显示的警告为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">warning C4200: nonstandard extension used: zero-sized array in struct/union</span><br><span class="line">message : This member will be ignored by a defaulted constructor or copy/move assignment operator</span><br><span class="line">message : see reference to class template instantiation &#x27;yampl::DbgPrintType&lt;yampl::integral_const&lt;T,8&gt;&gt;&#x27; being compiled</span><br><span class="line">with</span><br><span class="line">[</span><br><span class="line">    T=int</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>请注意警告的信息确实比较多，但是仔细观察还是能看到<code>&#39;struct yampl::DbgPrintType&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#39;</code>这样类似的信息。另外值得高兴的是，这些警告信息也确实没有阻止程序的编译。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;逻辑运算符元函数&quot;&gt;&lt;a href=&quot;#逻辑运算符元函数&quot; class=&quot;headerlink&quot; title=&quot;逻辑运算符元函数&quot;&gt;&lt;/a&gt;逻辑运算符元函数&lt;/h2&gt;&lt;p&gt;在C++中逻辑运算符可以将两个或多个关系表达式连接成一个，例如&lt;code&gt;&amp;amp;&amp;amp</summary>
      
    
    
    
    <category term="CPP" scheme="http://0cch.com/categories/CPP/"/>
    
    
  </entry>
  
</feed>
