<!DOCTYPE html>
<html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <link rel="icon" href="/favicon.ico">
  
  <title>0CCh Blog | YAMPL的基础组件(3)</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox-1.3.4.css">
  <!--在这里倒入jquery 方便处理部分页面的jquery-->
  <script src="https://cdn.staticfile.org/jquery/1.7/jquery.min.js" type="text/javascript"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head></html>

<body>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="site-header navfixed-false">
  <div class="container">
      <h1><a href="/" title="0CCh Blog"><span class="octicon octicon-mark-github"></span> 0CCh Blog</a></h1>
      <nav class="site-header-nav" role="navigation">
        
              
              <a href="/"  class=" site-header-nav-item hvr-underline-from-center" title="Home">Home</a>
        
              
              <a href="/categories/"  class=" site-header-nav-item hvr-underline-from-center" title="Category">Category</a>
        
              
              <a href="/open-source/"  class=" site-header-nav-item hvr-underline-from-center" title="Open-Source">Open-Source</a>
        
      </nav>
  </div>
</header>

	
<section class="collection-head geopattern" data-pattern-id="YAMPL的基础组件(3)" >
    <div class="container">
        <div class="collection-title">
            <h1 class="collection-header">
                YAMPL的基础组件(3)
            </h1>
            
                <div class="collection-info">
                    <span class="meta-info">
                        <span class="octicon octicon-calendar"></span>
                        <time datetime="2020-03-08T14:23:33.000Z" itemprop="datePublished">2020-03-08</time>
                    </span>
                    
                        <span class="meta-info">
                            <span class="octicon octicon-file-directory"></span>
                            <a href='/categories/CPP/' title=''>CPP</a>
                        </span>
                    
                </div>
            
        </div>
    </div>
</section>
	<section class="container">
    <div class="columns">
        <div class="column  three-fourths " >
            <article class="article-content markdown-body">
                <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="逻辑运算符元函数"><a href="#逻辑运算符元函数" class="headerlink" title="逻辑运算符元函数"></a>逻辑运算符元函数</h2><p>在C++中逻辑运算符可以将两个或多个关系表达式连接成一个，例如<code>&amp;&amp;</code>和<code>||</code>，也能够使表达式的逻辑反转，例如<code>!</code>。在这个小节中，我们将根据C++的逻辑运算符实现一套YAMPL可以使用的逻辑运算符元函数，除此之外我们还将结合上面的内容来完成一个元编程例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="title">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">and_</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> inner = and_&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value &amp;&amp; inner::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="title">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">and_</span>&lt;N1, N2&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value &amp;&amp; N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>观察上面的代码会发现，<code>and_</code>元函数的实现和<code>plus</code>元函数几乎相同，除了使用了不同的运算符以外，唯一的区别就是返回类型。<code>and_</code>元函数的返回类型<code>using type = integral_const&lt;value_type, N1::value &amp;&amp; inner::value&gt;;</code>固定为<code>integral_const&lt;bool, true&gt;</code>或者<code>integral_const&lt;bool, false&gt;</code>之一，也就是<code>true_type</code>或者<code>false_type</code>。这个设计正好是对应<code>&amp;&amp;</code>运算符的返回值必须是<code>true</code>或者<code>false</code>之一。说明了这个区别之后，读者可以回味一下<code>plus</code>的实现应该就能理解<code>and_</code>元函数的实现细节了，这里也不再赘述。</p>
<p>如<code>and_</code>元函数一样，<code>or_</code>也可以通过这样的方式实现，而且只需要修改一个运算符而已。所以这里还是用宏简化代码的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_MULTI_OP_BOOL(name, op)                                  \</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="title">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;                         \</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">name</span> &#123;</span>                                                         \</span><br><span class="line">    <span class="keyword">using</span> inner = name&lt;N2, Nargs...&gt;;                                   \</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;                                            \</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value op inner::value&gt;; \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;                    \</span><br><span class="line">  &#125;;                                                                    \</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="title">class</span> <span class="title">N2</span>&gt;                                         \</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">name</span>&lt;N1, N2&gt; &#123;</span>                                                 \</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;                                            \</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value op N2::value)&gt;;  \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;                    \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">BINARY_MULTI_OP_BOOL(and_, &amp;&amp;);</span><br><span class="line">BINARY_MULTI_OP_BOOL(or_, ||);</span><br></pre></td></tr></table></figure>

<p>以上代码实现了逻辑与和逻辑或的运算符元函数，接下来我们需要实现一个逻辑非运算符元函数，也就是在C++中常用的<code>!</code>。逻辑非运算符元函数的实现相对于前两个就单纯多了，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">not_</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, !T::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里只需要注意<code>not_</code>元函数的返回类型也是固定为<code>integral_const&lt;bool, true&gt;</code>或者<code>integral_const&lt;bool, false&gt;</code>之一，剩下的代码和取负运算符元函数的代码几乎相同很容易理解。</p>
<p>现在，我们要利用上面介绍的内容实现一个特殊的函数模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">special_func</span>(<span class="title">T</span>) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>该函数模板需要完成这样一个任务：当模板实参<code>T</code>是一个标量或者引用时，函数参数的<code>T</code>为实参本身；否则<code>T</code>为实参的引用。也就是说当<code>T</code>为<code>int</code>时，函数为<code>void special_func(int) {}</code>；当<code>T</code>为<code>int&amp;</code>时，函数为<code>void special_func(int&amp;) {}</code>；当T为<code>std::string</code>时，函数为<code>void special_func(std::string&amp;) {}</code>。</p>
<p>以下是我的一种实现方案：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">func_helper</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> cond = or_&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::is_scalar&lt;T&gt;::type,</span><br><span class="line">                   <span class="keyword">typename</span> <span class="built_in">std</span>::is_reference&lt;T&gt;::type&gt;;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> if_&lt;<span class="keyword">typename</span> cond::type, T,</span><br><span class="line">                            <span class="keyword">typename</span> <span class="built_in">std</span>::add_lvalue_reference&lt;T&gt;::type&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">special_func</span>(<span class="title">typename</span> <span class="title">func_helper</span>&lt;T&gt;:</span>:type) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中实现了一个<code>func_helper</code>元函数，该元函数会针对<code>special_func</code>的模板实参进行处理以满足函数需求。在<code>func_helper</code>的实现代码中，首先调用了逻辑或元函数<code>or_</code>，用于判断<code>T</code>是否为标量或者引用类型。然后根据返回结果调用<code>if_</code>元函数。当<code>cond::type</code>的结果为<code>true_type</code>时返回<code>T</code>本身，否则调用<code>std::add_lvalue_reference</code>返回<code>T</code>的引用类型，最终<code>type</code>为要求的返回类型。</p>
<p>来测试一下刚刚编写的函数模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">special_func&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">special_func&lt;<span class="keyword">int</span>&amp;&gt;(n);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s&#123; <span class="string">"hello"</span> &#125;;</span><br><span class="line">special_func&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(s);</span><br></pre></td></tr></table></figure>

<p>使用<code>-fdump-tree-gimple</code>命令让GCC生成gimple的中间代码，观察代码发现这样三份中间代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">special_func&lt;int&gt; (type v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br><span class="line">special_func&lt;int&amp;&gt; (int &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br><span class="line">special_func&lt;std::__cxx11::basic_string&lt;char&gt; &gt; (struct basic_string &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到当模板实参为<code>int</code>和<code>int&amp;</code>时，函数形参类型为模板实参本身，而当模板实参为<code>std::__cxx11::basic_string&lt;char&gt;</code>时，函数形参类型为<code>struct basic_string &amp;</code>，满足函数的设计要求。</p>
<h2 id="类型打印元函数"><a href="#类型打印元函数" class="headerlink" title="类型打印元函数"></a>类型打印元函数</h2><p>模板元程序之所以比普通C++程序更难编写主要是因为它很难调试。我们常用的调试方法在模板元程序上都没法正常使用，比如调试器只能调试动态运行的程序，但是却无法调试编译期执行的元程序。</p>
<p>另外打印日志的方法也许能帮上一点忙，因为C++为我们提供了<code>typeid</code>这个操作符，它返回的<code>std::type_info</code>结构中存在一个<code>const char* name()</code>的成员函数可以返回类型名称。于是我们想到可以使用以下方法打印类型信息帮助调试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name();</span><br></pre></td></tr></table></figure>

<p>不过遗憾的是，这种方法也并不完美。首先来说，成员函数<code>name()</code>返回的类型名称在不同编译器中有不同的展现方法，比如MSVC编译出来的程序返回的是一个可读的名称，而GCC编译出来的程序返回的类型名称则需要使用特定API（例如<code>abi::__cxa_demangle</code>）将其转换为可读的名称。其次，<code>typeid</code>也无法真实的反应类型的状态，因为C++标准中说明了<code>typeid</code>会忽略类型的<code>cv</code>属性，也就是说<code>typeid(const T) == typeid(T)</code>。所以<code>typeid</code>打印日志的方法也不满足需求。</p>
<p>为了准确是输出类型信息，我们需要将目光从程序本身移动到编译期上，因为只有编译期才是掌握类型信息最全面的程序。于是我们可以想到使用编译期的错误信息来打印类型信息。由于错误信息往往是帮助程序员排查错误，所以类型信息会非常的全面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">err_print_type</span>;</span></span><br><span class="line"></span><br><span class="line">err_print_type&lt;<span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type&gt;();</span><br></pre></td></tr></table></figure>

<p>在上面的代码中<code>err_print_type</code>是一个缺少实现的类模板，所以当编译器将其进行实例化的时候必然会报错，而错误信息正是我们想要的结果。<code>err_print_type&lt;typename minus&lt;int_&lt;10&gt;, int_&lt;2&gt;&gt;::type&gt;();</code>在MSVC中会显示错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error C2027: use of undefined type &apos;err_print_type&lt;yampl::integral_const&lt;T,8&gt;&gt;&apos;</span><br><span class="line">with</span><br><span class="line">[</span><br><span class="line">    T=int</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在GCC中显示错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: invalid use of incomplete type &apos;struct err_print_type&lt;yampl::integral_const&lt;int, 8&gt; &gt;&apos;</span><br></pre></td></tr></table></figure>

<p>可以看到，无论是哪种编译器都非常详细的显示了类型信息。</p>
<p>现在类型信息是完整了，但这种方法还是不太好，因为错误会阻止程序的编译导致无法生成可执行程序。我们需要一种方法既能在编译期产生可用的日志，与此同时也不能阻碍程序的正常编译。于是我们想到，如果能将错误信息转换为警告信息不久好了么！在YAMPL中，打印类型信息的方法就是用这种思路实现的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__clang__)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> tmp = <span class="number">1</span> / (<span class="keyword">sizeof</span>(T) - <span class="keyword">sizeof</span>(T));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__GNUC__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic <span class="meta-keyword">warning</span> <span class="meta-string">"-Wsign-compare"</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; n = <span class="keyword">sizeof</span>(T) &gt; <span class="number">-1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push, 3)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">dbg_print_type</span> &#123;</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>以上代码实现了一个类模板<code>dbg_print_type</code>，并且分别对MSVC、GCC和CLang做了支持。当编译期时MSVC时，使用了数组大小为0的技巧促使编译期发出警告；当编译器是CLang时，使用除数为0的方式让编译器发出警告；当编译器是GCC时，使用不同符号类型比较让编译器发出警告，值得注意的是这个警告需要手动开启。</p>
<p>将上面示例中的<code>err_print_type</code>修改为<code>dbg_print_type</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbg_print_type&lt;<span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type&gt;();</span><br></pre></td></tr></table></figure>

<p>GCC会发出这样的警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In instantiation of &apos;struct yampl::DbgPrintType&lt;yampl::integral_const&lt;int, 8&gt; &gt;&apos;:</span><br><span class="line">required from here</span><br><span class="line">warning: comparison of integer expressions of different signedness: &apos;long long unsigned int&apos; and &apos;int&apos; [-Wsign-compare]</span><br><span class="line">   15 |   enum &#123; n = sizeof(T) &gt; -1 &#125;;</span><br></pre></td></tr></table></figure>

<p>MSVC显示的警告为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">warning C4200: nonstandard extension used: zero-sized array in struct/union</span><br><span class="line">message : This member will be ignored by a defaulted constructor or copy/move assignment operator</span><br><span class="line">message : see reference to class template instantiation &apos;yampl::DbgPrintType&lt;yampl::integral_const&lt;T,8&gt;&gt;&apos; being compiled</span><br><span class="line">with</span><br><span class="line">[</span><br><span class="line">    T=int</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>请注意警告的信息确实比较多，但是仔细观察还是能看到<code>&#39;struct yampl::DbgPrintType&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#39;</code>这样类似的信息。另外值得高兴的是，这些警告信息也确实没有阻止程序的编译。</p>

            </article>
            
                <div class="share">
                    <!--开启分享-->
<div class="share-component" data-disabled="google,twitter,facebook" data-description=""></div>

<script src="/js/share.min.js"></script>

                </div>    
            

            
            
                
<div class="comments">
    <div id="disqus_thread"></div>
    <script>

        var host = window.location.host;
        var disqus_shortname = host.includes('127.0.0.1') || host.includes('0.0.0.0') || host.includes('localhost') ? '0cchDev' : '0cch'

        var disqus_title = 'YAMPL的基础组件(3)';
        var disqus_config = function () {
            this.page.url = 'http://0cch.com/2020/03/08/yampl-base-components-part3/';
        };
        
        (function() {
            var d = document, s = d.createElement('script');

            s.src = '//0cch.disqus.com/embed.js';

            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>
        请启用JavaScript来查看 <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
    </noscript>
</div>
             

        </div>
        <div class="column one-fourth">
            
                
                


<h3>Post Directory</h3>

<div id="post-directory-module">
	<section class="post-directory">
		<p><strong class="toc-title">Article directory</strong></p>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#逻辑运算符元函数"><span class="toc-text">逻辑运算符元函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型打印元函数"><span class="toc-text">类型打印元函数</span></a></li></ol>
	</section>
</div>
            
        </div>
    </div>
</section>

<footer class="container">
    <div class="site-footer" role="contentinfo">
        
        <ul class="site-footer-links right mobile-hidden">
            <li>
                <a href="javascript:window.scrollTo(0,0)" >TOP</a>
            </li>
        </ul>

        <ul class="site-footer-links mobile-hidden">
            
                  
                  <li>
                    <a href="/"  title="Home">Home</a>
                  </li>
            
                  
                  <li>
                    <a href="/categories/"  title="Category">Category</a>
                  </li>
            
                  
                  <li>
                    <a href="/open-source/"  title="Open-Source">Open-Source</a>
                  </li>
            
            <li>
                <a href="/atom.xml">
                    <span class="octicon octicon-rss" style="color:orange;"></span>
                </a>
            </li>
        </ul>
    </div>
</footer>

		<script src="/js/geopattern.js"></script>
		<script src="/lib/fancybox/jquery.fancybox-1.3.4.pack.js"></script>
		
			<script src="/js/toc.js"></script>
		

		<script src="/js/index.js"></script>

		 <script src="/js/popular_repo.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --> 

	</body>
</html>