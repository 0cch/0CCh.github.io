<!DOCTYPE html>
<html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <link rel="icon" href="/favicon.ico">
  
  <title>0CCh Blog</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox-1.3.4.css">
  <!--在这里倒入jquery 方便处理部分页面的jquery-->
  <script src="https://cdn.staticfile.org/jquery/1.7/jquery.min.js" type="text/javascript" ></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body class="home">
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="site-header navfixed-false">
  <div class="container">
      <h1><a href="/" title="0CCh Blog"><span class="octicon octicon-mark-github"></span> 0CCh Blog</a></h1>
      <nav class="site-header-nav" role="navigation">
        
              
              <a href="/"  class=" site-header-nav-item hvr-underline-from-center" title="Home">Home</a>
        
              
              <a href="/categories/"  class=" site-header-nav-item hvr-underline-from-center" title="Category">Category</a>
        
              
              <a href="/open-source/"  class=" site-header-nav-item hvr-underline-from-center" title="Open-Source">Open-Source</a>
        
      </nav>
  </div>
</header>

	<section class="banner-false">
    <div class="collection-head">
        <div class="container">
            <div class="collection-title">
                <h1 class="collection-header" id="site-description">
                    
                </h1>
                <div class="collection-info">
                    
                    
                        <span class="meta-info">
                            
                                <span class="octicon octicon-location">
                                   
                                        China
                                    
                                </span>
                                
                            
                        </span>
                    
                        <span class="meta-info">
                            
                                <span class="octicon octicon-mark-github">
                                   
                                </span>
                                
                                    <a href="http://github.com/0cch" target="_blank">0cch</a>
                                
                            
                        </span>
                    
                </div>
            </div>
        </div>
    </div>
</section>
	   <section class="container">
    <div class="columns">
        <div class="column two-thirds">
            
                  <article id="post-reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/06/10/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862/">ReactOS-Freeldr磁盘及文件管理2</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ArcOpen的大体流程我们看过了。大致分为这几步</p>
<ol>
<li>函数会尝试找到文件所在分区的设备句柄，如果还没有对应的句柄。那么使用DEVICE.FuncTable中的Open函数打开设备，并为这个设备分配句柄。</li>
</ol>
<ol>
<li>打开设备后条用XxxMount识别分区格式，识别成功返回另外的FuncTable，存储到设备的FileData.FileFuncTable域。</li>
</ol>
<ol>
<li>为文件分配一个句柄，在对应的FileData.DeviceId为上面创建设备句柄，FileData.FuncTable为设备的FileData.FileFuncTable。</li>
</ol>
<ol>
<li>最后调用文件的FileData.FuncTable.Open函数打开文件。</li>
</ol>
<p><strong>挂载分区时做了什么</strong></p>
<p>之前我们忽略了XxxMount函数。现在来读读比较简单的FatMount (freeldr\freeldr\fs\fat.c)。</p>
<ol>
<li><p><em>const</em> DEVVTBL<strong>*</strong> FatMount<strong>(</strong>ULONG DeviceId<strong>)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p><strong>.**</strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.**</p>
</li>
<li><p>// 生成一个FAT_VOLUME_INFO结构</p>
</li>
<li><p>Volume <strong>=</strong> MmHeapAlloc<strong>(</strong><em>sizeof</em><strong>(</strong>FAT_VOLUME_INFO<strong>)**</strong>)<strong>**;</strong></p>
</li>
<li><p><em>if</em> <strong>(**</strong>!<strong>Volume</strong>)**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><em>RtlZeroMemory</em><strong>(</strong>Volume, <em>sizeof</em><strong>(</strong>FAT_VOLUME_INFO<strong>)**</strong>)<strong>**;</strong></p>
</li>
<li><p>// 读第一个扇区</p>
</li>
<li><p>Position<strong>.</strong>HighPart <strong>=</strong> 0<strong>;</strong></p>
</li>
<li><p>Position<strong>.</strong>LowPart <strong>=</strong> 0<strong>;</strong></p>
</li>
<li><p>ret <strong>=</strong> ArcSeek<strong>(</strong>DeviceId, <strong>&amp;</strong>Position, SeekAbsolute<strong>)**</strong>;**</p>
</li>
<li><p><em>if</em> <strong>(</strong>ret <strong>!**</strong>=<strong> ESUCCESS</strong>)**</p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree<strong>(</strong>Volume<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>ret <strong>=</strong> ArcRead<strong>(</strong>DeviceId, Buffer, <em>sizeof</em><strong>(</strong>Buffer<strong>)</strong>, <strong>&amp;</strong>Count<strong>)**</strong>;**</p>
</li>
<li><p><em>if</em> <strong>(</strong>ret <strong>!**</strong>=<strong> ESUCCESS </strong>|<strong>**|</strong> Count <strong>!**</strong>=<strong> <em>sizeof</em></strong>(<strong>Buffer</strong>)<strong>**)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree<strong>(</strong>Volume<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>// 判断是否有fat分区标志</p>
</li>
<li><p><em>if</em> <strong>(**</strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector</strong>-<strong>**&gt;</strong>FileSystemType, “FAT12 “, 8<strong>)</strong> <strong>&amp;**</strong>&amp;**</p>
</li>
<li><p><strong>!</strong>RtlEqualMemory<strong>(</strong>BootSector<strong>-**</strong>&gt;<strong>FileSystemType, “FAT16 “, 8</strong>)<strong> </strong>&amp;<strong>**&amp;</strong></p>
</li>
<li><p><strong>!</strong>RtlEqualMemory<strong>(</strong>BootSector32<strong>-**</strong>&gt;<strong>FileSystemType, “FAT32 “, 8</strong>)<strong> </strong>&amp;<strong>**&amp;</strong></p>
</li>
<li><p><strong>!</strong>RtlEqualMemory<strong>(</strong>BootSectorX<strong>-**</strong>&gt;<strong>FileSystemType, “FATX”, 4</strong>)<strong>**)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree<strong>(</strong>Volume<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>// 获得分区大小等信息</p>
</li>
<li><p>ret <strong>=</strong> ArcGetFileInformation<strong>(</strong>DeviceId, <strong>&amp;</strong>FileInformation<strong>)**</strong>;**</p>
</li>
<li><p><em>if</em> <strong>(</strong>ret <strong>!**</strong>=<strong> ESUCCESS</strong>)**</p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree<strong>(</strong>Volume<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>SectorCount<strong>.</strong>HighPart <strong>=</strong> FileInformation<strong>.</strong>EndingAddress<strong>.</strong>HighPart<strong>;</strong></p>
</li>
<li><p>SectorCount<strong>.</strong>LowPart <strong>=</strong> FileInformation<strong>.</strong>EndingAddress<strong>.</strong>LowPart<strong>;</strong></p>
</li>
<li><p>SectorCount<strong>.</strong>QuadPart <strong>/**</strong>=<strong> SECTOR_SIZE</strong>;**</p>
</li>
<li><p>Volume<strong>-**</strong>&gt;<strong>DeviceId </strong>=<strong> DeviceId</strong>;**</p>
</li>
<li><p>// 打开分区</p>
</li>
<li><p><em>if</em> <strong>(**</strong>!<strong>FatOpenVolume</strong>(<strong>Volume, BootSector, SectorCount</strong>.<strong>QuadPart</strong>)<strong>**)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree<strong>(</strong>Volume<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>// 存储FAT_VOLUME_INFO结构</p>
</li>
<li><p>FatVolumes<strong>[</strong>DeviceId<strong>]</strong> <strong>=</strong> Volume<strong>;</strong></p>
</li>
<li><p>// 返回fat文件读写的FuncTable</p>
</li>
<li><p><em>return</em> <strong>&amp;</strong>FatFuncTable<strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p><strong>           
</strong></p>
</li>
</ol>
<p>函数中的DeviceId是设备的句柄。</p>
<p>生成FAT_VOLUME_INFO结构。这个结构里面存储了FAT分区的基本信息。包括扇区大小，每个簇的扇区数等等。</p>
<ol>
<li><p><em>typedef</em> <em>struct</em> _FAT_VOLUME_INFO </p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>ULONG BytesPerSector<strong>;</strong> /<em> Number of bytes per sector </em>/</p>
</li>
<li><p>ULONG SectorsPerCluster<strong>;</strong> /<em> Number of sectors per cluster </em>/</p>
</li>
<li><p>ULONG FatSectorStart<strong>;</strong> /<em> Starting sector of 1st FAT table </em>/</p>
</li>
<li><p>ULONG ActiveFatSectorStart<strong>;</strong> /<em> Starting sector of active FAT table </em>/</p>
</li>
<li><p>ULONG NumberOfFats<strong>;</strong> /<em> Number of FAT tables </em>/</p>
</li>
<li><p>ULONG SectorsPerFat<strong>;</strong> /<em> Sectors per FAT table </em>/</p>
</li>
<li><p>ULONG RootDirSectorStart<strong>;</strong> /<em> Starting sector of the root directory (non-fat32) </em>/</p>
</li>
<li><p>ULONG RootDirSectors<strong>;</strong> /<em> Number of sectors of the root directory (non-fat32) </em>/</p>
</li>
<li><p>ULONG RootDirStartCluster<strong>;</strong> /<em> Starting cluster number of the root directory (fat32 only) </em>/</p>
</li>
<li><p>ULONG DataSectorStart<strong>;</strong> /<em> Starting sector of the data area </em>/</p>
</li>
<li><p>ULONG FatType<strong>;</strong> /<em> FAT12, FAT16, FAT32, FATX16 or FATX32 </em>/</p>
</li>
<li><p>ULONG DeviceId<strong>;</strong></p>
</li>
<li><p><strong>}</strong> FAT_VOLUME_INFO<strong>;</strong></p>
</li>
<li><p><strong>             
</strong></p>
</li>
</ol>
<p>  读取第一个山区，判断是否有fat标志。如果没有直接返回，挂载失败。之后使用ArcGetFileInformation获得分区大小。ArcGetFileInformation里面调用了FileData.FuncTable.GetFileInformation。因为当前DeviceId是设备句柄，所以他实际调用的是DiskGetFileInformation(freeldr\freeldr\arch\i386\hardware.c)。这个函数很简单，通过FileInformation返回分区开始和结束的地址，这里就不列出了。     </p>
<p>这里的代码用FileInformation<strong>.</strong>EndingAddress / SECTOR_SIZE计算出了该分区的扇区数SectorCount。这里应该BUG。因为EndingAddress是分区结束地址，真的扇区数应该是 (分区开始地址 - EndingAddress ) / SECTOR_SIZE。好在SectorCount只是判断fat分区的一个依据，而且一般C盘计算出的SectorCount误差不会很大，影响不大。</p>
<p>最后执行FatOpenVolume真正执行分区的挂载、初始化。初始化结束后将生成的Volume放到fat.c维护的全局数组FatVolumes里，之后对fat分区进行操作（读写）时，通过设备的DeviceId就可以找到对应的FAT_VOLUME_INFO结构。</p>
<p>最后函数返回FatFuncTable函数数组</p>
<ol>
<li><p><em>const</em> DEVVTBL FatFuncTable <strong>=</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>FatClose, </p>
</li>
<li><p>FatGetFileInformation, </p>
</li>
<li><p>FatOpen, </p>
</li>
<li><p>FatRead, </p>
</li>
<li><p>FatSeek, </p>
</li>
<li><p>L”fastfat”, </p>
</li>
<li><p><strong>}**</strong>;**</p>
</li>
<li></li>
</ol>
<p>用户可以通过这些函数就读写改fat分区啦。</p>
<p>那么FatOpenVolume都干了什么呢。</p>
<p>这个函数简单来说就是根据分区内容填写了Volume结构，已经算是一个分区的具体实现细节了，和整体架构无关，不多说了。这个函数在freeldr\freeldr\fs\fat.c中。</p>
<p><strong><strong>打开文件时做了什么</strong></strong></p>
<p>上一篇文章中还有一个地方没说，就是打开设备并创建完文件的句柄后，ArcOpen调用了文件对应的FileData.FuncTable.Open。对于fat分区而言这个函数是FatOpen(freeldr\freeldr\fs\fat.c). 这个函数也是和分区结构有关的了，有一点比较重要就是函数最后调用了FsSetDeviceSpecific把一个和文件相关的内部结构与文件句柄相关联。以后使用FatRead对文件句柄进行读操作时直接就可以获得这个结构啦。</p>
<ol>
<li><p>LONG FatOpen<strong>(</strong>CHAR<strong>*</strong> Path, OPENMODE OpenMode, ULONG<strong>*</strong> FileId<strong>)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p><strong>.**</strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.**</p>
</li>
<li></li>
<li><p>// 根据文件的FileId获得文件所在的设备句柄FileData.DeviceId, 从而获得FatMount时生成的Volume结构。</p>
</li>
<li><p>DeviceId <strong>=</strong> FsGetDeviceId<strong>(<strong>*</strong></strong>FileId<strong>)**</strong>;**</p>
</li>
<li><p>FatVolume <strong>=</strong> FatVolumes<strong>[</strong>DeviceId<strong>]**</strong>;**</p>
</li>
<li><p>// 从DeviceId设备中读取并查询fat表，判断path表示的文件是否存在</p>
</li>
<li><p><em>RtlZeroMemory</em><strong>(**</strong>&amp;<strong>TempFileInfo, <em>sizeof</em></strong>(<strong>TempFileInfo</strong>)<strong><strong>)</strong></strong>;**</p>
</li>
<li><p>ret <strong>=</strong> FatLookupFile<strong>(</strong>FatVolume, Path, DeviceId, <strong>&amp;</strong>TempFileInfo<strong>)**</strong>;**</p>
</li>
<li><p><em>if</em> <strong>(</strong>ret <strong>!**</strong>=<strong> ESUCCESS</strong>)**</p>
</li>
<li><p><em>return</em> ENOENT<strong>;</strong></p>
</li>
<li><p>// 判断是否是目录</p>
</li>
<li><p>IsDirectory <strong>=</strong> <strong>(</strong>TempFileInfo<strong>.</strong>Attributes <strong>&amp;</strong> ATTR_DIRECTORY<strong>)</strong> <strong>!**</strong>=<strong> 0</strong>;**</p>
</li>
<li><p><em>if</em> <strong>(</strong>IsDirectory <strong>&amp;**</strong>&amp;<strong> OpenMode </strong>!<strong>**=</strong> OpenDirectory<strong>)</strong></p>
</li>
<li><p><em>return</em> EISDIR<strong>;</strong></p>
</li>
<li><p><em>else</em> <em>if</em> <strong>(**</strong>!<strong>IsDirectory </strong>&amp;<strong>**&amp;</strong> OpenMode <strong>!**</strong>=<strong> OpenReadOnly</strong>)**</p>
</li>
<li><p><em>return</em> ENOTDIR<strong>;</strong></p>
</li>
<li><p>// 生成FAT_FILE_INFO结构，里面存放了文件的信息(开始的扇区等)</p>
</li>
<li><p>FileHandle <strong>=</strong> MmHeapAlloc<strong>(</strong><em>sizeof</em><strong>(</strong>FAT_FILE_INFO<strong>)**</strong>)<strong>**;</strong></p>
</li>
<li><p><em>if</em> <strong>(**</strong>!<strong>FileHandle</strong>)**</p>
</li>
<li><p><em>return</em> ENOMEM<strong>;</strong></p>
</li>
<li><p>RtlCopyMemory<strong>(</strong>FileHandle, <strong>&amp;</strong>TempFileInfo, <em>sizeof</em><strong>(</strong>FAT_FILE_INFO<strong>)**</strong>)<strong>**;</strong></p>
</li>
<li><p>FileHandle<strong>-**</strong>&gt;<strong>Volume </strong>=<strong> FatVolume</strong>;**</p>
</li>
<li><p>// 把这个结构和文件对应的FileData.Specific关联。之后进行FatRead等操作时可以直接获得这个结构了</p>
</li>
<li><p>FsSetDeviceSpecific<strong>(<strong>*</strong></strong>FileId, FileHandle<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> ESUCCESS<strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
</ol>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-06-09T18:17:00.000Z" itemprop="datePublished">2011-06-10</time>
        </span>

        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086/">ReactOS-Freeldr磁盘及文件管理</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Freeldr提供了对fat12、fat32、fatx、ntfs等文件系统的只读功能。这部分代码主要集中在boot\freeldr\freeldr\fs\fs.c文件中。<br>首先计算机加电后会把mbr读取到物理内存的0x7c00位置，mbr搜索活动分区并加载活动分区根目录下的Freeldr.sys文件。加载后跳入Freeldr入口start。Freeldr进行32为初始化后跳入主初始化函数BootMain(boot\freeldr\freeldr\Freeldr.c)中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">VOID <span class="title">BootMain</span><span class="params">(LPSTR CmdLine)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">......</div><div class="line">MachInit(CmdLine);</div><div class="line">FsInit();</div><div class="line">......</div><div class="line">RunLoader();</div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>BootMain会对硬件(MachInit)和文件系统(FsInit)进行检测和初始化。所有准备工作进行完毕后就会调用RunLoader进行系统的加载工作。<br>Fs初始化和DEVICE、FILEDATA结构<br>下面看一下文件系统的初始化 FsInit(boot\freeldr\freeldr\fs\fs.c)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">VOID <span class="title">FsInit</span><span class="params">(VOID)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">ULONG i;</div><div class="line">RtlZeroMemory(FileData, <span class="keyword">sizeof</span>(FileData));</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FDS; i++)</div><div class="line">FileData[i].DeviceId = (ULONG)<span class="number">-1</span>;</div><div class="line">InitializeListHead(&amp;DeviceListHead);</div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>FsInit初始化FileData数组。和一个和磁盘分区相关的链表DeviceListHead。<br>首先fs.c维护了一个MAX_FDS(60)大小的数组 static FILEDATA FileData[MAX_FDS];  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDEVVTBL</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">ARC_CLOSE Close;</div><div class="line">ARC_GET_FILE_INFORMATION GetFileInformation;</div><div class="line">ARC_OPEN Open;</div><div class="line">ARC_READ Read;</div><div class="line">ARC_SEEK Seek;</div><div class="line">LPCWSTR ServiceName;</div><div class="line">&#125; DEVVTBL;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagFILEDATA</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">ULONG DeviceId;            <span class="comment">// 文件所在磁盘的磁盘文件句柄, 同样也是FileData的索引</span></div><div class="line">ULONG ReferenceCount;       <span class="comment">// 引用计数</span></div><div class="line"><span class="keyword">const</span> DEVVTBL* FuncTable;    <span class="comment">// 对文件进行读写的指针</span></div><div class="line"><span class="keyword">const</span> DEVVTBL* FileFuncTable; <span class="comment">// 对文件进行读写的函数数组</span></div><div class="line">VOID* Specific;             <span class="comment">// 文件系统自定义指针</span></div><div class="line">&#125; FILEDATA;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>每一个成功打开的文件会返回一个文件句柄，这个句柄实际上就是FileData数组的索引。所以每个打开的文件都有一个对应的FileData。这个结构就类似windows中的FILE_OBJECT<br>FileData中DeviceId是文件所在磁盘的句柄。这个句柄同样也是FileData数组的索引，通过这个句柄可以找到”磁盘文件”，对”磁盘文件”的读写就是直接对相应的磁盘或磁盘分区的读写。类似Windows中直接对磁盘分区进行CreateFile返回的句柄。”磁盘文件”的DeviceId没有意义。<br>ReferenceCount是该文件的引用计数。<br>FuncTable这是一个函数数组指针，里面存放了对文件进行读写、SEEK等操作的函数指针。<br>FileFuncTable只对”磁盘文件”有意义。当Freeldr确定了磁盘文件对应的分区的分区格式后，会把与分区格式相关的函数指针数组放到这个字段里面。如Fat12分区”磁盘文件”的FileFuncTable字段存放的就是FatFuncTable指针。<br>Specific存放于文件有关的结构。磁盘文件就是DISKCONTEXT指针，fat12下的文件就是FAT_FILE_INFO指针 等等。<br>之后是DeviceListHead，这是DEVICE结构的链表头  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDEVICE</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">LIST_ENTRY ListEntry;        <span class="comment">// 链表节点</span></div><div class="line"><span class="keyword">const</span> DEVVTBL* FuncTable;    <span class="comment">// 操作该分区的函数表</span></div><div class="line">CHAR* Prefix;              <span class="comment">// 分区对应的ArcName</span></div><div class="line">ULONG DeviceId;            <span class="comment">// FILEDATA中该分区对应的句柄</span></div><div class="line">ULONG ReferenceCount;      <span class="comment">// 引用计数</span></div><div class="line">&#125; DEVICE;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>用户电脑中的每一个硬盘和硬盘中的每一分区都对应了一个DEVICE结构。<br>FuncTable里面存放了对该分区进行读写等操作的指针，对于硬盘而言这个数组就是DiskVtbl。<br>Prefix是该分区或硬盘的ArcName。(如multi(0)disk(0)rdisk(0)partition(0))。Freeldr中的文件路径都是Arc形式的路径。而且0号分区代表整个硬盘，真正的分区从1号开始。如multi(0)disk(0)rdisk(0)partition(0)便代表第0块硬盘本身。multi(0)disk(0)rdisk(0)partition(1)代表第0块硬盘的第0个分区。<br>通过DeviceId字段可以找到该DEVICE的文件句柄。这个字段和FILEDATA相互配合，使系统可以遍历DEVICE结构快速找到某个分区的文件句柄。<br>DEVICE(磁盘及分区)的检测<br>上面说到Freeldr操作的路径都是存储在DEVICE结构中的ArcPath。那么这些DEVICE是怎么来的呢？<br>首先我们看一下DEVICE的注册函数，FsRegisterDevice(boot\freeldr\freeldr\fs\fs.c)  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">VOID <span class="title">FsRegisterDevice</span><span class="params">(CHAR* Prefix, <span class="keyword">const</span> DEVVTBL* FuncTable)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">DEVICE* pNewEntry;</div><div class="line">ULONG dwLength;</div><div class="line">dwLength = <span class="built_in">strlen</span>(Prefix) + <span class="number">1</span>;</div><div class="line">pNewEntry = MmHeapAlloc(<span class="keyword">sizeof</span>(DEVICE) + dwLength);</div><div class="line"><span class="keyword">if</span> (!pNewEntry)</div><div class="line"><span class="keyword">return</span>;</div><div class="line">pNewEntry-&gt;FuncTable = FuncTable;</div><div class="line">pNewEntry-&gt;ReferenceCount = <span class="number">0</span>;</div><div class="line">pNewEntry-&gt;Prefix = (CHAR*)(pNewEntry + <span class="number">1</span>);</div><div class="line"><span class="built_in">memcpy</span>(pNewEntry-&gt;Prefix, Prefix, dwLength);</div><div class="line">InsertHeadList(&amp;DeviceListHead, &amp;pNewEntry-&gt;ListEntry);</div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>这么函数非常简单。Prefix就是Arc路径，FuncTable是操作这个分区（磁盘）对应的函数数组。FsRegisterDevice生成了一个DEVICE结构，把ArcName和FuncTable复制进去。之后连入了DeviceListHead链表。<br>那么又是谁调用的FsRegisterDevice呢？是DetectBiosDisks(boot\freeldr\freeldr\arch\i386\hardware.c)函数。虽然这一部分已经不属于FS的范畴，还是在这里简单讲一下便于理解。这里我略去了不必要的代码。<br>DetectBiosDisks的调用顺序是 RunLoader -&gt; MachHwDetect (PcHwDetect)-&gt; DetectISABios -&gt; DetectBiosDisks</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> VOID</div><div class="line">DetectBiosDisks(PCONFIGURATION_COMPONENT_DATA BusKey)</div><div class="line">&#123;</div><div class="line">BOOLEAN BootDriveReported = FALSE;</div><div class="line">ULONG i;</div><div class="line">ULONG DiskCount = GetDiskCount(BusKey);</div><div class="line">CHAR BootPath[<span class="number">512</span>];</div><div class="line">......</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DiskCount; i++)</div><div class="line">&#123;</div><div class="line">ULONG Size;</div><div class="line">CHAR Identifier[<span class="number">20</span>];</div><div class="line">......</div><div class="line"><span class="keyword">if</span> (BootDrive == <span class="number">0x80</span> + i)</div><div class="line">BootDriveReported = TRUE;</div><div class="line"><span class="comment">/* Get disk values */</span></div><div class="line">GetHarddiskIdentifier(Identifier, <span class="number">0x80</span> + i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>首先使用GetDiskCount从Freeldr注册表的System键中读取硬盘总数。System键的初始化在DetectSystem(freeldr\freeldr\arch\i386\hardware.c)中，一会儿再看。<br>于是进入一个for循环，为每个硬盘调用GetHarddiskIdentifier函数。在BIOS中硬盘号是从0x80开始的，所以GetHarddiskIdentifier的硬盘号加了0x80。<br>GetHarddiskIdentifier的作用是为制定硬盘生成一个唯一的ID，并通过Identifier参数返回。但这个函数名起得并不好，因为生成ID其实只是这个函数的功能之一。另外的一大功能是检测硬盘，并且为硬盘本身和硬盘分区调用FsRegisterDevice函数进行注册。通过这个注册后硬盘才能真正被文件系统识别。<br>freeldr\freeldr\arch\i386\hardware.c中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> VOID</div><div class="line">GetHarddiskIdentifier(PCHAR Identifier,</div><div class="line">ULONG DriveNumber)</div><div class="line">&#123;</div><div class="line">PMASTER_BOOT_RECORD Mbr;</div><div class="line">ULONG *Buffer;</div><div class="line">ULONG i;</div><div class="line">ULONG Checksum;</div><div class="line">ULONG Signature;</div><div class="line">CHAR ArcName[<span class="number">256</span>];</div><div class="line">PARTITION_TABLE_ENTRY PartitionTableEntry;</div><div class="line"><span class="comment">/* Read the MBR */</span></div><div class="line"><span class="keyword">if</span> (!MachDiskReadLogicalSectors(DriveNumber, <span class="number">0U</span>LL, <span class="number">1</span>, (PVOID)DISKREADBUFFER))</div><div class="line">&#123;</div><div class="line">DPRINTM(DPRINT_HWDETECT, <span class="string">"Reading MBR failed\n"</span>);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">Buffer = (ULONG*)DISKREADBUFFER;</div><div class="line">Mbr = (PMASTER_BOOT_RECORD)DISKREADBUFFER;</div><div class="line">Signature = Mbr-&gt;Signature;</div><div class="line">DPRINTM(DPRINT_HWDETECT, <span class="string">"Signature: %x\n"</span>, Signature);</div><div class="line"><span class="comment">/* Calculate the MBR checksum */</span></div><div class="line">Checksum = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</div><div class="line">&#123;</div><div class="line">Checksum += Buffer[i];</div><div class="line">&#125;</div><div class="line">Checksum = ~Checksum + <span class="number">1</span>;</div><div class="line">DPRINTM(DPRINT_HWDETECT, <span class="string">"Checksum: %x\n"</span>, Checksum);</div><div class="line"><span class="comment">/* Fill out the ARC disk block */</span></div><div class="line">reactos_arc_disk_info[reactos_disk_count].Signature = Signature;</div><div class="line">reactos_arc_disk_info[reactos_disk_count].CheckSum = Checksum;</div><div class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">"multi(0)disk(0)rdisk(%lu)"</span>, reactos_disk_count);</div><div class="line"><span class="built_in">strcpy</span>(reactos_arc_strings[reactos_disk_count], ArcName);</div><div class="line">reactos_arc_disk_info[reactos_disk_count].ArcName =</div><div class="line">reactos_arc_strings[reactos_disk_count];</div><div class="line">reactos_disk_count++;</div><div class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">"multi(0)disk(0)rdisk(%lu)partition(0)"</span>, DriveNumber - <span class="number">0x80</span>);</div><div class="line">FsRegisterDevice(ArcName, &amp;DiskVtbl);</div><div class="line"><span class="comment">/* Add partitions */</span></div><div class="line">i = <span class="number">1</span>;</div><div class="line">DiskReportError(FALSE);</div><div class="line"><span class="keyword">while</span> (DiskGetPartitionEntry(DriveNumber, i, &amp;PartitionTableEntry))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (PartitionTableEntry.SystemIndicator != PARTITION_ENTRY_UNUSED)</div><div class="line">&#123;</div><div class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">"multi(0)disk(0)rdisk(%lu)partition(%lu)"</span>, DriveNumber - <span class="number">0x80</span>, i);</div><div class="line">FsRegisterDevice(ArcName, &amp;DiskVtbl);</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line">DiskReportError(TRUE);</div><div class="line"><span class="comment">/* Convert checksum and signature to identifier string */</span></div><div class="line">Identifier[<span class="number">0</span>] = Hex[(Checksum &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">1</span>] = Hex[(Checksum &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">2</span>] = Hex[(Checksum &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">3</span>] = Hex[(Checksum &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">4</span>] = Hex[(Checksum &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">5</span>] = Hex[(Checksum &gt;&gt; <span class="number">8</span> ) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">6</span>] = Hex[(Checksum &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">7</span>] = Hex[Checksum &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">8</span>] = <span class="string">'-'</span>;</div><div class="line">Identifier[<span class="number">9</span>] = Hex[(Signature &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">10</span>] = Hex[(Signature &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">11</span>] = Hex[(Signature &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">12</span>] = Hex[(Signature &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">13</span>] = Hex[(Signature &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">14</span>] = Hex[(Signature &gt;&gt; <span class="number">8</span> ) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">15</span>] = Hex[(Signature &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">16</span>] = Hex[Signature &amp; <span class="number">0x0F</span>];</div><div class="line">Identifier[<span class="number">17</span>] = <span class="string">'-'</span>;</div><div class="line">Identifier[<span class="number">18</span>] = <span class="string">'A'</span>;</div><div class="line">Identifier[<span class="number">19</span>] = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>函数首先使用MachDiskReadLogicalSectors读取指定硬盘的MBR。对于PC机而言MachDiskReadLogicalSectors使用int 13h中断实现对硬盘的读操作。里面包括了16、32位代码的互转，和本节内容无关，以后再做说明。<br>MBR结构为。详细信息可以参考(<a href="http://en.wikipedia.org/wiki/Master_boot_record" target="_blank" rel="external">http://en.wikipedia.org/wiki/Master_boot_record</a>)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MASTER_BOOT_RECORD</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">UCHAR        MasterBootRecordCodeAndData[<span class="number">0x1b8</span>];   <span class="comment">/* 0x000 */</span></div><div class="line">ULONG        Signature;          <span class="comment">/* 0x1B8 */</span></div><div class="line">USHORT        Reserved;          <span class="comment">/* 0x1BC */</span></div><div class="line">PARTITION_TABLE_ENTRY   PartitionTable[<span class="number">4</span>];        <span class="comment">/* 0x1BE */</span></div><div class="line">USHORT        MasterBootRecordMagic;        <span class="comment">/* 0x1FE */</span></div><div class="line">&#125; MASTER_BOOT_RECORD, *PMASTER_BOOT_RECORD;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>GetHarddiskIdentifier在获取了Signature、计算了Checksum后 。<br>sprintf(ArcName, “multi(0)disk(0)rdisk(%lu)partition(0)”, DriveNumber - 0x80);<br>FsRegisterDevice(ArcName, &amp;DiskVtbl);<br>生成对应硬盘的ArcName，使用FsRegisterDevice注册这块硬盘，这个函数我们已经看过。注意这里Partition为0，所以0号分区实际表示硬盘本身。<br>之后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (DiskGetPartitionEntry(DriveNumber, i, &amp;PartitionTableEntry))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (PartitionTableEntry.SystemIndicator != PARTITION_ENTRY_UNUSED)</div><div class="line">&#123;</div><div class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">"multi(0)disk(0)rdisk(%lu)partition(%lu)"</span>, DriveNumber - <span class="number">0x80</span>, i);</div><div class="line">FsRegisterDevice(ArcName, &amp;DiskVtbl);</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>DiskGetParititionEntry将会解析DriveNumber对应磁盘的分区表，填充第i个分区的信息到PartitionTableEntry结构。如果分区存在则使用FsRegisterDevice注册分区。<br>使用刚才计算的CheckSum和Signature组合一个ID返回给调用者。其实这个ID没有被使用过。。。<br>最后看一下调用FsRegisterDevice时的第二个参数DiskVtbl  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> DEVVTBL DiskVtbl = &#123;</div><div class="line">DiskClose,</div><div class="line">DiskGetFileInformation,</div><div class="line">DiskOpen,</div><div class="line">DiskRead,</div><div class="line">DiskSeek,</div><div class="line">&#125;;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>这里面包含了对磁盘扇区读写的全部函数。我们之后再介绍。<br>至此硬盘的及硬盘分区的注册完成。<br>执行完DetectBiosDisks后，DeviceListHead里面就存放了当前计算机所有的磁盘和分区对应的DEVICE结构。<br>文件系统的识别和文件的打开<br>这时Fs模块已经知道的硬盘数量，分区信息。下面来看看一个文件的打开流程。<br>首先，Freeldr使用的是Arc路径，IDE硬盘以multi(0)disk(0)rdisk(n)开头，文件也是以Arc路径表示的。打开文件的函数在Freeldr\Freeldr\fs\fs.c中。这函数比较长，我们分段阅读。<br>Freeldr\Freeldr\fs\fs.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function">LONG <span class="title">ArcOpen</span><span class="params">(CHAR* Path, OPENMODE OpenMode, ULONG* FileId)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">......</div><div class="line">*FileId = MAX_FDS;</div><div class="line"><span class="comment">/* Search last ')', which delimits device and path */</span></div><div class="line">FileName = <span class="built_in">strrchr</span>(Path, <span class="string">')'</span>);</div><div class="line"><span class="keyword">if</span> (!FileName)</div><div class="line"><span class="keyword">return</span> EINVAL;</div><div class="line">FileName++;</div><div class="line"><span class="comment">/* Count number of "()", which needs to be replaced by "(0)" */</span></div><div class="line">dwCount = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (p = Path; p != FileName; p++)</div><div class="line"><span class="keyword">if</span> (*p == <span class="string">'('</span> &amp;&amp; *(p + <span class="number">1</span>) == <span class="string">')'</span>)</div><div class="line">dwCount++;</div><div class="line"><span class="comment">/* Duplicate device name, and replace "()" by "(0)" (if required) */</span></div><div class="line">dwLength = FileName - Path + dwCount;</div><div class="line"><span class="keyword">if</span> (dwCount != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">DeviceName = MmHeapAlloc(FileName - Path + dwCount);</div><div class="line"><span class="keyword">if</span> (!DeviceName)</div><div class="line"><span class="keyword">return</span> ENOMEM;</div><div class="line"><span class="keyword">for</span> (p = Path, q = DeviceName; p != FileName; p++)</div><div class="line">&#123;</div><div class="line">*q++ = *p;</div><div class="line"><span class="keyword">if</span> (*p == <span class="string">'('</span> &amp;&amp; *(p + <span class="number">1</span>) == <span class="string">')'</span>)</div><div class="line">*q++ = <span class="string">'0'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">DeviceName = Path;</div><div class="line">......</div><div class="line"> </div></pre></td></tr></table></figure>
<p>这个函数有三个参数Path是文件名的Arc路径，如multi(0)disk(0)rdisk(0)partition(1)Freeldr.sys就表示C盘中的Freeldr.sys文件。<br>OpenMode是打开模式(OpenReadOnly、OpenReadWrite等)。<br>如果打开成功，文件句柄将通过FileId参数返回。<br>首先这一部分代码分理出Arc磁盘路径中的”()”替换成”(0)”并存入DeviceName中，如multi()disk()rdisk()partition(1)Freeldr.sys处理后，DeviceName将指向multi(0)disk(0)rdisk(0)partition(1)。注意这个DeviceName是不以NULL结尾的。。。这是个很蛋疼的设计。<br>FileName会指向Arc路径中的文件名部分，上面的例子将是Freeldr.sys。<br>文件打开分为两步，第一步是开个文件所在的设备、创建设备的句柄。第二部才是打开文件本身。<br>这里是第一步打开设备的代码。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line">pEntry = DeviceListHead.Flink;</div><div class="line"><span class="keyword">while</span> (pEntry != &amp;DeviceListHead)</div><div class="line">&#123;</div><div class="line">pDevice = CONTAINING_RECORD(pEntry, DEVICE, ListEntry);</div><div class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(pDevice-&gt;Prefix, DeviceName, dwLength) == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">/* OK, device found. It is already opened? */</span></div><div class="line"><span class="keyword">if</span> (pDevice-&gt;ReferenceCount == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">/* Search some room for the device */</span></div><div class="line"><span class="keyword">for</span> (DeviceId = <span class="number">0</span>; DeviceId &lt; MAX_FDS; DeviceId++)</div><div class="line"><span class="keyword">if</span> (!FileData[DeviceId].FuncTable)</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">if</span> (DeviceId == MAX_FDS)</div><div class="line"><span class="keyword">return</span> EMFILE;</div><div class="line"><span class="comment">/* Try to open the device */</span></div><div class="line">FileData[DeviceId].FuncTable = pDevice-&gt;FuncTable;</div><div class="line">ret = pDevice-&gt;FuncTable-&gt;Open(pDevice-&gt;Prefix, DeviceOpenMode, &amp;DeviceId);</div><div class="line"><span class="keyword">if</span> (ret != ESUCCESS)</div><div class="line">&#123;</div><div class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!*FileName)</div><div class="line">&#123;</div><div class="line"><span class="comment">/* Done, caller wanted to open the raw device */</span></div><div class="line">*FileId = DeviceId;</div><div class="line">pDevice-&gt;ReferenceCount++;</div><div class="line"><span class="keyword">return</span> ESUCCESS;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* Try to detect the file system */</span></div><div class="line">FileData[DeviceId].FileFuncTable = FatMount(DeviceId);</div><div class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</div><div class="line">FileData[DeviceId].FileFuncTable = NtfsMount(DeviceId);</div><div class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</div><div class="line">FileData[DeviceId].FileFuncTable = Ext2Mount(DeviceId);</div><div class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</div><div class="line">&#123;</div><div class="line"><span class="comment">/* Error, unable to detect file system */</span></div><div class="line">pDevice-&gt;FuncTable-&gt;Close(DeviceId);</div><div class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">return</span> ENODEV;</div><div class="line">&#125;</div><div class="line">pDevice-&gt;DeviceId = DeviceId;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">DeviceId = pDevice-&gt;DeviceId;</div><div class="line">&#125;</div><div class="line">pDevice-&gt;ReferenceCount++;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">pEntry = pEntry-&gt;Flink;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (pEntry == &amp;DeviceListHead)</div><div class="line"><span class="keyword">return</span> ENODEV;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>一个循环，遍历DEVICE链表，找到DEVICE-&gt;Prefix (磁盘、分区的Arc路径，上一节说过)和刚刚分解出来的DeviceName相等的节点。如果没有则函数直接失败。<br>找到DEVICE节点后判断DEVICE-&gt;ReferenceCount是否为0。这个代表该DEVICE被打开的次数，如果ReferenceCount不为0，说明DEVICE已经被打开。那个直接从Device-&gt;DeviceId中获得设备的文件句柄。可以看出无论打开一个设备多少次，只会有ReferenceCount的变化，而句柄都是相同的。所以如果设备打开两次，SEEK时会相互影响。读写之前最好重新调用SEEK函数。<br>当DEVICE-&gt;ReferenceCount为0时是Freeldr需要调用进行打开和文件系统的识别。我们仔细读读。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Search some room for the device */</span></div><div class="line"><span class="keyword">for</span> (DeviceId = <span class="number">0</span>; DeviceId &lt; MAX_FDS; DeviceId++)</div><div class="line"><span class="keyword">if</span> (!FileData[DeviceId].FuncTable)</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">if</span> (DeviceId == MAX_FDS)</div><div class="line"><span class="keyword">return</span> EMFILE;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>首先在FileData数组中找到空闲项，数组的索引即将成为设备句柄。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Try to open the device */</span></div><div class="line">FileData[DeviceId].FuncTable = pDevice-&gt;FuncTable;</div><div class="line">ret = pDevice-&gt;FuncTable-&gt;Open(pDevice-&gt;Prefix, DeviceOpenMode, &amp;DeviceId);</div><div class="line"><span class="keyword">if</span> (ret != ESUCCESS)</div><div class="line">&#123;</div><div class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!*FileName)</div><div class="line">&#123;</div><div class="line"><span class="comment">/* Done, caller wanted to open the raw device */</span></div><div class="line">*FileId = DeviceId;</div><div class="line">pDevice-&gt;ReferenceCount++;</div><div class="line"><span class="keyword">return</span> ESUCCESS;</div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>之后把DEVICE中存储的设别操作函数数组FuncTable赋值给对应FileData中的FuncTable。之后对该句柄的读写操作将直接传递给FileData.FuncTable中的函数。<br>调用FuncTable-&gt;Open打开设备。上面我们看过这个函数实际是freeldr\freeldr\arch\i386\hardware.c中的DiskOpen。<br>打开成功后，如果FileName（需要打开的文件名）为空，说明这次请求只打开设备，于是直接返回设备的句柄。<br>如果不为空，则下面开始识别分区格式，打开文件的操作。<br>在继续读ArcOpen函数前我们先看看DiskOpen在打开设备时都做了什么。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">ArcOpen -&gt; DiskOpen (freeldr\freeldr\arch\i386\hardware.c)</div><div class="line"><span class="function"><span class="keyword">static</span> LONG <span class="title">DiskOpen</span><span class="params">(CHAR* Path, OPENMODE OpenMode, ULONG* FileId)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">......</div><div class="line"><span class="keyword">if</span> (!DissectArcPath(Path, FileName, &amp;DriveNumber, &amp;DrivePartition))</div><div class="line"><span class="keyword">return</span> EINVAL;</div><div class="line"><span class="keyword">if</span> (DrivePartition == <span class="number">0xff</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">/* This is a CD-ROM device */</span></div><div class="line">SectorSize = <span class="number">2048</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">SectorSize = <span class="number">512</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (DrivePartition != <span class="number">0xff</span> &amp;&amp; DrivePartition != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (!DiskGetPartitionEntry(DriveNumber, DrivePartition, &amp;PartitionTableEntry))</div><div class="line"><span class="keyword">return</span> EINVAL;</div><div class="line">SectorOffset = PartitionTableEntry.SectorCountBeforePartition;</div><div class="line">SectorCount = PartitionTableEntry.PartitionSectorCount;</div><div class="line">&#125;</div><div class="line">Context = MmHeapAlloc(<span class="keyword">sizeof</span>(DISKCONTEXT));</div><div class="line"><span class="keyword">if</span> (!Context)</div><div class="line"><span class="keyword">return</span> ENOMEM;</div><div class="line">Context-&gt;DriveNumber = DriveNumber;</div><div class="line">Context-&gt;SectorSize = SectorSize;</div><div class="line">Context-&gt;SectorOffset = SectorOffset;</div><div class="line">Context-&gt;SectorCount = SectorCount;</div><div class="line">Context-&gt;SectorNumber = <span class="number">0</span>;</div><div class="line">FsSetDeviceSpecific(*FileId, Context);</div><div class="line"><span class="keyword">return</span> ESUCCESS;</div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>这个函数非常简单，使用DissectArcPath根据设备的Arc路径分解出文件名FileName、BIOS驱动器号DriveNumber、和分区号DrivePartition（第0个分区的编号是1，0代表整个硬盘）<br>之后确定扇区大小，分区开始的扇区号、分区扇区数等信息，存入DISKCONTEXT结构。使用FsSetDeviceSpecific和FildId相关联。<br>还记得FILEDATA的结构么？FsSetDeviceSpecific就是填充里面的Specific指针 ：）  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">VOID <span class="title">FsSetDeviceSpecific</span><span class="params">(ULONG FileId, VOID* Specific)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">if</span> (FileId &gt;= MAX_FDS || !FileData[FileId].FuncTable)</div><div class="line"><span class="keyword">return</span>;</div><div class="line">FileData[FileId].Specific = Specific;</div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>实际上DiskOpen的作用就是获得该设备（分区）的基本信息——BIOS驱动器号、扇区大小、开始扇区号、扇区数量和当前读写指针（SectorNumber）。生成DISKCONTENT结构使用FsSetDeviceSpecific和FileID绑定。<br>现在我们回到ArcOpen函数，希望你还记得 ：）  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Try to detect the file system */</span></div><div class="line">FileData[DeviceId].FileFuncTable = FatMount(DeviceId);</div><div class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</div><div class="line">FileData[DeviceId].FileFuncTable = NtfsMount(DeviceId);</div><div class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</div><div class="line">FileData[DeviceId].FileFuncTable = Ext2Mount(DeviceId);</div><div class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</div><div class="line">&#123;</div><div class="line"><span class="comment">/* Error, unable to detect file system */</span></div><div class="line">pDevice-&gt;FuncTable-&gt;Close(DeviceId);</div><div class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">return</span> ENODEV;</div><div class="line">&#125;</div><div class="line">pDevice-&gt;DeviceId = DeviceId;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>现在FileData[DeviceId]已经代表刚刚打开的设备了，开始挂载分区。啥叫挂载分区，就是让文件系统提供个接口，能让我们操作分区里面的文件。而这个接口就是个DEVVTBL指针，和直接操作硬盘的接口一样，只不过这次这个可以操作文件了。如果分区识别成功，XxxMount函数将会返回另外一个DEVVTBL指针数组，这个指针赋值给设备对象的FileFuncTable成员。使用这个指针数组就可以在文件级别操作了。比如打开freeldr.sys文件就可以调用FileData[DeviceId].FileFuncTable-&gt;open函数。FileFuncTable和FuncTable是不同的哦！ ：）<br>注意FileFuncTable其实是不直接使用的，这个指针的作用是为之后打开的文件对应的FileData.FileTable赋值。于是操作文件和操作磁盘都是用对应的FileData.FileTable，实现形式上的统一。而且这种架构还可以轻易的实现将一个文件虚拟成为一个分区，只要为文件对象调用XxxMount并且给FileFuncTable域赋值就可以了，非常易于扩展。Freeldr并没有实现这种功能，文件的FileData.FileFuncTable没有使用～<br>下面我们就来看看第二步，打开文件<br>首先为文件找一个空闲的FileData  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FDS; i++)</div><div class="line"><span class="keyword">if</span> (!FileData[i].FuncTable)</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">if</span> (i == MAX_FDS)</div><div class="line"><span class="keyword">return</span> EMFILE;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>跳过文件名开始的 “\” 字符  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (*FileName == <span class="string">'\\'</span>)</div><div class="line">FileName++;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>我们前面说的，为FileData.FuncTable赋值。FileData.DeviceId是文件所在分区的句柄。FuncTable内部函数将通过这个句柄调用读写分区内容，为用户提供文件的读写接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FileData[i].FuncTable = FileData[DeviceId].FileFuncTable;</div><div class="line">FileData[i].DeviceId = DeviceId;</div><div class="line">*FileId = i;</div><div class="line">ret = FileData[i].FuncTable-&gt;Open(FileName, OpenMode, FileId);</div><div class="line"><span class="keyword">if</span> (ret != ESUCCESS)</div><div class="line">&#123;</div><div class="line">FileData[i].FuncTable = <span class="literal">NULL</span>;</div><div class="line">*FileId = MAX_FDS;</div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure>
<p>至此打开文件的操作结束。这里略去了XxxMount和文件的Open函数。以后再说。 ：）  </p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-06-02T06:33:19.000Z" itemprop="datePublished">2011-06-02</time>
        </span>

        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
        </div>
        <div class="column one-third">
          <!--处理未安装 search 插件 默认 Google 搜索-->
 

<h3>Search</h3>

<div id="site_search">

	<!-- Google -->
	
		<form action="http://www.google.com/search?" data-site="http://0cch.com">
	    	<input type="text" id="search_box" name="q" placeholder="Search">
	    	<button type="button" class="btn btn-default" id="site_search_do"><span class="octicon octicon-search"></span></button>
	    </form>
	

	<!-- 本地搜索 -->
	

</div>

<h3>Popular Repositories</h3>
    <div class="popular-container"></div>
    
    <script type="text/template" id="popular-list-template">
        <a href="{%=clone_url%}" class="card text-center" target="_blank">
            <div class="thumbnail">
                <div class="card-image geopattern" data-pattern-id="{%=name%}">
                    <div class="card-image-cell">
                        <h3 class="card-title">
                            {%=name%}
                        </h3>
                    </div>
                </div>
                <div class="caption">
                    <div class="card-description">
                        <p class="card-text">
                            {%=description%}
                        </p>
                    </div>
                    <div class="card-text">
                        <span class="meta-info tooltipped tooltipped-n" aria-label="{%=stargazers_count%} stars">
                            <span class="octicon octicon-star"></span> {%=stargazers_count%}
                        </span>
                        <span class="meta-info tooltipped tooltipped-n" aria-label="{%=forks_count%} forks">
                            <span class="octicon octicon-git-branch"></span> {%=forks_count%}
                        </span>
                        <span class="meta-info tooltipped tooltipped-n" aria-label="最后更新时间：{%=updated_at%}">
                            <span class="octicon octicon-clock"></span>
                            <time datetime="{%=updated_at%}">{%=updated_at%}</time>
                        </span>
                    </div>
                </div>
            </div>
        </a>
    </script>

    <script src="/js/baiduTemplate.js"></script>
    <script type="text/javascript">
        var popular_repos = function(){

            var baiduTpl = new Object();

            var handleTpl = function(){
                baiduTpl.popular_list = baidu.template("popular-list-template");
            };

            var handleGithub = function(){
                var popularContainer = $(".popular-container");

                var repos = "0cchext,luadbg".split(",");
                for(var i in repos){
                    var name = repos[i];
                    $.get("https://api.github.com/repos/0cch/"+name,handle);
                }

                function handle(result){
                    result.updated_at = result.updated_at.split("T")[0];
                    if(result){
                        var html = baiduTpl.popular_list(result);
                        popularContainer.append(html);
                        $(".geopattern").each(function(){           
                            $(this).geopattern($(this).data('pattern-id'));
                        });
                    }
                }
            };

            return {
                init:function(){
                    handleTpl();
                    handleGithub();
                }
            }
        }; 
        $(popular_repos().init);
    </script>


    <h3>Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">February 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">February 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">December 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">October 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">September 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/08/">August 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/06/">June 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/05/">May 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/04/">April 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/02/">February 2011</a></li></ul>
    </div>
  </div>


        </div>
    </div>

    
</section>

<footer class="container">
    <div class="site-footer" role="contentinfo">
        
        <ul class="site-footer-links right mobile-hidden">
            <li>
                <a href="javascript:window.scrollTo(0,0)" >TOP</a>
            </li>
        </ul>

        <ul class="site-footer-links mobile-hidden">
            
                  
                  <li>
                    <a href="/"  title="Home">Home</a>
                  </li>
            
                  
                  <li>
                    <a href="/categories/"  title="Category">Category</a>
                  </li>
            
                  
                  <li>
                    <a href="/open-source/"  title="Open-Source">Open-Source</a>
                  </li>
            
            <li>
                <a href="/atom.xml">
                    <span class="octicon octicon-rss" style="color:orange;"></span>
                </a>
            </li>
        </ul>
    </div>
</footer>

		<script src="/js/geopattern.js"></script>
		<script src="/lib/fancybox/jquery.fancybox-1.3.4.pack.js"></script>
		

		<script src="/js/index.js"></script>

		 <script src="/js/popular_repo.js"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --> 

	</body>
</html>