<!DOCTYPE html>
<html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init">
<head>
  <meta charset="utf-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <link rel="icon" href="/favicon.ico">
  
  <title>0CCh Blog</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox-1.3.4.css">
  <!--在这里倒入jquery 方便处理部分页面的jquery-->
  <script src="https://cdn.staticfile.org/jquery/1.7/jquery.min.js" type="text/javascript" ></script>
</head>
<body class="home">
	<header class="site-header navfixed-false">
  <div class="container">
      <h1><a href="/" title="0CCh Blog"><span class="octicon octicon-mark-github"></span> 0CCh Blog</a></h1>
      <nav class="site-header-nav" role="navigation">
        
              
              <a href="/"  class=" site-header-nav-item hvr-underline-from-center" title="Home">Home</a>
        
              
              <a href="/categories/"  class=" site-header-nav-item hvr-underline-from-center" title="Category">Category</a>
        
              
              <a href="/open-source/"  class=" site-header-nav-item hvr-underline-from-center" title="Open-Source">Open-Source</a>
        
      </nav>
  </div>
</header>

	<section class="banner-false">
    <div class="collection-head">
        <div class="container">
            <div class="collection-title">
                <h1 class="collection-header" id="site-description">
                    
                </h1>
                <div class="collection-info">
                    
                    
                        <span class="meta-info">
                            
                                <span class="octicon octicon-location">
                                   
                                        China
                                    
                                </span>
                                
                            
                        </span>
                    
                        <span class="meta-info">
                            
                                <span class="octicon octicon-mark-github">
                                   
                                </span>
                                
                                    <a href="http://github.com/0cch" target="_blank">0cch</a>
                                
                            
                        </span>
                    
                </div>
            </div>
        </div>
    </div>
</section>
	   <section class="container">
    <div class="columns">
        <div class="column two-thirds">
            
                  <article id="post-windbg-scripte79a84notepade8afade6b395e9ab98e4baaee9858de7bdaee69687e4bbb6" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2013/10/15/windbg-scripte79a84notepade8afade6b395e9ab98e4baaee9858de7bdaee69687e4bbb6/">Windbg script的notepad++语法高亮配置文件</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>经常写复杂的windbg脚本的程序员肯定知道，windbg脚本的宏替换的执行方式，让人非常的不舒服。另外windbg的脚本也没有一个好用的语法高亮编辑器，所以让脚本写起来更加痛苦。前者看来是已成定局，很难解决了。不过后者还是有机会改善的，闲暇之余，写了一个notepad++上的windbg脚本的语法高亮配置文件。以<a href="http://0cch.net/wordpress/?p=363" target="_blank" rel="external">上一篇文章</a>中的windbg脚本为例，高亮效果如下图：</p>
<p><a href="/uploads/2013/10/20131015164715.png"><img src="/uploads/2013/10/20131015164715.png" alt="20131015164715"></a></p>
<p>导入方式也非常简单，点击[语言]菜单下的define your language，在弹出的对话框中点击导入按钮，导入配置文件即可。</p>
<p><a href="/uploads/2013/10/20131015164704.png"><img src="/uploads/2013/10/20131015164704.png" alt="20131015164704"></a></p>
<p>下载脚本<a href="/uploads/2013/10/wds.zip">wds</a></p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2013-10-15T01:06:30.000Z" itemprop="datePublished">2013-10-15</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Debugging/' title=''>Debugging</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-windbge58685e6a0b8e8b083e8af95e69fa5e79c8be7aa97e58fa3e58fa5e69f84e4bfa1e681afe79a84e8849ae69cac" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2013/10/07/windbge58685e6a0b8e8b083e8af95e69fa5e79c8be7aa97e58fa3e58fa5e69f84e4bfa1e681afe79a84e8849ae69cac/">Windbg内核调试查看窗口句柄信息的脚本</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>十一长假瞬间就结束了，整一周都在玩，也没有研究什么好玩的东西，这里就分享一个以前写的windbg脚本吧。通途是内核调试查看窗口句柄信息。用法很简单，例如 $$&gt;a&lt;hwnd.wds 000207B8。运行结果如下图：</p>
<p><a href="/uploads/2013/10/20131007195716.png"><img src="/uploads/2013/10/20131007195716.png" alt="20131007195716"></a></p>
<pre><code>$$ Convert HWND to tagWnd
$$ Author: nighxie 
$$ Blog: 0cch.net

.if (${&#x2F;d:$arg1}) {

    .if (${&#x2F;d:$arg2}) {
            .if (${$arg2} == 1) {
                r $t0 = nt!PsActiveProcessHead
                .for (r $t1 = poi(@$t0);(@$t1 != 0) &amp; (@$t1 != @$t0);r $t1 = poi(@$t1)) {
                r? $t2 = #CONTAINING_RECORD(@$t1, nt!_EPROCESS, ActiveProcessLinks);
                as &#x2F;x ${&#x2F;v:$ProcAddr} @$t2;
                as &#x2F;ma ${&#x2F;v:$ImageName} @@c++(&amp;@$t2-&gt;ImageFileName[0]);

                .block {
                    $$ .echo ${$ImageName}
                    .if ($sicmp(&quot;${$ImageName}&quot;, &quot;explorer.exe&quot;) == 0) {
                        .echo Found the process at ${$ProcAddr};
                        .process &#x2F;p &#x2F;r ${$ProcAddr};
                        ad ${&#x2F;v:$ImageName};
                        ad ${&#x2F;v:$ProcAddr};
                        .break;
                    }
                }

                ad ${&#x2F;v:$ImageName};
                ad ${&#x2F;v:$ProcAddr};
            }
        }
    }
    

    r @$t1 = ${$arg1};
    r @$t0 = win32k!gSharedInfo;
    .if ((@$t1&amp;0xffff) &lt; @@C++(((win32k!tagSHAREDINFO *)@$t0)-&gt;psi-&gt;cHandleEntries)) {
        r @$t0 = @@C++(((win32k!tagSHAREDINFO *)@$t0)-&gt;aheList);
        r @$t0 = @@C++(@$t0+(@$t1&amp;0xffff)*sizeof(win32k!_HANDLEENTRY));
        r @$t0 = poi(@$t0);
        .printf &quot;HWND: %p\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;head.h);
        .printf &#x2F;D &quot;tagWnd * @ %p\n&quot;, @$t0;
        .if (@@C++(((win32k!tagWnd *)@$t0)-&gt;strName.Buffer) != 0) {
            .printf &quot;Window Name: %mu\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;strName.Buffer);
        }
        .printf &#x2F;D &quot;tagCLS * @ pcls) win32k!tagCLS\&quot;&gt;%p\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;pcls);
        .if (@@C++(((win32k!tagWnd *)@$t0)-&gt;pcls-&gt;lpszAnsiClassName) != 0) {
            .printf &quot;Window Class Name: %ma\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;pcls-&gt;lpszAnsiClassName);
        }
        .if (@@C++(((win32k!tagWnd *)@$t0)-&gt;spwndNext) != 0) {
            .printf &quot;Next Wnd:     %p\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;spwndNext-&gt;head.h);
        }
        .if (@@C++(((win32k!tagWnd *)@$t0)-&gt;spwndPrev) != 0) {
            .printf &quot;Previous Wnd: %p\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;spwndPrev-&gt;head.h);
        }
        .if (@@C++(((win32k!tagWnd *)@$t0)-&gt;spwndParent) != 0) {
            .printf &quot;Parent Wnd:   %p\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;spwndParent-&gt;head.h);
        }
        .if (@@C++(((win32k!tagWnd *)@$t0)-&gt;spwndChild) != 0) {
            .printf &quot;Child Wnd:    %p\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;spwndChild-&gt;head.h);
        }
        .if (@@C++(((win32k!tagWnd *)@$t0)-&gt;spwndOwner) != 0) {
            .printf &quot;Own Wnd:      %p\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;spwndOwner-&gt;head.h);
        }
        .if (@@C++(((win32k!tagWnd *)@$t0)-&gt;lpfnWndProc) != 0) {
            .printf &#x2F;D &quot;pfnWndProc:   head.pti-&gt;pEThread)-&gt;Tcb.Process);u @@C++(((win32k!tagWnd *)@$t0)-&gt;lpfnWndProc)\&quot;&gt;%p\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;lpfnWndProc);
        }
        .printf &quot;Visiable: %d\n&quot;, @@C++((((win32k!tagWnd *)@$t0)-&gt;style &amp; (1&lt;&lt;28)) != 0);
        .printf &quot;Child:    %d\n&quot;, @@C++((((win32k!tagWnd *)@$t0)-&gt;style &amp; (1&lt;&lt;30)) != 0);
        .printf &quot;Minimized:%d\n&quot;, @@C++((((win32k!tagWnd *)@$t0)-&gt;style &amp; (1&lt;&lt;29)) != 0);
        .printf &quot;Disabled: %d\n&quot;, @@C++((((win32k!tagWnd *)@$t0)-&gt;style &amp; (1&lt;&lt;27)) != 0);
        .printf &quot;Window Rect { %d, %d, %d, %d}\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;rcWindow.left), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcWindow.top), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcWindow.right), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcWindow.bottom);
        .printf &quot;Clent Rect  { %d, %d, %d, %d}\n&quot;, @@C++(((win32k!tagWnd *)@$t0)-&gt;rcClient.left), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcClient.top), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcClient.right), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcClient.bottom);
    
    }
    .else {
        .printf &quot;HWND is out of range.\n&quot;;
    }
    
}
.else {
    .echo &quot;Usage $$&gt;a&lt;${$arg0} HWND(HEX)&quot;
    .echo &quot;e.g. $$&gt;a&lt;${$arg0} 0x60962&quot;
}

 </code></pre>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2013-10-07T06:00:26.000Z" itemprop="datePublished">2013-10-07</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Debugging/' title=''>Debugging</a><a href='/categories/Debugging/Tips/' title=''>Tips</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-e8a7a3e69e90youkue8a786e9a291e59cb0e59d80e79a84pythone8849ae69cac" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2013/09/28/e8a7a3e69e90youkue8a786e9a291e59cb0e59d80e79a84pythone8849ae69cac/">解析youku视频地址的python脚本</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>几个月前写的东西，偶然翻出来发现还能用，就贴出来吧。非专业python程序员，代码比较乱 :-(</p>
<p><a href="/uploads/2013/09/20130928134507.png"><img src="/uploads/2013/09/20130928134507.png" alt="20130928134507"></a></p>
<pre><code>&#39;&#39;&#39;
Created on 2013-3-6

@author: nightxie
&#39;&#39;&#39;

import sys
import urllib.request
import urllib.parse
import json

def GetKeyString(seed):
    base_string = &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x2F;\\:._-1234567890&#39;;
    target_string = &#39;&#39;;
    while len(base_string) != 0 :
        seed = (seed * 211 + 30031) % 65536;
        index = (seed &#x2F; 65536 * len(base_string));
        target_string += base_string[int(index)];
        base_string = base_string[:int(index)] + base_string[int(index)+1:];
    return target_string;

def GetFildId(daye_str, seed):

    new_list = daye_str.split(&#39;*&#39;);
    target_string = &#39;&#39;;
    base_string = GetKeyString(seed);
    length = len(new_list);
    i = 0;
    while i &lt; length - 1:
        index = int(new_list[i]);
        target_string += base_string[index];
        i += 1;
    return target_string;

def GetFlvPath(videoids, flv_type):
    url = &#39;http:&#x2F;&#x2F;v.youku.com&#x2F;player&#x2F;getPlayList&#x2F;VideoIDS&#x2F;&#39; + videoids + &#39;&#x2F;timezone&#x2F;+08&#x2F;version&#x2F;5&#x2F;source&#x2F;video&#39;
    req = urllib.request.Request(url);
    req.add_header(&#39;Referer&#39;, &#39;http:&#x2F;&#x2F;static.youku.com&#x2F;v1.0.0307&#x2F;v&#x2F;swf&#x2F;player_yk.swf&#39;);
    req.add_header(&#39;User-Agent&#39;, &#39;Mozilla&#x2F;5.0 (Windows NT 6.1) AppleWebKit&#x2F;537.17 (KHTML, like Gecko) Chrome&#x2F;24.0.1312.56 Safari&#x2F;537.17&#39;);
    play_list = urllib.request.urlopen(req).read().decode(&quot;utf8&quot;);
   
    play_list_data = json.loads(play_list)[&#39;data&#39;][0];
    seed = play_list_data[&#39;seed&#39;];
    streamfileids = play_list_data[&#39;streamfileids&#39;];
    regs = play_list_data[&#39;segs&#39;];
    
    type_fileid = streamfileids[flv_type];
    type_list = regs[flv_type];
    url_type = flv_type;
    if url_type == &#39;hd2&#39;:
        url_type = &#39;flv&#39;
    
    type_list_count = len(type_list);
    i = 0;
    while i &lt; type_list_count :
        fileid = GetFildId(type_fileid, seed);
        fileid = fileid[:8] + (&quot;%0.2X&quot; % i) + fileid[10:];
        fileid += &#39;?k=&#39;;
        fileid += type_list[i][&#39;k&#39;];
        flv_path = &#39;http:&#x2F;&#x2F;f.youku.com&#x2F;player&#x2F;getFlvPath&#x2F;sid&#x2F;00_00&#x2F;st&#x2F;&#39;+url_type+&#39;&#x2F;fileid&#x2F;&#39; + fileid;
        print(flv_path);
        i += 1;
        
def GetVideoIdsFromUrl(url):
    url_object = urllib.parse.urlparse(url);
    url_path = url_object.path;
    return url_path[11:-5]

def GetFlvPathFromUrl(url, video_type):
    video_ids = GetVideoIdsFromUrl(url);
    GetFlvPath(video_ids, video_type);

if __name__ == &#39;__main__&#39;:
    if len(sys.argv) == 3:
        GetFlvPathFromUrl(sys.argv[1], sys.argv[2]);
    else:
        print(&quot;youku.py  &quot;);
   
</code></pre>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2013-09-27T21:48:02.000Z" itemprop="datePublished">2013-09-28</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Tips/' title=''>Tips</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-floppy-disk-controllere7bc96e7a88b" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2013/09/21/floppy-disk-controllere7bc96e7a88b/">Floppy Disk Controller编程</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p><a href="/uploads/2013/09/N82077AA.jpg"><img src="/uploads/2013/09/N82077AA.jpg" alt="N82077AA"></a></p>
<p>看的没错，这篇文章将描述一些关于Floppy Disk Controller的编程知识。我们知道，在当今的计算机硬件体系中，软盘驱动器是一个已经完全被淘汰的设备，那么为什么还要有这样一篇文章？原因很简单，如果想构建自己的操作系统，必须有相应的存储介质，而软盘正是这样一个好的存储介质。他的容量虽然很小，但是却完全足够应付我们的内核程序，另一方面软盘驱动器的控制相对于之前我所介绍的硬盘的控制要简单的多，而且关于软盘驱动器控制的教程和文章在互联网上也非常的多（虽然绝大部分都是英文的）。基于以上几点，我认为还是有必要把自己学到的知识写下了分享。</p>
<p>Floppy Disk Controller，中文称为：软盘控制器，简称：FDC，是一个用来控制软盘驱动器的芯片。在1980年代到1990年代，软盘控制器普遍使用于个人电脑以及与IBM PC兼容的机型上，如 8272A、82078、82077SL以及82077AA，其中82077AA是最先进的一款芯片（1991年开始生产）。除了软盘控制器，软驱本身也在几十年的历史中留下了许多机型，如图所示：<br><a href="/uploads/2013/09/floppy_types.png"><img src="/uploads/2013/09/floppy_types.png" alt="floppy_types"></a><br>实际上，我从刚刚接触软盘到最后软盘被淘汰，只使用过3.5英寸1.44MB的软盘，其他型号完全没有接触过。</p>
<p>对于CPU还运行在实模式下的启动引导程序和内核程序，我们可以调用BIOS提供的函数来完成软盘的访问，其中中断号是13h（INT13h），功能号为2（AH=2）是读取操作，功能号为3（AH=3）时是写入操作。实模式下通过中断读写软盘的资料很多（包括中文资料），如果想了解更多的实模式下访问软盘的知识，可以上网google一下，我这里就不做详细的介绍了。</p>
<p>虽然调用中断访问软盘简单，但是我们不能让自己的内核总是跑在实模式下啊。所以我们需要写一个能跑在保护模式下的软驱驱动，要完成这样的驱动，就必须对FDC进行编程了。不过在此之前，我们需要知道，到底PC上有没有软驱。要获得这个信息，我们需要读取CMOS，然后解析读取的信息即可。</p>
<pre><code>mov dx, 70h
mov al, 10h
out dx, al

mov dx, 71h
in  al, dx

mov f_b, al
and f_b, 0fh
shr al, 4
mov f_a, al

f_a db	0h
f_b db	0h
 </code></pre>
<p>要从CMOS中获得软盘信息，我们需要先给对应的端口设置正确的索引，然后再去数据端口读取数据。具体做法是设置0x70端口为0x10，然后读取0x71端口。读取到的信息都放在一个字节中，需要把字节分为两个部分，高四位是驱动器A的类型索引号，低四位是驱动器B的类型索引号。索引号与软盘类型的对应关系如下图所示：<br><a href="/uploads/2013/09/cmos_floppytype.png"><img src="/uploads/2013/09/cmos_floppytype.png" alt="cmos_floppytype"></a></p>
<p>在确认了软驱存在的情况下，接下来就可以对FDC进行编程了。先来看看FDC的几个基本知识。</p>
<p><strong>寻址方式</strong><br>软盘驱动器使用CHS寻址方式。软盘介质总是有两个头（面），但磁道数和每个磁道的扇区扇区数是不一定的。通常情况下，1.44mb的软盘，他有80个磁道和每个磁道有18个扇区。另外值得注意的是，磁道和磁头是从0开始计算，但是扇区是从1开始计数的。即，有效的磁道通常为0到79，磁头为0或1，而扇区号是1到18的。如果访问0号扇区，那么一定会引起访问错误的。</p>
<p><strong>数据传输方式</strong><br>和硬盘的数据传输方式一样，软盘也支持PIO和DMA两种数据传输方式。<br>软盘使用的通常是ISA DMA方式（这和 PCI BusMastering DMA完全是两码事）。使用DMA传输的方法，简单来说就是这是DMA的通道2，如传输的字节数以及对应的物理地址。物理地址必须是以64k为边界的。当然，还需要设置IRQ6，当数据传输结束的时候，控制器将发送一个IRQ6的中断。用DMA传输数据，这个过程是不需要占用CPU时间的，对于多任务的系统是比较好的选择。缺点是ISA DMA这种古老的DMA比PIO还要慢。<br>PIO数据传输既可以使用轮询，也能使用中断。使用PIO模式传输数据的速度比DMA传输快10％，但这会消耗CPU周期，是一个巨大的成本问题。然而，如果我们的操作系统或应用程序是单任务的，那么没有别的程序需要CPU，这样你就也可以使用PIO模式。使用PIO的要点是，在设置好了各种命令后，需要等待中断或者轮询状态结果，最后还需要使用IO的方式，读取数据，也就是这部分需要消耗额外的CPU周期。<br>值得注意的是，bochs并不支持PIO模式，使用PIO模式的时候bochs会报错，提示没有完全实现PIO模式。所以我在实验代码中也没有写PIO的代码。毕竟我的实验环境是bochs。</p>
<p><strong>ISA DMA</strong><br>ISA DMA全称Industry Standard Architecture Direct Memory Access，是一种古老的DMA方式，速度比PIO还要慢，但是编程相对于PCI BusMastering DMA要简单一点。这里我并不打算详细介绍ISA DMA，因为说明它需要的篇幅不亚于这篇。后面的代码中，在必要的地方我会加入一些解释。</p>
<p><strong>3种模式</strong><br>这三种模式是：PC-AT模式，PS/2模式，Mode 30模式。现在最有可能看到硬件上仍然运行模式是30模式。</p>
<p>FDC寄存器<br><a href="/uploads/2013/09/floppy_regs.png"><img src="/uploads/2013/09/floppy_regs.png" alt="floppy_regs"></a></p>
<p>如上图所示，上面的寄存器我们不会都用到，一般情况下大概只会用到一半的样子，其他的我们可以暂时不去理会。另外我在这里不会列出每个寄存器的详细参数，因为这些参数很多而且复杂，不仅单调乏味，而且容易让初学者望而却步。我采取的做法是，先列出控制FDC的代码，然后在需要讲解的地方详细的说明。</p>
<p><strong>实践</strong><br>下面就是一段控制FDC读取软盘数据的代码。需要说明的是这份代码为了保持简洁易学，它没有任何的错误检测，另外代码也假设了你已经初始化了PIC，并且设置好了IRQ6。</p>
<pre><code>; MASM的宏应该不陌生吧，就不做解释了。
outb macro port:req, b:req
    mov dx, port
    mov al, b
    out dx, al
endm

inb macro port:req
    mov dx, port
    in al, dx
endm

wait_status macro
    inb 3f4h
@@:
    test al, 80h
    jz @B
endm

; ISA DMA 初始化部分， 由于ISA DMA不是这篇文章的重点
; 所以这里只说明大概的用途。
outb 0dh, 0ffh      ; 重置DMA控制器
outb 0ah, 6h        ; 选择设置2号DMA通道
outb 0ch, 0ffh      ; 重置Flipflop寄存器
outb 4h, 0h         ; 设置DMA的物理地址，需要设置两次
outb 4h, 0f0h       ; 我这里设置的是0xf000
outb 81h, 0h        ; 设置地址24bit的高8bit为0，也就是0x00f000
outb 0ch, 0ffh      ; 重置Flipflop寄存器
outb 5h, 0ffh       ; 设置物理内存大小，其大小为Length-1
outb 5h, 0fh        ; 我这里的内存大小是0x1000，所以设置为0xfff
outb 0ah, 2h        ; 选择清除2号DMA通道

; FDC的初始化过程
outb 3f2h, 0h       ; 1.重置数字输出寄存器
outb 3f2h, 0ch
call WaitIrq

mov ecx, 4
check_int:
wait_status
outb 3f5h, 8h       ; 发送8号命令，该命令清除控制器触发的中断
wait_status         ; 并且返回结果，这里重复4次，是为了清除4个软驱的状态
inb 3f5h
wait_status
inb 3f5h
wait_status
loop check_int

outb 3f7h, 0h       ; 2.设置传输速度为500kb&#x2F;s
wait_status
outb 3f5h, 3h       ; 3.设置FDC里面三个时钟以及DMA。
wait_status
outb 3f5h, 0dfh
wait_status
outb 3f5h, 2h

outb 3f2h, 1ch      ; 开启软驱电动机
wait_status
outb 3f5h, 7h       ; 发送校验命令
wait_status
outb 3f5h, 0h       ; 选择0号软驱
wait_status
outb 3f5h, 8h       ; 发送清楚中断命令，获得结果
wait_status
inb 3f5h
wait_status
inb 3f5h
outb 3f2h, 4h       ; 关闭电动机

; 接下来是软盘的读取操作
outb 3f2h, 1ch      ; 开启电动机
wait_status
outb 3f5h, 0fh      ; 4.发送0f寻道命令
wait_status
outb 3f5h, 0h
wait_status
outb 3f5h, 0h
wait_status
outb 3f5h, 8h       ; 发送清楚中断命令，获得结果
wait_status
inb 3f5h
wait_status
inb 3f5h

; 设置ISA DMA为读取
outb 0ah, 6h
outb 0bh, 46h
outb 0ah, 2h

wait_status
outb 3f5h, 0e6h     ; 5.发送读取扇区命令
wait_status
outb 3f5h, 0h       ; 设置磁头和驱动器号
wait_status
outb 3f5h, 0h       ; 设置磁道
wait_status
outb 3f5h, 0h       ; 设置磁头
wait_status
outb 3f5h, 1h       ; 设置扇区号
wait_status
outb 3f5h, 2h       ; 设置扇区大小
wait_status
outb 3f5h, 8h       ; 设置读取扇区数量
wait_status
outb 3f5h, 1bh      ; 设置磁盘为3.5英寸
wait_status
outb 3f5h, 0ffh     ; 设置读取长度，总是0xff

call WaitIrq

mov ecx, 7
loop_ret:
wait_status
inb 3f5h
loop loop_ret

wait_status
outb 3f5h, 8h       ; 发送清楚中断命令，获得结果
wait_status
inb 3f5h
wait_status
inb 3f5h
outb 3f2h, 4h       ; 关闭电动机
 </code></pre>
<p>1.重置数字输出寄存器<br>这是一个只写寄存器，可以用来控制FDC，例如控制软驱电动机，重置控制器，选择目标软驱，设置数据模式，以下是他的详细参数<br>Bits 0-1<br>00 - 软驱 0<br>01 - 软驱 1<br>10 - 软驱 2<br>11 - 软驱 3<br>Bit 2 重置<br>0 - 重置控制器<br>1 - 开启控制器<br>Bit 3 模式<br>0 - IRQ 模式<br>1 - DMA 模式<br>Bits 4 - 7 电动机控制器 (软驱 0 - 3)<br>0 - 停止电动机<br>1 - 开启电动机  </p>
<p>我这里设置的是0Ch也就是说，选择了0号软驱，开启了控制器和DMA模式。</p>
<p>2.设置传输速度为500kb/s<br>这个寄存器只有前两位有效，下面两位不同的组合表达了不同的速度，如下表：<br>00 500 Kbps<br>10 250 Kbps<br>01 300 Kbps<br>11 1 Mbps  </p>
<p>3.设置FDC里面三个时钟以及DMA<br>三个时钟分别是步进速率时钟、磁头卸载时钟和磁头装入时钟。数据格式如下：<br>S S S S H H H H - S=步进速率时钟 H=磁头卸载时钟<br>H H H H H H H NDMA - H=磁头装入时钟 NDMA=0 (DMA模式) 或者 1 (非DMA模式)<br>实际上这个大家可以随意设置，我设置的是步进速率时钟=3ms, 磁头卸载时钟=240ms, 磁头装入时钟=16ms  </p>
<p>4.发送寻道命令进行寻道<br>寻道命令的参数是两个自己，分别代表磁头、柱面和驱动器号，格式如下<br>x x x x x HD DR1 DR0 - HD=磁头 DR1/DR0 = 驱动器<br>C C C C C C C C - C=柱面  </p>
<p>5.发送读取扇区命令<br>读取和写入命令一样，有8个参数和7个返回值！<br>第1个参数字节 = (磁头号 &lt;&lt; 2) | 驱动器号 (驱动器号必须是当前选择的驱动器)<br>第2个参数字节 = 柱面号<br>第3个参数字节 = 磁头号 (没错，重复了 = =)<br>第4个参数字节 = 开始的扇区号<br>第5个参数字节 = 2 (总是2，代表软盘扇区大小总是512字节)<br>第6个参数字节 = 操作扇区数<br>第7个参数字节 = 0x1b (软盘大小是3.5in)<br>第8个参数字节 = 0xff (总是0xff)<br>这里不关心返回值，如果有兴趣可以自己查找资料。  </p>
<p>读取就是这样，如果要写入安排，只需要更改命令即可，这里就不再赘述了。最后按照国际惯例，提供一些深入学习的链接：<br><a href="http://wiki.osdev.org/Floppy" target="_blank" rel="external">http://wiki.osdev.org/Floppy</a><br><a href="http://en.wikipedia.org/wiki/Floppy" target="_blank" rel="external">http://en.wikipedia.org/wiki/Floppy</a><br><a href="http://www.isdaman.com/alsos/hardware/fdc/floppy.htm" target="_blank" rel="external">http://www.isdaman.com/alsos/hardware/fdc/floppy.htm</a><br><a href="http://www.osdever.net/documents/82077AA_FloppyControllerDatasheet.pdf?the_id=41" target="_blank" rel="external">http://www.osdever.net/documents/82077AA_FloppyControllerDatasheet.pdf</a>  </p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2013-09-21T00:39:56.000Z" itemprop="datePublished">2013-09-21</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/MiniKernel/' title=''>MiniKernel</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-e4bdbfe794a8windbg-logextse79b91e68ea7e7a88be5ba8fapie8b083e794a8" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2013/09/14/e4bdbfe794a8windbg-logextse79b91e68ea7e7a88be5ba8fapie8b083e794a8/">使用Windbg Logexts监控程序API调用</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>在我们调试BUG和逆向程序的时候，往往需要监控一些API的调用。这个时候我们可以借助调试器和第三方工具完成这样的任务。例如调试器可以下断点查看栈状态得到相关信息，或者使用第三方工具如API Monitor可以方便的监控API的调用。不过，这篇文章中想说的是另一个工具，Windbg的扩展程序Logexts.dll。闲话少说，我们先看一看监控的效果如何吧。</p>
<p><a href="/uploads/2013/09/20130914230701.png"><img src="/uploads/2013/09/20130914230701.png" alt="20130914230701"></a></p>
<p>上图是Windbg输出的信息，再看看使用logviewer.exe查看的效果。</p>
<p><a href="/uploads/2013/09/20130914234812.png"><img src="/uploads/2013/09/20130914234812.png" alt="20130914234812"></a></p>
<p>怎么样，是不是相当的不错！那么下面我就来简单介绍一下，这个扩展的用法。</p>
<p>!logexts.logi<br>将Logger注入目标程序，初始化监控，但是并不开启它。</p>
<p>!logexts.loge<br>开启监控，如果之前没有调用logexts.logi，这个扩展命令会先初始化监控，然后启动。</p>
<p>!logexts.logd<br>停止监控。这个命令会摘掉所有的Hook，从而让程序自由运行。不过COM的Hook并不会被摘除。</p>
<p>!logexts.logo<br>显示或者修改输出选项，这里有三种输出方式：1.在调试器中显示，2.输出到一个文本文件，3.输出到lgv文件。其中lgv文件会包含更多的信息，我们可以使用LogViewer进行查看。</p>
<p>!logexts.logc<br>显示或者控制监控的API分类。</p>
<p>!logexts.logb<br>显示或者刷新输出缓存。由于如果在监控过程中发生异常，那么扩展可能无法将记录的日志写入文件中，这个时候我们就需要这个命令，手动的将缓存中的数据写入文件。</p>
<p>!logexts.logm<br>显示和创建模块的包含/排除列表。这可以帮助我们指定记录那些特定模块中的API调用。</p>
<p>上面图中我所使用的命令是这样的：</p>
<pre><code>&gt;!logexts.loge D:\  
!logexts.logc d *  
!logexts.logc e 15 16 19  
!logexts.logo e *  
!logexts.logm i notepad.exe</code></pre>
<p>其输出结果是：</p>
<pre><code>!logexts.loge D:\  
Windows API Logging Extensions v3.01  
Parsing the manifest files...  
Location: C:\Program Files (x86)\Windows Kits\8.0\Debuggers\x64\winext\manifest\main.h  
Parsing file &quot;main.h&quot; ...  
Parsing file &quot;winerror.h&quot; ...  
Parsing file &quot;kernel32.h&quot; ...  
Parsing file &quot;debugging.h&quot; ...  
Parsing file &quot;processes.h&quot; ...  
Parsing file &quot;memory.h&quot; ...  
Parsing file &quot;registry.h&quot; ...  
Parsing file &quot;fileio.h&quot; ...  
Parsing file &quot;strings.h&quot; ...  
Parsing file &quot;user32.h&quot; ...  
Parsing file &quot;clipboard.h&quot; ...  
Parsing file &quot;hook.h&quot; ...  
Parsing file &quot;gdi32.h&quot; ...  
Parsing file &quot;winspool.h&quot; ...  
Parsing file &quot;version.h&quot; ...  
Parsing file &quot;winsock2.h&quot; ...  
Parsing file &quot;advapi32.h&quot; ...  
Parsing file &quot;uuids.h&quot; ...  
Parsing file &quot;com.h&quot; ...  
Parsing file &quot;shell.h&quot; ...  
Parsing file &quot;ole32.h&quot; ...  
Parsing file &quot;ddraw.h&quot; ...  
Parsing file &quot;winmm.h&quot; ...  
Parsing file &quot;avifile.h&quot; ...  
Parsing file &quot;dplay.h&quot; ...  
Parsing file &quot;d3d.h&quot; ...  
Parsing file &quot;d3dtypes.h&quot; ...  
Parsing file &quot;d3dcaps.h&quot; ...  
Parsing file &quot;d3d8.h&quot; ...  
Parsing file &quot;d3d8types.h&quot; ...  
Parsing file &quot;d3d8caps.h&quot; ...  
Parsing file &quot;dsound.h&quot; ...  
Parsing completed.  
Logexts injected. Output: &quot;D:\\LogExts\&quot;  
Logging enabled.  
0:000&gt; !logexts.logc d *  
All categories disabled.  
0:000&gt; !logexts.logc e 15 16 19  
15 IOFunctions Enabled  
16 MemoryManagementFunctions Enabled  
19 ProcessesAndThreads Enabled  
0:000&gt; !logexts.logo e *  
Debugger Enabled  
Text file Enabled  
Verbose log Enabled  
0:000&gt; !logexts.logm i notepad.exe  
Included modules:  
notepad.exe</code></pre>
<p>简单说明一下这些命令：<br>!logexts.loge D:\<br>设置log的保持路径，并且开启监控  </p>
<p>!logexts.logc d *<br>先关闭所有API分类的监控  </p>
<p>!logexts.logc e 15 16 19<br>然后设置我们想监控分类，这里是IOFunctions，MemoryManagementFunctions和ProcessesAndThreads。至于如何查询分类对于的id，可以直接输入!logexts.logc进行查看。</p>
<p>!logexts.logo e *<br>这里我开启了所有输出方式，注意：如果想要被监控的程序响应的更快，可以去掉Debugger的输出，因为显示花费的时间比较的多。</p>
<p>!logexts.logm i notepad.exe<br>最后当然是设置inclusion list了。</p>
<p>按下F5，让程序跑起来看看效果吧。先别着急惊叹，Logexts还有更惊艳的地方。那就是他的高度可配置性。如果你想监控他描述以外的API，那么你可以自己写这个API的“头文件”。这里用引号是因为，它并不是真正的头文件，只不过他的语法和C的头文件非常的相似。我们可以看一个例子：</p>
<p>创建%windbg_dir%\winext\manifest\Context.h<br>并且写入这些内容</p>
<pre><code>
category ActivationContext:
module KERNEL32.DLL:

FailOnFalse ActivateActCtx(HANDLE hActCtx, [out] PULONG_PTR lpCookie);
FailOnFalse DeactivateActCtx(DWORD dwFlags, ULONG_PTR upCookie);

 </code></pre>
<p>在%windbg_dir%\winext\manifest\main.h文件的最后加入一行 #include “Context.h”</p>
<p>保存后，重启调试程序，输入!logexts.logc，可以看了多出了ActivationContext这一项。现在就可以选择这一项分类来监控ActivateActCtx和DeactivateActCtx了。</p>
<p>最后，大家应该发现了这样一个问题，开启这个API监控还是比较麻烦的，需要输入好几条命令。为了更方便的使用这个功能，我写了一个脚本来解决这个问题，这样就可以用一行命令来开启监控。使用方法是：<br>Usage $$&gt;a<logger.wds output_dir="" categories="" include_modules="" e.g.="" $$="">a&lt;logger.wds “d:\” “15 16 19” “notepad.exe”  </logger.wds></p>
<p>下载<a href="/uploads/2013/09/logger.zip">logger</a></p>
<p>关于Logexts的更多详细信息请参考msdn：<a href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff560170(v=vs.85" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/windows/hardware/ff560170(v=vs.85).aspx</a>.aspx)</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2013-09-14T09:13:22.000Z" itemprop="datePublished">2013-09-14</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Debugging/' title=''>Debugging</a><a href='/categories/Debugging/Tips/' title=''>Tips</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-windows7e4b88be68ea7e588b6e58d95e4b8aae8bf9be7a88be99fb3e9878fe79a84e5b08fe68a80e5b7a7" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2013/09/10/windows7e4b88be68ea7e588b6e58d95e4b8aae8bf9be7a88be99fb3e9878fe79a84e5b08fe68a80e5b7a7/">Windows7下控制单个进程音量的小技巧</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p><a href="/uploads/2013/09/2013-09-10_200213.png"><img src="/uploads/2013/09/2013-09-10_200213.png" alt="2013-09-10_200213"></a></p>
<p>如上图所示，Windows7下有一个很有趣的功能，就是可以给单独的进程调节音量。出于好奇，在网上翻了下资料，原来这个功能要归功于Windows7上新的音频接口——Core Audio APIs。这套API是用COM写，各种接口也比较多。但是如果我们的目的只是控制单个进程的音量，那还是很简单的。接下来的代码就是控制进程音量的函数了。</p>
<pre><code>const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
const IID IID_IAudioSessionManager2 = __uuidof(IAudioSessionManager2);
const IID IID_IAudioSessionControl2 = __uuidof(IAudioSessionControl2);
const IID IID_ISimpleAudioVolume = __uuidof(ISimpleAudioVolume);

BOOL SetProcessVolume(ULONG target_pid, float level)
{
    CComPtr imm_dev_enumor;

    HRESULT hr = imm_dev_enumor.CoCreateInstance(
        CLSID_MMDeviceEnumerator, NULL,
        CLSCTX_ALL);

    if (FAILED(hr)) {
        return FALSE;
    }

    CComPtr imm_dev;
    hr = imm_dev_enumor-&gt;GetDefaultAudioEndpoint(eRender, eMultimedia, &amp;imm;_dev.p);
    if (FAILED(hr)) {
        return FALSE;
    }

    CComPtr session_mgr2;
    hr = imm_dev-&gt;Activate(IID_IAudioSessionManager2, CLSCTX_ALL, NULL, (void **)&amp;session;_mgr2.p);
    if (FAILED(hr)) {
        return FALSE;
    }

    CComPtr session_enumor;
    hr = session_mgr2-&gt;GetSessionEnumerator(&amp;session;_enumor.p);
    if (FAILED(hr)) {
        return FALSE;
    }

    int count;
    if (FAILED(hr)) {
        return FALSE;
    }

    hr = session_enumor-&gt;GetCount(&amp;count;);
    for (int i = 0; i &lt; count; i++) {
        CComPtr session_ctrl;
        hr = session_enumor-&gt;GetSession(i, &amp;session;_ctrl.p);
        if (FAILED(hr)) {
            continue;
        }

        CComPtr session_ctrl2;
        hr = session_ctrl-&gt;QueryInterface(IID_IAudioSessionControl2, (void **)&amp;session;_ctrl2.p);
        if (FAILED(hr)) {

        }

        ULONG pid;
        hr = session_ctrl2-&gt;GetProcessId(&amp;pid;);
        if (FAILED(hr)) {
            continue;
        }


        if (pid != target_pid) {
            continue;
        }

        CComPtr simple_vol;
        hr = session_ctrl2-&gt;QueryInterface(IID_ISimpleAudioVolume, (void **)&amp;simple;_vol.p);
        if (FAILED(hr)) {
            continue;
        }

        simple_vol-&gt;SetMasterVolume(level, NULL);
    }

    return TRUE;
}
 </code></pre>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2013-09-10T04:05:47.000Z" itemprop="datePublished">2013-09-10</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Tips/' title=''>Tips</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-2" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2013/08/31/e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-2/">使用PCI IDE Controller读写硬盘 – 2</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p><a href="/uploads/2013/09/20130901011808.png"><img src="/uploads/2013/09/20130901011808.png" alt="20130901011808"></a></p>
<p>上一篇文章简单介绍了用PIO的方式读写硬盘数据，那么这篇文章就来介绍另一种数据传输的方式——DMA。</p>
<p>DMA全称是Direct memory access，以下依旧是wiki上的一段简短的介绍：<br>“直接存储器访问（Direct Memory Access，DMA）是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统存储器，而不需绕道中央处理器（CPU）。很多硬件的系统会使用DMA，包含硬盘控制器、绘图显卡、网卡和声卡。”</p>
<p>结合以上的描述和上一篇PIO的介绍，我们就可以发现DMA的优势，他最大的优势之一就是解放了CPU，让CPU不用重复的执行IO端口的操作读写数据。使用DMA的时候，CPU可以做其他的计算，读写数据的操作完全交由CPU外部的DMA芯片进行操作。当读写操作结束后CPU收到通知，然后再来处理读写之后的工作。DMA的另一个优势，就是速度快，不过这么说也不是完全正确的。因为古老的ISA DMA的速度只有4MB/s，现代CPU跑起PIO来，传输速度应该会比这个快。幸运的是，硬盘使用的DMA并不是ISA DMA，而是PCI DMA。PCI DMA的速度通常都超过了100MB/s，所以说速度也算是DMA的一个优势了吧。这里在顺便提一点，ISA DMA也不是完全没有用处的。软盘使用的DMA就是ISA DMA，虽然说软盘在现代的PC上已经消失了，但是如果要写自己的Mini Kernel，那么支持软盘以及ISA DMA还是很有必要的。</p>
<p>DMA的优势很明显，付出的代价就是编程起来相对复杂。那么下面就来介绍让IDE使用DMA传输数据的基础知识。</p>
<p><strong>物理区域描述符（Physical Region Descriptor）</strong><br><a href="/uploads/2013/09/20130828165621.jpg"><img src="/uploads/2013/09/20130828165621.jpg" alt="20130828165621"></a>进行数据传输的物理内存块都用物理区域描述符进行描述。当所有在物理区域描述符表中的物理区域描述符所指向的内存都被传输完成后，数据传输就会停止。每个物理区域描述符是8字节。前4个字节指定的是物理内存区域的地址。接下来的两个字节指定内存数量。最后一个字节的第7位表示此理区域描述符是该表中最后一个描述符。</p>
<p><strong>物理区域描述符表（Physical Region Descriptor Table）</strong><br>这张表中包含一定数量的物理区域描述符（PRD），描述符表必须是4字节对齐且不能跨越64K边界的内存。</p>
<p><strong>总线主控IDE寄存器（Bus Master IDE Register）</strong><br><a href="/uploads/2013/09/20130829115331.png"><img src="/uploads/2013/09/20130829115331.png" alt="20130829115331"></a></p>
<p>要获得总线主控IDE寄存器的基础地址，需要读取PCI配置空间IDE区域的0x20处的DWORD。由于这篇文章不会设计到如何读取PCI配置空间，所以这里的基址就采用bochs设定（0xC000）。后面代码部分也会直接硬编码。</p>
<p><strong>总线主控IDE命令寄存器（Bus Master IDE Command Register）</strong><br><a href="/uploads/2013/09/20130829120041.png"><img src="/uploads/2013/09/20130829120041.png" alt="20130829120041"></a></p>
<p>这里读写控制位是特别要注意的，刚开始容易理解错误。这里的读写是针对的设备，而不是CPU。也就是说这里的都，是指设备读取CPU指定的内存到自己的数据空间。而写是指将自己的数据空间的数据写到CPU指定的内存。所以这里的读写和我们对硬盘要做的读写是刚好相反的。</p>
<p><strong>总线主控IDE状态寄存器（Bus Master IDE Status Register）</strong><br><a href="/uploads/2013/09/20130829120248.png"><img src="/uploads/2013/09/20130829120248.png" alt="20130829120248"></a></p>
<p><strong>描述符指针寄存器（Descriptor Table Pointer Register）</strong><br>用于设置物理区域描述符表的地址</p>
<p>对于初学者理论知识不用了解的过细，最好还是在代码中边写边学习，还是一边堆代码，一边解释吧。<br>（关于下面代码的补充说明：由于使用DMA必须处理中断以获得DMA处理结束的信号，而配置中断又涉及到许多理论知识和额外代码（8259A &amp;IDT），所以下面的代码就不涉及配置中断了，我这里就假设CPU已经进入保护模式，但没有开启分页并且IDE的中断已经配置完毕了。以下代码依旧为了保持最简洁，忽略了状态和结果的检查，在试验中够用即可）</p>
<pre><code>mov dx, 0C000h ; 设置开始停止位为0，停止DMA
mov al, 0h
out dx, al

mov dx, 0C002h ; 清除中断位和错误位，这里清除方式比较特别，设置1后清除
mov al, 6h
out dx, al

; 配置描述符表，表地址为10000h，且只有一个描述符
; 描述符描述的物理基址是20000h，大小为512字节，且设置了第7位，
; 说明自己就是最后一个描述符
mov dword ptr [10000h], 20000h
mov dowrd ptr [10004h], 200h | 80000000h
mov dx, 0C004h
mov eax, 10000h
out dx, eax

mov dx, 3f6h   ; 这里不再设置nIEN，DMA需要中断
mov al, 0h
out dx, al

mov dx, 1f1h   ; 下面代码基本上和PIO一致，
mov al, 0      ; 详细注释请看上一篇文章
out dx, al

mov dx, 1f2h
mov al, 1
out dx, al

mov dx, 1f3h
mov al, 11h
out dx, al

mov dx, 1f4h
mov al, 22h
out dx, al

mov dx, 1f5h
mov al, 33h
out dx, al

mov dx, 1f6h
mov al, 44h
out dx, al

mov dx, 1f7h   ; 设置读取扇区的命令C8h，不同于20h，这个是DMA读取扇区的命令
mov al, C8h
out dx, al

mov dx, 0C000h ; 设置开始停止位为1，开始DMA，并且指定为读取硬盘操作
mov al, 9h     ; （对硬盘而言是写出，所以设置bit3）
out dx, al

call wait_int  ; 等待中断

mov dx, 0C000h ; 中断返回，设置开始停止位为0，停止DMA
mov al, 0h     ; 如果一切都顺利，那么20000h开始的512个字节
out dx, al     ; 就应该是读出的硬盘数据了
 </code></pre>
<p>上面的代码主要分为以下这几步：<br>1) 在系统内存中配置PRD Table。每个PRD是8个字节，其中包含着一个起始内存地址和一个内存大小传送，而且PRD必须是4字节对齐的。<br>2) 给PRD Table指针寄存器传入配置好的PRD Table的地址，设置读写控制位，清除中断和错误位。<br>3) 设置读写命令，包括读写的驱动器，逻辑地址等（这里基本上和PIO类似）。<br>4) 设置总线主控IDE命令寄存器的开始/停止位为1，控制器开始执行DMA操作。<br>5) 控制器DMA操作结束，IDE设备发起中断，收到中断后，设置开始/停止位为0（我们省略了读取状态寄存器来查看操作是否成功的步骤。）  </p>
<p>如果只是从IDE方面来看，代码没有复杂多少，可惜的是他还需要配合其他计算机硬件，所以实际要用上的代码要比PIO多上了不少。最后还是给大家推荐一些深入理解DMA的资料吧。<br>ISA DMA：<a href="http://wiki.osdev.org/ISA_DMA" target="_blank" rel="external">http://wiki.osdev.org/ISA_DMA</a><br>PCI DMA：<a href="http://wiki.osdev.org/ATA/ATAPI_using_DMA" target="_blank" rel="external">http://wiki.osdev.org/ATA/ATAPI_using_DMA</a>  </p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2013-08-31T09:24:36.000Z" itemprop="datePublished">2013-08-31</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/MiniKernel/' title=''>MiniKernel</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-1" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2013/08/26/e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-1/">使用PCI IDE Controller读写硬盘 – 1</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p><a href="/uploads/2013/08/PIO_hd04.jpg"><img src="/uploads/2013/08/PIO_hd04.jpg" alt="PIO_hd04"></a></p>
<p>上一篇文章中提到了一些IDE基础的知识，并且知道了如何判断IDE的类型。接下来介绍IDE最基本的IO方法——PIO。</p>
<p>PIO是Programmed input/output的缩写，下面是一段wiki上对PIO的介绍：<br>“可编程输入输出（英语：PIO）是CPU与外围设备（如网卡、硬盘等）传输数据的一种方法。当 CPU 上执行的软件程序使用 I/O 地址空间来与输入/输出设备（I/O 设备）进行数据传输时，系统即进行了 PIO. 这和直接内存存取（DMA）恰好相反。</p>
<p>在 PC 上最常见的使用 PIO 的例子是 ATA 接口，但 ATA 接口也可以在 DMA 模式下工作。 PC 上的许多比较古老的设备也使用 PIO, 如串行端口、并行端口（在不使用 ECP 模式时）、PS/2 接口、MIDI 接口、内部时钟以及一些古老的网卡。”</p>
<p>实际上，在DMA出现之前，PIO是硬盘唯一的数据传输的方式。就算是现在，ATA的部分命令还必须使用PIO的方式获得数据，例如DEVICE IDENTIFY。PIO传输数据的思想简单直接，例如从硬盘都数据，只需要在硬盘准备好了之后，不断的读取特定端口就能将数据读出来了。例如 in eax, dx（dx里是数据端口号），这样每次就传输4个字节，也就是说如果需要传输512（一个扇区）的数据，需要128次IO。这样一方面数据传输的效率难以提高，另一方面还占用了CPU时间。所以被DMA淘汰也是有道理的。然而，他也有自身的优势，那就是编程起来简单方便。不像DMA那样，需要配置中断和其他一些事情。简单的对IDE下命令就可以达到数据传输的目的了。所以这也是我们入门的很好的切入口。</p>
<p>最后，在开始堆代码之前，我们必须了解硬盘的两种寻址模式：CHS(cylinders-heads-sectors，磁柱-磁头-扇区)寻址模式和LBA(Logical Block Address, 逻辑区块地址)寻址模式。<br>CHS寻址模式，区块必须以硬盘上某个磁柱、磁头、扇区的硬件位置所合成的地址来指定。<br>LBA寻址模式从0开始编号来定位区块，第一区块LBA=0，第二区块LBA=1，依此类推。  </p>
<p>前者的描述更偏向物理，理解起来需要转换，而后者更偏向思维逻辑，理解起来直接了当。既然LBA模式简单容易理解，所以下面的文章和代码所采用的寻址模式就默认是LBA28。所谓LBA28其实是LBA模式中的子模式，它可以寻址到128GB，与之对应的是LBA48，它的寻址范围可以达到128PB，这个对我们来说没啥意义，所以还是选用LBA28。另外CHS模式还需要解释硬盘机械方面的知识，前提太多不利于学习，就暂时搁下吧。</p>
<p>好了，介绍理论的知识不是这篇文章的目的，就让我们一边堆代码，一边讲解这些理论知识吧。下面就是一段读取硬盘数据的asm代码。</p>
<pre><code>    mov dx, 3f6h    ; 1.设置nIEN
    mov al, 2h
    out dx, al
    
    mov dx, 1f1h    ; 2.设置FEATURES为0
    mov al, 0
    out dx, al
        
    mov dx, 1f2h    ; 3.设置读取的扇区数量，这里指定为1
    mov al, 1
    out dx, al
        
    mov dx, 1f3h    ; 4.设置读取地址的低八位
    mov al, 11h
    out dx, al
        
    mov dx, 1f4h    ; 5.设置读取地址的中八位
    mov al, 22h
    out dx, al
        
    mov dx, 1f5h    ; 6.设置读取地址的高八位
    mov al, 33h
    out dx, al
    
    mov dx, 1f6h    ; 7.设置LBA模式，目标驱动器，和地址的最高4位
    mov al, 44h     ;   其中第6位（40h）是设置LBA模式，第4位设置主从驱动器，0为主驱动器
    out dx, al      ;   后四位就是LBA最高位了，这里是4h，也就是说读取的地址是04332211h
        
    mov dx, 1f7h    ; 8.设置读取扇区的命令20h
    mov al, 20h
    out dx, al
pri_stat:
    in al, dx       ; 9.轮询状态寄存器，第3位（8）如果是设置状态，表明可以进行数据传输了。
    test al, 8
    jz pri_stat
         
    mov ecx, 512&#x2F;4  ; IO 128次！
    mov edi, offset buffer  ; 设置buffer地址到edi
    mov dx, 1f0h
    rep insw        ; 10.循环128次从数据寄存器读取1个扇区的数据
 </code></pre>
<p>上面的代码主要分为以下这几步：<br>1.我们现在不需要IRQs，所以我们这里要禁用它，以免发生不必要的问题。这里，我们设置CBR（Control Block Register）的第1位，也叫nIEN位，只要它处于设置的状态，那么IRQs就不会触发。<br>2.设置FEATURES寄存器<br>3.设置扇区数寄存器<br>4.设置LBA低8位<br>5.设置LBA中8位<br>6.设置LBA中高8位<br>7.设置LBA最高4位，以及驱动器，指明使用LBA模式<br>8.设置读扇区命令<br>9.轮询等待完成状态<br>10.循环128次读取1个扇区的数据（128*4=512 bytes）  </p>
<p>再看看写扇区有哪些不同呢？没错，只有最后几条指令有细微的差别。</p>
<pre><code>    mov dx, 1f7h
    mov al, 30h     ; 这里命令改为30h，写扇区
    out dx, al
pri_stat:
    in al,dx
    test al,8
    jz pri_stat
    
    mov ecx, 512&#x2F;4
    mov esi, offset buffer ; 设置buffer地址到esi
    mov dx, 1f0h
    rep outsd       ; 这里指令改为outsd
 </code></pre>
<p>看起来还是很简单的吧！不过这也是当然的，因为我们没有做任何的排错和检验处理。不过这样的代码才是初学者最喜欢看到的吧，同样对于做操作系统实验也没多大问题。</p>
<p>最后，如果对CHS以及LBA和CHS的转换关系感兴趣，推荐翻阅wiki：<br><a href="http://en.wikipedia.org/wiki/Cylinder-head-sector" target="_blank" rel="external">http://en.wikipedia.org/wiki/Cylinder-head-sector</a><br><a href="http://en.wikipedia.org/wiki/Logical_block_addressing#CHS_conversion" target="_blank" rel="external">http://en.wikipedia.org/wiki/Logical_block_addressing#CHS_conversion</a>  </p>
<p>在下一篇的文章中，会介绍一些用PCI DMA的方式读写硬盘的知识。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2013-08-26T07:00:42.000Z" itemprop="datePublished">2013-08-26</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/MiniKernel/' title=''>MiniKernel</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-0" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2013/08/17/e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-0/">使用PCI IDE Controller读写硬盘 - 0</a>
  

      </h3>
      <div class="repo-list-description">
        
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>依稀记得我一年半以前曾经写过一篇关于PIO读硬盘数据的文章，当时就提到了读写硬盘操作很复杂，完全可以拿来做一个系列来写。当时也是真有写出一个系列的冲动，不过不巧的是，由于那段时间换工作，新的工作和底层的关系不太大，也就没时间继续读相关文档来把这个系列写下来。我现在还很清楚的记得当时有关使用IDE接口读写硬盘的中文资料特别的少，虽然英文资料倒是挺全面，但是对于英语不好的我来说，看起来还是挺吃力的。一年半后，我又好奇的搜索的这方面的中文资料，结果依旧令人失望。于是，我就决定我把知道的IDE方面的知识写出来，一方面算是自己的一个学习笔记，另一方面也算是一种分享。我将这个系列定位为学习笔记，就是说，文章的很多地方都是自己的理解，不能保证所提到的知识都是正确的。所以如果这篇文章有幸被你看见，并且发现了问题，请使用email联系我。</p>
<h1 id="IDE介绍"><a href="#IDE介绍" class="headerlink" title="IDE介绍"></a>IDE介绍</h1><p><a href="/uploads/2013/08/hdd-sata-pata-ide-aussie-pc-fix.png"><img src="/uploads/2013/08/hdd-sata-pata-ide-aussie-pc-fix.png" alt="hdd-sata-pata-ide-aussie-pc-fix"></a></p>
<p>IDE是Integrated Drive Electronics的简称，wiki上翻译的中文是“集成驱动电子设备”。我们可以认为它是一种接口，可以管理控制IDE的驱动器，比如硬盘，光驱等等。事实上，现在所谓的ATA/ATAPI接口的第一个版本的名称就叫做IDE，所以现在人们通常认为IDE就是PATA。如果现在去买主板，我们会发现集成PATA/IDE的主板已经消失了，现在主流主板都是使用的SATA，这是一套新的接口。那么，我们干嘛要学习一个已经淘汰的技术呢？其实不然，虽然硬件的接口被淘汰了，但是IDE的驱动器的控制模式还是存在的。现在的BIOS设置中，通常有一种叫做“legacy mode”或者“IDE”的选项，开启这个选项，系统就能如同操作IDE/PATA一样操作SATA了。而对于我这有写迷你内核的人来说，学习IDE是非常好的，因为虚拟机bochs模拟的硬盘设备就是IDE/PATA的，另一方面，把迷你内核拿到真机上做实验的时候，开启“legacy mode”或者“IDE”也能够很顺利的进行实验。</p>
<p><a href="/uploads/2013/08/bios-sata-native-mode-ide-raid-ahci-ca184a.jpg"><img src="/uploads/2013/08/bios-sata-native-mode-ide-raid-ahci-ca184a.jpg" alt="bios-sata-native-mode-ide-raid-ahci-ca184a"></a></p>
<h1 id="IDE通道以及通道寄存器地址"><a href="#IDE通道以及通道寄存器地址" class="headerlink" title="IDE通道以及通道寄存器地址"></a>IDE通道以及通道寄存器地址</h1><p>IDE有2个通道，可以管理4个驱动器，分别是：<br>通道1：<br>第一主驱动器<br>第一从驱动器<br>通道2：<br>第二主驱动器<br>第二从驱动器  </p>
<p>每个通道都有两套用于控制其主从驱动器的寄存器，他们分别是 Control Block Registers 和 Command Block Registers。这些寄存器首先是有一个基础地址，然后通过按顺序可以获得整套寄存器地址，而寄存器的基础地址可以通过PCI Configuration Space来获得，更多情况下，我们不妨直接使用下面这张表来配置寄存器的基础地址。</p>
<p><a href="/uploads/2013/08/2013-08-18_142953.png"><img src="/uploads/2013/08/2013-08-18_142953.png" alt="2013-08-18_142953"></a></p>
<p>事实上，这个基础地址是根据PCI IDE Controller模式不同而确定的。Compatibility模式下，寄存器的基础地址是固定的，但是在Native-PCI模式下，这个就需要读取具体的配置信息了。不过，大部分情况下，用上述地址不会有什么问题，所以这里就略过读取PCI Configuration Space的步骤了。</p>
<p>现在既然知道了寄存器的Base Address，那么下一步就是获得每个寄存器的地址了，其实这也非常简单。</p>
<p>Command Block Registers<br>1F0 （170）（读取和写入）：数据寄存器<br>1F1 （171）（读）：错误寄存器<br>1F1 （171）（写入）：特性寄存器<br>1F2 （172）（读取和写入）：扇区数寄存器<br>1F3 （173）（读取和写入）：低LBA寄存器<br>1F4 （174）（读取和写入）：中LBA寄存器<br>1F5 （175）（读取和写入）：高LBA寄存器<br>1F6 （176）（读取和写入）：驱动器/磁头寄存器<br>1F7 （177）（读）：状态寄存器<br>1F7 （177）（写入）：命令寄存器  </p>
<p>Control Block Registers<br>3F6 （376）（读取）：备用状态寄存器<br>3F6 （376）（写入）：设备控制寄存器  </p>
<p>另外还有一组寄存器叫做Bus Master IDE Register，我们使用DMA进行数据传输的时候会用到这类寄存器。现在就不去了解了，以免东西太多，造成不必要的混乱。</p>
<p>判断驱动器类型</p>
<p>前面说了很多的理论上的东西，现在我们看看怎么运用它们判断驱动器类型，比如是PATA还是SATA。当然，在做判断它们的类型之前，我们需要检测驱动器是否存在。判断方法很简单，先选择驱动器，对扇区数寄存器（1F2）和低LBA寄存器（1F3）写两个非0的数字，然后进行读取。如果读出的内容和写入的相同，那么我们可以认为驱动存在。就拿第一主驱动器举个例子：<br>mov dx, 1f6h ; 驱动器寄存器<br>xor al, al ; 选择驱动器，如果al第4位是0，那么选择0号设备，否则选择1号设备<br>out dx, al  </p>
<p>mov dx, 1f2h<br>mov al, 55h ; 随意写一个数<br>out dx, al  </p>
<p>mov dx, 1f3h<br>mov al, aah<br>out dx, al  </p>
<p>mov dx, 1f2h<br>in al, dx ; 读取后比较<br>cmp al, 55h<br>jnz not_exist  </p>
<p>mov dx, 1f3h<br>in al, dx<br>cmp al, aah<br>jnz not_exist  </p>
<p>我用bochs测试的结果是，如果驱动器不存在，读出的数字总是0。接下来就可以获得驱动器的类型了，步骤是：1.选择驱动器（前面的操作以及做完这步了）2.软件复位驱动器。3.读取高LBA寄存器和中LBA寄存器。  </p>
<p>mov dx, 3f6h ; 选择设备控制寄存器<br>mov al, 4h ; 设置第二位，表示软件复位<br>out dx, al  </p>
<p>mov dx, 3f6h ; 选择设备控制寄存器<br>mov al, 0h<br>out dx, al  </p>
<p>mov dx, 1f4h<br>in al, dx<br>mov id1, al  </p>
<p>mov dx, 1f5h<br>in al, dx<br>mov id2, al  </p>
<p>当ID1和ID2为不同的数值的时候，表示的设备不同，如下表所示<br><a href="/uploads/2013/08/20130818152800.png"><img src="/uploads/2013/08/20130818152800.png" alt="20130818152800"></a><br>我在bochs实验的得到的结果是PATA，虽然模拟的设备比较老，但是这正是我想要的。  </p>
<p>这样，我们读写硬盘的第一步，环境检测已经完成了。这个系列的下一篇文章，我们就来了解下通过PIO的方式读写硬盘。  </p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2013-08-17T07:51:35.000Z" itemprop="datePublished">2013-08-17</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/MiniKernel/' title=''>MiniKernel</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-e4bdbfe794a8e58fafe7bc96e7a88be997b4e99a94e5ae9ae697b6e599a8programmable-interval-timere7bc96e58699e7b3bbe7bb9fe697b6e9929f" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2013/08/04/e4bdbfe794a8e58fafe7bc96e7a88be997b4e99a94e5ae9ae697b6e599a8programmable-interval-timere7bc96e58699e7b3bbe7bb9fe697b6e9929f/">使用可编程间隔定时器(Programmable Interval Timer)编写系统时钟</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>很久没有写关于MiniKernel的文章了，这周末看着有点时间，就写一点关于定时器的东西吧。</p>
<p><a href="/uploads/2013/08/8253.jpg"><img src="/uploads/2013/08/8253.jpg" alt="8253"></a></p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>可编程间隔定时器（PIT）芯片（也就是我们常说的8253/8254芯片），他包含了1个振荡器，1个预分频器和3个独立的分频器。每个分频器有一个输出，它是可以让定时器控制外部电路（例如，IRQ0）</p>
<p>其中PIT的振荡器的频率是1.193182 MHz。具体为什么是这么个奇怪的数字，是有一点历史的，但这些不是这篇文章的重点，有兴趣的可以Google一下。</p>
<p>分频器也比较容易理解，就是把高频分割为低频，一般来说就是使用一个计数器，当每次脉冲的时候，计数器的数值减少，当计数器数值为0的时候，在输出上产生一个脉冲，并且计数器复位，重新开始计数。</p>
<p>PIT定时器的准确度依赖于所使用的振荡器，一般来说，一天的浮动为+/- 1.73秒。不过这种浮动，对我们影响并不大，所以也不必过于在意。</p>
<p>PIT的输出通道一共有三个：通道0，直接连接到IRQ0，并且触发时钟中断（这个通道是我们写MiniKernel最重要的一个。）。通道1，貌似以前是定时刷新内存的，但是现在没什么用了。通道2是连接到PC扬声器的，目前我也没有研究过它的作用。</p>
<p>这里再重点介绍一下通道0：PIT通道0的输出是连接到PIC芯片上的（8259A，以后有空也可以写一篇简单的介绍），因此，它能生成一个IRQ0的中断。通常情况下，在开机时，BIOS会将通道0的计数器的值设置为65535或0（其中如果是0，硬件会自动转化为65536），这样，它的输出频率就是18.2065Hz。另外，之所以说通道0最重要，主要原因就是它是三个通道中，唯一一个能连接到IRQ的，对于编写系统时钟至关重要。</p>
<h2 id="编程相关"><a href="#编程相关" class="headerlink" title="编程相关"></a>编程相关</h2><p>PIT是使用以下IO端口进行控制：<br><pre><code>I&#x2F;O 端口     用途
0x40         通道0的数据端口
0x41         通道1的数据端口
0x42         通道2的数据端口
0x43         控制字寄存器</code></pre></p>
<p>控制字寄存器的具体内容如下：</p>
<p><a href="/uploads/2013/08/8253cw.png"><img src="/uploads/2013/08/8253cw.png" alt="8253cw"></a></p>
<pre><code>Bits
6 7选择通道：
0 0 =通道0
0 1 =通道1
1 0 =通道2
1 1 =回读命令（只有8254支持）
4 5访问模式：
0 0 =锁存计数值命令
0 1 =访问模式：读写最低有效字节
1 0 =访问模式：读写最高有效字节
1 1 =访问模式：先读写最低有效字节，然后读写高位字节
1-3工作模式：
0 0 0 =模式0（计数结束中断）
0 0 1 =模式1（硬件再触发单稳）
0 1 0 =模式2（速率发生器）
0 1 1 =模式3（方波发生器）
1 0 0 =模式4（软件触发闸门）
1 0 1 =模式5（硬件触发闸门）
1 1 0 =模式2（速率发生器，与010B相同）
1 1 1 =模式3（方波发生器，与011B相同）
0 BCD &#x2F;二进制模式：0 = 16位二进制数，1 =四位BCD&lt;&#x2F;blockquote&gt;</code></pre>
<p>这里，我们要写系统时钟，那么就应该这样选择：</p>
<ol>
<li>选择通道，必须是通道0，那么bit 6 7 就分别为 0 0。  </li>
<li>由于我们的计数器是16位的，那么访问模式bit 4 5就应该选择1 1。  </li>
<li>数据模式，毫无疑问选择二进制模式。  </li>
<li>最后就是工作模式了，应该选择什么呢？这里我也不想把这些模式都讲的很清楚，因为那样就涉及到引脚和电平等等硬件知识。现在我们只需要知道0，1，4，5这些模式都可以触发中断，但是却不会自动复位。只有模式2和3会自动复位。所以模式2 3都是我们可以用来作为系统时钟的模式。那么1-3 bits可以为0 1 0或者0 1 1。</li>
</ol>
<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>现在假设，系统的时钟中断例程已经设置好了，并且设置好了PIC的IRQ0到这个例程。下面要做的事情就是，设置时钟中断的频率了。</p>
<pre><code>mov dx, 1193180 &#x2F; 100 ; 没10ms触发一次中断
mov al, 110110b ; 设置控制字寄存器，上面已经介绍过每个位的含意
out 0x43, al
mov ax, dx
out 0x40, al   ;先设置低位的值
xchg ah, al
out 0x40, al   ;再设置高位的值</code></pre>
<p>总的来说8253 和 8254 是很有用的芯片。他们可以用在很多不同的设备，并用于很多不同的目的。不过就目前的PC来说，系统对他们的依赖已经不像以前那样严重了。随着科技的进步，APIC Timer已经可以取代他们。另外2005年，Intel和MS已经联合开发了新的高精度的定时器芯片High Precision Event Timer（HPET）。</p>
<p>虽然成熟的系统可能已经不用8253 和 8254了，但是对于我们自己的迷你内核来说，使用它们就完全足够了</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2013-08-04T00:12:15.000Z" itemprop="datePublished">2013-08-04</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/MiniKernel/' title=''>MiniKernel</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
        </div>
        <div class="column one-third">
          <!--处理未安装 search 插件 默认 Google 搜索-->
 

<h3>Search</h3>

<div id="site_search">

	<!-- Google -->
	
		<form action="http://www.google.com/search?" data-site="http://0cch.com">
	    	<input type="text" id="search_box" name="q" placeholder="Search">
	    	<button type="button" class="btn btn-default" id="site_search_do"><span class="octicon octicon-search"></span></button>
	    </form>
	

	<!-- 本地搜索 -->
	

</div>

<h3>Popular Repositories</h3>
    <div class="popular-container"></div>
    
    <script type="text/template" id="popular-list-template">
        <a href="{%=clone_url%}" class="card text-center" target="_blank">
            <div class="thumbnail">
                <div class="card-image geopattern" data-pattern-id="{%=name%}">
                    <div class="card-image-cell">
                        <h3 class="card-title">
                            {%=name%}
                        </h3>
                    </div>
                </div>
                <div class="caption">
                    <div class="card-description">
                        <p class="card-text">
                            {%=description%}
                        </p>
                    </div>
                    <div class="card-text">
                        <span class="meta-info tooltipped tooltipped-n" aria-label="{%=stargazers_count%} stars">
                            <span class="octicon octicon-star"></span> {%=stargazers_count%}
                        </span>
                        <span class="meta-info tooltipped tooltipped-n" aria-label="{%=forks_count%} forks">
                            <span class="octicon octicon-git-branch"></span> {%=forks_count%}
                        </span>
                        <span class="meta-info tooltipped tooltipped-n" aria-label="最后更新时间：{%=updated_at%}">
                            <span class="octicon octicon-clock"></span>
                            <time datetime="{%=updated_at%}">{%=updated_at%}</time>
                        </span>
                    </div>
                </div>
            </div>
        </a>
    </script>

    <script src="/js/baiduTemplate.js"></script>
    <script type="text/javascript">
        var popular_repos = function(){

            var baiduTpl = new Object();

            var handleTpl = function(){
                baiduTpl.popular_list = baidu.template("popular-list-template");
            };

            var handleGithub = function(){
                var popularContainer = $(".popular-container");

                var repos = "0cchext".split(",");
                for(var i in repos){
                    var name = repos[i];
                    $.get("https://api.github.com/repos/0cch/"+name,handle);
                }

                function handle(result){
                    result.updated_at = result.updated_at.split("T")[0];
                    if(result){
                        var html = baiduTpl.popular_list(result);
                        popularContainer.append(html);
                        $(".geopattern").each(function(){           
                            $(this).geopattern($(this).data('pattern-id'));
                        });
                    }
                }
            };

            return {
                init:function(){
                    handleTpl();
                    handleGithub();
                }
            }
        }; 
        $(popular_repos().init);
    </script>

        </div>
    </div>

    
      <div class="pagination text-align">
          <div class="btn-group">
              <a class="extend prev" rel="prev" href="/archives/page/7/">&laquo;</a><a class="page-number" href="/archives/">1</a><a class="page-number" href="/archives/page/2/">2</a><a class="page-number" href="/archives/page/3/">3</a><a class="page-number" href="/archives/page/4/">4</a><a class="page-number" href="/archives/page/5/">5</a><a class="page-number" href="/archives/page/6/">6</a><a class="page-number" href="/archives/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/archives/page/9/">9</a><a class="page-number" href="/archives/page/10/">10</a><a class="page-number" href="/archives/page/11/">11</a><a class="page-number" href="/archives/page/12/">12</a><a class="extend next" rel="next" href="/archives/page/9/">&raquo;</a>
          </div>
      </div>
    
</section>

<footer class="container">
    <div class="site-footer" role="contentinfo">
        <div class="copyright left mobile-block">
                © 2016
                <span title="yumemor">yumemor</span>
                <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a>
        </div>

        <ul class="site-footer-links right mobile-hidden">
            <li>
                <a href="javascript:window.scrollTo(0,0)" >TOP</a>
            </li>
        </ul>

        <a href="https://github.com/yumemor/hexo-theme-primer" target="_blank" aria-label="view source code">
            <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
        </a>

        <ul class="site-footer-links mobile-hidden">
            
                  
                  <li>
                    <a href="/"  title="Home">Home</a>
                  </li>
            
                  
                  <li>
                    <a href="/categories/"  title="Category">Category</a>
                  </li>
            
                  
                  <li>
                    <a href="/open-source/"  title="Open-Source">Open-Source</a>
                  </li>
            
            <li>
                <a href="/atom.xml">
                    <span class="octicon octicon-rss" style="color:orange;"></span>
                </a>
            </li>
        </ul>
    </div>
</footer>

		<script src="/js/geopattern.js"></script>
		<script src="/js/highlight.pack.js"></script>
		<script src="/lib/fancybox/jquery.fancybox-1.3.4.pack.js"></script>

		

		<script src="/js/index.js"></script>

		 <script src="/js/popular_repo.js"></script> 

	</body>
</html>