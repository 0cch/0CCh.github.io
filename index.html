<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>0CCh Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="0CCh Blog">
<meta property="og:url" content="http://0cch.com/index.html">
<meta property="og:site_name" content="0CCh Blog">
<meta property="og:locale">
<meta property="article:author" content="0CCh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="0CCh Blog" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class="active"
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">0CCh Blog</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-dpcpp" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/01/dpcpp/">DPC++中的现代C++语言特性</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/12/01/dpcpp/" class="article-date"><time datetime="2021-12-01T00:24:18.000Z" itemprop="datePublished">2021-12-01</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Ⅰ-DPC-简介"><a href="#Ⅰ-DPC-简介" class="headerlink" title="Ⅰ DPC++简介"></a>Ⅰ DPC++简介</h1><p>DPC++是Data Parallel C++（数据并行C++）的首字母缩写，它是Intel为了将SYCL引入LLVM和oneAPI所开发的开源项目。SYCL是为了提高各种加速设备上的编程效率而开发的一种高级别的编程模型，简单来说它是一种跨平台的抽象层，用户不需要关心底层的加速器具体是什么，按照标准编写统一的代码就可以在各种平台上运行。可以说SYCL大大提高了编写异构计算代码的可移植性和编程效率，已经成为了异构计算的行业标准。值得一提的是SYCL并不是由多个单词的首字母的缩写。DPC++正是建立在SYCL和现代C++语言之上，具体来说是建立在C++17标准之上的。<br>写本篇文章的目是为了讨论现代C++语言在DPC++中的应用，算是对《现代C++语言核心特性解析》一书的补充，而不是要探究异构计算的原理，因为这是一个庞大的话题，需要资深专家才好驾驭。<br>关于实验环境，我选择的是本地安装Intel oneApi Toolkit，因为本地工具用起来还是更加方便一些。不过，如果读者朋友们的硬件条件不允许，那么我们可以注册使用DevCloud。DevCloud是Intel公司提供的远程开发环境，包含了最新的Intel 硬件和软件集群。</p>
<h1 id="Ⅱ-DPC-背景"><a href="#Ⅱ-DPC-背景" class="headerlink" title="Ⅱ DPC++背景"></a>Ⅱ DPC++背景</h1><h3 id="1．什么是数据并行编程"><a href="#1．什么是数据并行编程" class="headerlink" title="1．什么是数据并行编程"></a>1．什么是数据并行编程</h3><p>数据并行编程既可以被描述为一种思维方式，也可以被描述为一种编程方式。 数据由一组并行的处理单元进行操作。 每个处理单元都是能够对数据进行计算的硬件设备。这些处理单元可能存在于单个设备上，也可能存在于我们计算机系统中的多个设备上。 我们可以指定代码以内核的形式处理我们的数据。<br>内核是数据并行编程中一个重要的概念，它的功能是让设备上的处理单元执行计算。这个术语在SYCL、OpenCL、CUDA 和 DPC++都有使用到。</p>
<h3 id="2．什么是异构系统"><a href="#2．什么是异构系统" class="headerlink" title="2．什么是异构系统"></a>2．什么是异构系统</h3><p>异构系统是包含多种类型的计算设备的任何系统。 例如，同时具有CPU和GPU的系统就是异构系统。现在已经有很多中这样的计算设备了，包括 CPU、GPU、FPGA、DSP、ASIC和AI 芯片。异构系统的出现带来了一个很大的挑战，就是刚刚提到的这些设备，每一种都具有不同的架构，也具有不同的特性，这就导致对每个设备有不同编程和优化需求，而DPC++开发一个动机就是帮助解决这样的挑战。</p>
<h3 id="3．为什么需要异构系统"><a href="#3．为什么需要异构系统" class="headerlink" title="3．为什么需要异构系统"></a>3．为什么需要异构系统</h3><p>因为异构计算很重要，一直以来计算机架构师致力于限制功耗、减少延迟和提高吞吐量的工作。从1990年到2006年，由于处理器性能每两到三年翻一番（主要是因为时钟频率每两年翻一番），导致那个时候应用程序的性能都跟着有所提升。这种情况在2006年左右结束，一个多核和多核处理器的新时代出现了。由于架构向并行处理的转变为多任务系统带来了性能提升，但是在不改变编程代码的情况下，并没有为大多数现有的单个应用程序带来性能提升。在这个新时代，GPU等加速器因为能够更高效的加速应用程序变得比以往任何时候都流行。这催生了一个异构计算时代，诞生了大量的具有自己的专业处理能力的加速器以及许多不同的编程模型。它们通过更加专业化的加速器设计可以在特定问题上提供更高性能的计算，因为它们不必去处理所有问题。这是一个经典的计算机架构权衡。它通常意味着加速器只能支持为处理器设计的编程语言的子集。事实上，在DPC++中，只有在内核中编写的代码才能在加速器中运行。<br>加速器架构可以分为几大类，这些类别会影响我们对编程模型、算法以及如何高效使用加速器的决策。例如，CPU是通用代码的最佳选择，包括标量和决策代码，并且通常内置向量加速器。GPU则是寻求加速向量和密切相关的张量。DSP寻求是以低延迟加速特定数学运算，通常用于处理手机的模拟信号等。AI加速器通常用于加速矩阵运算，尽管有些加速器也可能加速图。FPGA和ASIC特别适用于加速计算空间问题。</p>
<h3 id="4．为什么使用DPC"><a href="#4．为什么使用DPC" class="headerlink" title="4．为什么使用DPC++"></a>4．为什么使用DPC++</h3><p>一方面因为DPC++具有可移植性、高级性和非专有性，同时满足现代异构计算机体系结构的要求。另一方面，它可以让跨主机和计算设备的代码使用相同的编程环境，即现代C++的编程环境。最后，计算机体系结构的未来包括跨越标量、向量、矩阵和空间 (SVMS) 操作的加速器，需要对包括 SVMS 功能在内的异构机器的支持。并且这种支持应该涵盖高度复杂的可编程设备，以及可编程性较低的固定功能或专用的设备。</p>
<h1 id="Ⅲ-初探DPC"><a href="#Ⅲ-初探DPC" class="headerlink" title="Ⅲ 初探DPC++"></a>Ⅲ 初探DPC++</h1><p>在开始讨论现代C++语言在DPC++中的应用之前，让我们先看一遍完整的代码，顺便测试我们的实验环境：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CL/sycl.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sycl;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelGPUSelector</span> :</span> <span class="keyword">public</span> device_selector &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> device&amp; Device)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> std::string DeviceName = Device.get_info&lt;info::device::name&gt;();</span><br><span class="line">    <span class="keyword">const</span> std::string DeviceVendor = Device.get_info&lt;info::device::vendor&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Device.<span class="built_in">is_gpu</span>() &amp;&amp; (DeviceName.<span class="built_in">find</span>(<span class="string">&quot;Intel&quot;</span>) != std::string::npos) ? <span class="number">100</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IntelGPUSelector d;</span><br><span class="line">  <span class="function">queue <span class="title">q</span><span class="params">(d)</span></span>;</span><br><span class="line">  <span class="keyword">int</span>* data = malloc_shared&lt;<span class="keyword">int</span>&gt;(N, q);</span><br><span class="line">  q.<span class="built_in">parallel_for</span>(N, [=](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">     data[i] = i;</span><br><span class="line">   &#125;).<span class="built_in">wait</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">free</span>(data, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行上面的代码，如果没有问题应该输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</span><br></pre></td></tr></table></figure>
<p>简单解释一下这段代码，sycl是DPC++的实体的命名空间，用<code>using namespace sycl;</code>打开命名空间可以简化后续代码。<code>IntelGPUSelector</code>是一个继承了<code>device_selector</code>的设备选择器，其中<code>device_selector</code>是纯虚类，它有个纯虚函数<code>int operator()(const device&amp; Device) const</code>需要派生类来实现，该函数会遍历计算机上的计算设备，并且返回使用设备的优先级，返回数字越高优先级越高，这里选择Intel的GPU作为首选的计算设备，注意这个函数使用了<code>override</code>来说明其目的是覆盖虚函数。<code>queue</code>的目的是指定工作的目标位置，这里设置的是Intel的GPU。函数模板<code>malloc_shared</code>分配了可在设备上使用的工作内存。成员函数<code>parallel_for</code>执行并行计算。值得注意的是<code>free</code>调用的是<code>sycl::free</code>而不是C运行时库的<code>free</code>。在这段代码中，比较明显使用了现在C++语法的地方是函数<code>parallel_for</code>的实参，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[=](<span class="keyword">auto</span> i) &#123; data[i] = i; &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个lambda表达式。<br>Ⅳ DPC++和lambda表达式<br>如果要选出一个对DPC++最重要的现代C++语言特性，我觉得lambda表达式应该可以被选上。因为在DPC++的代码中，内核代码一般都是以lambda表达式的形式出现。比如上面的例子就是将lambda表达式作为对象传入到Intel的GPU设备上然后进行计算的。在这个lambda表达式中，<code>[=]</code>是捕获列表，它可以捕获当前定义作用域内的变量的值，这也是它可以在函数体内使用<code>data[i]</code>的原因。捕获列表<code>[=]</code>之后的是形参列表<code>(auto i)</code>，注意这里的形参类型使用的是<code>auto</code>占位符，也就是说，我们将形参类型的确认工作交给了编译器。我们一般称这种lambda表达式为泛型lambda表达式。当然，如果在编译时选择C++20标准，我们还可以将其改为模板语法的泛型lambda表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[=]&lt;<span class="keyword">typename</span> T&gt;(T i) &#123; data[i] = i; &#125;</span><br></pre></td></tr></table></figure>
<p>lambda表达式的捕获列表功能非常强大，除了捕获值以外，还可以捕获引用，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[&amp;](<span class="keyword">auto</span> i) &#123; data[i] = i; &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会捕获当前定义作用域内的变量的引用，不过值得注意的是，由于这里的代码会交给加速核心运行，捕获引用并不是一个正确的做法，会导致编译出错。另外一般来说，我们并不推荐直接捕获所有可捕获的对象，而是有选择的捕获，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[data](<span class="keyword">auto</span> i) &#123; data[i] = i; &#125;</span><br></pre></td></tr></table></figure>
<p>当然，除了使用lambda表达式，我们也可以选择其他形式的代码来运行设备，比如使用仿函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AssginTest</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">auto</span> i)</span> <span class="keyword">const</span> </span>&#123; data_[i] = i; &#125;</span><br><span class="line">  <span class="keyword">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AssginTest functor&#123;data&#125;;</span><br><span class="line">q.<span class="built_in">parallel_for</span>(N, functor).<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>
<p>但是很明显，这种方法没有使用lambda表达式来的简单直接。</p>
<h1 id="Ⅴ-DPC-和泛型能力"><a href="#Ⅴ-DPC-和泛型能力" class="headerlink" title="Ⅴ DPC++和泛型能力"></a>Ⅴ DPC++和泛型能力</h1><p>之所以能够让<code>parallel_for</code>这么灵活的接受各种形式的实参，是因为<code>parallel_for</code>本身是一个成员函数模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KernelName = detail::auto_name, <span class="keyword">typename</span> KernelType&gt;</span><br><span class="line">event <span class="built_in">parallel_for</span>(range&lt;<span class="number">1</span>&gt; NumWorkItems,</span><br><span class="line">                   _KERNELFUNCPARAM(KernelFunc) _CODELOCPARAM(&amp;CodeLoc)) &#123;</span><br><span class="line">  _CODELOCARG(&amp;CodeLoc);</span><br><span class="line">  <span class="keyword">return</span> parallel_for_impl&lt;KernelName&gt;(NumWorkItems, KernelFunc, CodeLoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>KernelFunc</code>就是传入的lambda表达式或者仿函数，<code>KernelType</code>是<code>KernelFunc</code>的类型。<br>如果从这里的代码一路运行跟踪下去，会发现它们都是用模板传递实参类型，直到<code>submit_impl</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sycld.dll!cl::sycl::queue::submit_impl</span><br><span class="line">dpcpp.exe!cl::sycl::queue::submit</span><br><span class="line">dpcpp.exe!cl::sycl::queue::parallel_for_impl</span><br><span class="line">dpcpp.exe!cl::sycl::queue::parallel_for</span><br></pre></td></tr></table></figure>
<p>这是因为sycld.dll是一个二进制模块，它无法以模板的形式提供代码，所有的类型必须确定下来，为了解决这个问题，<code>cl::sycl::queue::submit_impl</code>使用了<code>std::function</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">event <span class="title">submit_impl</span><span class="params">(function_class&lt;<span class="keyword">void</span>(handler &amp;)&gt; CGH,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> detail::code_location &amp;CodeLoc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数模板<code>cl::sycl::queue::parallel_for_impl</code>将<code>KernelFunc</code>封装到另外一个lambda表达式对象中，并且通过<code>function_class&lt;void(handler &amp;)&gt;</code>来传递整个lambda表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KernelName = detail::auto_name, <span class="keyword">typename</span> KernelType,</span><br><span class="line">            <span class="keyword">int</span> Dims&gt;</span><br><span class="line">  event <span class="built_in">parallel_for_impl</span>(</span><br><span class="line">      range&lt;Dims&gt; NumWorkItems, KernelType KernelFunc,</span><br><span class="line">      <span class="keyword">const</span> detail::code_location &amp;CodeLoc = detail::code_location::<span class="built_in">current</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">submit</span>(</span><br><span class="line">        [&amp;](handler &amp;CGH) &#123;</span><br><span class="line">          CGH.<span class="keyword">template</span> parallel_for&lt;KernelName, KernelType&gt;(NumWorkItems,</span><br><span class="line">                                                            KernelFunc);</span><br><span class="line">        &#125;,</span><br><span class="line">        CodeLoc);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>function_class</code>就是<code>std::function</code>。注意这里<code>CGH.template parallel_for</code>需要说明符<code>template</code>否则尖括号会解析出错。DPC++通过这样一系列的操作，最大限度的保留了用户编程的灵活性。</p>
<h1 id="Ⅵ-DPC-和模板推导"><a href="#Ⅵ-DPC-和模板推导" class="headerlink" title="Ⅵ DPC++和模板推导"></a>Ⅵ DPC++和模板推导</h1><p>DPC++代码中大量的运用了C++17标准才引入的模板推导特性，关于这些特性我们还是从一个DPC++的小例子开始：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IntelGPUSelector d;</span><br><span class="line">  <span class="function">queue <span class="title">q</span><span class="params">(d)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(N)</span></span>;</span><br><span class="line">  std::array&lt;<span class="keyword">int</span>, N&gt; v2;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">buffer <span class="title">buf1</span><span class="params">(v1)</span></span>;</span><br><span class="line">    <span class="function">buffer <span class="title">buf2</span><span class="params">(v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">      accessor <span class="built_in">a1</span>(buf1, h, write_only);</span><br><span class="line">      accessor <span class="built_in">a2</span>(buf2, h, write_only);</span><br><span class="line">      h.<span class="built_in">parallel_for</span>(N, [=](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">        a1[i] = i;</span><br><span class="line">        a2[i] = i;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) std::cout &lt;&lt; v1[i] &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码没有使用<code>malloc_shared</code>分配内存，取而代之的是使用<code>buffer</code>和<code>accessor</code>，其中<code>buffer</code>用于封装数据，<code>accessor</code>用于访问数据。这里以<code>buffer</code>为例解析DPC++对模板推导的使用。<br>首先观察buffer的两个实例，它们的构造函数的实参分别是<code>std::vector&lt;int&gt;</code>和<code>std::array&lt;int, N&gt;</code>类型。之所以能够这样调用构造函数，并不是因为<code>buffer</code>为这两个类型重载了它的构造函数，而是因为其构造函数使用了模板。这里涉及到一个C++17标准新特性——类模板的模板实参推导。在以往，类模板的实例化必须是显式传入模板实参，否则会造成编译出错。在新的标准中，类模板的模板实参已经可以根据构造函数来推导了。来看一下<code>buffer</code>的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> dimensions = <span class="number">1</span>,</span><br><span class="line">          <span class="keyword">typename</span> AllocatorT = cl::sycl::buffer_allocator,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="keyword">typename</span> detail::<span class="keyword">enable_if_t</span>&lt;(dimensions &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                                                  (dimensions &lt;= <span class="number">3</span>)&gt;&gt;</span><br><span class="line">class buffer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">template</span> &lt;class Container, <span class="keyword">int</span> N = dimensions,</span><br><span class="line">            <span class="keyword">typename</span> = EnableIfOneDimension&lt;N&gt;,</span><br><span class="line">            <span class="keyword">typename</span> = EnableIfContiguous&lt;Container&gt;&gt;</span><br><span class="line">  <span class="built_in">buffer</span>(Container &amp;container, AllocatorT allocator,</span><br><span class="line">         <span class="keyword">const</span> property_list &amp;propList = &#123;&#125;)</span><br><span class="line">      : <span class="built_in">Range</span>(range&lt;<span class="number">1</span>&gt;(container.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    impl = std::make_shared&lt;detail::buffer_impl&gt;(</span><br><span class="line">        container.<span class="built_in">data</span>(), <span class="built_in">get_count</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(T),</span><br><span class="line">        detail::<span class="built_in">getNextPowerOfTwo</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T)), propList,</span><br><span class="line">        make_unique_ptr&lt;detail::SYCLMemObjAllocatorHolder&lt;AllocatorT&gt;&gt;(</span><br><span class="line">            allocator));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>, <span class="title">int</span> <span class="title">N</span> =</span> dimensions,</span><br><span class="line">            <span class="keyword">typename</span> = EnableIfOneDimension&lt;N&gt;,</span><br><span class="line">            <span class="keyword">typename</span> = EnableIfContiguous&lt;Container&gt;&gt;</span><br><span class="line">  <span class="built_in">buffer</span>(Container &amp;container, <span class="keyword">const</span> property_list &amp;propList = &#123;&#125;)</span><br><span class="line">      : <span class="built_in">buffer</span>(container, &#123;&#125;, propList) &#123;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码<code>buffer buf1(v1);</code>会执行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">buffer</span>(Container &amp;container, <span class="keyword">const</span> property_list &amp;propList = &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这条构造函数，值得注意的是该构造函数并没有实际的实现代码，而是通过委托构造函数的方法调用了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">buffer</span>(Container &amp;container, AllocatorT allocator, <span class="keyword">const</span> property_list &amp;propList = &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>委托构造函数是C++11引入的特性，它可以让某个构造函数将构造的执行权交给另外的构造函数。回到模板推导，这里通过构造函数会推导出<code>Container</code>是<code>std::vector&lt;int&gt;，dimensions</code>的推导结果是1，而后面两个模板参数是用来检查前两个模板参数是否正确的，这里大量的使用了模板元编程的技巧：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dims&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfOneDimension = <span class="keyword">typename</span> detail::<span class="keyword">enable_if_t</span>&lt;<span class="number">1</span> == dims&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> EnableIfContiguous =</span><br><span class="line">    detail::<span class="keyword">void_t</span>&lt;detail::<span class="keyword">enable_if_t</span>&lt;std::is_convertible&lt;</span><br><span class="line">                       detail::<span class="keyword">remove_pointer_t</span>&lt;<span class="keyword">decltype</span>(</span><br><span class="line">                           std::declval&lt;Container&gt;().<span class="built_in">data</span>())&gt; (*)[],</span><br><span class="line">                       <span class="keyword">const</span> <span class="built_in">T</span> (*)[]&gt;::value&gt;,</span><br><span class="line">                   <span class="keyword">decltype</span>(std::declval&lt;Container&gt;().<span class="built_in">size</span>())&gt;;</span><br></pre></td></tr></table></figure>
<p>首先它们都是使用using定义的别名模板，它们的目的分别是检查<code>dims</code>是否为1和<code>Container</code>是否为连续的。第一个别名模板很简单，直接检查<code>dims</code>是否为1，<code>detail::enable_if_t</code>就是<code>std::enable_if_t</code>。第二个检查连续性的方法稍微麻烦一些，简单来说就是检查容器对象的成员函数<code>data()</code>返回值的类型的数组指针是否能和<code>const T (*)[]</code>转换，这里主要检查两点，第一容器具有<code>data()</code>成员函数，第二返回类型的指针和<code>T const T (*)[]</code>转换。事实上，在标准容器中，只有连续容器有<code>data()</code>成员函数，其他的都会因为没有<code>data()</code>而报错，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no member named &#x27;data&#x27; in &#x27;std::list&lt;int&gt;&#x27;</span><br></pre></td></tr></table></figure>
<p>仔细阅读上面代码的朋友应该会发现另外一个问题，那就是没有任何地方可以帮助编译器推导出buffer的类模板形参T。这就不得不说DPC++将C++17关于模板推导的新特性用的淋漓尽致了。实际上在代码中，有这样一句用户自定义推导指引的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="built_in">buffer</span>(Container &amp;, <span class="keyword">const</span> property_list &amp; = &#123;&#125;)</span><br><span class="line">    -&gt;buffer&lt;<span class="keyword">typename</span> Container::value_type, <span class="number">1</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>用户自定义推导指引是指程序员可以指导编译器如何通过函数实参推导模板形参的类型。最后在这个例子中，需要注意一下，<code>buffer</code>在析构的时候才会将缓存的数据写到<code>v1</code>和<code>v2</code>，所以这里用了单独的作用域。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">buffer_impl</span>() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    BaseT::<span class="built_in">updateHostMemory</span>();</span><br><span class="line">  &#125; <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Ⅶ-总结"><a href="#Ⅶ-总结" class="headerlink" title="Ⅶ 总结"></a>Ⅶ 总结</h1><p>本篇文章从几个简单的DPC++的例子展开，逐步探究了DPC++对于现代C++语言特性的运用，其中比较重要的包括lambda表达式、泛型和模板推导，当然DPC++运用的新特性远不止这些。从另一方面来看，这些新特性的加入确实的帮助DPC++完成了过去无法完成的工作，这也是近几年C++的发展趋势，越来越多的代码库开始引入新的特性，并且有一些非常”神奇“的代码也孕育而生。DPC++就是其中之一，光是阅读DPC++中使用新特性的代码就已经足够让人拍案叫绝了，更何况还有代码的组织架构、底层的抽象等等。我知道，单单一篇文章并不能讨论清楚DPC++中现代C++语言的特性，所以王婆卖瓜的推荐自己写的书《<a target="_blank" rel="noopener" href="https://www.epubit.com/bookDetails?id=UB77e5a81975b11" title="现代C++语言核心特性解析">现代C++语言核心特性解析</a>》和盛格塾课程《现代C++42讲》，相信看完这本书或者经过课程训练后朋友们会对现代C++语言的特性有一个比较深入的理解。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<p>1.DPC++ Part 1: An Introduction to the New Programming Model [<a target="_blank" rel="noopener" href="https://simplecore-ger.intel.com/techdecoded/wp-content/uploads/sites/11/Webinar-Slides-DPC-Part-1-An-Introduction-to-the-New-Programming-Model-.pdf]">https://simplecore-ger.intel.com/techdecoded/wp-content/uploads/sites/11/Webinar-Slides-DPC-Part-1-An-Introduction-to-the-New-Programming-Model-.pdf]</a><br>2.Data Parallel C++: Mastering DPC++ for Programming of Heterogeneous Systems Using C++ and SYCL preview [<a target="_blank" rel="noopener" href="https://resource-cms.springernature.com/springer-cms/rest/v1/content/17382710/data/v1]">https://resource-cms.springernature.com/springer-cms/rest/v1/content/17382710/data/v1]</a><br>3.Intel® DevCloud [<a target="_blank" rel="noopener" href="https://software.intel.com/en-us/devcloud/oneapi]">https://software.intel.com/en-us/devcloud/oneapi]</a><br>4.New, Open DPC++ Extensions Complement SYCL and C++ [<a target="_blank" rel="noopener" href="https://insidehpc.com/2020/06/new-open-dpc-extensions-complement-sycl-and-c/]">https://insidehpc.com/2020/06/new-open-dpc-extensions-complement-sycl-and-c/]</a></p>
</blockquote>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/12/01/dpcpp/" data-id="ckwli3eew0000x8upgv11g3iw" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-module-ext" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/02/module-ext/">补编-模块(C++20)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/11/02/module-ext/" class="article-date"><time datetime="2021-11-02T05:24:45.000Z" itemprop="datePublished">2021-11-02</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>声明：这是一篇对《现代C++语言核心特性解析》中模块小节的补充，因为在我写模块的时间点实验环境并不理想，所以写的比较简单，也有读者提出了疑问，所以这里写一篇补充文来展示C++20中模块这个新特性。</p>
</blockquote>
<p>一直以来，在我的个人世界中，C++编译器就是最强大的编译器，它们灵活、稳定并且十分高效。但不幸的是，源代码引入方式的落后导致C++编译器在面对巨型工程的时候总是力不从心，如果读者编译过Chromium、QT、LLVM这种规模的项目应该知道我的意思。</p>
<h2 id="代码引入的问题"><a href="#代码引入的问题" class="headerlink" title="代码引入的问题"></a>代码引入的问题</h2><p>在解释C++代码引入的问题之前，我们先看一段这样一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一段最简单的“Hello world”的代码，算上空格和换行字符一共仅仅70个字符。但是编译器在编译这份代码的时候却不能只解析这70个字符，它还需要处理<code>&lt;iostream&gt;</code>这个头文件。处理头文件的方式和宏一样，预处理器会把这个头文件完整的替换到源代码中，并且重新扫描源代码再替换源代码中新增的<code>#include</code>的头文件，一直递归处理下去，直到所有的替换都完成。</p>
<p>我们可以使用GCC生成替换后的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -E -P test.cpp -o expand.cpp</span><br></pre></td></tr></table></figure>

<p>然后会发现整个expand.cpp文件有717192个字符！而我们的代码在这份代码中占据不到万分之一，但现实是这正是C++编译器需要处理的内容。事实上，大多数情况下编译器要处理的头文件内容要比原本的代码要多的多，真正我们自己编写的代码不到头文件的十分之一也是很常见的事情。一个更大的问题是，几乎所有的源代码都会包含一些头文件，比如标准库头文件，编译器不得不做巨量重复的工作。</p>
<p>像chromium这样的巨型项目会采用一些办法减少这种情况的出现，例如Jumbo/Unity builds，原理上就是讲多个源文件包含在一个文件中，这样多次的递归替换就能够合并为一次，事实证明这种方式非常有效，chromium的编译时间缩减了50%。但是这种方式对于代码组织非常苛刻，稍有不慎就会造成编译错误。</p>
<p>原始的头文件替换出了造成了编译低效之外，还有一些问题是一个现代语言需要解决的，例如：难以做到组件化、无法做代码隔离、难以支持现代语义感知开发工具等。C++急需一种高效的新方式代替原始的代码替换。</p>
<h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p>事实上，C++委员会早就发现了这些问题，并且在2007年就逐步开展了研究工作，只不过进度非常缓慢，直到2018年C++委员会才确定了最终草案（微软提供的方案），并在C++20标准中引入了模块。</p>
<p>我们通常可以认为，一个程序是由一组翻译单元（Translated units）组合而成的。这些翻译单元在没有额外信息的情况下是互相独立的，要将他们联系到一起需要这些翻译单元声明外部名称，编译器和链接器就是通过这些外部名称把独立的翻译单元组合起来的，而模块就可以认为是一个或者一组独立的翻译单元以及一组外部名称的组合体。那么模块名（Module name）就是引用组合体符号，模块单元（Module unit）其实就是组合体的翻译单元，模块接口单元（Module interface unit）很显然就是组合体里的那一组外部名称。</p>
<p>正规来说，一个模块由模块单元组成，模块单元分为模块接口单元和模块实现单元（Module implementation unit）。另外一个模块可以有多个模块分区，模块分区也是模块单元，模块分区的目的是方便模块代码的组织。对于每个模块，必须有一个没有分区的模块接口单元，该模块单元称为主模块接口单元。 导入一个模块，实际上导入的就是主模块的接口。</p>
<h2 id="模块的语法"><a href="#模块的语法" class="headerlink" title="模块的语法"></a>模块的语法</h2><p>模块的语法应该算是非常简单的了，关键字包括<code>export</code>、<code>import</code>和<code>module</code>，其中<code>module</code>可以用来定义模块名、模块分区和模块片段，先来看看定义模块名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MyModule;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个名为<code>MyModule</code>的模块单元，但是请注意这个模块不能作为主模块接口单元，因为定义主模块接口单元必须加上<code>export</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br></pre></td></tr></table></figure>

<p>注意，我们以后可能会在一些库中看到如下命名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> std.core;</span><br></pre></td></tr></table></figure>

<p>这里的<code>std.core</code>是一个模块名，看上去表达的是标准库中的核心模块，<code>.</code>在其中表示层次关系，但是其注意，这里的<code>.</code>并没有任何的语法规定，它在这纯粹是为了一种层次。</p>
<p>在定义了模块名之后，就可以导出指定名称了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">bar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> baz &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用<code>export</code>说明符导出了变量、函数、类以及命名空间，这些名称都是可以导出的。其他源文件可以使用<code>import</code>说明符导入这些名称：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">import</span> MyModule;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = x + <span class="built_in">foo</span>() + <span class="built_in">bar</span>().<span class="built_in">run</span>() + baz::<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行上面的代码，y的最终结果为10。当然，每个名称都依次使用<code>export</code>导出并不方便，标准还提供了更加简洁的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">bar</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> baz &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，没有<code>export</code>的名称是不能被<code>import</code>到其他源代码中的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> z = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">import</span> MyModule;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = x + <span class="built_in">foo</span>() + <span class="built_in">bar</span>().<span class="built_in">run</span>() + baz::<span class="built_in">foo</span>() + z; <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里test.cpp会编译报错，编译器会提示找不到标识符<code>z</code>。</p>
<p><code>import</code>说明符不仅能引入模块，也能引入头文件，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">bar</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> baz &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; std::cout &lt;&lt; n; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">import</span> MyModule;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = x + <span class="built_in">foo</span>() + <span class="built_in">bar</span>().<span class="built_in">run</span>() + baz::<span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">print</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这里使用了<code>import</code>来引入<code>&lt;iostream&gt;</code>而不是使用<code>#include</code>。在模块单元中不要使用<code>#include</code>来引入头文件因为这样会导致这些内容成为模块单元的一部分。</p>
<p>另外还有一个地方需要特别注意，<code>import</code>进来的头文件是不会被源文件中的宏修改的，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OUTPUT_HELLO</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;world&quot;</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT_HELLO</span></span><br><span class="line"><span class="keyword">import</span> MyModule;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码在<code>test.cpp</code>中定义了宏<code>OUTPUT_HELLO</code>，然后<code>import</code>了<code>MyModule</code>模块，如果<code>OUTPUT_HELLO</code>能够影响引入的模块，那么运行结果输出<code>hello</code>，否则输出<code>world</code>。编译运行这段代码会发现最终结果为<code>world</code>，<code>import</code>的内容不受宏的影响。但是，如果确实有这样的需求该怎么做呢？标准提供了一种叫做模块片段机制，模块片段通常用来做一些配置相关的工作，它通过<code>module;</code>开始，注意这里的<code>module</code>后直接跟着分号而没有模块名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>;</span><br><span class="line"><span class="comment">// module fragment begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOME_CONFIG 20211102</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;some_header&gt;</span></span></span><br><span class="line"><span class="comment">// module fragment end</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块片段还可以分为全局和私有，上面的代码编写的是全局的模块片段，要设置私有代码片段需要叫上<code>private</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> : <span class="keyword">private</span>;</span><br></pre></td></tr></table></figure>

<p>标准规定，私有模块片段只能出现在主模块接口单元中，并且具有私有模块片段的模块单元应是其模块的唯一模块单元。</p>
<p>最后，让我们来看一看什么是模块分区。如果要导出的模块内容很多，我们不能将所有的代码放到一个文件中，需要将其按照逻辑做合理的物理分割，这个时候就需要用到模块分区了，请看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// part1.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule:part1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_impl</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">foo_impl</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part2.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule:part2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> :part1;</span><br><span class="line"><span class="keyword">import</span> :part2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">import</span> MyModule;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>part1.ixx</code>和<code>part1.ixx</code>的模块名分别为<code>MyModule:part1</code>和<code>MyModule:part2</code>，其中<code>MyModule</code>当然就是模块名，而紧跟在<code>:</code>后的名称则是它们的分区名。主模块接口单元可以通过<code>import</code>将模块分区合并到主模块接口单元中，并且无论模块分区是否导出了它的内容，它的内容都是对主模块接口单元可见的，所以<code>print</code>函数可以调用<code>bar</code>函数。</p>
<p>另外，主模块接口单元还可以决定直接导出分区定义的接口，比如代码中的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> :part1;</span><br></pre></td></tr></table></figure>

<p>这样模块分区<code>part1</code>的函数<code>foo</code>也成为了导出接口。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/11/02/module-ext/" data-id="ckvhshunv0000tgupd9libp7u" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-moderncpp42" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/07/moderncpp42/">《现代C++语言核心特性解析》上架感言</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/10/07/moderncpp42/" class="article-date"><time datetime="2021-10-07T01:44:05.000Z" itemprop="datePublished">2021-10-07</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>还记得2015年的时候，在下班回家的地铁上跟好朋友聊起C++11标准引入的一系列新特性，当时我已经学习过一阵这些有趣的新功能了，所以聊天的时候也是信手拈来，也就是这个时候朋友跟我提了一句，要不你去写一本书吧。虽然当时并没有把这句话放在心上，但是也算是在心中埋藏了一颗种子。</p>
<p>时间一晃就到了2017年，随着C++17标准的发布，C++又引入了一大批新特性，很多特性结合在一起甚至能写出“不太像C++代码”的错觉。另外，当时的国外已经诞生一批用新标准规范写的开源代码，这让我感觉到我们是不是有些落后了。于是乎，诞生了一个写一本有关C++新标准书籍的想法。其实，作为一个读书人，写一本书的想法一直都有，但是就是没有好的主题，当然动力有所不足。这次似乎是一个挺好的机会，那就动笔吧。就这样从2017年到2019年，每天都会在工作之余抽出一点点时间写写文字。因为第一次写书，所以刚开始写的时候文笔非常生硬，后面慢慢的熟练起来，不过目录的顺序并不是当时写书的顺序，所以读的时候会发现有的章节写的尚可，有的读起来生硬无比。虽然后来经过了一番修改，但是书中的问题肯定还是不少（发售之后也能找到不少拼写和错别字错误）。就这样，一直写到了C++20标准的草案接近完成，当时我就在想，总不能辛辛苦苦写的书，还没到发售就已经过时了吧？这可不行，于是改变计划，加入了C++20的内容。这一加，就写到了2020年的8月。</p>
<p>2020年8月，书的最后一个章节编写完毕。面对整篇书稿的完工，一方面是高兴兴奋，另一方面却也非常惶恐，因为要面临找出版社的考验了。虽然我对书的内容比较有信心，但是现在C++实在不是一门流行的技术了，至少招人方面已经很难招到合适的了。一个印象很深刻的事情是，我们家在饭桌讨论找出版社的事情，我的父母都表示肯定很难，让我如果找不到也不要伤心。我的爱人鼓励我说，“即使找不到出版社，这本书咱们自己花钱也要出出来”，这也是我当时的想法，不能让心血白费了，至少得有个结果。事实情况其实比我们想象的好很多，我在9月就找了国内一家计算机方面知名的出版社分社，开始讨论了一番以后发现对方对这本书的内容并没有太大兴趣，于是和这个出版社的联系就断了。10月份的时候找到另外一家知名出版社，也就是本书现在的出版社人民邮电出版社。当时出版社的陈编辑非常热情的给我介绍了如何申报图书出版的步骤，我也按照要求把资料提供了上去，大概过了一两周的样子，编辑告诉我出版社决定出版这本书，当时可把我高兴坏了。</p>
<p>从2020年10月到2021年9月，出版这本书整整花了一年的时候，从一审到三审，从一校到三校，还有申请ISBN编号，每一步我都想催着陈编辑快点做完，虽然每次催都特别不好意思，但是控制不住自己啊。幸好陈编辑每次都挺耐心的，真的很nice的人。在这一年期间，我遇到另外一个贵人是《软件调试》的作者张银奎老师，我和张老师认识的挺早的，大概就是《软件调试》刚刚出版后搞的一次书友会上认识的，有过一些交流，那个时候就记住了他的邮箱地址。这个邮箱地址可就发挥的重要作用了，当这本书需要一篇序的时候，我是第一时间想到了张银奎老师，想到了这个邮箱，于是就厚着脸皮发了一份邮件，请求张老师为本书作序，没想到的是张老师爽快的答应了，并且还邀请我做了一个课程。</p>
<p>就是这样，《现代C++语言核心特性解析》这本书在2021年的中秋节前上架了，一时感触非常多，想感谢很多人很多事，但是不知从哪里开始怎么开始，想来想去还是写一篇文章简单记录一下这段宝贵的过程好了，于是就有了这篇文章，大概就是这样了。</p>
<p><img src="/uploads/2021/10/85a4c8598523e22e24ec83ca7c0d83a.jpg" alt="moderncpp"></p>
<p><a target="_blank" rel="noopener" href="https://www.epubit.com/bookDetails?id=UB77e5a81975b11">《现代C++语言核心特性解析》的出版社链接</a></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/10/07/moderncpp42/" data-id="ckum20zbx0000mgup48dnfhow" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-optimization-details-in-qmutex" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/12/optimization-details-in-qmutex/">QMutex中的优化小细节</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/09/12/optimization-details-in-qmutex/" class="article-date"><time datetime="2021-09-12T11:46:53.000Z" itemprop="datePublished">2021-09-12</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在这篇文章中，我们要讨论的并不是<code>QMutex</code>的原理或者是应该如何使用，而是<code>QMutex</code>中一个很少被提到的优化细节。</p>
<p>我们知道在QT中，<code>QMutex</code>通常会和<code>QMutexLocker</code>一起使用，主要的用途是保护一个对象、数据结构或代码段，以便一次只让一个线程可以访问它们。 这一点对于多线程程序来说非常重要，而如今的程序已经离不开多线程，所以<code>QMutex</code>的使用场景也是越来越多，为了提高<code>QMutex</code>的使用效率，QT在<code>QMutex</code>的实现上加入了一个优化细节，这是<code>std::mutex</code>没有的，让我们来看看这个优化具体是什么。</p>
<p><code>QMutex</code>的基类<code>QBasicMutex</code>有一个类型为<code>QBasicAtomicPointer&lt;QMutexData&gt;</code>成员，这里可以先忽略<code>QBasicAtomicPointer</code>，它只是保证对指针的原子操作，正在发挥作用的是<code>QMutexData*</code>。<code>QMutexData</code>类型也没有什么特殊之处，真正的优化是在它的派生类<code>QMutexPrivate</code>，来看一段<code>QMutexPrivate</code>的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QMutexPrivate</span> :</span> <span class="keyword">public</span> QMutexData</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!refCount.<span class="built_in">deref</span>())</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QMutexPrivate::release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freelist</span>()-&gt;<span class="built_in">release</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当引用计数为0的时候调用的<code>release</code>函数并没有真正释放互斥体对象，而是调用了一个<code>freelist</code>的<code>release</code>函数。追踪<code>freelist()</code>会发现这样一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FreeListConstants</span> :</span> QFreeListDefaultConstants &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> BlockCount = <span class="number">4</span>, MaxIndex=<span class="number">0xffff</span> &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Sizes[BlockCount];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FreeListConstants::Sizes[FreeListConstants::BlockCount] = &#123;</span><br><span class="line">    <span class="number">16</span>,</span><br><span class="line">    <span class="number">128</span>,</span><br><span class="line">    <span class="number">1024</span>,</span><br><span class="line">    FreeListConstants::MaxIndex - (<span class="number">16</span> + <span class="number">128</span> + <span class="number">1024</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> QFreeList&lt;QMutexPrivate, FreeListConstants&gt; FreeList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> FreeList freeList_;</span><br><span class="line"><span class="function">FreeList *<span class="title">freelist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;freeList_;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这下就豁然开朗了，<code>QFreeList</code>可以被认为是缓存池，用于维护<code>QMutexPrivate</code>的内存，当<code>QMutexPrivate</code>调用<code>release</code>函数的时候，QT并不会真的释放对象，而是将其加入到缓存池中，以便后续代码申请使用。这样不但可以减少内存反复分配带来的开销，也可以减少反复分配内核对象代码的开销，对于程序的性能是有所帮助的。</p>
<p>具体<code>QFreeList</code>的实现并不复杂，大家可以参考QT中的源代码<code>qtbase\src\corelib\tools\qfreelist_p.h</code>，另外除了<code>QMutex</code>以外，<code>QRecursiveMutex</code>和<code>QReadWriteLock</code>也用到了相同的技术。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/09/12/optimization-details-in-qmutex/" data-id="cktihnvqn00aynoupa1w30hj6" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-pointer-to-implementation" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/05/pointer-to-implementation/">指向实现的指针Pointer to implementation</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/08/05/pointer-to-implementation/" class="article-date"><time datetime="2021-08-05T13:25:52.000Z" itemprop="datePublished">2021-08-05</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>写这篇文章缘于我的一个朋友的故事：</p>
<blockquote>
<p>插件业务部门线上发布插件，发布之后经过用户反馈得知用户那更新插件后出现程序崩溃。检查原因是某个基础模块用导出类的方式导出接口，但是基础部门最近改动了基础模块某个类的内存布局，即头文件中类的定义发生了变化。</p>
</blockquote>
<p>导出类作为接口是一个比较考验编程经验的事情，随意的导出类很容易导致二进制兼容性问题。对于有经验的程序员一般会想到2中可行方案：</p>
<ol>
<li>定义纯虚类，实现派生类并且将所有的细节全部隐藏在派生类中，然后通过工厂类输出基类指针。典型的应用场景如Windows导出的COM接口。</li>
<li>使用指向实现的指针（pimpl），即这篇文章的主题。典型的应用场景如Qt。</li>
</ol>
<p>当然，使用pimpl优点并不限于上面提到的这一种，总体说来包括：</p>
<ol>
<li>解决二进制兼容性问题；</li>
<li>减少头文件依赖，给项目编译提速；</li>
<li>提供的接口文件中可以隐藏实现细节；</li>
<li>对于移动语义非常友好。</li>
</ol>
<p>pimpl也是有缺点的，比如：</p>
<ol>
<li>需要从额外从堆中分配内存；</li>
<li><code>const</code>声明会被忽略；</li>
</ol>
<p>当然这些问题都是通过一些列方法改善的。但是说到底，实现pimpl有一些细节需要特殊小心。好了，现在让我们从头开始介绍pimpl。</p>
<h2 id="需要隐藏的实现细节"><a href="#需要隐藏的实现细节" class="headerlink" title="需要隐藏的实现细节"></a>需要隐藏的实现细节</h2><p> 从C语言开始头文件（.h）就一直作为接口文件提供给用户，那个时候的头文件可以很轻松的隐藏实现细节，因为它们只需要对外暴露函数即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span> <span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是到了C++，头文件就很难隐藏实现细节了，因为需要将数据成员定义在类中，导致细节暴露：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// someclass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;someclass.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_someData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码暴露了类的数据成员。另外一个问题是，如果<code>SomeClass</code>引用了其他对象，那么可能需要<code>include</code>更多头文件，这样做的代价是降低了编译效率：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;A&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;B&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;C&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">    AClass m_aClass;</span><br><span class="line">    BClass m_bClass;</span><br><span class="line">    CClass m_cClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为C++的预处理器是直接用替换的方式将头文件<code>A</code>、<code>B</code>和<code>C</code>加到<code>someclass.h</code>中的。另外，无论这些头文件中哪个发生变动，都会导致任何引用<code>someclass.h</code>的源文件重新编译，非常的低效。当然，有一种解决方案是前置声明类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">    AClass *m_aClass;</span><br><span class="line">    BClass *m_bClass;</span><br><span class="line">    CClass *m_cClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样确实可以解决以上编译相关的问题，但是引入的新问题是它需要多次访问堆来分配内存，对于代码的运行效率是不利的。此外，它也没法解决暴露细节的问题。所以我们需要pimpl来帮助我们解决上述这些问题。</p>
<h2 id="pimpl的简单实现"><a href="#pimpl的简单实现" class="headerlink" title="pimpl的简单实现"></a>pimpl的简单实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClassPrivate</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SomeClass</span>();</span><br><span class="line">    ~<span class="built_in">SomeClass</span>();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SomeClassPrivate *m_pimpl = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// someclass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;someclass.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;A&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;B&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;C&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClassPrivate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_someData; &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">    AClass m_aClass;</span><br><span class="line">    BClass m_bClass;</span><br><span class="line">    CClass m_cClass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeClass::<span class="built_in">SomeClass</span>() : <span class="built_in">m_pimpl</span>(<span class="keyword">new</span> SomeClassPrivate) &#123;&#125;</span><br><span class="line"></span><br><span class="line">SomeClass::~<span class="built_in">SomeClass</span>() &#123; <span class="keyword">delete</span> m_pimpl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pimpl-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将之前头文件中的所有细节隐藏到<code>SomeClassPrivate</code>之中，用户对于<code>SomeClassPrivate</code>可以是一无所知的，无论怎么修改<code>SomeClassPrivate</code>的内存布局，都不会影响用户对<code>SomeClass</code>的使用，也不会存在兼容性问题。另外由于没有引入额外头文件，不会发生宏展开，对<code>A</code>、<code>B</code>和<code>C</code>头文件的修改只会让<code>someclass.cpp</code>重新编译，并不会影响其他引用<code>someclass.h</code>的源文件。又因为<code>m_aClass</code>、<code>m_bClass</code>和<code>m_cClass</code>会一次性随着<code>SomeClassPrivate</code>从堆中分配，这样就减少了两次堆访问，提高的运行效率。最后，这样的结构对移动语义非常友好：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">SomeClass</span>(SomeClass&amp;&amp; other);</span><br><span class="line">    SomeClass&amp; SomeClass::<span class="keyword">operator</span>=(SomeClass&amp;&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SomeClassPrivate *m_pimpl = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// someclass.cpp</span></span><br><span class="line">SomeClass::<span class="built_in">SomeClass</span>(SomeClass&amp;&amp; other) : <span class="built_in">m_pimpl</span>(other.m_pimpl) &#123; </span><br><span class="line">    other.m_pimpl = <span class="literal">nullptr</span>; </span><br><span class="line">&#125;</span><br><span class="line">SomeClass&amp; SomeClass::<span class="keyword">operator</span>=(SomeClass&amp;&amp; other) &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(m_pimpl, other.m_pimpl);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决pimpl存在的问题"><a href="#解决pimpl存在的问题" class="headerlink" title="解决pimpl存在的问题"></a>解决pimpl存在的问题</h2><p>上文我们提到过pimpl存在的2个问题，现在让我们看看它们是什么，并且如何解决这2个问题。</p>
<h3 id="额外从堆中分配内存"><a href="#额外从堆中分配内存" class="headerlink" title="额外从堆中分配内存"></a>额外从堆中分配内存</h3><p>这个问题其实容易解决，为了提高效率我们可以采用内存池来管理内存分配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SomeClass::<span class="built_in">SomeClass</span>() : <span class="built_in">m_pimpl</span>(</span><br><span class="line">    <span class="built_in"><span class="keyword">new</span></span>(somePool::<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SomeClassPrivate))) SomeClassPrivate) &#123;&#125;</span><br><span class="line">SomeClass::~<span class="built_in">SomeClass</span>() &#123;</span><br><span class="line">    m_pimpl-&gt;~<span class="built_in">SomeClassPrivate</span>();</span><br><span class="line">    somePool::<span class="built_in">free</span>(m_pimpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const声明被忽略"><a href="#const声明被忽略" class="headerlink" title="const声明被忽略"></a><code>const</code>声明被忽略</h3><p>这是一个比较有趣的问题，让我们看看以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pimpl-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这里<code>foo()</code>函数被声明为<code>const</code>，说明函数中<code>this</code>的类型是<code>const SomeClass*</code>，但是这只能表示<code>m_pimpl</code>是一个<code>SomeClass * const</code>，也就是说<code>m_pimpl</code>是一个指针常量，而不是一个指向常量的指针。这导致<code>const</code>对<code>m_pimpl-&gt;foo()</code>没有任何约束能力。</p>
<p>为了解决这个问题，我们可以想到两种方法。</p>
<p>首先可以仿造Qt的代码实现两个代理函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> SomeClassPrivate * <span class="title">SomeClass::d_func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_pimpl; &#125;</span><br><span class="line"><span class="function">SomeClassPrivate * <span class="title">SomeClass::d_func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_pimpl; &#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式获取对象指针能传递将函数的<code>const</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClassPrivate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_someData; &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">d_func</span>()-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Qt中有一个宏来实现这个方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_PRIVATE(Class) \</span></span><br><span class="line"><span class="meta">    inline Class##Private* d_func() \</span></span><br><span class="line"><span class="meta">    &#123; Q_CAST_IGNORE_ALIGN(return reinterpret_cast<span class="meta-string">&lt;Class##Private *&gt;</span>(qGetPtrHelper(d_ptr));) &#125; \</span></span><br><span class="line"><span class="meta">    inline const Class##Private* d_func() const \</span></span><br><span class="line"><span class="meta">    &#123; Q_CAST_IGNORE_ALIGN(return reinterpret_cast<span class="meta-string">&lt;const Class##Private *&gt;</span>(qGetPtrHelper(d_ptr));) &#125; \</span></span><br><span class="line"><span class="meta">    friend class Class##Private;</span></span><br></pre></td></tr></table></figure>

<p>另外一个方法是使用<code>std::experimental::propagate_const</code>，不过该方法还在C ++库基础技术规范第二版（ C++ <em>Library Fundamentals</em> Technical Specification V2）中，还没有正式加入STL。不过原理非常简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">propagate_const</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">propagate_const</span><span class="params">( T * t )</span> : p( t ) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">const</span> T &amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *p; &#125;</span><br><span class="line">    T &amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *p; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> T * <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">    T * <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    propagate_const&lt;SomeClassPrivate&gt; m_pimpl</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方式比<code>d_func</code>要繁琐一些，但有一个好处是程序员无法直接使用原生的<code>SomeClassPrivate*</code>，而<code>d_func</code>却没法控制，必须依靠代码规范约束每个程序员。</p>
<h2 id="一个使用pimpl值得注意的问题"><a href="#一个使用pimpl值得注意的问题" class="headerlink" title="一个使用pimpl值得注意的问题"></a>一个使用pimpl值得注意的问题</h2><p>当使用pimpl的时候如果有<code>SomeClassPrivate</code>中调用<code>SomeClass</code>成员函数的需求，需要将<code>SomeClass</code>的<code>this</code>指针传入<code>SomeClassPrivate</code>。这很简单啊！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;someclass.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClassPrivate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SomeClassPrivate</span>(SomeClass* p) : <span class="built_in">m_pub</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_someData; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123; m_pub-&gt;<span class="built_in">bar</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">    SomeClass* m_pub = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeClass::<span class="built_in">SomeClass</span>() : <span class="built_in">m_pimpl</span>(<span class="keyword">new</span> <span class="built_in">SomeClassPrivate</span>(<span class="keyword">this</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">SomeClass::~<span class="built_in">SomeClass</span>() &#123; <span class="keyword">delete</span> m_pimpl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pimpl-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错！请记住，当<code>SomeClass</code>正在构造的时候，传递<code>this</code>指针是非常不安全的，可能造成未定义的行为。正确的做法是在初始化列表完成以后再给<code>m_pub</code>赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someclass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;someclass.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClassPrivate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SomeClassPrivate</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_someData; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123; m_pub-&gt;<span class="built_in">bar</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(SomeClass* p)</span> </span>&#123; m_pub = p; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_someData = <span class="number">0</span>;</span><br><span class="line">    SomeClass* m_pub = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeClass::<span class="built_in">SomeClass</span>() : <span class="built_in">m_pimpl</span>(<span class="keyword">new</span> SomeClassPrivate) &#123;</span><br><span class="line">    m_pimpl-&gt;<span class="built_in">init</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SomeClass::~<span class="built_in">SomeClass</span>() &#123; <span class="keyword">delete</span> m_pimpl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pimpl-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeClass::bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和<code>m_pimpl</code>一样，<code>m_pub</code>也应该用<code>propagate_const</code>来包装。当然也可以实现类似<code>d_func</code>的函数。比如Qt就是通过定义一组<code>q_func</code>来实现的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_PUBLIC(Class)                                    \</span></span><br><span class="line"><span class="meta">    inline Class* q_func() &#123; return static_cast<span class="meta-string">&lt;Class *&gt;</span>(q_ptr); &#125; \</span></span><br><span class="line"><span class="meta">    inline const Class* q_func() const &#123; return static_cast<span class="meta-string">&lt;const Class *&gt;</span>(q_ptr); &#125; \</span></span><br><span class="line"><span class="meta">    friend class Class;</span></span><br></pre></td></tr></table></figure>

<p>好了，关于pimpl的内容我要写的就这么多了，如果pimpl还有其他有趣的技巧欢迎发邮件与我交流。最后说一句：“基础部门赶紧把二进制兼容问题解决掉呀！”</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/08/05/pointer-to-implementation/" data-id="cktihnvqm00awnoupaoqu9ed6" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-qt-implicit-sharing-copy-on-write" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/11/qt-implicit-sharing-copy-on-write/">Qt的隐式共享和写时拷贝</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/11/qt-implicit-sharing-copy-on-write/" class="article-date"><time datetime="2021-07-11T10:18:12.000Z" itemprop="datePublished">2021-07-11</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>不得不说Qt为了提高代码的运行效率做了很多伟大的工作，引入隐式共享和写时拷贝技术就是其中之一。该技术十分值得我们学习，一方面是因为它也可以运用到我们的代码中提高代码的运行效率，另一方面我们在理解其原理之后才能够更加高效的使用Qt。</p>
<p>Qt中的隐式共享是指类中存在一个共享数据块指针，改数据块由数据和引用技术组成。</p>
<ul>
<li>当类型对象被创建时，共享数据块也被创建，并且设置引用技术为1。</li>
<li>当类型对象发生拷贝时，共享数据块共享其指针，并且递增引用计数（+1）。</li>
<li>当类型对象销毁时，共享数据块引用技术递减（-1），当引用计数归零时销毁数据块。</li>
<li>当类型对象调用方法有可能被修改时，采用写时拷贝机制，创建真正对象副本。</li>
</ul>
<p>使用隐式共享和写时拷贝的好处非常明显，在只读的情况下，拷贝对象的内存和CPU计算成本非常低。只有在真正修改对象的时候，才会发生对象拷贝。除了Qt中的普通类型以外，Qt的容器类型也大量采用了这种技术，这也是Qt容器和STL容器的一个显著的区别。</p>
<p>来看一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class QPenPrivate *d</span></span><br><span class="line"></span><br><span class="line">QPen::<span class="built_in">QPen</span>(<span class="keyword">const</span> QPen &amp;p) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    d = p.d;</span><br><span class="line">    <span class="keyword">if</span> (d)</span><br><span class="line">        d-&gt;ref.<span class="built_in">ref</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QPen::~<span class="built_in">QPen</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &amp;&amp; !d-&gt;ref.<span class="built_in">deref</span>())</span><br><span class="line">        <span class="keyword">delete</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QPen::detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ref.<span class="built_in">loadRelaxed</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    QPenData *x = <span class="keyword">new</span> <span class="built_in">QPenData</span>(*<span class="keyword">static_cast</span>&lt;QPenData *&gt;(d));</span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;ref.<span class="built_in">deref</span>())</span><br><span class="line">        <span class="keyword">delete</span> d;</span><br><span class="line">    x-&gt;ref.<span class="built_in">storeRelaxed</span>(<span class="number">1</span>);</span><br><span class="line">    d = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QPen::setStyle</span><span class="params">(Qt::PenStyle s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;style == s)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">detach</span>();</span><br><span class="line">    d-&gt;style = s;</span><br><span class="line">    QPenData *dd = <span class="keyword">static_cast</span>&lt;QPenData *&gt;(d);</span><br><span class="line">    dd-&gt;dashPattern.<span class="built_in">clear</span>();</span><br><span class="line">    dd-&gt;dashOffset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>Pen</code>的拷贝构造函数只是将共享数据块指针从<code>p</code>赋值到当前对象，然后增加其引用计数。当对象析构时，首先减少引用计数，然后判断引用计数是否归零，如果条件成立则释放对象。当调用<code>setStyle</code>函数修改对象的时候，函数调用了一个<code>detach</code>函数，这个<code>detach</code>函数检查当前的引用计数，若引用计数为1，证明没有共享数据块，可以直接修改数据。反之引用计数不为1，则证明存在共享改数据块的类，无法直接修改数据，需要拷贝一份新的数据。</p>
<p>现在看来，Qt似乎已经为我们考虑的十分周到了，不调用修改对象的函数是不会发生真正的拷贝的。那么需要我们做什么呢？答案是，Qt的使用者应该尽可能的避免误操作导致的数据拷贝。前面提到过，Qt认为可能发生写对象的操作都会真实的拷贝对象，其中要给典型的情况是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line"><span class="keyword">int</span>* p = test2.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<p>这里看起来并没有发生对象的写操作，但是数据拷贝还是发生了，因为Qt认为这是一个可能发生写数据的操作，所以在调用<code>data()</code>的时候就调用了<code>detach()</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> T *<span class="title">data</span><span class="params">()</span> </span>&#123; <span class="built_in">detach</span>(); <span class="keyword">return</span> d-&gt;<span class="built_in">begin</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>如果确定不会修改对象的数据应该明确告知编译器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test3 = test1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = test2.<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* q = test3.<span class="built_in">constData</span>();</span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T *<span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d-&gt;<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T *<span class="title">constData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d-&gt;<span class="built_in">begin</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>它们都不会调用<code>detach</code>函数拷贝对象。还是C++编程老生常谈那句话：在确定不修改对象的时候总是使用<code>const</code>来声明它，以便编译器对其做优化处理。</p>
<p>有时候我们并不是完全弄清楚编程环境中具体发生了什么，比如你可能不知道Qt的隐式共享和写时拷贝，但是保持良好的编程习惯，比如对于不修改的对象声明为<code>const</code>，有时候可以在不经意间优化了编写的代码，何乐而不为呢。</p>
<p>值得注意的是，我们应该尽量避免直接引用并通过引用修改Qt容器中的对象。千万不要这么做，因为可能会得到你不想看到的结果，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line"><span class="keyword">int</span>&amp; v = test1[<span class="number">1</span>];</span><br><span class="line">v = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>这份代码不会出现问题，因为当表达式<code>test2 = test1</code>运行时，共享数据的引用计数递增为2，当调用<code>operator []</code>的时候由于<code>test1</code>不是<code>const</code>，所以会为<code>test1</code>拷贝一份副本。最后结果是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">test1[<span class="number">1</span>] == <span class="number">20</span>;</span><br><span class="line">test2[<span class="number">1</span>] == <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这样看来没有问题，但不幸的是我们有时候也会这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>&amp; v = test1[<span class="number">1</span>];</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line">v = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>上面这份代码会带来一个意想不到的结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">test1[<span class="number">1</span>] == <span class="number">20</span>;</span><br><span class="line">test2[<span class="number">1</span>] == <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>因为在运行<code>int&amp; v = test1[1];</code>这句代码的时候，数据块的引用计数为1，<code>detach</code>函数认为数据块没有共享，所以无需拷贝数据。当执行<code>test2 = test1</code>的时候，Qt并不知道之前发生了什么，所以仅仅增加了引用计数，所以修改<code>v</code>同时修改了<code>test1</code>和<code>test2</code>。这不是我们想看到的结果，所以我们应该怎么做？注意代码执行的顺序么？得了吧，即使能保证自己会注意到代码的执行顺序问题，也不能保证其他人修改你的代码时会怎么做，最好的做法是告诉大家，我们的项目有一条规则——禁止直接引用并通过引用修改Qt容器中的对象！或者干脆，使用STL的容器吧。</p>
<p>最后，如果觉得Qt的隐式共享和写时拷贝技术很不错，碰巧你的项目的编写环境中也有Qt，那么使用<code>QSharedData</code>和<code>QSharedDataPointer</code>会让你的工作轻松很多。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/07/11/qt-implicit-sharing-copy-on-write/" data-id="cktihnvql00aunoup5q9ogjz7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-use-Q_DECLARE_TYPEINFO-to-optimize-the-container" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/15/use-Q_DECLARE_TYPEINFO-to-optimize-the-container/">使用Q_DECLARE_TYPEINFO让Qt优化容器算法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/06/15/use-Q_DECLARE_TYPEINFO-to-optimize-the-container/" class="article-date"><time datetime="2021-06-15T03:39:02.000Z" itemprop="datePublished">2021-06-15</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>如果需要使用Qt容器，那么使用<code>Q_DECLARE_TYPEINFO</code>让Qt了解容器内元素的类型特征是一个不错的做法。因为Qt可以通过识别<code>Q_DECLARE_TYPEINFO</code>给定的类型特征，在容器中采用不同的算法和内存模型以达到计算速度和内存使用上的优化。</p>
<p><code>Q_DECLARE_TYPEINFO(Type, Flags)</code>的使用非常简单，在定义了数据结构之后，通过指定类型名和枚举标识来指定这个类型特征，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(Point2D, Q_PRIMITIVE_TYPE);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Q_PRIMITIVE_TYPE</code>指定Type是没有构造函数或析构函数的POD(plain old data) 类型，并且<code>memcpy()</code>可以这种类型创建有效的独立副本的对象。</li>
<li><code>Q_MOVABLE_TYPE</code>指定Type具有构造函数或析构函数，但可以使用<code>memcpy()</code>在内存中移动。注意：尽管有叫做move，但是这个和移动构造函数或移动语义无关。</li>
<li><code>Q_COMPLEX_TYPE</code>（默认值）指定Type具有构造函数和析构函数，并且可能不会在内存中移动。</li>
</ul>
<p>再来看看<code>Q_DECLARE_TYPEINFO</code>的具体实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QTypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        isSpecialized = std::is_enum&lt;T&gt;::value, <span class="comment">// don&#x27;t require every enum to be marked manually</span></span><br><span class="line">        isPointer = <span class="literal">false</span>,</span><br><span class="line">        isIntegral = std::is_integral&lt;T&gt;::value,</span><br><span class="line">        isComplex = !qIsTrivial&lt;T&gt;(),</span><br><span class="line">        isStatic = <span class="literal">true</span>,</span><br><span class="line">        isRelocatable = qIsRelocatable&lt;T&gt;(),</span><br><span class="line">        isLarge = (<span class="built_in"><span class="keyword">sizeof</span></span>(T)&gt;<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*)),</span><br><span class="line">        isDummy = <span class="literal">false</span>, </span><br><span class="line">        sizeOf = <span class="built_in"><span class="keyword">sizeof</span></span>(T)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_TYPEINFO_BODY(TYPE, FLAGS) \</span></span><br><span class="line"><span class="meta">class QTypeInfo<span class="meta-string">&lt;TYPE &gt;</span> \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    enum &#123; \</span></span><br><span class="line"><span class="meta">        isSpecialized = true, \</span></span><br><span class="line"><span class="meta">        isComplex = (((FLAGS) &amp; Q_PRIMITIVE_TYPE) == 0) &amp;&amp; !qIsTrivial<span class="meta-string">&lt;TYPE&gt;</span>(), \</span></span><br><span class="line"><span class="meta">        isStatic = (((FLAGS) &amp; (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), \</span></span><br><span class="line"><span class="meta">        isRelocatable = !isStatic || ((FLAGS) &amp; Q_RELOCATABLE_TYPE) || qIsRelocatable<span class="meta-string">&lt;TYPE&gt;</span>(), \</span></span><br><span class="line"><span class="meta">        isLarge = (sizeof(TYPE)&gt;sizeof(void*)), \</span></span><br><span class="line"><span class="meta">        isPointer = false, \</span></span><br><span class="line"><span class="meta">        isIntegral = std::is_integral<span class="meta-string">&lt; TYPE &gt;</span>::value, \</span></span><br><span class="line"><span class="meta">        isDummy = (((FLAGS) &amp; Q_DUMMY_TYPE) != 0), \</span></span><br><span class="line"><span class="meta">        sizeOf = sizeof(TYPE) \</span></span><br><span class="line"><span class="meta">    &#125;; \</span></span><br><span class="line"><span class="meta">    static inline const char *name() &#123; return #TYPE; &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_TYPEINFO(TYPE, FLAGS) \</span></span><br><span class="line"><span class="meta">template<span class="meta-string">&lt;&gt;</span> \</span></span><br><span class="line"><span class="meta">Q_DECLARE_TYPEINFO_BODY(TYPE, FLAGS)</span></span><br></pre></td></tr></table></figure>

<p>可以看出<code>Q_DECLARE_TYPEINFO</code>是一个典型的模板特化和模板enum hack结合的例子，代码使用宏<code>Q_DECLARE_TYPEINFO_BODY</code>定义了一个<code>QTypeInfo</code>的特化版本<code>class QTypeInfo&lt;TYPE &gt;</code>，并且使用定义给定的标志，计算出了一系列枚举值，例如<code>isComplex</code>、<code>isStatic</code>等。</p>
<p>Qt预定义了自己类型的<code>QTypeInfo</code>以便让它们在容器中获得更高的处理效率，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">bool</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">char</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">signed</span> <span class="keyword">char</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(uchar, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">short</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(ushort, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">int</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(uint, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">long</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(ulong, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(qint64, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(quint64, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">float</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">double</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">long</span> <span class="keyword">double</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">char16_t</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">char32_t</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">wchar_t</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">long</span> <span class="keyword">double</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QFileSystemWatcherPathKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QLoggingRule, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QProcEnvKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QProcEnvValue, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QResourceRoot, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QConfFileCustomFormat, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsIniKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsIniSection, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsGroup, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QModelIndex, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QItemSelectionRange, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QBasicTimer, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(pollfd, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSocketNotifierSetUNIX, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(Variable, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QMetaMethod, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QMetaEnum, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QMetaClassInfo, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QArgumentType, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QCustomTypeInfo, Q_MOVABLE_TYPE);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Qt容器类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QList);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QVector);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QQueue);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QStack);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QSet);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QMap);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QMultiMap);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QHash);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QMultiHash);</span><br></pre></td></tr></table></figure>

<p>最后让我们来看看Qt容器如何利用<code>QTypeInfo</code>来优化容器算法的。以我们之前介绍过的<code>QList</code>为例，<code>QList</code>会因为类型大小的不同采用不同的内存布局和构造方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Q_INLINE_TEMPLATE <span class="keyword">void</span> QList&lt;T&gt;::<span class="built_in">node_construct</span>(Node *n, <span class="keyword">const</span> T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) n-&gt;v = <span class="keyword">new</span> <span class="built_in">T</span>(t);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isComplex) <span class="built_in"><span class="keyword">new</span></span> (n) <span class="built_in">T</span>(t);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__IBMCPP__)) &amp;&amp; !defined(__OPTIMIZE__)</span></span><br><span class="line">    <span class="keyword">else</span> *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(n) = t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">else</span> ::<span class="built_in">memcpy</span>(n, <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;(&amp;t), <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Q_INLINE_TEMPLATE <span class="keyword">void</span> QList&lt;T&gt;::<span class="built_in">node_destruct</span>(Node *n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) <span class="keyword">delete</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(n-&gt;v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isComplex) <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(n)-&gt;~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Q_INLINE_TEMPLATE <span class="keyword">void</span> QList&lt;T&gt;::<span class="built_in">node_copy</span>(Node *from, Node *to, Node *src)</span><br><span class="line">&#123;</span><br><span class="line">    Node *current = from;</span><br><span class="line">    <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) &#123;</span><br><span class="line">        QT_TRY &#123;</span><br><span class="line">            <span class="keyword">while</span>(current != to) &#123;</span><br><span class="line">                current-&gt;v = <span class="keyword">new</span> <span class="built_in">T</span>(*<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(src-&gt;v));</span><br><span class="line">                ++current;</span><br><span class="line">                ++src;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">QT_CATCH</span>(...) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current-- != from)</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(current-&gt;v);</span><br><span class="line">            QT_RETHROW;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isComplex) &#123;</span><br><span class="line">        QT_TRY &#123;</span><br><span class="line">            <span class="keyword">while</span>(current != to) &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">new</span></span> (current) <span class="built_in">T</span>(*<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(src));</span><br><span class="line">                ++current;</span><br><span class="line">                ++src;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">QT_CATCH</span>(...) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current-- != from)</span><br><span class="line">                (<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(current))-&gt;~<span class="built_in">T</span>();</span><br><span class="line">            QT_RETHROW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (src != from &amp;&amp; to - from &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(from, src, (to - from) * <span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上代码可以看出，<code>QList</code>根据<code>QTypeInfo</code>中<code>isLarge</code>、<code>isStatic</code>和<code>isComplex</code>的不同采用不同的构造析构和拷贝方法。以构造为例，当表达式<code>QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic</code>计算结果为<code>true</code>时，<code>QList</code>从堆里分配新内存并且构造对象存储在<code>node</code>中。当<code>QTypeInfo&lt;T&gt;::isComplex</code>的计算结果为<code>true</code>时，<code>QList</code>采用Placement new的方式直接使用<code>node</code>内存构造对象。除此之外则简单粗暴的拷贝内存到<code>node</code>内存上。析构和拷贝也有相似处理，阅读代码很容易理解其中的含义。</p>
<p>我们应该怎么做？Qt默认情况下会认为类型特征<code>isStatic</code>为<code>true</code>，这会导致一些不必要的性能下降，例如<code>QList</code>会无视类型大小，采用从堆重新分配内存构造对象。所以我们应该做的是充分理解我们的对象类型是否可以安全的移动，如果可以移动请使用<code>Q_DECLARE_TYPEINFO(TYPE, Q_MOVABLE_TYPE);</code>告知Qt，这样当对象长度小于指针长度的时候，Qt可以避免访问堆来分配内存，并且直接利用已有内存，对于频繁发生的小尺寸对象的操作这种优化是非常巨大的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Run on (8 X 3600 MHz CPU s)</span><br><span class="line">CPU Caches:</span><br><span class="line">  L1 Data 32 KiB (x4)</span><br><span class="line">  L1 Instruction 32 KiB (x4)</span><br><span class="line">  L2 Unified 256 KiB (x4)</span><br><span class="line">  L3 Unified 8192 KiB (x1)</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Benchmark                                         Time             CPU   Iterations</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">BM_QListPushString/iterations:10000000          152 ns          150 ns     10000000</span><br><span class="line">BM_QVectorPushString/iterations:10000000        102 ns          102 ns     10000000</span><br><span class="line">BM_QListPushChar/iterations:10000000           12.2 ns         12.5 ns     10000000</span><br><span class="line">BM_QVectorPushChar/iterations:10000000         4.92 ns         4.69 ns     10000000</span><br></pre></td></tr></table></figure>

<p>详细可以阅读前面的文章《<code>QList</code> 的工作原理和运行效率浅析》。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/06/15/use-Q_DECLARE_TYPEINFO-to-optimize-the-container/" data-id="cktihnvqj00asnoupe2qmftfk" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-the-working-principle-of-qlist" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/29/the-working-principle-of-qlist/">QList 的工作原理和运行效率浅析</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/05/29/the-working-principle-of-qlist/" class="article-date"><time datetime="2021-05-29T09:34:16.000Z" itemprop="datePublished">2021-05-29</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道Qt为了在一些没有STL的环境中运作，开发了一套相对完整的容器。大部分Qt的容器我们都能够招到对应STL容器，例如<code>QVector</code>对应<code>std::vector</code>, <code>QMap</code>对应<code>std::map</code>，不过这其中也有一些特例，例如<code>QList</code>在STL中就没有应该的容器，<code>std::list</code>对应的Qt容器实际上是<code>QLinkedList</code>。所以在使用<code>QList</code>的时候请务必弄清楚这一点，否则可能会导致程序的运行效率的低下，让我们先看一份代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;benchmark/benchmark.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qlist&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qvector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> std::string test_buffer&#123; <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ITER_COUNTS = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QListPushString</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QList&lt;std::string&gt; test_qlist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qlist.<span class="built_in">push_back</span>(test_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QListPushString)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QVectorPushString</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QVector&lt;std::string&gt; test_qvector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qvector.<span class="built_in">push_back</span>(test_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QVectorPushString)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QListPushChar</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QList&lt;<span class="keyword">char</span>&gt; test_qlist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qlist.<span class="built_in">push_back</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QListPushChar)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QVectorPushChar</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QVector&lt;<span class="keyword">char</span>&gt; test_qvector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qvector.<span class="built_in">push_back</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QVectorPushChar)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK_MAIN</span>();</span><br></pre></td></tr></table></figure>

<p>以上代码使用google benchmark统计<code>QList</code>和<code>QVector</code>的运行效率，代码采用的最简单的<code>push_back</code>函数测试两种容器对于小数据和相对较大数据的处理性能。结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Run on (8 X 3600 MHz CPU s)</span><br><span class="line">CPU Caches:</span><br><span class="line">  L1 Data 32 KiB (x4)</span><br><span class="line">  L1 Instruction 32 KiB (x4)</span><br><span class="line">  L2 Unified 256 KiB (x4)</span><br><span class="line">  L3 Unified 8192 KiB (x1)</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Benchmark                                         Time             CPU   Iterations</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">BM_QListPushString/iterations:10000000          152 ns          150 ns     10000000</span><br><span class="line">BM_QVectorPushString/iterations:10000000        102 ns          102 ns     10000000</span><br><span class="line">BM_QListPushChar/iterations:10000000           12.2 ns         12.5 ns     10000000</span><br><span class="line">BM_QVectorPushChar/iterations:10000000         4.92 ns         4.69 ns     10000000</span><br></pre></td></tr></table></figure>

<p>可以发现<code>QVector</code>在两种情况下的性能都占优，尤其是<code>PushChar</code>的情况优势更加明显。原因就要从<code>QList</code>的原理说起了。前面说过<code>QList</code>并不是一个链表链接的结构，它的实际结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       QListData                                 +--------------------+</span><br><span class="line">                                                 |                    |</span><br><span class="line">+------------------------+                       |      obj buffer 1  |</span><br><span class="line">|                        |                       |                    |</span><br><span class="line">|      ptr to buffer 1   +-----------------------&gt;                    |</span><br><span class="line">|                        |                       +--------------------+</span><br><span class="line">+------------------------+</span><br><span class="line">|                        |                       +--------------------+</span><br><span class="line">|      ptr to buffer 2   |                       |                    |</span><br><span class="line">|                        +-----------------------&gt;      obj buffer 2  |</span><br><span class="line">+------------------------+                       |                    |</span><br><span class="line">|                        |                       |                    |</span><br><span class="line">|           .            |                       +--------------------+</span><br><span class="line">|           .            |</span><br><span class="line">|           .            |</span><br><span class="line">|                        |</span><br><span class="line">+------------------------+</span><br><span class="line">|                        |                       +--------------------+</span><br><span class="line">|                        |                       |                    |</span><br><span class="line">|      ptr to buffer N   +-----------------------&gt;                    |</span><br><span class="line">|                        |                       |      obj buffer N  |</span><br><span class="line">+------------------------+                       |                    |</span><br><span class="line">                                                 +--------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它的内部维护了一个指针（void*）的数组，该数组指向了真正的对象，它就像是一个<code>vector</code>和<code>list</code>的结合体一样。在对象占用内存大的时候（大于<code>sizeof(void*)</code>），它每次会从堆中分配内存。然后将内存的起始地址放入数组中。相对于<code>QVector</code>慢的原因是它每次都要经过堆分配内存，而<code>QVector</code>可以预分配内存从而提高<code>push_back</code>的运行效率。而对于小内存对象，他直接将其存储到数组中，这样不需要经过堆分配内存，所以相对于大内存<code>QList</code>本身也有很大的性能提升，但是由于它每次需要用到<code>sizeof(void*)</code>的内存，也会导致更多的内存分配，所以运行效率还是不如<code>QVector</code>。</p>
<p>当然，<code>QList</code>也有自己的优势，例如当对占用大内存对象进行重新排续的时候，<code>QVector</code>只能进行大量内存移动，而<code>QList</code>则只需要移动对象指针即可。相对于<code>std::list</code>，<code>QList</code>在单纯的<code>push_back</code>和枚举的时候也有不错的表现。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/05/29/the-working-principle-of-qlist/" data-id="cktihnvqj00aqnoupe730gmlg" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-parallel-algorithm-in-stl" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/05/parallel-algorithm-in-stl/">STL中并行算法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/04/05/parallel-algorithm-in-stl/" class="article-date"><time datetime="2021-04-05T03:04:49.000Z" itemprop="datePublished">2021-04-05</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>C++17标准的一个重大突破是让标准库中的部分算法支持了并行计算，这对于无处不在的多线程环境来说无疑是一个非常不错的消息。具体支持并行计算的算法可以参考提案文档<a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html#algorithms.parallel.overloads">p0024r2</a>。</p>
<p>接下来将会选取两个典型算法函数对STL的并行算法进行介绍：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::for_each(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">            val *= val;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是一个最简单的并行计算例子，例子中使用了<code>for_each</code>函数，该函数并不是新加入到标准库的。只不过现在多了一个并行计算的版本，其中第一个参数是并行计算的策略。实际上，大部分并行计算的算法都是在原有算法的基础做了新增，它们的共同特点是第一个参数改为了并行计算策略，当然老的算法也依然存在。在这个例子中，策略<code>std::execution::par</code>是并行计算其中的一种策略。在这个策略中函数会使用多线程执行算法，并且线程在执行算法的单个步骤是不会被打断的。为了看清线程的执行情况，我们可以将线程id输出到控制台：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::for_each(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            val *= val;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这份代码就会发现线程id交替输出到控制台上，可见确实是多线程执行<code>for_each</code>函数。让我们再看看排序函数<code>std::sort</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; val2) &#123;</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这份代码同样的会发现多个线程交替输出线程id到控制台上，实际上它们正在并行计算排续该容器。并行计算的优势在数据量足够大的时候是非常明显的，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::<span class="built_in">sort</span>(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; val2) &#123;</span><br><span class="line">            <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; diff = end - start;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;elapsed time = &quot;</span> &lt;&lt; diff.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逆向排序100000个数，使用并行算法在我的机器上消耗了0.48秒。如果删除第一个参数使用传统单线程排续，在我的机器上消耗0.89秒，并行计算性能提升近1倍。</p>
<p>最后来介绍一下C++17中的3种并行计算策略：</p>
<ul>
<li><p><code>std::execution::seq</code> 该策略与非并行算法一样，当前执行线程逐个元素依次执行必要的操作。 使用该策略的行为类似于使用完全不接受任何执行策略的非并行调用算法的方式。</p>
</li>
<li><p><code>std::execution::par</code> 该策略会让多个线程执行元素的必要操作。 当算法开始执行必要的操作时，它会一直执行到操作结束，不会被打断。</p>
</li>
<li><p><code>std::execution::par_unseq</code> 该策略会让多个线程执行元素的必要操作，但是与<code>std::execution::par</code>不同的是，该策略不能保证一个线程执行完该元素的所有步骤而不被打断。在提案文档中也指出了错误示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">std::for_each(std::execution::par_unseq, </span><br><span class="line">              std::<span class="built_in">begin</span>(a), std::<span class="built_in">end</span>(a), [&amp;](<span class="keyword">int</span>) &#123;</span><br><span class="line">  std::lock_guard&lt;mutex&gt; <span class="built_in">guard</span>(m); <span class="comment">// Error: lock_guard constructor calls m.lock()</span></span><br><span class="line">  ++x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里由于<code>std::execution::par_unseq</code> 无法保证执行lambda表达式的时候不被打断，可能会造成同一个线程两次次进入lambda表达式，并且调用<code>m.lock()</code>导致死锁。</p>
</li>
</ul>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/04/05/parallel-algorithm-in-stl/" data-id="cktihnvqi00aonoup2ysn63dg" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-intro-3-cpp-online-tools" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/20/intro-3-cpp-online-tools/">C++在线工具</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/03/20/intro-3-cpp-online-tools/" class="article-date"><time datetime="2021-03-20T08:15:53.000Z" itemprop="datePublished">2021-03-20</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇博客打算介绍4个C++在线工具，当手头没有设备或者没有开发环境的时候可以用它们做一些研究性质的工作。</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://wandbox.org/">https://wandbox.org/</a></p>
<p>该网站可以在线编辑以及编译C++源代码并且运行编译后的程序。在C++类别它支持GCC和CLANG，另外除了C++，C、C#、Java、GO等等都有支持。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://quick-bench.com/">https://quick-bench.com/</a></p>
<p>这也是一个可以在线编辑以及编译C++源代码并且运行编译后的程序的网站，但是与上面网站不同的是它运行程序并非用来输出结果，而是对函数做基准检测，采用的是Google Benchmark。同样它支持GCC和CLANG。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://godbolt.org/">https://godbolt.org/</a></p>
<p>这是我很喜欢的一个网站，它可以在线编辑和编译C++源代码，但是不可以运行程序。但是这并不能掩盖其优秀的地方，它支持C++各种编译器的各种版本，跨度非常大也非常全面。同时还可以自由设置编译器的编译参数并且查看输出的中间文件，对于研究C++编译过程十分有用。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cppinsights.io/">https://cppinsights.io/</a></p>
<p>这是一个非常有趣的网站，它能够将源代码展开，使用一种容易理解的方式展示编译器做了哪些自动化工作。用它自己的话来说，就是从编译器的视角看到的源代码。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> arr[<span class="number">10</span>]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>&amp; c : arr)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被网站展开为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">const</span> <span class="params">(&amp;__range1)</span>[10] </span>= arr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * __begin1 = __range1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * __end1 = __range1 + <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">for</span>(; __begin1 != __end1; ++__begin1) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> &amp; c = *__begin1;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/03/20/intro-3-cpp-online-tools/" data-id="cktihnvqh00amnoup75fw5osi" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li class="disabled"><span class="page-prev"><i class="fa fa-chevron-left"></i> Prev</a></li><li class="active"><span class="page-number">1</span></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/17/">17</a></li><li><a class="page-next" rel="next" href="/page/2/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>https://github.com/0cch</p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CPP/">CPP</a><span class="sidebar-module-list-count">27</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/">Debugging</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">5</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/Tips/">Tips</a><span class="sidebar-module-list-count">7</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/DeepLearner/">DeepLearner</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MiniKernel/">MiniKernel</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">4</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Tips/">Tips</a><span class="sidebar-module-list-count">67</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/debugging/">debugging</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/machinelearning/">machinelearning</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/File-System/" rel="tag">File System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/IDE/" rel="tag">IDE</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Kernel/" rel="tag">Kernel</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/MiniKernel/" rel="tag">MiniKernel</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTFS/" rel="tag">NTFS</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTInternals/" rel="tag">NTInternals</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTSTATUS/" rel="tag">NTSTATUS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/OS/" rel="tag">OS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/PIO/" rel="tag">PIO</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/System/" rel="tag">System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Test/" rel="tag">Test</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Volume/" rel="tag">Volume</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Windows/" rel="tag">Windows</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/grub/" rel="tag">grub</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/snapshot/" rel="tag">snapshot</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/File-System/" style="font-size: 10px;">File System</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Kernel/" style="font-size: 20px;">Kernel</a> <a href="/tags/MiniKernel/" style="font-size: 10px;">MiniKernel</a> <a href="/tags/NTFS/" style="font-size: 15px;">NTFS</a> <a href="/tags/NTInternals/" style="font-size: 10px;">NTInternals</a> <a href="/tags/NTSTATUS/" style="font-size: 10px;">NTSTATUS</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/PIO/" style="font-size: 10px;">PIO</a> <a href="/tags/System/" style="font-size: 10px;">System</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Volume/" style="font-size: 10px;">Volume</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/snapshot/" style="font-size: 10px;">snapshot</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/12/">December 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/11/">November 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/10/">October 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/09/">September 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/08/">August 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/06/">June 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/05/">May 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/04/">April 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/03/">March 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/02/">February 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/01/">January 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/12/">December 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/11/">November 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/10/">October 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/09/">September 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/08/">August 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/07/">July 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">June 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/05/">May 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/04/">April 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/03/">March 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/01/">January 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/12/">December 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/11/">November 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/07/">July 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/06/">June 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/05/">May 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">April 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">March 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">February 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">January 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">December 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">November 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">October 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">September 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">August 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">March 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">February 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">January 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">December 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/11/">November 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">October 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/09/">September 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">August 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">July 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">June 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/05/">May 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">April 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/03/">March 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/01/">January 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/12/">December 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/11/">November 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">October 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">September 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/08/">August 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/07/">July 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/06/">June 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/05/">May 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/04/">April 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/03/">March 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/02/">February 2016</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/01/">January 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/12/">December 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/11/">November 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/10/">October 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/09/">September 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/08/">August 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/07/">July 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/06/">June 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/05/">May 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/04/">April 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/03/">March 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/02/">February 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/01/">January 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/12/">December 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/11/">November 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/10/">October 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/09/">September 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/08/">August 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/07/">July 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/06/">June 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/05/">May 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/04/">April 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/03/">March 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/02/">February 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/01/">January 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/12/">December 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/11/">November 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/10/">October 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/09/">September 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/08/">August 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/07/">July 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/06/">June 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/05/">May 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/04/">April 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/03/">March 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/02/">February 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/01/">January 2013</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/12/">December 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/11/">November 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/08/">August 2012</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/02/">February 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/12/">December 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/10/">October 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/09/">September 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/08/">August 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/06/">June 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/05/">May 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/04/">April 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/02/">February 2011</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2021/12/01/dpcpp/">DPC++中的现代C++语言特性</a>
        </li>
      
        <li>
          <a href="/2021/11/02/module-ext/">补编-模块(C++20)</a>
        </li>
      
        <li>
          <a href="/2021/10/07/moderncpp42/">《现代C++语言核心特性解析》上架感言</a>
        </li>
      
        <li>
          <a href="/2021/09/12/optimization-details-in-qmutex/">QMutex中的优化小细节</a>
        </li>
      
        <li>
          <a href="/2021/08/05/pointer-to-implementation/">指向实现的指针Pointer to implementation</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2021 0CCh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
