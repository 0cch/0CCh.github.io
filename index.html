<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>0CCh Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="0CCh Blog">
<meta property="og:url" content="https://0cch.com/index.html">
<meta property="og:site_name" content="0CCh Blog">
<meta property="og:locale">
<meta property="article:author" content="0CCh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="0CCh Blog" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class="active"
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">0CCh Blog</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-k+&amp;c++new-standard-details" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/21/k+&c++new-standard-details/">K+ 技术峰会之旅&amp;C++新标准细节简析</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/08/21/k+&c++new-standard-details/" class="article-date"><time datetime="2022-08-21T06:15:46.000Z" itemprop="datePublished">2022-08-21</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TIPS/">TIPS</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>这年头，参加一次线下技术大会实属不易，当然举办方就更加不容易了。这届K+大会举办地是深圳，好巧不巧，开幕前一周深圳出现疫情，大会临时将举办地点从迁移到没有疫情的区域，只用了一周时间，可想而知这个事情有多难。</p>
<p>到举办酒店后，确实能感受到举办方满满的诚意和热情，这让我是没想到的，尤其是举办方为了每个讲师准备了精美的伴手礼，我第一时间也发了朋友圈，表示了感谢。到酒店之后就没什么好说的了，这次演讲是第一天，这很好因为可以赶回家和家人度过周日。</p>
<p>回家的过程也很顺利，并没有弹窗，这也要归功于举办方提供的出行建议，周六的23点顺利到家，没有任何阻碍。</p>
<p>这次在大会上讲的主体是《C++新标准细节简析》，讲这个也没有什么特别的理由，就是觉得去讲一些大家都知道的东西，或者标准中一些重要的东西没什么意思，因为重要的大家都有所了解，所以想讲点细节，可能知道的人并不多。</p>
<p>最后再说一下K+大会的特点，大会主要还是以技术上层的东西居多，技术底层和技术细节相对较少，比如第一届的主体是云原生，第二届的主体是能效，而底层技术主要是张银奎老师出品的论坛，我有幸也是这个论坛的讲师之一。如果要提一个希望，那就是希望K+大会更加重视基础和底层，邀请更多做底层技术的专家参加到论坛。大厦不可能没有地基，所有看起来华丽的架构都需要底层的支持，反过来说有了底层的支持，华丽的上层技术才不会沦为虚无缥缈的表面繁荣。</p>
<p>我还是非常支持K+大会的，有这样的大会举办方我相信K+大会会成为国内最顶尖的技术会议之一。</p>
<p>最后，奉上K+大会的PPT：</p>


	<div class="row">
    <embed src="/uploads/2022/08/k+2022.pdf" width="100%" height="550px" type="application/pdf">
	</div>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/08/21/k+&c++new-standard-details/" data-id="cl81eyd1t00bkfkuv3qerar10" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-virtual-function-calls-in-constructors" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/03/virtual-function-calls-in-constructors/">关于构造函数中调用虚函数</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/07/03/virtual-function-calls-in-constructors/" class="article-date"><time datetime="2022-07-03T02:38:00.000Z" itemprop="datePublished">2022-07-03</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在我们学习C++编程的时候，通常都会被告诫：“不要在构造函数中调用虚函数”。为什么会有这样一条规则呢？从语法上来看，当构造函数的函数体执行的时候，该类的虚表和虚表指针应该已经准备就绪了，不会造成调用失败或者引发未定义行为，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()                &#123; std::cout &lt;&lt; <span class="string">&quot;A()\n&quot;</span>;      &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::foo()\n&quot;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;B()\n&quot;</span>;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::foo()\n&quot;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span>()        &#123; std::cout &lt;&lt; <span class="string">&quot;C()\n&quot;</span>; &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::foo()\n&quot;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，它的派生类不会在此时构造好虚表指针，不可能调用到派生类的虚函数，所以上述代码会有如下的执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">B::foo()</span><br><span class="line">C()</span><br></pre></td></tr></table></figure>

<p>这个结果显然是合理的，因为基类<code>B</code>在构造的时候，<code>C</code>还没有构造，这个时候调用<code>B</code>类的虚函数是安全的。那么回到开始的问题，为什么建议大家不要在构造函数中调用虚函数呢？我认为最重要的原因是他的行为跟通常使用虚函数的时候有一些差异，容易造成理解偏差。比如上面的代码，一般情况下，如果在<code>C</code>类构造完毕后调用<code>foo</code>函数，那么调用的必然是<code>C::foo()</code>这个函数。</p>
<p>另外，C++构造函数中调用虚函数和其他语言的行为也会有所不同，这也会造成程序员某种程度上的记忆偏差，最终导致程序设计出现问题。下面，我们以C#和Java为例来展示这种偏差：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Base</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;From base&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">Base</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;From derived&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> Derived();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行这份C#代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From derived</span><br></pre></td></tr></table></figure>

<p>再来看看Java的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">            Test();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;From base&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;From derived&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Program</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Program</span>();</span><br><span class="line">        Program.<span class="type">Derived</span> <span class="variable">d</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行这份代码，输出结果的和C#相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From derived</span><br></pre></td></tr></table></figure>

<p>由此可见，这些不同的结果确实容易影响到程序员的记忆。</p>
<p>最后值得一提的是，C++的这种处理从安全性上更好，这一点非常明显，无论是C#还是Java，在基类中调用派生类虚函数或者说调用被派生类重写的方法，执行的代码都会在派生类构造之前执行，造成未定义的行为。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/07/03/virtual-function-calls-in-constructors/" data-id="cl81eyd1t00bifkuv9a0ffgqq" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-addition-to-rvo-and-copy-elimination" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/01/addition-to-rvo-and-copy-elimination/">返回值优化和拷贝消除的一点补充</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/06/01/addition-to-rvo-and-copy-elimination/" class="article-date"><time datetime="2022-06-01T13:17:10.000Z" itemprop="datePublished">2022-06-01</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在我写的《现代C++语言核心特性解析》中有一个小节是讲解的返回值优化，在这篇文章中，我将对这部分内容进行一点补充，将更多细节展示出来。<br>首先还是来看看书中的这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;X ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">const</span> X&amp; x) &#123; std::cout &lt;&lt; <span class="string">&quot;X copy ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;X dtor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">X <span class="title">make_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x1;</span><br><span class="line">    <span class="keyword">return</span> x1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x2 = <span class="built_in">make_x</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码在开启和关闭拷贝消除的运行情况是不同的，不过书中只使用了两种情况讨论，但是实际上我漏掉了C++17关闭拷贝消除的情况，以下是正确的对比表格：</p>
<table>
<thead>
<tr>
<th>拷贝消除</th>
<th>C++14 关闭拷贝消除</th>
<th>C++17 关闭拷贝消除</th>
</tr>
</thead>
<tbody><tr>
<td>X ctor</td>
<td>X ctor</td>
<td>X ctor</td>
</tr>
<tr>
<td>X dtor</td>
<td>X copy ctor</td>
<td>X copy ctor</td>
</tr>
<tr>
<td></td>
<td>X dtor</td>
<td>X dtor</td>
</tr>
<tr>
<td></td>
<td>X copy ctor</td>
<td>X dtor</td>
</tr>
<tr>
<td></td>
<td>X dtor</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X dtor</td>
<td></td>
</tr>
</tbody></table>
<p>可以看到C++17和C++14的行为是不同的。开启拷贝消除的很明显，优化让构造直接发生在<code>main</code>函数中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_x</span>(): # @<span class="built_in">make_x</span>()</span><br><span class="line">  push rbx</span><br><span class="line">  mov rbx, <span class="function">rdi</span></span><br><span class="line"><span class="function">  call <span class="title">X::X</span><span class="params">()</span> [base object constructor]</span></span><br><span class="line"><span class="function">  mov rax, rbx</span></span><br><span class="line"><span class="function">  pop rbx</span></span><br><span class="line"><span class="function">  ret</span></span><br><span class="line"><span class="function">main: # @main</span></span><br><span class="line"><span class="function">  push rbx</span></span><br><span class="line"><span class="function">  sub rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">  lea rdi, [rsp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function">  call make_x()</span></span><br></pre></td></tr></table></figure>
<p>C++14的行为也很明确，和书中介绍了一样，发生了三次构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_x</span>(): # @<span class="built_in">make_x</span>()</span><br><span class="line">  push r14</span><br><span class="line">  push rbx</span><br><span class="line">  push rax</span><br><span class="line">  mov rbx, rdi</span><br><span class="line">  mov r14, rsp</span><br><span class="line">  mov rdi, <span class="function">r14</span></span><br><span class="line"><span class="function">  call <span class="title">X::X</span><span class="params">()</span> [base object constructor]</span></span><br><span class="line"><span class="function">  mov rdi, rbx</span></span><br><span class="line"><span class="function">  mov rsi, r14</span></span><br><span class="line"><span class="function">  call <span class="title">X::X</span><span class="params">(X <span class="type">const</span>&amp;)</span> [base object constructor]</span></span><br><span class="line"><span class="function">  mov rdi, rsp</span></span><br><span class="line"><span class="function">  call X::~<span class="title">X</span><span class="params">()</span> [base object destructor]</span></span><br><span class="line"><span class="function">  mov rax, rbx</span></span><br><span class="line"><span class="function">  add rsp, 8</span></span><br><span class="line"><span class="function">  pop rbx</span></span><br><span class="line"><span class="function">  pop r14</span></span><br><span class="line"><span class="function">  ret</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">main: # @main</span></span><br><span class="line"><span class="function">  push rbx</span></span><br><span class="line"><span class="function">  sub rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">  mov rbx, rsp</span></span><br><span class="line"><span class="function">  mov rdi, rbx</span></span><br><span class="line"><span class="function">  call make_x()</span></span><br><span class="line"><span class="function">  lea rdi, [rsp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function">  mov rsi, rbx</span></span><br><span class="line"><span class="function">  call X::X(X const&amp;) [base object constructor]</span></span><br><span class="line"><span class="function">  mov rdi, rsp</span></span><br><span class="line"><span class="function">  call X::~X() [base object destructor]</span></span><br><span class="line"><span class="function">  lea rdi, [rsp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function">  call X::~X() [base object destructor]</span></span><br><span class="line"><span class="function">  xor eax, eax</span></span><br><span class="line"><span class="function">  add rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">  pop rbx</span></span><br><span class="line"><span class="function">  ret</span></span><br></pre></td></tr></table></figure>
<p>但是C++17的行为相对就比较奇怪了，关闭拷贝消除但并没有完全关闭：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_x</span>(): # @<span class="built_in">make_x</span>()</span><br><span class="line">  push r14</span><br><span class="line">  push rbx</span><br><span class="line">  push rax</span><br><span class="line">  mov rbx, rdi</span><br><span class="line">  mov r14, rsp</span><br><span class="line">  mov rdi, <span class="function">r14</span></span><br><span class="line"><span class="function">  call <span class="title">X::X</span><span class="params">()</span> [base object constructor]</span></span><br><span class="line"><span class="function">  mov rdi, rbx</span></span><br><span class="line"><span class="function">  mov rsi, r14</span></span><br><span class="line"><span class="function">  call <span class="title">X::X</span><span class="params">(X <span class="type">const</span>&amp;)</span> [base object constructor]</span></span><br><span class="line"><span class="function">  mov rdi, rsp</span></span><br><span class="line"><span class="function">  call X::~<span class="title">X</span><span class="params">()</span> [base object destructor]</span></span><br><span class="line"><span class="function">  mov rax, rbx</span></span><br><span class="line"><span class="function">  add rsp, 8</span></span><br><span class="line"><span class="function">  pop rbx</span></span><br><span class="line"><span class="function">  pop r14</span></span><br><span class="line"><span class="function">  ret</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">main: # @main</span></span><br><span class="line"><span class="function">  push rbx</span></span><br><span class="line"><span class="function">  sub rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">  lea rbx, [rsp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function">  mov rdi, rbx</span></span><br><span class="line"><span class="function">  call make_x()</span></span><br><span class="line"><span class="function">  mov rdi, rbx</span></span><br><span class="line"><span class="function">  call X::~X() [base object destructor]</span></span><br><span class="line"><span class="function">  xor eax, eax</span></span><br><span class="line"><span class="function">  add rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">  pop rbx</span></span><br><span class="line"><span class="function">  ret</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>只有两次构造，<code>x1</code>拷贝到临时对象，临时对象拷贝到<code>x2</code>的过程合并成了一次，也就是<code>x1</code>直接拷贝到了<code>x2</code>，这是为什么呢？<br>其实是因为C++17对临时对象进行了特殊规定：</p>
<blockquote>
<p>6.7.7 Temporary objects [class.temporary]</p>
<p>The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary objects.</p>
</blockquote>
<p>在提案文档p0135r1中也对拷贝消除的描述进行了修改（<a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html</a><br>）。</p>
<p>至此，我们已经了解了C++17关闭拷贝消除后的特殊情况的因由。最后补充一点，关于拷贝消除，除了在返回值上可以做优化，还有下面这些情况都可以进行优化，当然有一些优化是没有实现的：</p>
<blockquote>
<ol>
<li>return语句中返回类类型，返回对象类型和函数返回类型相同，并且要求类型是非易失且有自动存储周期的对象。</li>
<li>throw表达式，操作数类型也要求是非易失且有自动存储周期的对象，并且作用域不超过最内侧的try。</li>
<li>异常处理（其实就是try-catch中catch(){}），声明的对象如果和抛出对象类型相同，可以将声明对象看作抛出对象的别名，前提条件是这个对象在这个过程中除了构造和析构是不会被改变的。</li>
<li>在协程中，协程参数的拷贝可以被忽略，也就是直接引用参数本身，当然也有前提条件，就是在处理对象的过程中除了构造和析构是不会被改变的。</li>
</ol>
</blockquote>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/06/01/addition-to-rvo-and-copy-elimination/" data-id="cl81eyd1t00bgfkuvhqrqayy7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-use-async-with-caution" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/02/use-async-with-caution/">谨慎使用std::async</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/05/02/use-async-with-caution/" class="article-date"><time datetime="2022-05-02T12:09:08.000Z" itemprop="datePublished">2022-05-02</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p><code>std::async</code>是C++11标准引入的函数模板，它用于异步执行某些任务，通常在单独的线程或者线程池中运行，它会返回一个<code>std::future</code>用于等待和获取异步执行的结果。<br>为什么这里说需要谨慎使用呢？其实原因上面一句话也提到了，就是它可能是在单独的线程中运行的。那么躲过我们想并发执行多个异步任务，会导致系统产生多个线程，执行完任务后退出。熟悉操作系统的朋友应该知道，创建线程的操作是非常耗时的，它需要让系统进入到内核，并且执行很多进程和线程相关的操作，另外过多的线程并不能真正的做到异步，因为我们的CPU的执行单元是有限的。所以调用<code>std::async</code>是应该谨慎一些的。<br>接下来让我们看看三大编译器的<code>std::async</code>的实现：<br>首先来看GCC：<br><a target="_blank" rel="noopener" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/future">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/future</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Shared state created by std::async().</span></span><br><span class="line">  <span class="comment">// Starts a new thread that runs a function and makes the shared state ready.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _BoundFn, <span class="keyword">typename</span> _Res&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">__future_base</span>::_Async_state_impl <span class="keyword">final</span></span><br><span class="line">    : <span class="keyword">public</span> __future_base::_Async_state_commonV2</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">explicit</span></span><br><span class="line">    _Async_state_impl(_Args&amp;&amp;... __args)</span><br><span class="line">    : _M_result(<span class="keyword">new</span> _Result&lt;_Res&gt;()),</span><br><span class="line">      _M_fn&#123;&#123;std::forward&lt;_Args&gt;(__args)...&#125;&#125;</span><br><span class="line">    &#123;</span><br><span class="line">      _M_thread = std::thread&#123;&amp;_Async_state_impl::_M_run, <span class="keyword">this</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Must not destroy _M_result and _M_fn until the thread finishes.</span></span><br><span class="line">      <span class="comment">// Call join() directly rather than through _M_join() because no other</span></span><br><span class="line">      <span class="comment">// thread can be referring to this state if it is being destroyed.</span></span><br><span class="line">      ~_Async_state_impl()</span><br><span class="line">      &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_thread.<span class="built_in">joinable</span>())</span><br><span class="line">      _M_thread.<span class="built_in">join</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">void</span></span><br><span class="line">      _M_run()</span><br><span class="line">      &#123;</span><br><span class="line">    __try</span><br><span class="line">      &#123;</span><br><span class="line">        _M_set_result(_S_task_setter(_M_result, _M_fn));</span><br><span class="line">      &#125;</span><br><span class="line">    __catch (<span class="type">const</span> __cxxabiv1::__forced_unwind&amp;)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// make the shared state ready on thread cancellation</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(_M_result))</span><br><span class="line">          <span class="keyword">this</span>-&gt;_M_break_promise(std::<span class="built_in">move</span>(_M_result));</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">typedef</span> __future_base::_Ptr&lt;_Result&lt;_Res&gt;&gt; _Ptr_type;</span><br><span class="line">      _Ptr_type _M_result;</span><br><span class="line">      _BoundFn _M_fn;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>很显然使用了<code>std::thread</code>创建新线程。<br>然后再来看Clang：<br><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/future">https://github.com/llvm/llvm-project/blob/main/libcxx/include/future</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY future&lt;_Rp&gt;</span><br><span class="line">__make_async_assoc_state(_Fp&amp;&amp; __f)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;__async_assoc_state&lt;_Rp, _Fp&gt;, __release_shared_count&gt;</span><br><span class="line">        __h(<span class="keyword">new</span> __async_assoc_state&lt;_Rp, _Fp&gt;(_VSTD::forward&lt;_Fp&gt;(__f)));</span><br><span class="line">    _VSTD::<span class="built_in">thread</span>(&amp;__async_assoc_state&lt;_Rp, _Fp&gt;::__execute, __h.<span class="built_in">get</span>()).<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">future</span>&lt;_Rp&gt;(__h.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，采用了创建新线程的方法。<br>最后来看看MSVC提供的STL的实现：<br><a target="_blank" rel="noopener" href="https://github.com/microsoft/STL/blob/main/stl/inc/future">https://github.com/microsoft/STL/blob/main/stl/inc/future</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rx</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Task_async_state</span> : <span class="keyword">public</span> _Packaged_state&lt;_Rx()&gt; &#123;</span><br><span class="line">    <span class="comment">// class for managing associated synchronous state for asynchronous execution from async</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> _Mybase     = _Packaged_state&lt;_Rx()&gt;;</span><br><span class="line">    <span class="keyword">using</span> _State_type = <span class="keyword">typename</span> _Mybase::_State_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fty2</span>&gt;</span><br><span class="line">    _Task_async_state(_Fty2&amp;&amp; _Fnarg) : _Mybase(_STD forward&lt;_Fty2&gt;(_Fnarg)) &#123;</span><br><span class="line">        _Task = ::Concurrency::<span class="built_in">create_task</span>([<span class="keyword">this</span>]() &#123; <span class="comment">// do it now</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_Call_immediate();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Running = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~_Task_async_state() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123;</span><br><span class="line">        _Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Wait() <span class="keyword">override</span> &#123; <span class="comment">// wait for completion</span></span><br><span class="line">        _Task.<span class="built_in">wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _State_type&amp; _Get_value(<span class="type">bool</span> _Get_only_once) <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">// return the stored result or throw stored exception</span></span><br><span class="line">        _Task.<span class="built_in">wait</span>();</span><br><span class="line">        <span class="keyword">return</span> _Mybase::_Get_value(_Get_only_once);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ::Concurrency::task&lt;<span class="type">void</span>&gt; _Task;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，微软提供的<code>std::async</code>的实现好了一些，它使用了线程池来进行异步操作，这样效率会好不少。值得一提的是，这里使用的是微软提供Parallel Patterns Library (PPL)库，专门用于多线程和并行计算的，和Intel的TBB比较类似。<br>由此可见，如果需要大量使用异步操作执行任务，依赖<code>std::async</code>的效率是不太可靠的，我们最好是能够使用更高效的线程池的方案。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/05/02/use-async-with-caution/" data-id="cl81eyd1s00befkuv1iolcae8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-pass-params" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/12/pass-params/">值传参</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/04/12/pass-params/" class="article-date"><time datetime="2022-04-12T12:03:43.000Z" itemprop="datePublished">2022-04-12</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>我在大学里学C++的时候，印象最为深刻的是老师反复告诫我们，应该如何传递函数参数。为了避免发生不必要的内存拷贝和复杂的对象构造，一般来说对于复杂对象都会采取使用传递引用的方式，当然如果参数不会被改变，最好使用常量引用，只有一些基础类型可以通过值传递参数。<br>按照上述方式写代码确实不会任何问题，不过C++向来是一门追求极致的语言，在效率方面更是如此，所以在C++17引入了<code>std::string_view</code>，并且推荐使用值传递的方式作为参数来传递，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_sv_byval</span><span class="params">(std::string_view sv)</span> </span>&#123; <span class="keyword">return</span> sv.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码通过值来传递<code>std::string_view</code>，而不是通过引用，下面我们就来探讨为何这里更加推荐使用通过值来传递参数。<br>首先，也是最容易理解的一点，能够使用值传递<code>std::string_view</code>必然是因为它足够简单。它的典型的实现只有两个成员：指向常量字符串的指针和字符串大小。值得一提的是，<code>std::string_view</code>并不是C++17才出现在我们视野中的，实际上在chromium和llvm中，早就出现了类似的实现。在C++标准的草案也可以追述到2012年的n3442，当时<code>std::string_view</code>还被称为<code>string_ref</code>。后来到了2014年，经过了大约7个版本的修订，才有了我们今天看到的<code>std::string_view</code>。<br>我们当然不能因为<code>std::string_view</code>足够简单认为使用传值的方式比传递引用的方式高效，这需要我们拿出其他的证据。</p>
<h3 id="通过传值使用std-string-view可以消除引用中的内存操作"><a href="#通过传值使用std-string-view可以消除引用中的内存操作" class="headerlink" title="通过传值使用std::string_view可以消除引用中的内存操作"></a>通过传值使用std::string_view可以消除引用中的内存操作</h3><p>我们都知道，对象的拷贝是在caller中发生的，例如下面这两行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_str_byref</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_str_byval</span><span class="params">(std::string s)</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>在使用-O2的优化选项进行编译的情况下，他们生成的汇编代码是相同的，都是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ret_str_byref:</span><br><span class="line">  mov eax, DWORD PTR [rdi+<span class="number">8</span>]</span><br><span class="line">  ret</span><br><span class="line">ret_str_byval:</span><br><span class="line">  mov eax, DWORD PTR [rdi+<span class="number">8</span>]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>因为临时对象的拷贝在调用者函数中发生，所以这里不会有任何区别。可以看到，这里都使用了内存访问，访问了rdi+8的数据。这里如果我们使用<code>std::string_view</code>会如何呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_sv_byval</span><span class="params">(std::string_view sv)</span> </span>&#123; <span class="keyword">return</span> sv.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ret_sv_byval:</span><br><span class="line">  mov eax, edi</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>显然，这里直接使用了寄存器，没有涉及到任何内存的访问，这样访问效率必然是有所提升的。<br>引用的另一个劣势是，在一个不需要涉及内存的操作中，因为引用语义和内存相关，导致编译器会强行将对象设置在内存中，来看看下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">sv_call_val</span><span class="params">(std::string_view sv)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ret_sv_byval</span>(sv);&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">sv_call_ref</span><span class="params">(std::string_view sv)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ret_sv_byref</span>(sv);&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数非常简单，直接使用参数调用后续函数，不过编译后的代码截然不同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sv_call_val</span><br><span class="line">  jmp ret_sv_byval</span><br><span class="line">sv_call_ref</span><br><span class="line">  sub rsp, <span class="number">24</span></span><br><span class="line">  mov qword ptr [rsp + <span class="number">8</span>], rdi</span><br><span class="line">  mov qword ptr [rsp + <span class="number">16</span>], rsi</span><br><span class="line">  lea rdi, [rsp + <span class="number">8</span>]</span><br><span class="line">  call ret_sv_byref</span><br><span class="line">  add rsp, <span class="number">24</span></span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>可以看出，前者可以直接执行jmp，跳到目标函数。后者，也就是穿引用的函数，则是需要先将数据写到栈上，然后在调用函数，显然前者的效率更高。</p>
<h3 id="通过传值使用std-string-view可以帮助编译器进行优化"><a href="#通过传值使用std-string-view可以帮助编译器进行优化" class="headerlink" title="通过传值使用std::string_view可以帮助编译器进行优化"></a>通过传值使用std::string_view可以帮助编译器进行优化</h3><p>程序的编译优化并不是容易的事情，编译器要考虑非常多的因素，例如外部对内部的影响等。传值和传引用的区别在于，传递引用的对象可能会被其他外部因素干扰导致编译器没办法进行优化，但是传值就不存在这样的问题，因为传值是拷贝，不会被外部影响，编译器优化起来更加得心应手，来看看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_sv_byval</span><span class="params">(std::string_view sv, <span class="type">size_t</span>&amp; troublemaker)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> temp = troublemaker;</span><br><span class="line">    troublemaker++;</span><br><span class="line">    <span class="type">size_t</span> retval = sv.<span class="built_in">size</span>();</span><br><span class="line">    troublemaker = temp;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_sv_byref</span><span class="params">(<span class="type">const</span> std::string_view&amp; sv, <span class="type">size_t</span>&amp; troublemaker)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> temp = troublemaker;</span><br><span class="line">    troublemaker++;</span><br><span class="line">    <span class="type">size_t</span> retval = sv.<span class="built_in">size</span>();</span><br><span class="line">    troublemaker = temp;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个函数唯一的区别就是<code>sv</code>是传值还是传引用，看似没有太大区别，但是我们来看看汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ret_sv_byval</span><br><span class="line">  mov rax, rdi</span><br><span class="line">  ret</span><br><span class="line">ret_sv_byref</span><br><span class="line">  mov rcx, qword ptr [rsi]</span><br><span class="line">  lea rax, [rcx + <span class="number">1</span>]</span><br><span class="line">  mov qword ptr [rsi], rax</span><br><span class="line">  mov rax, qword ptr [rdi]</span><br><span class="line">  mov qword ptr [rsi], rcx</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>可以看到，前者就是简单了一条寄存器操作就返回了，<code>temp</code>和<code>troublemaker</code>都没有给函数带来任何影响。而后者就完全不同了，因为传递的是引用，即使是常量引用，也导致编译器无法对代码进行优化。因为对于编译器而言，并不知道<code>troublemaker</code>是否会对<code>sv</code>的内部有所影响，只能按照代码进行编译。<br>至此，我们可以得到结论是，对于简单对象，例如使用寄存器就能传递其数据的对象，我们可以使用传值的方式传递参数，例如简单的<code>std::pair</code>，<code>std::span</code>等等。当然比较复杂的对象，还是要使用传递引用的方式的。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/04/12/pass-params/" data-id="cl81eyd1s00bcfkuvd2me8kt5" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-oneapi-summary" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/08/oneapi-summary/">oneAPI 组件简介</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/03/08/oneapi-summary/" class="article-date"><time datetime="2022-03-08T00:00:31.000Z" itemprop="datePublished">2022-03-08</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在oneAPI的一系列的产品中，我首先要介绍的是DPC和它的编译器，因为这部分内容十分有趣。我们都知道，一个程序运行效率高低，跟语言本身和他的编译器是息息相关的，比如我们不能指望python的程序在算法和运行环境相同的情况下跑过C和C的程序。</p>
<p><img src="/uploads/2022/03/oneapi-summary-1.png" alt="组件"></p>
<p>Intel的DPC团队当然考虑到了这一点，DPC和他的编译器正是基于高效的C语言以及时下先进的编译器clang&#x2F;llvm的。在llvm的支持下，让DPC能够轻松的在不同的平台上使用。</p>
<p>DPC是基于标准C和SYCL的，也就是说，我们可以用C一种语言来编写各种加速平台的程序，这样就让程序员能脱离学习专属语言的麻烦。至于SYCL标准，DPC实际上在它的基础上也做了比较多的优化，方便程序员编写代码。</p>
<p>因为DPC++的编译器是基于clang&#x2F;llvm的，所以它也是一个开源的编译器，我们可以在Github上找到他的源代码。并且通过翻阅提交记录来初步了解编译器是怎么构建起来的，总的来说这是一个在前中后端都有进行开发的编译器。</p>
<p>oneAPI还提供了一套兼容性工具，这套工具可以将CUDA编写的代码转换为标准的c代码，便于使用DPC进行编译。不过需要注意的是，并不是所有的代码都可以。CUDA代码大约可以有90%到95%能够正确的转换为DPC++的代码，当然剩下的一部分会注释留白，让开发人员进行转换。这个转换工具会尽可能的转换出开发人员可读的源代码程序。</p>
<p><img src="/uploads/2022/03/oneapi-summary-2.png" alt="兼容性工具"></p>
<p><a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compatibility-tool.html#gs.zio9bm">dpc-compatibility-tool</a></p>
<p>感兴趣的朋友可以访问以上链接，这里有非常详细的代码和操作例子。</p>
<p>再来说一下oneAPI提供的API，使用API可以让除了C以外的语言也享受到oneAPI提供的强大的高性能计算功能。例如，DPC库，这个还是基于的C++，它是优化了C++标准算法，包括并行算法等，并且能够保证在不同的硬件平台上高效运行。另外，为了让开发人员快速学习，它基于的是pstl和boost.compute库。再例如oneDNN这个库，主要就是用来做深度学习框架的，在oneAPI里提供的tensorflow的底层就是由oneDNN做的支持。</p>
<p>oneAPI提供的库有很多，有兴趣的朋友可以直接上官网查看，会有非常详细的介绍。其实在了解oneAPI之前，我就用过这其中的TBB库，这是一个做并行编程和多线程的库，和微软的PPL很像。简单来说就是在使用这个库的时候，我们不需要关心线程本身，也不需要关心硬件环境使用多少线程效率最高，如何做线程调度效率最高，直接把任务扔到接口就行了，非常方便，即使不编写高性能计算程序的朋友也可以去了解一下。</p>
<p>要介绍的最后一部分是分析和调试工具，这一部分中的GDB，我想大家再熟悉不过，不过oneAPI提供的GDB是有一些不同的，它除了能调试普通程序，还支持通过双机来调试异构程序。也就是说，它可以调试到设备内核代码中。请注意，这里的内核不是指操作系统内核，而是在加速设备上执行代码。使用普通的调试器是无法做到这一点的，虽然看起来都像是C++的代码，但其实编译出的程序并不是像主机端的代码一样可调的。大家也可以试一试，如果使用普通的调试器对内核代码下断点，跑起来的程序是肯定不会中断下来的。</p>
<p>第二个工具是Advisor，这个工具可以对异构程序进行分析，并且提供优化建议，包括怎么使用内存，怎么使用多线程，怎么使用并发。这个工具我是用的不多，有兴趣的朋友还是可以看官方文档。</p>
<p><img src="/uploads/2022/03/oneapi-summary-3.png" alt="Vtune"></p>
<p>第三个工具是Vtune，这个工具就厉害了，我想做过性能优化的朋友肯定是用过的。这个工具在做性能优化方面并不局限于异构程序，其实很早之前我就接触过它了。它可以对程序性能的缺陷做非常系统的分析，包括IO，线程、内存、指令集的使用等等，分析的粒度可以从指令到代码行再到函数块，支持的架构从CPU、GPU到FPGA，总之做性能优化的朋友千万不要错过这个工具。</p>
<p>以上就是对Intel oneAPI的一个大概的介绍，想了解更多信息还是要访问<a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/overview.html">官网</a>，另外，如果有朋友想进一步的做实验，Intel还提供了DevCloud这样一个免费的实验平台给大家，有兴趣的朋友不妨一试。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/03/08/oneapi-summary/" data-id="cl81eyd1s00bafkuv1mm489u7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-k+2021" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/12/k+2021/">2021K+软件峰会PPT</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/02/12/k+2021/" class="article-date"><time datetime="2022-02-12T03:15:07.000Z" itemprop="datePublished">2022-02-12</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>去年K+上用的PPT，讲了一些跟C++20协程有关的内容，分享出来。</p>


	<div class="row">
    <embed src="/uploads/2022/02/k+2021.pdf" width="100%" height="550px" type="application/pdf">
	</div>



      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/02/12/k+2021/" data-id="cl81eyd1r00b6fkuv11zf1gak" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-summary" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/01/2021-summary/">2021小结</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/01/01/2021-summary/" class="article-date"><time datetime="2021-12-31T23:15:55.000Z" itemprop="datePublished">2022-01-01</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>这是一篇想到哪写到哪的流水账，和技术无关和工作无关，就是想写点东西。</p>
<p>让我想想从哪里开始写起，那就从春节开始说起吧，今年春节我们家贴了一副非常可爱的“牛转乾坤”春联。</p>
<p>熟悉我的朋友都知道今年我出版了一本书，也是我的第一本书，其实整个期间我是很忐忑的，所以从2020年的10月开始我对编辑小姐姐的催促就没有间断过。</p>
<p>2021年2月到3月书其实正经历二审和三审，当时我并不知道三审后才是校对，并且需要申请出版号，天真的以为5月之前书一定可以出版。后来才知道后面还有很多步骤，例如质量审查、申请图书出版号、封面设计等等，预想出版的时间从5月推迟到6月，然后又推迟到7月，最后一直推迟到了9月，当时真的只能安慰自己好事多磨。这些步骤中最令人抓狂的就是质量审查环节，因为我问不到进度，而且一旦质量审查没通过就得修正好再审查一次，相当消耗时间。我是真的希望能一次性通过质量审查，当然大家应该能猜到，谁也逃不过遵循墨菲定律，果然第一次质量审查是没有通过的，所以后来多花了将近一个月的时候修改并且通过质量审查。当然了，其实这并不是意见坏事，毕竟作为自己写的书，并且还是第一本，对它的质量要求是很高的，我希望我能拿出一本让读者满意的书，也不枉费4年的时间。</p>
<p>2021年中秋节，终于，我拿到自己写的书，我很难描述当时的心情，感觉和高考结束后有点类似，就是那种好像一切都结束了的感觉。没有表现的特别高兴，反而还有点惆怅，真的没办法形容。当然这种心情持续并不久，我就开始关心书的销量了，关心这个词可能用的并不准确，用担心也许会更好吧。幸运的是，这种心情也没持续多久，因为销量还挺不错的，一度还蹭上了当当计算机类新书榜前十，还是听鼓舞人心的。</p>
<p>在书出版了以后，我就开始了另外项目，也就是录一个系列的C++课程，这个课程在张银奎老实的盛格塾小程序上连载。我是一个口才普通的人，普通话也不算标准，所以录制课程对我来说调整其实挺大的。尤其是刚刚开始的时候，10分钟的课程我录制加剪辑可以耗上一下午。多亏爱人的工作和剪辑相关，给我在剪辑方面提供一些帮助，否则话的时间更久。不过熟能生巧这个事情到哪都是通用的，课程一共42讲，录到10讲以后速度明显快很多了，录过了35讲就基本上已经游刃有余了。而且这段时间感觉自己说话都变利索了不少。</p>
<p>生活的奇妙之处就是这样，每件事情有时候衔接的特别理想。在课程录制到倒数第二讲的时候，我开始了另外一件事情，就是11月去上海参加K+技术峰会。不得不说要感谢之前录制课程的经历，否则练习演讲估计得弄的我直翻白眼。整体来说这次上海之旅还算挺顺利的，除了回来后社区打电话来说上海闹疫情了，庆幸自己没在上海到处浪，这疫情也不知道什么时候是个头啊。</p>
<p>K+技术峰会结束后，Intel找到了我让我参加DPC++认证讲师培训，这也是个挺好的事情所以就参加了。当然培训最后也有考核，就是录一个课程“而已”，如果说半年前我还对这种事情很畏惧，那么现在已经轻车熟路了，果然是每一份付出都是有收获的，感谢自己的付出让自己变的更好了。</p>
<p>2021年的倒数第二天，出版社的杨社长又给我带来了一个好消息，是我获得异步社区的年度影响力作者，居然还有奖杯可以拿，可把我高兴坏了。</p>
<p>上面这些是我业余耗费最多精力的事情，也是我很重视的一些事情。当然2021年发生的事情远远不止这些，比如工作上取得了从未有过的收获，这也是巨大成就感的来源之一。不过最最最重要的是家里多了一个小成员，几乎每天回去都要和他折腾很久，每天都很累但是却很开心。</p>
<p>2021年对我来说是非常重要的一年，完成了很多以前想都没想过的事情，我觉得我可以把他称为我人生中最自豪的一年，果然很“牛转乾坤”。</p>
<p>2022年虎年希望自己在“牛转乾坤”之后再接再厉，福虎生旺、龙腾虎跃！</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/01/01/2021-summary/" data-id="cl81eyd1r00b4fkuv8dzbab3k" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-dpcpp" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/01/dpcpp/">DPC++中的现代C++语言特性</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/12/01/dpcpp/" class="article-date"><time datetime="2021-12-01T00:24:18.000Z" itemprop="datePublished">2021-12-01</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Ⅰ-DPC-简介"><a href="#Ⅰ-DPC-简介" class="headerlink" title="Ⅰ DPC++简介"></a>Ⅰ DPC++简介</h1><p>DPC++是Data Parallel C++（数据并行C++）的首字母缩写，它是Intel为了将SYCL引入LLVM和oneAPI所开发的开源项目。SYCL是为了提高各种加速设备上的编程效率而开发的一种高级别的编程模型，简单来说它是一种跨平台的抽象层，用户不需要关心底层的加速器具体是什么，按照标准编写统一的代码就可以在各种平台上运行。可以说SYCL大大提高了编写异构计算代码的可移植性和编程效率，已经成为了异构计算的行业标准。值得一提的是SYCL并不是由多个单词的首字母的缩写。DPC++正是建立在SYCL和现代C++语言之上，具体来说是建立在C++17标准之上的。<br>写本篇文章的目是为了讨论现代C++语言在DPC++中的应用，算是对《现代C++语言核心特性解析》一书的补充，而不是要探究异构计算的原理，因为这是一个庞大的话题，需要资深专家才好驾驭。<br>关于实验环境，我选择的是本地安装Intel oneApi Toolkit，因为本地工具用起来还是更加方便一些。不过，如果读者朋友们的硬件条件不允许，那么我们可以注册使用DevCloud。DevCloud是Intel公司提供的远程开发环境，包含了最新的Intel 硬件和软件集群。</p>
<h1 id="Ⅱ-DPC-背景"><a href="#Ⅱ-DPC-背景" class="headerlink" title="Ⅱ DPC++背景"></a>Ⅱ DPC++背景</h1><h3 id="1．什么是数据并行编程"><a href="#1．什么是数据并行编程" class="headerlink" title="1．什么是数据并行编程"></a>1．什么是数据并行编程</h3><p>数据并行编程既可以被描述为一种思维方式，也可以被描述为一种编程方式。 数据由一组并行的处理单元进行操作。 每个处理单元都是能够对数据进行计算的硬件设备。这些处理单元可能存在于单个设备上，也可能存在于我们计算机系统中的多个设备上。 我们可以指定代码以内核的形式处理我们的数据。<br>内核是数据并行编程中一个重要的概念，它的功能是让设备上的处理单元执行计算。这个术语在SYCL、OpenCL、CUDA 和 DPC++都有使用到。</p>
<h3 id="2．什么是异构系统"><a href="#2．什么是异构系统" class="headerlink" title="2．什么是异构系统"></a>2．什么是异构系统</h3><p>异构系统是包含多种类型的计算设备的任何系统。 例如，同时具有CPU和GPU的系统就是异构系统。现在已经有很多中这样的计算设备了，包括 CPU、GPU、FPGA、DSP、ASIC和AI 芯片。异构系统的出现带来了一个很大的挑战，就是刚刚提到的这些设备，每一种都具有不同的架构，也具有不同的特性，这就导致对每个设备有不同编程和优化需求，而DPC++开发一个动机就是帮助解决这样的挑战。</p>
<h3 id="3．为什么需要异构系统"><a href="#3．为什么需要异构系统" class="headerlink" title="3．为什么需要异构系统"></a>3．为什么需要异构系统</h3><p>因为异构计算很重要，一直以来计算机架构师致力于限制功耗、减少延迟和提高吞吐量的工作。从1990年到2006年，由于处理器性能每两到三年翻一番（主要是因为时钟频率每两年翻一番），导致那个时候应用程序的性能都跟着有所提升。这种情况在2006年左右结束，一个多核和多核处理器的新时代出现了。由于架构向并行处理的转变为多任务系统带来了性能提升，但是在不改变编程代码的情况下，并没有为大多数现有的单个应用程序带来性能提升。在这个新时代，GPU等加速器因为能够更高效的加速应用程序变得比以往任何时候都流行。这催生了一个异构计算时代，诞生了大量的具有自己的专业处理能力的加速器以及许多不同的编程模型。它们通过更加专业化的加速器设计可以在特定问题上提供更高性能的计算，因为它们不必去处理所有问题。这是一个经典的计算机架构权衡。它通常意味着加速器只能支持为处理器设计的编程语言的子集。事实上，在DPC++中，只有在内核中编写的代码才能在加速器中运行。<br>加速器架构可以分为几大类，这些类别会影响我们对编程模型、算法以及如何高效使用加速器的决策。例如，CPU是通用代码的最佳选择，包括标量和决策代码，并且通常内置向量加速器。GPU则是寻求加速向量和密切相关的张量。DSP寻求是以低延迟加速特定数学运算，通常用于处理手机的模拟信号等。AI加速器通常用于加速矩阵运算，尽管有些加速器也可能加速图。FPGA和ASIC特别适用于加速计算空间问题。</p>
<h3 id="4．为什么使用DPC"><a href="#4．为什么使用DPC" class="headerlink" title="4．为什么使用DPC++"></a>4．为什么使用DPC++</h3><p>一方面因为DPC++具有可移植性、高级性和非专有性，同时满足现代异构计算机体系结构的要求。另一方面，它可以让跨主机和计算设备的代码使用相同的编程环境，即现代C++的编程环境。最后，计算机体系结构的未来包括跨越标量、向量、矩阵和空间 (SVMS) 操作的加速器，需要对包括 SVMS 功能在内的异构机器的支持。并且这种支持应该涵盖高度复杂的可编程设备，以及可编程性较低的固定功能或专用的设备。</p>
<h1 id="Ⅲ-初探DPC"><a href="#Ⅲ-初探DPC" class="headerlink" title="Ⅲ 初探DPC++"></a>Ⅲ 初探DPC++</h1><p>在开始讨论现代C++语言在DPC++中的应用之前，让我们先看一遍完整的代码，顺便测试我们的实验环境：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CL/sycl.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sycl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelGPUSelector</span> : <span class="keyword">public</span> device_selector &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> device&amp; Device)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::string DeviceName = Device.<span class="built_in">get_info</span>&lt;info::device::name&gt;();</span><br><span class="line">    <span class="type">const</span> std::string DeviceVendor = Device.<span class="built_in">get_info</span>&lt;info::device::vendor&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Device.<span class="built_in">is_gpu</span>() &amp;&amp; (DeviceName.<span class="built_in">find</span>(<span class="string">&quot;Intel&quot;</span>) != std::string::npos) ? <span class="number">100</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IntelGPUSelector d;</span><br><span class="line">  <span class="function">queue <span class="title">q</span><span class="params">(d)</span></span>;</span><br><span class="line">  <span class="type">int</span>* data = <span class="built_in">malloc_shared</span>&lt;<span class="type">int</span>&gt;(N, q);</span><br><span class="line">  q.<span class="built_in">parallel_for</span>(N, [=](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">     data[i] = i;</span><br><span class="line">   &#125;).<span class="built_in">wait</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">free</span>(data, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行上面的代码，如果没有问题应该输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</span><br></pre></td></tr></table></figure>
<p>简单解释一下这段代码，sycl是DPC++的实体的命名空间，用<code>using namespace sycl;</code>打开命名空间可以简化后续代码。<code>IntelGPUSelector</code>是一个继承了<code>device_selector</code>的设备选择器，其中<code>device_selector</code>是纯虚类，它有个纯虚函数<code>int operator()(const device&amp; Device) const</code>需要派生类来实现，该函数会遍历计算机上的计算设备，并且返回使用设备的优先级，返回数字越高优先级越高，这里选择Intel的GPU作为首选的计算设备，注意这个函数使用了<code>override</code>来说明其目的是覆盖虚函数。<code>queue</code>的目的是指定工作的目标位置，这里设置的是Intel的GPU。函数模板<code>malloc_shared</code>分配了可在设备上使用的工作内存。成员函数<code>parallel_for</code>执行并行计算。值得注意的是<code>free</code>调用的是<code>sycl::free</code>而不是C运行时库的<code>free</code>。在这段代码中，比较明显使用了现在C++语法的地方是函数<code>parallel_for</code>的实参，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[=](<span class="keyword">auto</span> i) &#123; data[i] = i; &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个lambda表达式。<br>Ⅳ DPC++和lambda表达式<br>如果要选出一个对DPC++最重要的现代C++语言特性，我觉得lambda表达式应该可以被选上。因为在DPC++的代码中，内核代码一般都是以lambda表达式的形式出现。比如上面的例子就是将lambda表达式作为对象传入到Intel的GPU设备上然后进行计算的。在这个lambda表达式中，<code>[=]</code>是捕获列表，它可以捕获当前定义作用域内的变量的值，这也是它可以在函数体内使用<code>data[i]</code>的原因。捕获列表<code>[=]</code>之后的是形参列表<code>(auto i)</code>，注意这里的形参类型使用的是<code>auto</code>占位符，也就是说，我们将形参类型的确认工作交给了编译器。我们一般称这种lambda表达式为泛型lambda表达式。当然，如果在编译时选择C++20标准，我们还可以将其改为模板语法的泛型lambda表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[=]&lt;<span class="keyword">typename</span> T&gt;(T i) &#123; data[i] = i; &#125;</span><br></pre></td></tr></table></figure>
<p>lambda表达式的捕获列表功能非常强大，除了捕获值以外，还可以捕获引用，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[&amp;](<span class="keyword">auto</span> i) &#123; data[i] = i; &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会捕获当前定义作用域内的变量的引用，不过值得注意的是，由于这里的代码会交给加速核心运行，捕获引用并不是一个正确的做法，会导致编译出错。另外一般来说，我们并不推荐直接捕获所有可捕获的对象，而是有选择的捕获，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[data](<span class="keyword">auto</span> i) &#123; data[i] = i; &#125;</span><br></pre></td></tr></table></figure>
<p>当然，除了使用lambda表达式，我们也可以选择其他形式的代码来运行设备，比如使用仿函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AssginTest</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">auto</span> i)</span> <span class="type">const</span> </span>&#123; data_[i] = i; &#125;</span><br><span class="line">  <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AssginTest functor&#123;data&#125;;</span><br><span class="line">q.<span class="built_in">parallel_for</span>(N, functor).<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>
<p>但是很明显，这种方法没有使用lambda表达式来的简单直接。</p>
<h1 id="Ⅴ-DPC-和泛型能力"><a href="#Ⅴ-DPC-和泛型能力" class="headerlink" title="Ⅴ DPC++和泛型能力"></a>Ⅴ DPC++和泛型能力</h1><p>之所以能够让<code>parallel_for</code>这么灵活的接受各种形式的实参，是因为<code>parallel_for</code>本身是一个成员函数模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KernelName = detail::auto_name, <span class="keyword">typename</span> KernelType&gt;</span><br><span class="line">event <span class="built_in">parallel_for</span>(range&lt;<span class="number">1</span>&gt; NumWorkItems,</span><br><span class="line">                   _KERNELFUNCPARAM(KernelFunc) _CODELOCPARAM(&amp;CodeLoc)) &#123;</span><br><span class="line">  _CODELOCARG(&amp;CodeLoc);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parallel_for_impl</span>&lt;KernelName&gt;(NumWorkItems, KernelFunc, CodeLoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>KernelFunc</code>就是传入的lambda表达式或者仿函数，<code>KernelType</code>是<code>KernelFunc</code>的类型。<br>如果从这里的代码一路运行跟踪下去，会发现它们都是用模板传递实参类型，直到<code>submit_impl</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sycld.dll!cl::sycl::queue::submit_impl</span><br><span class="line">dpcpp.exe!cl::sycl::queue::submit</span><br><span class="line">dpcpp.exe!cl::sycl::queue::parallel_for_impl</span><br><span class="line">dpcpp.exe!cl::sycl::queue::parallel_for</span><br></pre></td></tr></table></figure>
<p>这是因为sycld.dll是一个二进制模块，它无法以模板的形式提供代码，所有的类型必须确定下来，为了解决这个问题，<code>cl::sycl::queue::submit_impl</code>使用了<code>std::function</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">event <span class="title">submit_impl</span><span class="params">(function_class&lt;<span class="type">void</span>(handler &amp;)&gt; CGH,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> detail::code_location &amp;CodeLoc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数模板<code>cl::sycl::queue::parallel_for_impl</code>将<code>KernelFunc</code>封装到另外一个lambda表达式对象中，并且通过<code>function_class&lt;void(handler &amp;)&gt;</code>来传递整个lambda表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KernelName = detail::auto_name, <span class="keyword">typename</span> KernelType,</span><br><span class="line">            <span class="type">int</span> Dims&gt;</span><br><span class="line">  event <span class="built_in">parallel_for_impl</span>(</span><br><span class="line">      range&lt;Dims&gt; NumWorkItems, KernelType KernelFunc,</span><br><span class="line">      <span class="type">const</span> detail::code_location &amp;CodeLoc = detail::code_location::<span class="built_in">current</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">submit</span>(</span><br><span class="line">        [&amp;](handler &amp;CGH) &#123;</span><br><span class="line">          CGH.<span class="keyword">template</span> <span class="built_in">parallel_for</span>&lt;KernelName, KernelType&gt;(NumWorkItems,</span><br><span class="line">                                                            KernelFunc);</span><br><span class="line">        &#125;,</span><br><span class="line">        CodeLoc);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>function_class</code>就是<code>std::function</code>。注意这里<code>CGH.template parallel_for</code>需要说明符<code>template</code>否则尖括号会解析出错。DPC++通过这样一系列的操作，最大限度的保留了用户编程的灵活性。</p>
<h1 id="Ⅵ-DPC-和模板推导"><a href="#Ⅵ-DPC-和模板推导" class="headerlink" title="Ⅵ DPC++和模板推导"></a>Ⅵ DPC++和模板推导</h1><p>DPC++代码中大量的运用了C++17标准才引入的模板推导特性，关于这些特性我们还是从一个DPC++的小例子开始：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IntelGPUSelector d;</span><br><span class="line">  <span class="function">queue <span class="title">q</span><span class="params">(d)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(N)</span></span>;</span><br><span class="line">  std::array&lt;<span class="type">int</span>, N&gt; v2;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">buffer <span class="title">buf1</span><span class="params">(v1)</span></span>;</span><br><span class="line">    <span class="function">buffer <span class="title">buf2</span><span class="params">(v2)</span></span>;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">      accessor <span class="built_in">a1</span>(buf1, h, write_only);</span><br><span class="line">      accessor <span class="built_in">a2</span>(buf2, h, write_only);</span><br><span class="line">      h.<span class="built_in">parallel_for</span>(N, [=](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">        a1[i] = i;</span><br><span class="line">        a2[i] = i;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) std::cout &lt;&lt; v1[i] &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码没有使用<code>malloc_shared</code>分配内存，取而代之的是使用<code>buffer</code>和<code>accessor</code>，其中<code>buffer</code>用于封装数据，<code>accessor</code>用于访问数据。这里以<code>buffer</code>为例解析DPC++对模板推导的使用。<br>首先观察buffer的两个实例，它们的构造函数的实参分别是<code>std::vector&lt;int&gt;</code>和<code>std::array&lt;int, N&gt;</code>类型。之所以能够这样调用构造函数，并不是因为<code>buffer</code>为这两个类型重载了它的构造函数，而是因为其构造函数使用了模板。这里涉及到一个C++17标准新特性——类模板的模板实参推导。在以往，类模板的实例化必须是显式传入模板实参，否则会造成编译出错。在新的标准中，类模板的模板实参已经可以根据构造函数来推导了。来看一下<code>buffer</code>的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> dimensions = <span class="number">1</span>,</span><br><span class="line">          <span class="keyword">typename</span> AllocatorT = cl::sycl::buffer_allocator,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="keyword">typename</span> detail::<span class="type">enable_if_t</span>&lt;(dimensions &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                                                  (dimensions &lt;= <span class="number">3</span>)&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> buffer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Container, <span class="type">int</span> N = dimensions,</span><br><span class="line">            <span class="keyword">typename</span> = EnableIfOneDimension&lt;N&gt;,</span><br><span class="line">            <span class="keyword">typename</span> = EnableIfContiguous&lt;Container&gt;&gt;</span><br><span class="line">  <span class="built_in">buffer</span>(Container &amp;container, AllocatorT allocator,</span><br><span class="line">         <span class="type">const</span> property_list &amp;propList = &#123;&#125;)</span><br><span class="line">      : <span class="built_in">Range</span>(<span class="built_in">range</span>&lt;<span class="number">1</span>&gt;(container.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    impl = std::<span class="built_in">make_shared</span>&lt;detail::buffer_impl&gt;(</span><br><span class="line">        container.<span class="built_in">data</span>(), <span class="built_in">get_count</span>() * <span class="built_in">sizeof</span>(T),</span><br><span class="line">        detail::<span class="built_in">getNextPowerOfTwo</span>(<span class="built_in">sizeof</span>(T)), propList,</span><br><span class="line">        make_unique_ptr&lt;detail::SYCLMemObjAllocatorHolder&lt;AllocatorT&gt;&gt;(</span><br><span class="line">            allocator));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>, <span class="type">int</span> N = dimensions,</span><br><span class="line">            <span class="keyword">typename</span> = EnableIfOneDimension&lt;N&gt;,</span><br><span class="line">            <span class="keyword">typename</span> = EnableIfContiguous&lt;Container&gt;&gt;</span><br><span class="line">  <span class="built_in">buffer</span>(Container &amp;container, <span class="type">const</span> property_list &amp;propList = &#123;&#125;)</span><br><span class="line">      : <span class="built_in">buffer</span>(container, &#123;&#125;, propList) &#123;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码<code>buffer buf1(v1);</code>会执行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">buffer</span>(Container &amp;container, <span class="type">const</span> property_list &amp;propList = &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这条构造函数，值得注意的是该构造函数并没有实际的实现代码，而是通过委托构造函数的方法调用了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">buffer</span>(Container &amp;container, AllocatorT allocator, <span class="type">const</span> property_list &amp;propList = &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>委托构造函数是C++11引入的特性，它可以让某个构造函数将构造的执行权交给另外的构造函数。回到模板推导，这里通过构造函数会推导出<code>Container</code>是<code>std::vector&lt;int&gt;，dimensions</code>的推导结果是1，而后面两个模板参数是用来检查前两个模板参数是否正确的，这里大量的使用了模板元编程的技巧：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> dims&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfOneDimension = <span class="keyword">typename</span> detail::<span class="type">enable_if_t</span>&lt;<span class="number">1</span> == dims&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfContiguous =</span><br><span class="line">    detail::<span class="type">void_t</span>&lt;detail::<span class="type">enable_if_t</span>&lt;std::is_convertible&lt;</span><br><span class="line">                       detail::<span class="type">remove_pointer_t</span>&lt;<span class="keyword">decltype</span>(</span><br><span class="line">                           std::<span class="built_in">declval</span>&lt;Container&gt;().<span class="built_in">data</span>())&gt; (*)[],</span><br><span class="line">                       <span class="type">const</span> <span class="built_in">T</span> (*)[]&gt;::value&gt;,</span><br><span class="line">                   <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;Container&gt;().<span class="built_in">size</span>())&gt;;</span><br></pre></td></tr></table></figure>
<p>首先它们都是使用using定义的别名模板，它们的目的分别是检查<code>dims</code>是否为1和<code>Container</code>是否为连续的。第一个别名模板很简单，直接检查<code>dims</code>是否为1，<code>detail::enable_if_t</code>就是<code>std::enable_if_t</code>。第二个检查连续性的方法稍微麻烦一些，简单来说就是检查容器对象的成员函数<code>data()</code>返回值的类型的数组指针是否能和<code>const T (*)[]</code>转换，这里主要检查两点，第一容器具有<code>data()</code>成员函数，第二返回类型的指针和<code>T const T (*)[]</code>转换。事实上，在标准容器中，只有连续容器有<code>data()</code>成员函数，其他的都会因为没有<code>data()</code>而报错，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no member named &#x27;data&#x27; in &#x27;std::list&lt;int&gt;&#x27;</span><br></pre></td></tr></table></figure>
<p>仔细阅读上面代码的朋友应该会发现另外一个问题，那就是没有任何地方可以帮助编译器推导出buffer的类模板形参T。这就不得不说DPC++将C++17关于模板推导的新特性用的淋漓尽致了。实际上在代码中，有这样一句用户自定义推导指引的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="built_in">buffer</span>(Container &amp;, <span class="type">const</span> property_list &amp; = &#123;&#125;)</span><br><span class="line">    -&gt;buffer&lt;<span class="keyword">typename</span> Container::value_type, <span class="number">1</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>用户自定义推导指引是指程序员可以指导编译器如何通过函数实参推导模板形参的类型。最后在这个例子中，需要注意一下，<code>buffer</code>在析构的时候才会将缓存的数据写到<code>v1</code>和<code>v2</code>，所以这里用了单独的作用域。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">buffer_impl</span>() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    BaseT::<span class="built_in">updateHostMemory</span>();</span><br><span class="line">  &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Ⅶ-总结"><a href="#Ⅶ-总结" class="headerlink" title="Ⅶ 总结"></a>Ⅶ 总结</h1><p>本篇文章从几个简单的DPC++的例子展开，逐步探究了DPC++对于现代C++语言特性的运用，其中比较重要的包括lambda表达式、泛型和模板推导，当然DPC++运用的新特性远不止这些。从另一方面来看，这些新特性的加入确实的帮助DPC++完成了过去无法完成的工作，这也是近几年C++的发展趋势，越来越多的代码库开始引入新的特性，并且有一些非常”神奇“的代码也孕育而生。DPC++就是其中之一，光是阅读DPC++中使用新特性的代码就已经足够让人拍案叫绝了，更何况还有代码的组织架构、底层的抽象等等。我知道，单单一篇文章并不能讨论清楚DPC++中现代C++语言的特性，所以王婆卖瓜的推荐自己写的书《<a target="_blank" rel="noopener" href="https://www.epubit.com/bookDetails?id=UB77e5a81975b11" title="现代C++语言核心特性解析">现代C++语言核心特性解析</a>》和盛格塾课程《现代C++42讲》，相信看完这本书或者经过课程训练后朋友们会对现代C++语言的特性有一个比较深入的理解。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<p>1.DPC++ Part 1: An Introduction to the New Programming Model [<a target="_blank" rel="noopener" href="https://simplecore-ger.intel.com/techdecoded/wp-content/uploads/sites/11/Webinar-Slides-DPC-Part-1-An-Introduction-to-the-New-Programming-Model-.pdf]">https://simplecore-ger.intel.com/techdecoded/wp-content/uploads/sites/11/Webinar-Slides-DPC-Part-1-An-Introduction-to-the-New-Programming-Model-.pdf]</a><br>2.Data Parallel C++: Mastering DPC++ for Programming of Heterogeneous Systems Using C++ and SYCL preview [<a target="_blank" rel="noopener" href="https://resource-cms.springernature.com/springer-cms/rest/v1/content/17382710/data/v1]">https://resource-cms.springernature.com/springer-cms/rest/v1/content/17382710/data/v1]</a><br>3.Intel® DevCloud [<a target="_blank" rel="noopener" href="https://software.intel.com/en-us/devcloud/oneapi]">https://software.intel.com/en-us/devcloud/oneapi]</a><br>4.New, Open DPC++ Extensions Complement SYCL and C++ [<a target="_blank" rel="noopener" href="https://insidehpc.com/2020/06/new-open-dpc-extensions-complement-sycl-and-c/]">https://insidehpc.com/2020/06/new-open-dpc-extensions-complement-sycl-and-c/]</a></p>
</blockquote>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2021/12/01/dpcpp/" data-id="cl81eyd1r00b8fkuvgo2dcz1n" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-module-ext" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/02/module-ext/">补编-模块(C++20)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/11/02/module-ext/" class="article-date"><time datetime="2021-11-02T05:24:45.000Z" itemprop="datePublished">2021-11-02</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>声明：这是一篇对《现代C++语言核心特性解析》中模块小节的补充，因为在我写模块的时间点实验环境并不理想，所以写的比较简单，也有读者提出了疑问，所以这里写一篇补充文来展示C++20中模块这个新特性。</p>
</blockquote>
<p>一直以来，在我的个人世界中，C++编译器就是最强大的编译器，它们灵活、稳定并且十分高效。但不幸的是，源代码引入方式的落后导致C++编译器在面对巨型工程的时候总是力不从心，如果读者编译过Chromium、QT、LLVM这种规模的项目应该知道我的意思。</p>
<h2 id="代码引入的问题"><a href="#代码引入的问题" class="headerlink" title="代码引入的问题"></a>代码引入的问题</h2><p>在解释C++代码引入的问题之前，我们先看一段这样一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一段最简单的“Hello world”的代码，算上空格和换行字符一共仅仅70个字符。但是编译器在编译这份代码的时候却不能只解析这70个字符，它还需要处理<code>&lt;iostream&gt;</code>这个头文件。处理头文件的方式和宏一样，预处理器会把这个头文件完整的替换到源代码中，并且重新扫描源代码再替换源代码中新增的<code>#include</code>的头文件，一直递归处理下去，直到所有的替换都完成。</p>
<p>我们可以使用GCC生成替换后的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -E -P test.cpp -o expand.cpp</span><br></pre></td></tr></table></figure>

<p>然后会发现整个expand.cpp文件有717192个字符！而我们的代码在这份代码中占据不到万分之一，但现实是这正是C++编译器需要处理的内容。事实上，大多数情况下编译器要处理的头文件内容要比原本的代码要多的多，真正我们自己编写的代码不到头文件的十分之一也是很常见的事情。一个更大的问题是，几乎所有的源代码都会包含一些头文件，比如标准库头文件，编译器不得不做巨量重复的工作。</p>
<p>像chromium这样的巨型项目会采用一些办法减少这种情况的出现，例如Jumbo&#x2F;Unity builds，原理上就是讲多个源文件包含在一个文件中，这样多次的递归替换就能够合并为一次，事实证明这种方式非常有效，chromium的编译时间缩减了50%。但是这种方式对于代码组织非常苛刻，稍有不慎就会造成编译错误。</p>
<p>原始的头文件替换出了造成了编译低效之外，还有一些问题是一个现代语言需要解决的，例如：难以做到组件化、无法做代码隔离、难以支持现代语义感知开发工具等。C++急需一种高效的新方式代替原始的代码替换。</p>
<h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p>事实上，C++委员会早就发现了这些问题，并且在2007年就逐步开展了研究工作，只不过进度非常缓慢，直到2018年C++委员会才确定了最终草案（微软提供的方案），并在C++20标准中引入了模块。</p>
<p>我们通常可以认为，一个程序是由一组翻译单元（Translated units）组合而成的。这些翻译单元在没有额外信息的情况下是互相独立的，要将他们联系到一起需要这些翻译单元声明外部名称，编译器和链接器就是通过这些外部名称把独立的翻译单元组合起来的，而模块就可以认为是一个或者一组独立的翻译单元以及一组外部名称的组合体。那么模块名（Module name）就是引用组合体符号，模块单元（Module unit）其实就是组合体的翻译单元，模块接口单元（Module interface unit）很显然就是组合体里的那一组外部名称。</p>
<p>正规来说，一个模块由模块单元组成，模块单元分为模块接口单元和模块实现单元（Module implementation unit）。另外一个模块可以有多个模块分区，模块分区也是模块单元，模块分区的目的是方便模块代码的组织。对于每个模块，必须有一个没有分区的模块接口单元，该模块单元称为主模块接口单元。 导入一个模块，实际上导入的就是主模块的接口。</p>
<h2 id="模块的语法"><a href="#模块的语法" class="headerlink" title="模块的语法"></a>模块的语法</h2><p>模块的语法应该算是非常简单的了，关键字包括<code>export</code>、<code>import</code>和<code>module</code>，其中<code>module</code>可以用来定义模块名、模块分区和模块片段，先来看看定义模块名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MyModule;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个名为<code>MyModule</code>的模块单元，但是请注意这个模块不能作为主模块接口单元，因为定义主模块接口单元必须加上<code>export</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br></pre></td></tr></table></figure>

<p>注意，我们以后可能会在一些库中看到如下命名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> std.core;</span><br></pre></td></tr></table></figure>

<p>这里的<code>std.core</code>是一个模块名，看上去表达的是标准库中的核心模块，<code>.</code>在其中表示层次关系，但是其注意，这里的<code>.</code>并没有任何的语法规定，它在这纯粹是为了一种层次。</p>
<p>在定义了模块名之后，就可以导出指定名称了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">bar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> baz &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用<code>export</code>说明符导出了变量、函数、类以及命名空间，这些名称都是可以导出的。其他源文件可以使用<code>import</code>说明符导入这些名称：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">import</span> MyModule;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = x + <span class="built_in">foo</span>() + <span class="built_in">bar</span>().<span class="built_in">run</span>() + baz::<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行上面的代码，y的最终结果为10。当然，每个名称都依次使用<code>export</code>导出并不方便，标准还提供了更加简洁的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> baz &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，没有<code>export</code>的名称是不能被<code>import</code>到其他源代码中的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">import</span> MyModule;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = x + <span class="built_in">foo</span>() + <span class="built_in">bar</span>().<span class="built_in">run</span>() + baz::<span class="built_in">foo</span>() + z; <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里test.cpp会编译报错，编译器会提示找不到标识符<code>z</code>。</p>
<p><code>import</code>说明符不仅能引入模块，也能引入头文件，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> baz &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; std::cout &lt;&lt; n; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">import</span> MyModule;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = x + <span class="built_in">foo</span>() + <span class="built_in">bar</span>().<span class="built_in">run</span>() + baz::<span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">print</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这里使用了<code>import</code>来引入<code>&lt;iostream&gt;</code>而不是使用<code>#include</code>。在模块单元中不要使用<code>#include</code>来引入头文件因为这样会导致这些内容成为模块单元的一部分。</p>
<p>另外还有一个地方需要特别注意，<code>import</code>进来的头文件是不会被源文件中的宏修改的，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OUTPUT_HELLO</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;world&quot;</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT_HELLO</span></span><br><span class="line"><span class="keyword">import</span> MyModule;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码在<code>test.cpp</code>中定义了宏<code>OUTPUT_HELLO</code>，然后<code>import</code>了<code>MyModule</code>模块，如果<code>OUTPUT_HELLO</code>能够影响引入的模块，那么运行结果输出<code>hello</code>，否则输出<code>world</code>。编译运行这段代码会发现最终结果为<code>world</code>，<code>import</code>的内容不受宏的影响。但是，如果确实有这样的需求该怎么做呢？标准提供了一种叫做模块片段机制，模块片段通常用来做一些配置相关的工作，它通过<code>module;</code>开始，注意这里的<code>module</code>后直接跟着分号而没有模块名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>;</span><br><span class="line"><span class="comment">// module fragment begin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOME_CONFIG 20211102</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;some_header&gt;</span></span></span><br><span class="line"><span class="comment">// module fragment end</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块片段还可以分为全局和私有，上面的代码编写的是全局的模块片段，要设置私有代码片段需要叫上<code>private</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> : <span class="keyword">private</span>;</span><br></pre></td></tr></table></figure>

<p>标准规定，私有模块片段只能出现在主模块接口单元中，并且具有私有模块片段的模块单元应是其模块的唯一模块单元。</p>
<p>最后，让我们来看一看什么是模块分区。如果要导出的模块内容很多，我们不能将所有的代码放到一个文件中，需要将其按照逻辑做合理的物理分割，这个时候就需要用到模块分区了，请看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// part1.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule:part1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_impl</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">foo_impl</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part2.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule:part2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mymodule.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> MyModule;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> :part1;</span><br><span class="line"><span class="keyword">import</span> :part2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">import</span> MyModule;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>part1.ixx</code>和<code>part1.ixx</code>的模块名分别为<code>MyModule:part1</code>和<code>MyModule:part2</code>，其中<code>MyModule</code>当然就是模块名，而紧跟在<code>:</code>后的名称则是它们的分区名。主模块接口单元可以通过<code>import</code>将模块分区合并到主模块接口单元中，并且无论模块分区是否导出了它的内容，它的内容都是对主模块接口单元可见的，所以<code>print</code>函数可以调用<code>bar</code>函数。</p>
<p>另外，主模块接口单元还可以决定直接导出分区定义的接口，比如代码中的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> :part1;</span><br></pre></td></tr></table></figure>

<p>这样模块分区<code>part1</code>的函数<code>foo</code>也成为了导出接口。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2021/11/02/module-ext/" data-id="cl81eyd1r00b2fkuv93at7j8g" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li class="disabled"><span class="page-prev"><i class="fa fa-chevron-left"></i> Prev</a></li><li class="active"><span class="page-number">1</span></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/18/">18</a></li><li><a class="page-next" rel="next" href="/page/2/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>https://github.com/0cch</p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CPP/">CPP</a><span class="sidebar-module-list-count">31</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/">Debugging</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">5</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/Tips/">Tips</a><span class="sidebar-module-list-count">7</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/DeepLearner/">DeepLearner</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MiniKernel/">MiniKernel</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">4</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TIPS/">TIPS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Tips/">Tips</a><span class="sidebar-module-list-count">70</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/debugging/">debugging</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/machinelearning/">machinelearning</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/File-System/" rel="tag">File System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/IDE/" rel="tag">IDE</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Kernel/" rel="tag">Kernel</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/MiniKernel/" rel="tag">MiniKernel</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTFS/" rel="tag">NTFS</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTInternals/" rel="tag">NTInternals</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTSTATUS/" rel="tag">NTSTATUS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/OS/" rel="tag">OS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/PIO/" rel="tag">PIO</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/System/" rel="tag">System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Test/" rel="tag">Test</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Volume/" rel="tag">Volume</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Windows/" rel="tag">Windows</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/grub/" rel="tag">grub</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/snapshot/" rel="tag">snapshot</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/File-System/" style="font-size: 10px;">File System</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Kernel/" style="font-size: 20px;">Kernel</a> <a href="/tags/MiniKernel/" style="font-size: 10px;">MiniKernel</a> <a href="/tags/NTFS/" style="font-size: 15px;">NTFS</a> <a href="/tags/NTInternals/" style="font-size: 10px;">NTInternals</a> <a href="/tags/NTSTATUS/" style="font-size: 10px;">NTSTATUS</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/PIO/" style="font-size: 10px;">PIO</a> <a href="/tags/System/" style="font-size: 10px;">System</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Volume/" style="font-size: 10px;">Volume</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/snapshot/" style="font-size: 10px;">snapshot</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/08/">August 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/07/">July 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/06/">June 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/05/">May 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/04/">April 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/03/">March 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/02/">February 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/01/">January 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/12/">December 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/11/">November 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/10/">October 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/09/">September 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/08/">August 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/06/">June 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/05/">May 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/04/">April 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/03/">March 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/02/">February 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/01/">January 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/12/">December 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/11/">November 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/10/">October 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/09/">September 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/08/">August 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/07/">July 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">June 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/05/">May 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/04/">April 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/03/">March 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/01/">January 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/12/">December 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/11/">November 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/07/">July 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/06/">June 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/05/">May 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">April 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">March 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">February 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">January 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">December 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">November 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">October 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">September 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">August 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">March 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">February 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">January 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">December 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/11/">November 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">October 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/09/">September 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">August 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">July 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">June 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/05/">May 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">April 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/03/">March 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/01/">January 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/12/">December 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/11/">November 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">October 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">September 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/08/">August 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/07/">July 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/06/">June 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/05/">May 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/04/">April 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/03/">March 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/02/">February 2016</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/01/">January 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/12/">December 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/11/">November 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/10/">October 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/09/">September 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/08/">August 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/07/">July 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/06/">June 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/05/">May 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/04/">April 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/03/">March 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/02/">February 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/01/">January 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/12/">December 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/11/">November 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/10/">October 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/09/">September 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/08/">August 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/07/">July 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/06/">June 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/05/">May 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/04/">April 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/03/">March 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/02/">February 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/01/">January 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/12/">December 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/11/">November 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/10/">October 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/09/">September 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/08/">August 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/07/">July 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/06/">June 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/05/">May 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/04/">April 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/03/">March 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/02/">February 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/01/">January 2013</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/12/">December 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/11/">November 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/08/">August 2012</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/02/">February 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/12/">December 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/10/">October 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/09/">September 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/08/">August 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/06/">June 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/05/">May 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/04/">April 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/02/">February 2011</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2022/08/21/k+&c++new-standard-details/">K+ 技术峰会之旅&amp;C++新标准细节简析</a>
        </li>
      
        <li>
          <a href="/2022/07/03/virtual-function-calls-in-constructors/">关于构造函数中调用虚函数</a>
        </li>
      
        <li>
          <a href="/2022/06/01/addition-to-rvo-and-copy-elimination/">返回值优化和拷贝消除的一点补充</a>
        </li>
      
        <li>
          <a href="/2022/05/02/use-async-with-caution/">谨慎使用std::async</a>
        </li>
      
        <li>
          <a href="/2022/04/12/pass-params/">值传参</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 0CCh<br>
      <a href="https://beian.miit.gov.cn/" target="_blank">鄂ICP备2022015101号</a><br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
