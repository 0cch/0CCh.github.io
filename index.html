<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>0CCh Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="0CCh Blog">
<meta property="og:url" content="https://0cch.com/index.html">
<meta property="og:site_name" content="0CCh Blog">
<meta property="og:locale">
<meta property="article:author" content="0CCh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="0CCh Blog" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class="active"
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">0CCh Blog</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-some-tips-about-weakptr" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/31/some-tips-about-weakptr/">关于std::weak_ptr使用的理解</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/10/31/some-tips-about-weakptr/" class="article-date"><time datetime="2022-10-30T17:05:30.000Z" itemprop="datePublished">2022-10-31</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>周末时候和朋友讨论一下C++的智能指针，突然发现虽然智能指针进入C++11标准库已经有十多年了，但是有些朋友对部分细节的理解还是比较局限，以<code>std::weak_ptr</code>为例，很多人的理解只是停留在避免<code>std::shared_ptr</code>出现相互引用，导致对象无法析构，内存无法释放的问题。<br>当然，并不是说这种用法有什么不对，恰恰相反，它是一个非常经典的使用场景。但是<code>std::weak_ptr</code>的使用场景或者说它诞生的理念却不仅仅是这些，如果没有更加透彻理解<code>std::weak_ptr</code>，也很难合理的使用<code>std::shared_ptr</code>。</p>
<p><code>std::weak_ptr</code>从概念上，它是一个智能指针，相对于<code>std::shared_ptr</code>，它对于引用的对象是“弱引用”的关系。简单来说，它并不“拥有”对象本身。<br>如果我们去类比生活中的场景，那么它可以是一个房地产中介。房地产中介并不拥有房子，但是我们有办法找到注册过的房产资源。在客户想要买房子的时候，它起初并不知道房子是否已经卖出了，它需要找到房主询问后再答复客户。<br><code>std::weak_ptr</code>做的事情几乎和房产中介是一模一样的。<code>std::weak_ptr</code>并不拥有对象，在另外一个<code>std::shared_ptr</code>想要拥有对象的时候，它并不能做决定，需要转化到一个<code>std::shared_ptr</code>后才能使用对象。所以<code>std::weak_ptr</code>只是一个“引路人”而已。</p>
<p>说了这么多，那么<code>std::weak_ptr</code>除了解决相互引用的问题，还能做什么？答案是：一切应该不具有对象所有权，又想安全访问对象的情况。<br>还是以互相引用的情况为例，通常的场景是：一个公司类可以拥有员工，那么这些员工就使用<code>std::shared_ptr</code>维护。另外有时候我们希望员工也能找到他的公司，所以也是用<code>std::shared_ptr</code>维护，这个时候问题就出来了。但是实际情况是，员工并不拥有公司，所以应该用<code>std::weak_ptr</code>来维护对公司的指针。<br>再举一个例子：我们要使用异步方式执行一系列的Task，并且Task执行完毕后获取最后的结果。所以发起Task的一方和异步执行Task的一方都需要拥有Task。但是有时候，我们还想去了解一个Task的执行状态，比如每10秒看看进度如何，这种时候也许我们会将Task放到一个链表中做监控。这里需要注意的是，这个监控链表并不应该拥有Task本身，放到链表中的Task的生命周期不应该被一个观察者修改。所以这个时候就需要用到<code>std::weak_ptr</code>来安全的访问Task对象了。</p>
<p>最后再来聊一个新手使用<code>std::weak_ptr</code>容易被坑的地方：对象资源竞争。以下代码在多线程程序中是存在很大风险的，因为<code>wp.expired()</code>和<code>wp.lock()</code>运行的期间对象可能被释放：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::weak_ptr&lt;SomeClass&gt; wp&#123; sp &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!wp.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">    wp.<span class="built_in">lock</span>()-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正确的做法是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = wp.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (sp) &#123;</span><br><span class="line">    sp-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::weak_ptr</code>的<code>lock</code>函数是一个原子操作。有趣的是，最开始的C++11标准是没有提到原子操作的，C++14标准才对这一点进行了补充，详细过程可以参考提案文档：<a target="_blank" rel="noopener" href="https://cplusplus.github.io/LWG/issue2316">LWG2316</a>。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/10/31/some-tips-about-weakptr/" data-id="cl9zbftnu0000mguvcuoj0421" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-c++summit&amp;sycl" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/30/c++summit&sycl/">2022全球C++及系统软件技术大会之旅</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/09/30/c++summit&sycl/" class="article-date"><time datetime="2022-09-30T09:02:45.000Z" itemprop="datePublished">2022-09-30</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TIPS/">TIPS</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>作为一个搞C++技术的人，9月的最后几天时间是值得开心的。因为由于疫情原因取消了一年的全球C++及系统软件技术大会，终于在9月28、29两天顺利开幕。虽然我的时间很紧张，28号下午才到，错过了开幕，29号急匆匆的昨晚演讲就离开上海，但是期间也和很多老朋友见面聊天。</p>
<p>这次C++大会因为有Intel oneAPI对我的赞助，演讲主体选择了异构计算相关的内容，主要是讲述通过sycl进行异构计算的方法，并且描述了dpc++编译器编译单一源代码的过程。对此有兴趣的朋友可以看看我分享的ppt，后续有机会可能会把分析内容总结为文章发表出来。</p>


	<div class="row">
    <embed src="/uploads/2022/09/c++2022.pdf" width="100%" height="550px" type="application/pdf">
	</div>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/09/30/c++summit&sycl/" data-id="cl9zbftnx0001mguvel5476ju" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-k+&amp;c++new-standard-details" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/21/k+&c++new-standard-details/">K+ 技术峰会之旅&amp;C++新标准细节简析</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/08/21/k+&c++new-standard-details/" class="article-date"><time datetime="2022-08-21T06:15:46.000Z" itemprop="datePublished">2022-08-21</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TIPS/">TIPS</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>这年头，参加一次线下技术大会实属不易，当然举办方就更加不容易了。这届K+大会举办地是深圳，好巧不巧，开幕前一周深圳出现疫情，大会临时将举办地点从迁移到没有疫情的区域，只用了一周时间，可想而知这个事情有多难。</p>
<p>到举办酒店后，确实能感受到举办方满满的诚意和热情，这让我是没想到的，尤其是举办方为了每个讲师准备了精美的伴手礼，我第一时间也发了朋友圈，表示了感谢。到酒店之后就没什么好说的了，这次演讲是第一天，这很好因为可以赶回家和家人度过周日。</p>
<p>回家的过程也很顺利，并没有弹窗，这也要归功于举办方提供的出行建议，周六的23点顺利到家，没有任何阻碍。</p>
<p>这次在大会上讲的主体是《C++新标准细节简析》，讲这个也没有什么特别的理由，就是觉得去讲一些大家都知道的东西，或者标准中一些重要的东西没什么意思，因为重要的大家都有所了解，所以想讲点细节，可能知道的人并不多。</p>
<p>最后再说一下K+大会的特点，大会主要还是以技术上层的东西居多，技术底层和技术细节相对较少，比如第一届的主体是云原生，第二届的主体是能效，而底层技术主要是张银奎老师出品的论坛，我有幸也是这个论坛的讲师之一。如果要提一个希望，那就是希望K+大会更加重视基础和底层，邀请更多做底层技术的专家参加到论坛。大厦不可能没有地基，所有看起来华丽的架构都需要底层的支持，反过来说有了底层的支持，华丽的上层技术才不会沦为虚无缥缈的表面繁荣。</p>
<p>我还是非常支持K+大会的，有这样的大会举办方我相信K+大会会成为国内最顶尖的技术会议之一。</p>
<p>最后，奉上K+大会的PPT：</p>


	<div class="row">
    <embed src="/uploads/2022/08/k+2022.pdf" width="100%" height="550px" type="application/pdf">
	</div>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/08/21/k+&c++new-standard-details/" data-id="cl81eyd1t00bkfkuv3qerar10" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-virtual-function-calls-in-constructors" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/03/virtual-function-calls-in-constructors/">关于构造函数中调用虚函数</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/07/03/virtual-function-calls-in-constructors/" class="article-date"><time datetime="2022-07-03T02:38:00.000Z" itemprop="datePublished">2022-07-03</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在我们学习C++编程的时候，通常都会被告诫：“不要在构造函数中调用虚函数”。为什么会有这样一条规则呢？从语法上来看，当构造函数的函数体执行的时候，该类的虚表和虚表指针应该已经准备就绪了，不会造成调用失败或者引发未定义行为，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()                &#123; std::cout &lt;&lt; <span class="string">&quot;A()\n&quot;</span>;      &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::foo()\n&quot;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;B()\n&quot;</span>;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::foo()\n&quot;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span>()        &#123; std::cout &lt;&lt; <span class="string">&quot;C()\n&quot;</span>; &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::foo()\n&quot;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，它的派生类不会在此时构造好虚表指针，不可能调用到派生类的虚函数，所以上述代码会有如下的执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">B::foo()</span><br><span class="line">C()</span><br></pre></td></tr></table></figure>

<p>这个结果显然是合理的，因为基类<code>B</code>在构造的时候，<code>C</code>还没有构造，这个时候调用<code>B</code>类的虚函数是安全的。那么回到开始的问题，为什么建议大家不要在构造函数中调用虚函数呢？我认为最重要的原因是他的行为跟通常使用虚函数的时候有一些差异，容易造成理解偏差。比如上面的代码，一般情况下，如果在<code>C</code>类构造完毕后调用<code>foo</code>函数，那么调用的必然是<code>C::foo()</code>这个函数。</p>
<p>另外，C++构造函数中调用虚函数和其他语言的行为也会有所不同，这也会造成程序员某种程度上的记忆偏差，最终导致程序设计出现问题。下面，我们以C#和Java为例来展示这种偏差：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Base</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;From base&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">Base</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;From derived&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> Derived();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行这份C#代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From derived</span><br></pre></td></tr></table></figure>

<p>再来看看Java的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">            Test();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;From base&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;From derived&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Program</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Program</span>();</span><br><span class="line">        Program.<span class="type">Derived</span> <span class="variable">d</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行这份代码，输出结果的和C#相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From derived</span><br></pre></td></tr></table></figure>

<p>由此可见，这些不同的结果确实容易影响到程序员的记忆。</p>
<p>最后值得一提的是，C++的这种处理从安全性上更好，这一点非常明显，无论是C#还是Java，在基类中调用派生类虚函数或者说调用被派生类重写的方法，执行的代码都会在派生类构造之前执行，造成未定义的行为。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/07/03/virtual-function-calls-in-constructors/" data-id="cl81eyd1t00bifkuv9a0ffgqq" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-addition-to-rvo-and-copy-elimination" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/01/addition-to-rvo-and-copy-elimination/">返回值优化和拷贝消除的一点补充</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/06/01/addition-to-rvo-and-copy-elimination/" class="article-date"><time datetime="2022-06-01T13:17:10.000Z" itemprop="datePublished">2022-06-01</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在我写的《现代C++语言核心特性解析》中有一个小节是讲解的返回值优化，在这篇文章中，我将对这部分内容进行一点补充，将更多细节展示出来。<br>首先还是来看看书中的这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;X ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">const</span> X&amp; x) &#123; std::cout &lt;&lt; <span class="string">&quot;X copy ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;X dtor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">X <span class="title">make_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x1;</span><br><span class="line">    <span class="keyword">return</span> x1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x2 = <span class="built_in">make_x</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码在开启和关闭拷贝消除的运行情况是不同的，不过书中只使用了两种情况讨论，但是实际上我漏掉了C++17关闭拷贝消除的情况，以下是正确的对比表格：</p>
<table>
<thead>
<tr>
<th>拷贝消除</th>
<th>C++14 关闭拷贝消除</th>
<th>C++17 关闭拷贝消除</th>
</tr>
</thead>
<tbody><tr>
<td>X ctor</td>
<td>X ctor</td>
<td>X ctor</td>
</tr>
<tr>
<td>X dtor</td>
<td>X copy ctor</td>
<td>X copy ctor</td>
</tr>
<tr>
<td></td>
<td>X dtor</td>
<td>X dtor</td>
</tr>
<tr>
<td></td>
<td>X copy ctor</td>
<td>X dtor</td>
</tr>
<tr>
<td></td>
<td>X dtor</td>
<td></td>
</tr>
<tr>
<td></td>
<td>X dtor</td>
<td></td>
</tr>
</tbody></table>
<p>可以看到C++17和C++14的行为是不同的。开启拷贝消除的很明显，优化让构造直接发生在<code>main</code>函数中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_x</span>(): # @<span class="built_in">make_x</span>()</span><br><span class="line">  push rbx</span><br><span class="line">  mov rbx, <span class="function">rdi</span></span><br><span class="line"><span class="function">  call <span class="title">X::X</span><span class="params">()</span> [base object constructor]</span></span><br><span class="line"><span class="function">  mov rax, rbx</span></span><br><span class="line"><span class="function">  pop rbx</span></span><br><span class="line"><span class="function">  ret</span></span><br><span class="line"><span class="function">main: # @main</span></span><br><span class="line"><span class="function">  push rbx</span></span><br><span class="line"><span class="function">  sub rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">  lea rdi, [rsp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function">  call make_x()</span></span><br></pre></td></tr></table></figure>
<p>C++14的行为也很明确，和书中介绍了一样，发生了三次构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_x</span>(): # @<span class="built_in">make_x</span>()</span><br><span class="line">  push r14</span><br><span class="line">  push rbx</span><br><span class="line">  push rax</span><br><span class="line">  mov rbx, rdi</span><br><span class="line">  mov r14, rsp</span><br><span class="line">  mov rdi, <span class="function">r14</span></span><br><span class="line"><span class="function">  call <span class="title">X::X</span><span class="params">()</span> [base object constructor]</span></span><br><span class="line"><span class="function">  mov rdi, rbx</span></span><br><span class="line"><span class="function">  mov rsi, r14</span></span><br><span class="line"><span class="function">  call <span class="title">X::X</span><span class="params">(X <span class="type">const</span>&amp;)</span> [base object constructor]</span></span><br><span class="line"><span class="function">  mov rdi, rsp</span></span><br><span class="line"><span class="function">  call X::~<span class="title">X</span><span class="params">()</span> [base object destructor]</span></span><br><span class="line"><span class="function">  mov rax, rbx</span></span><br><span class="line"><span class="function">  add rsp, 8</span></span><br><span class="line"><span class="function">  pop rbx</span></span><br><span class="line"><span class="function">  pop r14</span></span><br><span class="line"><span class="function">  ret</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">main: # @main</span></span><br><span class="line"><span class="function">  push rbx</span></span><br><span class="line"><span class="function">  sub rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">  mov rbx, rsp</span></span><br><span class="line"><span class="function">  mov rdi, rbx</span></span><br><span class="line"><span class="function">  call make_x()</span></span><br><span class="line"><span class="function">  lea rdi, [rsp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function">  mov rsi, rbx</span></span><br><span class="line"><span class="function">  call X::X(X const&amp;) [base object constructor]</span></span><br><span class="line"><span class="function">  mov rdi, rsp</span></span><br><span class="line"><span class="function">  call X::~X() [base object destructor]</span></span><br><span class="line"><span class="function">  lea rdi, [rsp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function">  call X::~X() [base object destructor]</span></span><br><span class="line"><span class="function">  xor eax, eax</span></span><br><span class="line"><span class="function">  add rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">  pop rbx</span></span><br><span class="line"><span class="function">  ret</span></span><br></pre></td></tr></table></figure>
<p>但是C++17的行为相对就比较奇怪了，关闭拷贝消除但并没有完全关闭：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_x</span>(): # @<span class="built_in">make_x</span>()</span><br><span class="line">  push r14</span><br><span class="line">  push rbx</span><br><span class="line">  push rax</span><br><span class="line">  mov rbx, rdi</span><br><span class="line">  mov r14, rsp</span><br><span class="line">  mov rdi, <span class="function">r14</span></span><br><span class="line"><span class="function">  call <span class="title">X::X</span><span class="params">()</span> [base object constructor]</span></span><br><span class="line"><span class="function">  mov rdi, rbx</span></span><br><span class="line"><span class="function">  mov rsi, r14</span></span><br><span class="line"><span class="function">  call <span class="title">X::X</span><span class="params">(X <span class="type">const</span>&amp;)</span> [base object constructor]</span></span><br><span class="line"><span class="function">  mov rdi, rsp</span></span><br><span class="line"><span class="function">  call X::~<span class="title">X</span><span class="params">()</span> [base object destructor]</span></span><br><span class="line"><span class="function">  mov rax, rbx</span></span><br><span class="line"><span class="function">  add rsp, 8</span></span><br><span class="line"><span class="function">  pop rbx</span></span><br><span class="line"><span class="function">  pop r14</span></span><br><span class="line"><span class="function">  ret</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">main: # @main</span></span><br><span class="line"><span class="function">  push rbx</span></span><br><span class="line"><span class="function">  sub rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">  lea rbx, [rsp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function">  mov rdi, rbx</span></span><br><span class="line"><span class="function">  call make_x()</span></span><br><span class="line"><span class="function">  mov rdi, rbx</span></span><br><span class="line"><span class="function">  call X::~X() [base object destructor]</span></span><br><span class="line"><span class="function">  xor eax, eax</span></span><br><span class="line"><span class="function">  add rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">  pop rbx</span></span><br><span class="line"><span class="function">  ret</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>只有两次构造，<code>x1</code>拷贝到临时对象，临时对象拷贝到<code>x2</code>的过程合并成了一次，也就是<code>x1</code>直接拷贝到了<code>x2</code>，这是为什么呢？<br>其实是因为C++17对临时对象进行了特殊规定：</p>
<blockquote>
<p>6.7.7 Temporary objects [class.temporary]</p>
<p>The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary objects.</p>
</blockquote>
<p>在提案文档p0135r1中也对拷贝消除的描述进行了修改（<a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html</a><br>）。</p>
<p>至此，我们已经了解了C++17关闭拷贝消除后的特殊情况的因由。最后补充一点，关于拷贝消除，除了在返回值上可以做优化，还有下面这些情况都可以进行优化，当然有一些优化是没有实现的：</p>
<blockquote>
<ol>
<li>return语句中返回类类型，返回对象类型和函数返回类型相同，并且要求类型是非易失且有自动存储周期的对象。</li>
<li>throw表达式，操作数类型也要求是非易失且有自动存储周期的对象，并且作用域不超过最内侧的try。</li>
<li>异常处理（其实就是try-catch中catch(){}），声明的对象如果和抛出对象类型相同，可以将声明对象看作抛出对象的别名，前提条件是这个对象在这个过程中除了构造和析构是不会被改变的。</li>
<li>在协程中，协程参数的拷贝可以被忽略，也就是直接引用参数本身，当然也有前提条件，就是在处理对象的过程中除了构造和析构是不会被改变的。</li>
</ol>
</blockquote>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/06/01/addition-to-rvo-and-copy-elimination/" data-id="cl81eyd1t00bgfkuvhqrqayy7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-use-async-with-caution" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/02/use-async-with-caution/">谨慎使用std::async</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/05/02/use-async-with-caution/" class="article-date"><time datetime="2022-05-02T12:09:08.000Z" itemprop="datePublished">2022-05-02</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p><code>std::async</code>是C++11标准引入的函数模板，它用于异步执行某些任务，通常在单独的线程或者线程池中运行，它会返回一个<code>std::future</code>用于等待和获取异步执行的结果。<br>为什么这里说需要谨慎使用呢？其实原因上面一句话也提到了，就是它可能是在单独的线程中运行的。那么躲过我们想并发执行多个异步任务，会导致系统产生多个线程，执行完任务后退出。熟悉操作系统的朋友应该知道，创建线程的操作是非常耗时的，它需要让系统进入到内核，并且执行很多进程和线程相关的操作，另外过多的线程并不能真正的做到异步，因为我们的CPU的执行单元是有限的。所以调用<code>std::async</code>是应该谨慎一些的。<br>接下来让我们看看三大编译器的<code>std::async</code>的实现：<br>首先来看GCC：<br><a target="_blank" rel="noopener" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/future">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/future</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Shared state created by std::async().</span></span><br><span class="line">  <span class="comment">// Starts a new thread that runs a function and makes the shared state ready.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _BoundFn, <span class="keyword">typename</span> _Res&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">__future_base</span>::_Async_state_impl <span class="keyword">final</span></span><br><span class="line">    : <span class="keyword">public</span> __future_base::_Async_state_commonV2</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">explicit</span></span><br><span class="line">    _Async_state_impl(_Args&amp;&amp;... __args)</span><br><span class="line">    : _M_result(<span class="keyword">new</span> _Result&lt;_Res&gt;()),</span><br><span class="line">      _M_fn&#123;&#123;std::forward&lt;_Args&gt;(__args)...&#125;&#125;</span><br><span class="line">    &#123;</span><br><span class="line">      _M_thread = std::thread&#123;&amp;_Async_state_impl::_M_run, <span class="keyword">this</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Must not destroy _M_result and _M_fn until the thread finishes.</span></span><br><span class="line">      <span class="comment">// Call join() directly rather than through _M_join() because no other</span></span><br><span class="line">      <span class="comment">// thread can be referring to this state if it is being destroyed.</span></span><br><span class="line">      ~_Async_state_impl()</span><br><span class="line">      &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_thread.<span class="built_in">joinable</span>())</span><br><span class="line">      _M_thread.<span class="built_in">join</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">void</span></span><br><span class="line">      _M_run()</span><br><span class="line">      &#123;</span><br><span class="line">    __try</span><br><span class="line">      &#123;</span><br><span class="line">        _M_set_result(_S_task_setter(_M_result, _M_fn));</span><br><span class="line">      &#125;</span><br><span class="line">    __catch (<span class="type">const</span> __cxxabiv1::__forced_unwind&amp;)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// make the shared state ready on thread cancellation</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(_M_result))</span><br><span class="line">          <span class="keyword">this</span>-&gt;_M_break_promise(std::<span class="built_in">move</span>(_M_result));</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">typedef</span> __future_base::_Ptr&lt;_Result&lt;_Res&gt;&gt; _Ptr_type;</span><br><span class="line">      _Ptr_type _M_result;</span><br><span class="line">      _BoundFn _M_fn;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>很显然使用了<code>std::thread</code>创建新线程。<br>然后再来看Clang：<br><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/future">https://github.com/llvm/llvm-project/blob/main/libcxx/include/future</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY future&lt;_Rp&gt;</span><br><span class="line">__make_async_assoc_state(_Fp&amp;&amp; __f)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;__async_assoc_state&lt;_Rp, _Fp&gt;, __release_shared_count&gt;</span><br><span class="line">        __h(<span class="keyword">new</span> __async_assoc_state&lt;_Rp, _Fp&gt;(_VSTD::forward&lt;_Fp&gt;(__f)));</span><br><span class="line">    _VSTD::<span class="built_in">thread</span>(&amp;__async_assoc_state&lt;_Rp, _Fp&gt;::__execute, __h.<span class="built_in">get</span>()).<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">future</span>&lt;_Rp&gt;(__h.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，采用了创建新线程的方法。<br>最后来看看MSVC提供的STL的实现：<br><a target="_blank" rel="noopener" href="https://github.com/microsoft/STL/blob/main/stl/inc/future">https://github.com/microsoft/STL/blob/main/stl/inc/future</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rx</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Task_async_state</span> : <span class="keyword">public</span> _Packaged_state&lt;_Rx()&gt; &#123;</span><br><span class="line">    <span class="comment">// class for managing associated synchronous state for asynchronous execution from async</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> _Mybase     = _Packaged_state&lt;_Rx()&gt;;</span><br><span class="line">    <span class="keyword">using</span> _State_type = <span class="keyword">typename</span> _Mybase::_State_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fty2</span>&gt;</span><br><span class="line">    _Task_async_state(_Fty2&amp;&amp; _Fnarg) : _Mybase(_STD forward&lt;_Fty2&gt;(_Fnarg)) &#123;</span><br><span class="line">        _Task = ::Concurrency::<span class="built_in">create_task</span>([<span class="keyword">this</span>]() &#123; <span class="comment">// do it now</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_Call_immediate();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Running = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~_Task_async_state() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123;</span><br><span class="line">        _Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Wait() <span class="keyword">override</span> &#123; <span class="comment">// wait for completion</span></span><br><span class="line">        _Task.<span class="built_in">wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _State_type&amp; _Get_value(<span class="type">bool</span> _Get_only_once) <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">// return the stored result or throw stored exception</span></span><br><span class="line">        _Task.<span class="built_in">wait</span>();</span><br><span class="line">        <span class="keyword">return</span> _Mybase::_Get_value(_Get_only_once);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ::Concurrency::task&lt;<span class="type">void</span>&gt; _Task;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，微软提供的<code>std::async</code>的实现好了一些，它使用了线程池来进行异步操作，这样效率会好不少。值得一提的是，这里使用的是微软提供Parallel Patterns Library (PPL)库，专门用于多线程和并行计算的，和Intel的TBB比较类似。<br>由此可见，如果需要大量使用异步操作执行任务，依赖<code>std::async</code>的效率是不太可靠的，我们最好是能够使用更高效的线程池的方案。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/05/02/use-async-with-caution/" data-id="cl81eyd1s00befkuv1iolcae8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-pass-params" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/12/pass-params/">值传参</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/04/12/pass-params/" class="article-date"><time datetime="2022-04-12T12:03:43.000Z" itemprop="datePublished">2022-04-12</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>我在大学里学C++的时候，印象最为深刻的是老师反复告诫我们，应该如何传递函数参数。为了避免发生不必要的内存拷贝和复杂的对象构造，一般来说对于复杂对象都会采取使用传递引用的方式，当然如果参数不会被改变，最好使用常量引用，只有一些基础类型可以通过值传递参数。<br>按照上述方式写代码确实不会任何问题，不过C++向来是一门追求极致的语言，在效率方面更是如此，所以在C++17引入了<code>std::string_view</code>，并且推荐使用值传递的方式作为参数来传递，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_sv_byval</span><span class="params">(std::string_view sv)</span> </span>&#123; <span class="keyword">return</span> sv.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码通过值来传递<code>std::string_view</code>，而不是通过引用，下面我们就来探讨为何这里更加推荐使用通过值来传递参数。<br>首先，也是最容易理解的一点，能够使用值传递<code>std::string_view</code>必然是因为它足够简单。它的典型的实现只有两个成员：指向常量字符串的指针和字符串大小。值得一提的是，<code>std::string_view</code>并不是C++17才出现在我们视野中的，实际上在chromium和llvm中，早就出现了类似的实现。在C++标准的草案也可以追述到2012年的n3442，当时<code>std::string_view</code>还被称为<code>string_ref</code>。后来到了2014年，经过了大约7个版本的修订，才有了我们今天看到的<code>std::string_view</code>。<br>我们当然不能因为<code>std::string_view</code>足够简单认为使用传值的方式比传递引用的方式高效，这需要我们拿出其他的证据。</p>
<h3 id="通过传值使用std-string-view可以消除引用中的内存操作"><a href="#通过传值使用std-string-view可以消除引用中的内存操作" class="headerlink" title="通过传值使用std::string_view可以消除引用中的内存操作"></a>通过传值使用std::string_view可以消除引用中的内存操作</h3><p>我们都知道，对象的拷贝是在caller中发生的，例如下面这两行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_str_byref</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_str_byval</span><span class="params">(std::string s)</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>在使用-O2的优化选项进行编译的情况下，他们生成的汇编代码是相同的，都是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ret_str_byref:</span><br><span class="line">  mov eax, DWORD PTR [rdi+<span class="number">8</span>]</span><br><span class="line">  ret</span><br><span class="line">ret_str_byval:</span><br><span class="line">  mov eax, DWORD PTR [rdi+<span class="number">8</span>]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>因为临时对象的拷贝在调用者函数中发生，所以这里不会有任何区别。可以看到，这里都使用了内存访问，访问了rdi+8的数据。这里如果我们使用<code>std::string_view</code>会如何呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_sv_byval</span><span class="params">(std::string_view sv)</span> </span>&#123; <span class="keyword">return</span> sv.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ret_sv_byval:</span><br><span class="line">  mov eax, edi</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>显然，这里直接使用了寄存器，没有涉及到任何内存的访问，这样访问效率必然是有所提升的。<br>引用的另一个劣势是，在一个不需要涉及内存的操作中，因为引用语义和内存相关，导致编译器会强行将对象设置在内存中，来看看下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">sv_call_val</span><span class="params">(std::string_view sv)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ret_sv_byval</span>(sv);&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">sv_call_ref</span><span class="params">(std::string_view sv)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ret_sv_byref</span>(sv);&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数非常简单，直接使用参数调用后续函数，不过编译后的代码截然不同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sv_call_val</span><br><span class="line">  jmp ret_sv_byval</span><br><span class="line">sv_call_ref</span><br><span class="line">  sub rsp, <span class="number">24</span></span><br><span class="line">  mov qword ptr [rsp + <span class="number">8</span>], rdi</span><br><span class="line">  mov qword ptr [rsp + <span class="number">16</span>], rsi</span><br><span class="line">  lea rdi, [rsp + <span class="number">8</span>]</span><br><span class="line">  call ret_sv_byref</span><br><span class="line">  add rsp, <span class="number">24</span></span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>可以看出，前者可以直接执行jmp，跳到目标函数。后者，也就是穿引用的函数，则是需要先将数据写到栈上，然后在调用函数，显然前者的效率更高。</p>
<h3 id="通过传值使用std-string-view可以帮助编译器进行优化"><a href="#通过传值使用std-string-view可以帮助编译器进行优化" class="headerlink" title="通过传值使用std::string_view可以帮助编译器进行优化"></a>通过传值使用std::string_view可以帮助编译器进行优化</h3><p>程序的编译优化并不是容易的事情，编译器要考虑非常多的因素，例如外部对内部的影响等。传值和传引用的区别在于，传递引用的对象可能会被其他外部因素干扰导致编译器没办法进行优化，但是传值就不存在这样的问题，因为传值是拷贝，不会被外部影响，编译器优化起来更加得心应手，来看看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_sv_byval</span><span class="params">(std::string_view sv, <span class="type">size_t</span>&amp; troublemaker)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> temp = troublemaker;</span><br><span class="line">    troublemaker++;</span><br><span class="line">    <span class="type">size_t</span> retval = sv.<span class="built_in">size</span>();</span><br><span class="line">    troublemaker = temp;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ret_sv_byref</span><span class="params">(<span class="type">const</span> std::string_view&amp; sv, <span class="type">size_t</span>&amp; troublemaker)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> temp = troublemaker;</span><br><span class="line">    troublemaker++;</span><br><span class="line">    <span class="type">size_t</span> retval = sv.<span class="built_in">size</span>();</span><br><span class="line">    troublemaker = temp;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个函数唯一的区别就是<code>sv</code>是传值还是传引用，看似没有太大区别，但是我们来看看汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ret_sv_byval</span><br><span class="line">  mov rax, rdi</span><br><span class="line">  ret</span><br><span class="line">ret_sv_byref</span><br><span class="line">  mov rcx, qword ptr [rsi]</span><br><span class="line">  lea rax, [rcx + <span class="number">1</span>]</span><br><span class="line">  mov qword ptr [rsi], rax</span><br><span class="line">  mov rax, qword ptr [rdi]</span><br><span class="line">  mov qword ptr [rsi], rcx</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>可以看到，前者就是简单了一条寄存器操作就返回了，<code>temp</code>和<code>troublemaker</code>都没有给函数带来任何影响。而后者就完全不同了，因为传递的是引用，即使是常量引用，也导致编译器无法对代码进行优化。因为对于编译器而言，并不知道<code>troublemaker</code>是否会对<code>sv</code>的内部有所影响，只能按照代码进行编译。<br>至此，我们可以得到结论是，对于简单对象，例如使用寄存器就能传递其数据的对象，我们可以使用传值的方式传递参数，例如简单的<code>std::pair</code>，<code>std::span</code>等等。当然比较复杂的对象，还是要使用传递引用的方式的。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/04/12/pass-params/" data-id="cl81eyd1s00bcfkuvd2me8kt5" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-oneapi-summary" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/08/oneapi-summary/">oneAPI 组件简介</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/03/08/oneapi-summary/" class="article-date"><time datetime="2022-03-08T00:00:31.000Z" itemprop="datePublished">2022-03-08</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在oneAPI的一系列的产品中，我首先要介绍的是DPC和它的编译器，因为这部分内容十分有趣。我们都知道，一个程序运行效率高低，跟语言本身和他的编译器是息息相关的，比如我们不能指望python的程序在算法和运行环境相同的情况下跑过C和C的程序。</p>
<p><img src="/uploads/2022/03/oneapi-summary-1.png" alt="组件"></p>
<p>Intel的DPC团队当然考虑到了这一点，DPC和他的编译器正是基于高效的C语言以及时下先进的编译器clang&#x2F;llvm的。在llvm的支持下，让DPC能够轻松的在不同的平台上使用。</p>
<p>DPC是基于标准C和SYCL的，也就是说，我们可以用C一种语言来编写各种加速平台的程序，这样就让程序员能脱离学习专属语言的麻烦。至于SYCL标准，DPC实际上在它的基础上也做了比较多的优化，方便程序员编写代码。</p>
<p>因为DPC++的编译器是基于clang&#x2F;llvm的，所以它也是一个开源的编译器，我们可以在Github上找到他的源代码。并且通过翻阅提交记录来初步了解编译器是怎么构建起来的，总的来说这是一个在前中后端都有进行开发的编译器。</p>
<p>oneAPI还提供了一套兼容性工具，这套工具可以将CUDA编写的代码转换为标准的c代码，便于使用DPC进行编译。不过需要注意的是，并不是所有的代码都可以。CUDA代码大约可以有90%到95%能够正确的转换为DPC++的代码，当然剩下的一部分会注释留白，让开发人员进行转换。这个转换工具会尽可能的转换出开发人员可读的源代码程序。</p>
<p><img src="/uploads/2022/03/oneapi-summary-2.png" alt="兼容性工具"></p>
<p><a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compatibility-tool.html#gs.zio9bm">dpc-compatibility-tool</a></p>
<p>感兴趣的朋友可以访问以上链接，这里有非常详细的代码和操作例子。</p>
<p>再来说一下oneAPI提供的API，使用API可以让除了C以外的语言也享受到oneAPI提供的强大的高性能计算功能。例如，DPC库，这个还是基于的C++，它是优化了C++标准算法，包括并行算法等，并且能够保证在不同的硬件平台上高效运行。另外，为了让开发人员快速学习，它基于的是pstl和boost.compute库。再例如oneDNN这个库，主要就是用来做深度学习框架的，在oneAPI里提供的tensorflow的底层就是由oneDNN做的支持。</p>
<p>oneAPI提供的库有很多，有兴趣的朋友可以直接上官网查看，会有非常详细的介绍。其实在了解oneAPI之前，我就用过这其中的TBB库，这是一个做并行编程和多线程的库，和微软的PPL很像。简单来说就是在使用这个库的时候，我们不需要关心线程本身，也不需要关心硬件环境使用多少线程效率最高，如何做线程调度效率最高，直接把任务扔到接口就行了，非常方便，即使不编写高性能计算程序的朋友也可以去了解一下。</p>
<p>要介绍的最后一部分是分析和调试工具，这一部分中的GDB，我想大家再熟悉不过，不过oneAPI提供的GDB是有一些不同的，它除了能调试普通程序，还支持通过双机来调试异构程序。也就是说，它可以调试到设备内核代码中。请注意，这里的内核不是指操作系统内核，而是在加速设备上执行代码。使用普通的调试器是无法做到这一点的，虽然看起来都像是C++的代码，但其实编译出的程序并不是像主机端的代码一样可调的。大家也可以试一试，如果使用普通的调试器对内核代码下断点，跑起来的程序是肯定不会中断下来的。</p>
<p>第二个工具是Advisor，这个工具可以对异构程序进行分析，并且提供优化建议，包括怎么使用内存，怎么使用多线程，怎么使用并发。这个工具我是用的不多，有兴趣的朋友还是可以看官方文档。</p>
<p><img src="/uploads/2022/03/oneapi-summary-3.png" alt="Vtune"></p>
<p>第三个工具是Vtune，这个工具就厉害了，我想做过性能优化的朋友肯定是用过的。这个工具在做性能优化方面并不局限于异构程序，其实很早之前我就接触过它了。它可以对程序性能的缺陷做非常系统的分析，包括IO，线程、内存、指令集的使用等等，分析的粒度可以从指令到代码行再到函数块，支持的架构从CPU、GPU到FPGA，总之做性能优化的朋友千万不要错过这个工具。</p>
<p>以上就是对Intel oneAPI的一个大概的介绍，想了解更多信息还是要访问<a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/overview.html">官网</a>，另外，如果有朋友想进一步的做实验，Intel还提供了DevCloud这样一个免费的实验平台给大家，有兴趣的朋友不妨一试。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/03/08/oneapi-summary/" data-id="cl81eyd1s00bafkuv1mm489u7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-k+2021" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/12/k+2021/">2021K+软件峰会PPT</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/02/12/k+2021/" class="article-date"><time datetime="2022-02-12T03:15:07.000Z" itemprop="datePublished">2022-02-12</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>去年K+上用的PPT，讲了一些跟C++20协程有关的内容，分享出来。</p>


	<div class="row">
    <embed src="/uploads/2022/02/k+2021.pdf" width="100%" height="550px" type="application/pdf">
	</div>



      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/02/12/k+2021/" data-id="cl81eyd1r00b6fkuv11zf1gak" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-summary" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/01/2021-summary/">2021小结</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2022/01/01/2021-summary/" class="article-date"><time datetime="2021-12-31T23:15:55.000Z" itemprop="datePublished">2022-01-01</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>这是一篇想到哪写到哪的流水账，和技术无关和工作无关，就是想写点东西。</p>
<p>让我想想从哪里开始写起，那就从春节开始说起吧，今年春节我们家贴了一副非常可爱的“牛转乾坤”春联。</p>
<p>熟悉我的朋友都知道今年我出版了一本书，也是我的第一本书，其实整个期间我是很忐忑的，所以从2020年的10月开始我对编辑小姐姐的催促就没有间断过。</p>
<p>2021年2月到3月书其实正经历二审和三审，当时我并不知道三审后才是校对，并且需要申请出版号，天真的以为5月之前书一定可以出版。后来才知道后面还有很多步骤，例如质量审查、申请图书出版号、封面设计等等，预想出版的时间从5月推迟到6月，然后又推迟到7月，最后一直推迟到了9月，当时真的只能安慰自己好事多磨。这些步骤中最令人抓狂的就是质量审查环节，因为我问不到进度，而且一旦质量审查没通过就得修正好再审查一次，相当消耗时间。我是真的希望能一次性通过质量审查，当然大家应该能猜到，谁也逃不过遵循墨菲定律，果然第一次质量审查是没有通过的，所以后来多花了将近一个月的时候修改并且通过质量审查。当然了，其实这并不是意见坏事，毕竟作为自己写的书，并且还是第一本，对它的质量要求是很高的，我希望我能拿出一本让读者满意的书，也不枉费4年的时间。</p>
<p>2021年中秋节，终于，我拿到自己写的书，我很难描述当时的心情，感觉和高考结束后有点类似，就是那种好像一切都结束了的感觉。没有表现的特别高兴，反而还有点惆怅，真的没办法形容。当然这种心情持续并不久，我就开始关心书的销量了，关心这个词可能用的并不准确，用担心也许会更好吧。幸运的是，这种心情也没持续多久，因为销量还挺不错的，一度还蹭上了当当计算机类新书榜前十，还是听鼓舞人心的。</p>
<p>在书出版了以后，我就开始了另外项目，也就是录一个系列的C++课程，这个课程在张银奎老实的盛格塾小程序上连载。我是一个口才普通的人，普通话也不算标准，所以录制课程对我来说调整其实挺大的。尤其是刚刚开始的时候，10分钟的课程我录制加剪辑可以耗上一下午。多亏爱人的工作和剪辑相关，给我在剪辑方面提供一些帮助，否则话的时间更久。不过熟能生巧这个事情到哪都是通用的，课程一共42讲，录到10讲以后速度明显快很多了，录过了35讲就基本上已经游刃有余了。而且这段时间感觉自己说话都变利索了不少。</p>
<p>生活的奇妙之处就是这样，每件事情有时候衔接的特别理想。在课程录制到倒数第二讲的时候，我开始了另外一件事情，就是11月去上海参加K+技术峰会。不得不说要感谢之前录制课程的经历，否则练习演讲估计得弄的我直翻白眼。整体来说这次上海之旅还算挺顺利的，除了回来后社区打电话来说上海闹疫情了，庆幸自己没在上海到处浪，这疫情也不知道什么时候是个头啊。</p>
<p>K+技术峰会结束后，Intel找到了我让我参加DPC++认证讲师培训，这也是个挺好的事情所以就参加了。当然培训最后也有考核，就是录一个课程“而已”，如果说半年前我还对这种事情很畏惧，那么现在已经轻车熟路了，果然是每一份付出都是有收获的，感谢自己的付出让自己变的更好了。</p>
<p>2021年的倒数第二天，出版社的杨社长又给我带来了一个好消息，是我获得异步社区的年度影响力作者，居然还有奖杯可以拿，可把我高兴坏了。</p>
<p>上面这些是我业余耗费最多精力的事情，也是我很重视的一些事情。当然2021年发生的事情远远不止这些，比如工作上取得了从未有过的收获，这也是巨大成就感的来源之一。不过最最最重要的是家里多了一个小成员，几乎每天回去都要和他折腾很久，每天都很累但是却很开心。</p>
<p>2021年对我来说是非常重要的一年，完成了很多以前想都没想过的事情，我觉得我可以把他称为我人生中最自豪的一年，果然很“牛转乾坤”。</p>
<p>2022年虎年希望自己在“牛转乾坤”之后再接再厉，福虎生旺、龙腾虎跃！</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://0cch.com/2022/01/01/2021-summary/" data-id="cl81eyd1r00b4fkuv8dzbab3k" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li class="disabled"><span class="page-prev"><i class="fa fa-chevron-left"></i> Prev</a></li><li class="active"><span class="page-number">1</span></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/18/">18</a></li><li><a class="page-next" rel="next" href="/page/2/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>https://github.com/0cch</p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/C/">C++</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CPP/">CPP</a><span class="sidebar-module-list-count">31</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/">Debugging</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">5</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/Tips/">Tips</a><span class="sidebar-module-list-count">7</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/DeepLearner/">DeepLearner</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MiniKernel/">MiniKernel</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">4</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TIPS/">TIPS</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Tips/">Tips</a><span class="sidebar-module-list-count">70</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/debugging/">debugging</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/machinelearning/">machinelearning</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/File-System/" rel="tag">File System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/IDE/" rel="tag">IDE</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Kernel/" rel="tag">Kernel</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/MiniKernel/" rel="tag">MiniKernel</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTFS/" rel="tag">NTFS</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTInternals/" rel="tag">NTInternals</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTSTATUS/" rel="tag">NTSTATUS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/OS/" rel="tag">OS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/PIO/" rel="tag">PIO</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/System/" rel="tag">System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Test/" rel="tag">Test</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Volume/" rel="tag">Volume</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Windows/" rel="tag">Windows</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/grub/" rel="tag">grub</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/snapshot/" rel="tag">snapshot</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/File-System/" style="font-size: 10px;">File System</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Kernel/" style="font-size: 20px;">Kernel</a> <a href="/tags/MiniKernel/" style="font-size: 10px;">MiniKernel</a> <a href="/tags/NTFS/" style="font-size: 15px;">NTFS</a> <a href="/tags/NTInternals/" style="font-size: 10px;">NTInternals</a> <a href="/tags/NTSTATUS/" style="font-size: 10px;">NTSTATUS</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/PIO/" style="font-size: 10px;">PIO</a> <a href="/tags/System/" style="font-size: 10px;">System</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Volume/" style="font-size: 10px;">Volume</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/snapshot/" style="font-size: 10px;">snapshot</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/10/">October 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/09/">September 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/08/">August 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/07/">July 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/06/">June 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/05/">May 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/04/">April 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/03/">March 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/02/">February 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/01/">January 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/12/">December 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/11/">November 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/10/">October 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/09/">September 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/08/">August 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/06/">June 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/05/">May 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/04/">April 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/03/">March 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/02/">February 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/01/">January 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/12/">December 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/11/">November 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/10/">October 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/09/">September 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/08/">August 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/07/">July 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">June 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/05/">May 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/04/">April 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/03/">March 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/01/">January 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/12/">December 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/11/">November 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/07/">July 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/06/">June 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/05/">May 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">April 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">March 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">February 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">January 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">December 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">November 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">October 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">September 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">August 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">March 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">February 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">January 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">December 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/11/">November 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">October 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/09/">September 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">August 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">July 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">June 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/05/">May 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">April 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/03/">March 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/01/">January 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/12/">December 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/11/">November 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">October 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">September 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/08/">August 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/07/">July 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/06/">June 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/05/">May 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/04/">April 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/03/">March 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/02/">February 2016</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/01/">January 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/12/">December 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/11/">November 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/10/">October 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/09/">September 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/08/">August 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/07/">July 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/06/">June 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/05/">May 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/04/">April 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/03/">March 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/02/">February 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/01/">January 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/12/">December 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/11/">November 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/10/">October 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/09/">September 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/08/">August 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/07/">July 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/06/">June 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/05/">May 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/04/">April 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/03/">March 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/02/">February 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/01/">January 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/12/">December 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/11/">November 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/10/">October 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/09/">September 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/08/">August 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/07/">July 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/06/">June 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/05/">May 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/04/">April 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/03/">March 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/02/">February 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/01/">January 2013</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/12/">December 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/11/">November 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/08/">August 2012</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/02/">February 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/12/">December 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/10/">October 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/09/">September 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/08/">August 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/06/">June 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/05/">May 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/04/">April 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/02/">February 2011</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2022/10/31/some-tips-about-weakptr/">关于std::weak_ptr使用的理解</a>
        </li>
      
        <li>
          <a href="/2022/09/30/c++summit&sycl/">2022全球C++及系统软件技术大会之旅</a>
        </li>
      
        <li>
          <a href="/2022/08/21/k+&c++new-standard-details/">K+ 技术峰会之旅&amp;C++新标准细节简析</a>
        </li>
      
        <li>
          <a href="/2022/07/03/virtual-function-calls-in-constructors/">关于构造函数中调用虚函数</a>
        </li>
      
        <li>
          <a href="/2022/06/01/addition-to-rvo-and-copy-elimination/">返回值优化和拷贝消除的一点补充</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 0CCh<br>
      <a href="https://beian.miit.gov.cn/" target="_blank">鄂ICP备2022015101号-1</a><br>
      <img src="/beian.png"/><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42010502001504" target="_blank">鄂公网安备 42010502001504号</a><br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
