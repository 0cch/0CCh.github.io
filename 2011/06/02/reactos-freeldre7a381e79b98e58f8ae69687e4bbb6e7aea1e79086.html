<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ReactOS-Freeldr磁盘及文件管理</title>
  <meta name="description" content="Freeldr提供了对fat12、fat32、fatx、ntfs等文件系统的只读功能。这部分代码主要集中在boot\freeldr\freeldr\fs\fs.c文件中。首先计算机加电后会把mbr读取到物理内存的0x7c00位置，mbr搜索活动分区并加载活动分区根目录下的Freeldr.sys文件。加载后跳入Fr...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://0cch.com/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086.html">
  <link rel="alternate" type="application/rss+xml" title="0CCh" href="http://0cch.com/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">0CCh</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>

    <div class="page-content">
      <div class="wrapper">
	  <div class="sidebar">
 <form class="search" method="GET" action="https://www.google.com.hk/search">
  <input type="text" name="as_q" class="search-query" placeholder="Search">
  <input type="hidden" name="as_sitesearch" value="0cch.com">
 </form>
 <div class="categories">
  <h3>Categories:</h3>
  <ul>
   
    
   
    
   
    
   
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
      <li><a class="page-link" href="/categories/debugging/index.html">debugging</a></li>
	  
    
   
    
	  
      <li><a class="page-link" href="/categories/ntinternals/index.html">ntinternals</a></li>
	  
    
   
    
	  
      <li><a class="page-link" href="/categories/tips/index.html">tips</a></li>
	  
    
   
    
	  
      <li><a class="page-link" href="/categories/minikernel/index.html">minikernel</a></li>
	  
    
   
  </ul>
 </div>
 <div class="categories">
  <h3>Archives:</h3>
  <ul>
   
   
    
	  
	  
    
   
    
	  
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2015/06/index.html">2015-06</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2015/05/index.html">2015-05</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2015/04/index.html">2015-04</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2015/03/index.html">2015-03</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2015/02/index.html">2015-02</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2015/01/index.html">2015-01</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/12/index.html">2014-12</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/11/index.html">2014-11</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/10/index.html">2014-10</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/09/index.html">2014-09</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/08/index.html">2014-08</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/07/index.html">2014-07</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/06/index.html">2014-06</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/05/index.html">2014-05</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/04/index.html">2014-04</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/03/index.html">2014-03</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/02/index.html">2014-02</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2014/01/index.html">2014-01</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/12/index.html">2013-12</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/11/index.html">2013-11</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/10/index.html">2013-10</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/09/index.html">2013-09</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/08/index.html">2013-08</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/07/index.html">2013-07</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/06/index.html">2013-06</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/05/index.html">2013-05</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/04/index.html">2013-04</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/03/index.html">2013-03</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/02/index.html">2013-02</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2013/01/index.html">2013-01</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2012/12/index.html">2012-12</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2012/11/index.html">2012-11</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2012/08/index.html">2012-08</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2012/02/index.html">2012-02</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2012/01/index.html">2012-01</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2011/12/index.html">2011-12</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2011/11/index.html">2011-11</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2011/10/index.html">2011-10</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2011/09/index.html">2011-09</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2011/08/index.html">2011-08</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2011/06/index.html">2011-06</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2011/05/index.html">2011-05</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2011/04/index.html">2011-04</a></li>
	  
    
   
    
	  
	  
	  <li><a class="page-link" href="/2011/02/index.html">2011-02</a></li>
	  
    
   
    
	  
	  
    
   
    
	  
	  
    
   
    
   
    
   
    
   
    
   
  </ul>
 </div>
</div>
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">ReactOS-Freeldr磁盘及文件管理</h1>
    <p class="post-meta">Jun 2, 2011 • cradiator</p>
  </header>

  <article class="post-content">
    <p>Freeldr提供了对fat12、fat32、fatx、ntfs等文件系统的只读功能。这部分代码主要集中在boot\freeldr\freeldr\fs\fs.c文件中。
首先计算机加电后会把mbr读取到物理内存的0x7c00位置，mbr搜索活动分区并加载活动分区根目录下的Freeldr.sys文件。加载后跳入Freeldr入口start。Freeldr进行32为初始化后跳入主初始化函数BootMain(boot\freeldr\freeldr\Freeldr.c)中。</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="n">VOID</span> <span class="nf">BootMain</span><span class="p">(</span><span class="n">LPSTR</span> <span class="n">CmdLine</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">......</span>
<span class="n">MachInit</span><span class="p">(</span><span class="n">CmdLine</span><span class="p">);</span>
<span class="n">FsInit</span><span class="p">();</span>
<span class="p">......</span>
<span class="n">RunLoader</span><span class="p">();</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>


BootMain会对硬件(MachInit)和文件系统(FsInit)进行检测和初始化。所有准备工作进行完毕后就会调用RunLoader进行系统的加载工作。
Fs初始化和DEVICE、FILEDATA结构
下面看一下文件系统的初始化 FsInit(boot\freeldr\freeldr\fs\fs.c)


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="n">VOID</span> <span class="nf">FsInit</span><span class="p">(</span><span class="n">VOID</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">ULONG</span> <span class="n">i</span><span class="p">;</span>
<span class="n">RtlZeroMemory</span><span class="p">(</span><span class="n">FileData</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">FileData</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_FDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">DeviceId</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">InitializeListHead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DeviceListHead</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>


FsInit初始化FileData数组。和一个和磁盘分区相关的链表DeviceListHead。
首先fs.c维护了一个MAX_FDS(60)大小的数组 static FILEDATA FileData[MAX_FDS];


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagDEVVTBL</span>
<span class="p">{</span>
<span class="n">ARC_CLOSE</span> <span class="n">Close</span><span class="p">;</span>
<span class="n">ARC_GET_FILE_INFORMATION</span> <span class="n">GetFileInformation</span><span class="p">;</span>
<span class="n">ARC_OPEN</span> <span class="n">Open</span><span class="p">;</span>
<span class="n">ARC_READ</span> <span class="n">Read</span><span class="p">;</span>
<span class="n">ARC_SEEK</span> <span class="n">Seek</span><span class="p">;</span>
<span class="n">LPCWSTR</span> <span class="n">ServiceName</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DEVVTBL</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagFILEDATA</span>
<span class="p">{</span>
<span class="n">ULONG</span> <span class="n">DeviceId</span><span class="p">;</span>            <span class="c1">// 文件所在磁盘的磁盘文件句柄, 同样也是FileData的索引
</span><span class="n">ULONG</span> <span class="n">ReferenceCount</span><span class="p">;</span>       <span class="c1">// 引用计数
</span><span class="k">const</span> <span class="n">DEVVTBL</span><span class="o">*</span> <span class="n">FuncTable</span><span class="p">;</span>    <span class="c1">// 对文件进行读写的指针
</span><span class="k">const</span> <span class="n">DEVVTBL</span><span class="o">*</span> <span class="n">FileFuncTable</span><span class="p">;</span> <span class="c1">// 对文件进行读写的函数数组
</span><span class="n">VOID</span><span class="o">*</span> <span class="n">Specific</span><span class="p">;</span>             <span class="c1">// 文件系统自定义指针
</span><span class="p">}</span> <span class="n">FILEDATA</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table>


每一个成功打开的文件会返回一个文件句柄，这个句柄实际上就是FileData数组的索引。所以每个打开的文件都有一个对应的FileData。这个结构就类似windows中的FILE_OBJECT
FileData中DeviceId是文件所在磁盘的句柄。这个句柄同样也是FileData数组的索引，通过这个句柄可以找到"磁盘文件"，对"磁盘文件"的读写就是直接对相应的磁盘或磁盘分区的读写。类似Windows中直接对磁盘分区进行CreateFile返回的句柄。"磁盘文件"的DeviceId没有意义。
ReferenceCount是该文件的引用计数。
FuncTable这是一个函数数组指针，里面存放了对文件进行读写、SEEK等操作的函数指针。
FileFuncTable只对"磁盘文件"有意义。当Freeldr确定了磁盘文件对应的分区的分区格式后，会把与分区格式相关的函数指针数组放到这个字段里面。如Fat12分区"磁盘文件"的FileFuncTable字段存放的就是FatFuncTable指针。
Specific存放于文件有关的结构。磁盘文件就是DISKCONTEXT指针，fat12下的文件就是FAT_FILE_INFO指针 等等。
之后是DeviceListHead，这是DEVICE结构的链表头


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagDEVICE</span>
<span class="p">{</span>
<span class="n">LIST_ENTRY</span> <span class="n">ListEntry</span><span class="p">;</span>        <span class="c1">// 链表节点
</span><span class="k">const</span> <span class="n">DEVVTBL</span><span class="o">*</span> <span class="n">FuncTable</span><span class="p">;</span>    <span class="c1">// 操作该分区的函数表
</span><span class="n">CHAR</span><span class="o">*</span> <span class="n">Prefix</span><span class="p">;</span>              <span class="c1">// 分区对应的ArcName
</span><span class="n">ULONG</span> <span class="n">DeviceId</span><span class="p">;</span>            <span class="c1">// FILEDATA中该分区对应的句柄
</span><span class="n">ULONG</span> <span class="n">ReferenceCount</span><span class="p">;</span>      <span class="c1">// 引用计数
</span><span class="p">}</span> <span class="n">DEVICE</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table>


用户电脑中的每一个硬盘和硬盘中的每一分区都对应了一个DEVICE结构。
FuncTable里面存放了对该分区进行读写等操作的指针，对于硬盘而言这个数组就是DiskVtbl。
Prefix是该分区或硬盘的ArcName。(如multi(0)disk(0)rdisk(0)partition(0))。Freeldr中的文件路径都是Arc形式的路径。而且0号分区代表整个硬盘，真正的分区从1号开始。如multi(0)disk(0)rdisk(0)partition(0)便代表第0块硬盘本身。multi(0)disk(0)rdisk(0)partition(1)代表第0块硬盘的第0个分区。
通过DeviceId字段可以找到该DEVICE的文件句柄。这个字段和FILEDATA相互配合，使系统可以遍历DEVICE结构快速找到某个分区的文件句柄。
DEVICE(磁盘及分区)的检测
上面说到Freeldr操作的路径都是存储在DEVICE结构中的ArcPath。那么这些DEVICE是怎么来的呢？
首先我们看一下DEVICE的注册函数，FsRegisterDevice(boot\freeldr\freeldr\fs\fs.c)


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="n">VOID</span> <span class="nf">FsRegisterDevice</span><span class="p">(</span><span class="n">CHAR</span><span class="o">*</span> <span class="n">Prefix</span><span class="p">,</span> <span class="k">const</span> <span class="n">DEVVTBL</span><span class="o">*</span> <span class="n">FuncTable</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">DEVICE</span><span class="o">*</span> <span class="n">pNewEntry</span><span class="p">;</span>
<span class="n">ULONG</span> <span class="n">dwLength</span><span class="p">;</span>
<span class="n">dwLength</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">Prefix</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">pNewEntry</span> <span class="o">=</span> <span class="n">MmHeapAlloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span> <span class="o">+</span> <span class="n">dwLength</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pNewEntry</span><span class="p">)</span>
<span class="k">return</span><span class="p">;</span>
<span class="n">pNewEntry</span><span class="o">-&gt;</span><span class="n">FuncTable</span> <span class="o">=</span> <span class="n">FuncTable</span><span class="p">;</span>
<span class="n">pNewEntry</span><span class="o">-&gt;</span><span class="n">ReferenceCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pNewEntry</span><span class="o">-&gt;</span><span class="n">Prefix</span> <span class="o">=</span> <span class="p">(</span><span class="n">CHAR</span><span class="o">*</span><span class="p">)(</span><span class="n">pNewEntry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">pNewEntry</span><span class="o">-&gt;</span><span class="n">Prefix</span><span class="p">,</span> <span class="n">Prefix</span><span class="p">,</span> <span class="n">dwLength</span><span class="p">);</span>
<span class="n">InsertHeadList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DeviceListHead</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pNewEntry</span><span class="o">-&gt;</span><span class="n">ListEntry</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>


这么函数非常简单。Prefix就是Arc路径，FuncTable是操作这个分区（磁盘）对应的函数数组。FsRegisterDevice生成了一个DEVICE结构，把ArcName和FuncTable复制进去。之后连入了DeviceListHead链表。
那么又是谁调用的FsRegisterDevice呢？是DetectBiosDisks(boot\freeldr\freeldr\arch\i386\hardware.c)函数。虽然这一部分已经不属于FS的范畴，还是在这里简单讲一下便于理解。这里我略去了不必要的代码。
DetectBiosDisks的调用顺序是 RunLoader -&gt; MachHwDetect (PcHwDetect)-&gt; DetectISABios -&gt; DetectBiosDisks


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><pre><span class="k">static</span> <span class="n">VOID</span>
<span class="nf">DetectBiosDisks</span><span class="p">(</span><span class="n">PCONFIGURATION_COMPONENT_DATA</span> <span class="n">BusKey</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BOOLEAN</span> <span class="n">BootDriveReported</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="n">ULONG</span> <span class="n">i</span><span class="p">;</span>
<span class="n">ULONG</span> <span class="n">DiskCount</span> <span class="o">=</span> <span class="n">GetDiskCount</span><span class="p">(</span><span class="n">BusKey</span><span class="p">);</span>
<span class="n">CHAR</span> <span class="n">BootPath</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="p">......</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DiskCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">ULONG</span> <span class="n">Size</span><span class="p">;</span>
<span class="n">CHAR</span> <span class="n">Identifier</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="p">......</span>
<span class="k">if</span> <span class="p">(</span><span class="n">BootDrive</span> <span class="o">==</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
<span class="n">BootDriveReported</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="cm">/* Get disk values */</span>
<span class="n">GetHarddiskIdentifier</span><span class="p">(</span><span class="n">Identifier</span><span class="p">,</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>


首先使用GetDiskCount从Freeldr注册表的System键中读取硬盘总数。System键的初始化在DetectSystem(freeldr\freeldr\arch\i386\hardware.c)中，一会儿再看。
于是进入一个for循环，为每个硬盘调用GetHarddiskIdentifier函数。在BIOS中硬盘号是从0x80开始的，所以GetHarddiskIdentifier的硬盘号加了0x80。
GetHarddiskIdentifier的作用是为制定硬盘生成一个唯一的ID，并通过Identifier参数返回。但这个函数名起得并不好，因为生成ID其实只是这个函数的功能之一。另外的一大功能是检测硬盘，并且为硬盘本身和硬盘分区调用FsRegisterDevice函数进行注册。通过这个注册后硬盘才能真正被文件系统识别。
freeldr\freeldr\arch\i386\hardware.c中


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74</pre></td><td class="code"><pre><span class="k">static</span> <span class="n">VOID</span>
<span class="nf">GetHarddiskIdentifier</span><span class="p">(</span><span class="n">PCHAR</span> <span class="n">Identifier</span><span class="p">,</span>
<span class="n">ULONG</span> <span class="n">DriveNumber</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">PMASTER_BOOT_RECORD</span> <span class="n">Mbr</span><span class="p">;</span>
<span class="n">ULONG</span> <span class="o">*</span><span class="n">Buffer</span><span class="p">;</span>
<span class="n">ULONG</span> <span class="n">i</span><span class="p">;</span>
<span class="n">ULONG</span> <span class="n">Checksum</span><span class="p">;</span>
<span class="n">ULONG</span> <span class="n">Signature</span><span class="p">;</span>
<span class="n">CHAR</span> <span class="n">ArcName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="n">PARTITION_TABLE_ENTRY</span> <span class="n">PartitionTableEntry</span><span class="p">;</span>
<span class="cm">/* Read the MBR */</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MachDiskReadLogicalSectors</span><span class="p">(</span><span class="n">DriveNumber</span><span class="p">,</span> <span class="mi">0ULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">DISKREADBUFFER</span><span class="p">))</span>
<span class="p">{</span>
<span class="n">DPRINTM</span><span class="p">(</span><span class="n">DPRINT_HWDETECT</span><span class="p">,</span> <span class="s">"Reading MBR failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONG</span><span class="o">*</span><span class="p">)</span><span class="n">DISKREADBUFFER</span><span class="p">;</span>
<span class="n">Mbr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PMASTER_BOOT_RECORD</span><span class="p">)</span><span class="n">DISKREADBUFFER</span><span class="p">;</span>
<span class="n">Signature</span> <span class="o">=</span> <span class="n">Mbr</span><span class="o">-&gt;</span><span class="n">Signature</span><span class="p">;</span>
<span class="n">DPRINTM</span><span class="p">(</span><span class="n">DPRINT_HWDETECT</span><span class="p">,</span> <span class="s">"Signature: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Signature</span><span class="p">);</span>
<span class="cm">/* Calculate the MBR checksum */</span>
<span class="n">Checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">Checksum</span> <span class="o">+=</span> <span class="n">Buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">Checksum</span> <span class="o">=</span> <span class="o">~</span><span class="n">Checksum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">DPRINTM</span><span class="p">(</span><span class="n">DPRINT_HWDETECT</span><span class="p">,</span> <span class="s">"Checksum: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Checksum</span><span class="p">);</span>
<span class="cm">/* Fill out the ARC disk block */</span>
<span class="n">reactos_arc_disk_info</span><span class="p">[</span><span class="n">reactos_disk_count</span><span class="p">].</span><span class="n">Signature</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">;</span>
<span class="n">reactos_arc_disk_info</span><span class="p">[</span><span class="n">reactos_disk_count</span><span class="p">].</span><span class="n">CheckSum</span> <span class="o">=</span> <span class="n">Checksum</span><span class="p">;</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">ArcName</span><span class="p">,</span> <span class="s">"multi(0)disk(0)rdisk(%lu)"</span><span class="p">,</span> <span class="n">reactos_disk_count</span><span class="p">);</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">reactos_arc_strings</span><span class="p">[</span><span class="n">reactos_disk_count</span><span class="p">],</span> <span class="n">ArcName</span><span class="p">);</span>
<span class="n">reactos_arc_disk_info</span><span class="p">[</span><span class="n">reactos_disk_count</span><span class="p">].</span><span class="n">ArcName</span> <span class="o">=</span>
<span class="n">reactos_arc_strings</span><span class="p">[</span><span class="n">reactos_disk_count</span><span class="p">];</span>
<span class="n">reactos_disk_count</span><span class="o">++</span><span class="p">;</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">ArcName</span><span class="p">,</span> <span class="s">"multi(0)disk(0)rdisk(%lu)partition(0)"</span><span class="p">,</span> <span class="n">DriveNumber</span> <span class="o">-</span> <span class="mh">0x80</span><span class="p">);</span>
<span class="n">FsRegisterDevice</span><span class="p">(</span><span class="n">ArcName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DiskVtbl</span><span class="p">);</span>
<span class="cm">/* Add partitions */</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">DiskReportError</span><span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">DiskGetPartitionEntry</span><span class="p">(</span><span class="n">DriveNumber</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PartitionTableEntry</span><span class="p">))</span>
<span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PartitionTableEntry</span><span class="p">.</span><span class="n">SystemIndicator</span> <span class="o">!=</span> <span class="n">PARTITION_ENTRY_UNUSED</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">ArcName</span><span class="p">,</span> <span class="s">"multi(0)disk(0)rdisk(%lu)partition(%lu)"</span><span class="p">,</span> <span class="n">DriveNumber</span> <span class="o">-</span> <span class="mh">0x80</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="n">FsRegisterDevice</span><span class="p">(</span><span class="n">ArcName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DiskVtbl</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DiskReportError</span><span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
<span class="cm">/* Convert checksum and signature to identifier string */</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Checksum</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Checksum</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Checksum</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Checksum</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Checksum</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Checksum</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Checksum</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[</span><span class="n">Checksum</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'-'</span><span class="p">;</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Signature</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Signature</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Signature</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Signature</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Signature</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Signature</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[(</span><span class="n">Signature</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hex</span><span class="p">[</span><span class="n">Signature</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'-'</span><span class="p">;</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>
<span class="n">Identifier</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>


函数首先使用MachDiskReadLogicalSectors读取指定硬盘的MBR。对于PC机而言MachDiskReadLogicalSectors使用int 13h中断实现对硬盘的读操作。里面包括了16、32位代码的互转，和本节内容无关，以后再做说明。
MBR结构为。详细信息可以参考(http://en.wikipedia.org/wiki/Master_boot_record)


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_MASTER_BOOT_RECORD</span>
<span class="p">{</span>
<span class="n">UCHAR</span>        <span class="n">MasterBootRecordCodeAndData</span><span class="p">[</span><span class="mh">0x1b8</span><span class="p">];</span>   <span class="cm">/* 0x000 */</span>
<span class="n">ULONG</span>        <span class="n">Signature</span><span class="p">;</span>          <span class="cm">/* 0x1B8 */</span>
<span class="n">USHORT</span>        <span class="n">Reserved</span><span class="p">;</span>          <span class="cm">/* 0x1BC */</span>
<span class="n">PARTITION_TABLE_ENTRY</span>   <span class="n">PartitionTable</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>        <span class="cm">/* 0x1BE */</span>
<span class="n">USHORT</span>        <span class="n">MasterBootRecordMagic</span><span class="p">;</span>        <span class="cm">/* 0x1FE */</span>
<span class="p">}</span> <span class="n">MASTER_BOOT_RECORD</span><span class="p">,</span> <span class="o">*</span><span class="n">PMASTER_BOOT_RECORD</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table>


GetHarddiskIdentifier在获取了Signature、计算了Checksum后 。
sprintf(ArcName, "multi(0)disk(0)rdisk(%lu)partition(0)", DriveNumber - 0x80);
FsRegisterDevice(ArcName, &amp;DiskVtbl);
生成对应硬盘的ArcName，使用FsRegisterDevice注册这块硬盘，这个函数我们已经看过。注意这里Partition为0，所以0号分区实际表示硬盘本身。
之后


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">DiskGetPartitionEntry</span><span class="p">(</span><span class="n">DriveNumber</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PartitionTableEntry</span><span class="p">))</span>
<span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PartitionTableEntry</span><span class="p">.</span><span class="n">SystemIndicator</span> <span class="o">!=</span> <span class="n">PARTITION_ENTRY_UNUSED</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">ArcName</span><span class="p">,</span> <span class="s">"multi(0)disk(0)rdisk(%lu)partition(%lu)"</span><span class="p">,</span> <span class="n">DriveNumber</span> <span class="o">-</span> <span class="mh">0x80</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="n">FsRegisterDevice</span><span class="p">(</span><span class="n">ArcName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DiskVtbl</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>


DiskGetParititionEntry将会解析DriveNumber对应磁盘的分区表，填充第i个分区的信息到PartitionTableEntry结构。如果分区存在则使用FsRegisterDevice注册分区。
使用刚才计算的CheckSum和Signature组合一个ID返回给调用者。其实这个ID没有被使用过。。。
最后看一下调用FsRegisterDevice时的第二个参数DiskVtbl


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">static</span> <span class="k">const</span> <span class="n">DEVVTBL</span> <span class="n">DiskVtbl</span> <span class="o">=</span> <span class="p">{</span>
<span class="n">DiskClose</span><span class="p">,</span>
<span class="n">DiskGetFileInformation</span><span class="p">,</span>
<span class="n">DiskOpen</span><span class="p">,</span>
<span class="n">DiskRead</span><span class="p">,</span>
<span class="n">DiskSeek</span><span class="p">,</span>
<span class="p">};</span><span class="w">
</span></pre></td></tr></tbody></table>


这里面包含了对磁盘扇区读写的全部函数。我们之后再介绍。
至此硬盘的及硬盘分区的注册完成。
执行完DetectBiosDisks后，DeviceListHead里面就存放了当前计算机所有的磁盘和分区对应的DEVICE结构。
文件系统的识别和文件的打开
这时Fs模块已经知道的硬盘数量，分区信息。下面来看看一个文件的打开流程。
首先，Freeldr使用的是Arc路径，IDE硬盘以multi(0)disk(0)rdisk(n)开头，文件也是以Arc路径表示的。打开文件的函数在Freeldr\Freeldr\fs\fs.c中。这函数比较长，我们分段阅读。
Freeldr\Freeldr\fs\fs.c


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></td><td class="code"><pre><span class="n">LONG</span> <span class="nf">ArcOpen</span><span class="p">(</span><span class="n">CHAR</span><span class="o">*</span> <span class="n">Path</span><span class="p">,</span> <span class="n">OPENMODE</span> <span class="n">OpenMode</span><span class="p">,</span> <span class="n">ULONG</span><span class="o">*</span> <span class="n">FileId</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">......</span>
<span class="o">*</span><span class="n">FileId</span> <span class="o">=</span> <span class="n">MAX_FDS</span><span class="p">;</span>
<span class="cm">/* Search last ')', which delimits device and path */</span>
<span class="n">FileName</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="sc">')'</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileName</span><span class="p">)</span>
<span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>
<span class="n">FileName</span><span class="o">++</span><span class="p">;</span>
<span class="cm">/* Count number of "()", which needs to be replaced by "(0)" */</span>
<span class="n">dwCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">FileName</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">')'</span><span class="p">)</span>
<span class="n">dwCount</span><span class="o">++</span><span class="p">;</span>
<span class="cm">/* Duplicate device name, and replace "()" by "(0)" (if required) */</span>
<span class="n">dwLength</span> <span class="o">=</span> <span class="n">FileName</span> <span class="o">-</span> <span class="n">Path</span> <span class="o">+</span> <span class="n">dwCount</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">dwCount</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">DeviceName</span> <span class="o">=</span> <span class="n">MmHeapAlloc</span><span class="p">(</span><span class="n">FileName</span> <span class="o">-</span> <span class="n">Path</span> <span class="o">+</span> <span class="n">dwCount</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DeviceName</span><span class="p">)</span>
<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">DeviceName</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">FileName</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="o">*</span><span class="n">q</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">')'</span><span class="p">)</span>
<span class="o">*</span><span class="n">q</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'0'</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="n">DeviceName</span> <span class="o">=</span> <span class="n">Path</span><span class="p">;</span>
<span class="p">......</span><span class="w">
</span></pre></td></tr></tbody></table>


这个函数有三个参数Path是文件名的Arc路径，如multi(0)disk(0)rdisk(0)partition(1)Freeldr.sys就表示C盘中的Freeldr.sys文件。
OpenMode是打开模式(OpenReadOnly、OpenReadWrite等)。
如果打开成功，文件句柄将通过FileId参数返回。
首先这一部分代码分理出Arc磁盘路径中的"()"替换成"(0)"并存入DeviceName中，如multi()disk()rdisk()partition(1)Freeldr.sys处理后，DeviceName将指向multi(0)disk(0)rdisk(0)partition(1)。注意这个DeviceName是不以NULL结尾的。。。这是个很蛋疼的设计。
FileName会指向Arc路径中的文件名部分，上面的例子将是Freeldr.sys。
文件打开分为两步，第一步是开个文件所在的设备、创建设备的句柄。第二部才是打开文件本身。
这里是第一步打开设备的代码。


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></td><td class="code"><pre><span class="p">......</span>
<span class="n">pEntry</span> <span class="o">=</span> <span class="n">DeviceListHead</span><span class="p">.</span><span class="n">Flink</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">pEntry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">DeviceListHead</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">pDevice</span> <span class="o">=</span> <span class="n">CONTAINING_RECORD</span><span class="p">(</span><span class="n">pEntry</span><span class="p">,</span> <span class="n">DEVICE</span><span class="p">,</span> <span class="n">ListEntry</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">Prefix</span><span class="p">,</span> <span class="n">DeviceName</span><span class="p">,</span> <span class="n">dwLength</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* OK, device found. It is already opened? */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">ReferenceCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* Search some room for the device */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">DeviceId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">DeviceId</span> <span class="o">&lt;</span> <span class="n">MAX_FDS</span><span class="p">;</span> <span class="n">DeviceId</span><span class="o">++</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FuncTable</span><span class="p">)</span>
<span class="k">break</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">DeviceId</span> <span class="o">==</span> <span class="n">MAX_FDS</span><span class="p">)</span>
<span class="k">return</span> <span class="n">EMFILE</span><span class="p">;</span>
<span class="cm">/* Try to open the device */</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FuncTable</span> <span class="o">=</span> <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">FuncTable</span><span class="p">;</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">FuncTable</span><span class="o">-&gt;</span><span class="n">Open</span><span class="p">(</span><span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">Prefix</span><span class="p">,</span> <span class="n">DeviceOpenMode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DeviceId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ESUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FuncTable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">FileName</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* Done, caller wanted to open the raw device */</span>
<span class="o">*</span><span class="n">FileId</span> <span class="o">=</span> <span class="n">DeviceId</span><span class="p">;</span>
<span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">ReferenceCount</span><span class="o">++</span><span class="p">;</span>
<span class="k">return</span> <span class="n">ESUCCESS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Try to detect the file system */</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span> <span class="o">=</span> <span class="n">FatMount</span><span class="p">(</span><span class="n">DeviceId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span><span class="p">)</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span> <span class="o">=</span> <span class="n">NtfsMount</span><span class="p">(</span><span class="n">DeviceId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span><span class="p">)</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span> <span class="o">=</span> <span class="n">Ext2Mount</span><span class="p">(</span><span class="n">DeviceId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* Error, unable to detect file system */</span>
<span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">FuncTable</span><span class="o">-&gt;</span><span class="n">Close</span><span class="p">(</span><span class="n">DeviceId</span><span class="p">);</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FuncTable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">return</span> <span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">DeviceId</span> <span class="o">=</span> <span class="n">DeviceId</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="n">DeviceId</span> <span class="o">=</span> <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">DeviceId</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">ReferenceCount</span><span class="o">++</span><span class="p">;</span>
<span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">pEntry</span> <span class="o">=</span> <span class="n">pEntry</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pEntry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">DeviceListHead</span><span class="p">)</span>
<span class="k">return</span> <span class="n">ENODEV</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table>


一个循环，遍历DEVICE链表，找到DEVICE-&gt;Prefix (磁盘、分区的Arc路径，上一节说过)和刚刚分解出来的DeviceName相等的节点。如果没有则函数直接失败。
找到DEVICE节点后判断DEVICE-&gt;ReferenceCount是否为0。这个代表该DEVICE被打开的次数，如果ReferenceCount不为0，说明DEVICE已经被打开。那个直接从Device-&gt;DeviceId中获得设备的文件句柄。可以看出无论打开一个设备多少次，只会有ReferenceCount的变化，而句柄都是相同的。所以如果设备打开两次，SEEK时会相互影响。读写之前最好重新调用SEEK函数。
当DEVICE-&gt;ReferenceCount为0时是Freeldr需要调用进行打开和文件系统的识别。我们仔细读读。


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="cm">/* Search some room for the device */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">DeviceId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">DeviceId</span> <span class="o">&lt;</span> <span class="n">MAX_FDS</span><span class="p">;</span> <span class="n">DeviceId</span><span class="o">++</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FuncTable</span><span class="p">)</span>
<span class="k">break</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">DeviceId</span> <span class="o">==</span> <span class="n">MAX_FDS</span><span class="p">)</span>
<span class="k">return</span> <span class="n">EMFILE</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table>


首先在FileData数组中找到空闲项，数组的索引即将成为设备句柄。


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="cm">/* Try to open the device */</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FuncTable</span> <span class="o">=</span> <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">FuncTable</span><span class="p">;</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">FuncTable</span><span class="o">-&gt;</span><span class="n">Open</span><span class="p">(</span><span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">Prefix</span><span class="p">,</span> <span class="n">DeviceOpenMode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DeviceId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ESUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FuncTable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">FileName</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* Done, caller wanted to open the raw device */</span>
<span class="o">*</span><span class="n">FileId</span> <span class="o">=</span> <span class="n">DeviceId</span><span class="p">;</span>
<span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">ReferenceCount</span><span class="o">++</span><span class="p">;</span>
<span class="k">return</span> <span class="n">ESUCCESS</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>


之后把DEVICE中存储的设别操作函数数组FuncTable赋值给对应FileData中的FuncTable。之后对该句柄的读写操作将直接传递给FileData.FuncTable中的函数。
调用FuncTable-&gt;Open打开设备。上面我们看过这个函数实际是freeldr\freeldr\arch\i386\hardware.c中的DiskOpen。
打开成功后，如果FileName（需要打开的文件名）为空，说明这次请求只打开设备，于是直接返回设备的句柄。
如果不为空，则下面开始识别分区格式，打开文件的操作。
在继续读ArcOpen函数前我们先看看DiskOpen在打开设备时都做了什么。


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></td><td class="code"><pre><span class="n">ArcOpen</span> <span class="o">-&gt;</span> <span class="n">DiskOpen</span> <span class="p">(</span><span class="n">freeldr</span><span class="err">\</span><span class="n">freeldr</span><span class="err">\</span><span class="n">arch</span><span class="err">\</span><span class="n">i386</span><span class="err">\</span><span class="n">hardware</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>
<span class="k">static</span> <span class="n">LONG</span> <span class="n">DiskOpen</span><span class="p">(</span><span class="n">CHAR</span><span class="o">*</span> <span class="n">Path</span><span class="p">,</span> <span class="n">OPENMODE</span> <span class="n">OpenMode</span><span class="p">,</span> <span class="n">ULONG</span><span class="o">*</span> <span class="n">FileId</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">......</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DissectArcPath</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">FileName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DriveNumber</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DrivePartition</span><span class="p">))</span>
<span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">DrivePartition</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* This is a CD-ROM device */</span>
<span class="n">SectorSize</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="n">SectorSize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">DrivePartition</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="n">DrivePartition</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DiskGetPartitionEntry</span><span class="p">(</span><span class="n">DriveNumber</span><span class="p">,</span> <span class="n">DrivePartition</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PartitionTableEntry</span><span class="p">))</span>
<span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>
<span class="n">SectorOffset</span> <span class="o">=</span> <span class="n">PartitionTableEntry</span><span class="p">.</span><span class="n">SectorCountBeforePartition</span><span class="p">;</span>
<span class="n">SectorCount</span> <span class="o">=</span> <span class="n">PartitionTableEntry</span><span class="p">.</span><span class="n">PartitionSectorCount</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Context</span> <span class="o">=</span> <span class="n">MmHeapAlloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DISKCONTEXT</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Context</span><span class="p">)</span>
<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
<span class="n">Context</span><span class="o">-&gt;</span><span class="n">DriveNumber</span> <span class="o">=</span> <span class="n">DriveNumber</span><span class="p">;</span>
<span class="n">Context</span><span class="o">-&gt;</span><span class="n">SectorSize</span> <span class="o">=</span> <span class="n">SectorSize</span><span class="p">;</span>
<span class="n">Context</span><span class="o">-&gt;</span><span class="n">SectorOffset</span> <span class="o">=</span> <span class="n">SectorOffset</span><span class="p">;</span>
<span class="n">Context</span><span class="o">-&gt;</span><span class="n">SectorCount</span> <span class="o">=</span> <span class="n">SectorCount</span><span class="p">;</span>
<span class="n">Context</span><span class="o">-&gt;</span><span class="n">SectorNumber</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">FsSetDeviceSpecific</span><span class="p">(</span><span class="o">*</span><span class="n">FileId</span><span class="p">,</span> <span class="n">Context</span><span class="p">);</span>
<span class="k">return</span> <span class="n">ESUCCESS</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>


这个函数非常简单，使用DissectArcPath根据设备的Arc路径分解出文件名FileName、BIOS驱动器号DriveNumber、和分区号DrivePartition（第0个分区的编号是1，0代表整个硬盘）
之后确定扇区大小，分区开始的扇区号、分区扇区数等信息，存入DISKCONTEXT结构。使用FsSetDeviceSpecific和FildId相关联。
还记得FILEDATA的结构么？FsSetDeviceSpecific就是填充里面的Specific指针 ：）


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="n">VOID</span> <span class="nf">FsSetDeviceSpecific</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">FileId</span><span class="p">,</span> <span class="n">VOID</span><span class="o">*</span> <span class="n">Specific</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FileId</span> <span class="o">&gt;=</span> <span class="n">MAX_FDS</span> <span class="o">||</span> <span class="o">!</span><span class="n">FileData</span><span class="p">[</span><span class="n">FileId</span><span class="p">].</span><span class="n">FuncTable</span><span class="p">)</span>
<span class="k">return</span><span class="p">;</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">FileId</span><span class="p">].</span><span class="n">Specific</span> <span class="o">=</span> <span class="n">Specific</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>


实际上DiskOpen的作用就是获得该设备（分区）的基本信息——BIOS驱动器号、扇区大小、开始扇区号、扇区数量和当前读写指针（SectorNumber）。生成DISKCONTENT结构使用FsSetDeviceSpecific和FileID绑定。
现在我们回到ArcOpen函数，希望你还记得 ：）


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="cm">/* Try to detect the file system */</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span> <span class="o">=</span> <span class="n">FatMount</span><span class="p">(</span><span class="n">DeviceId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span><span class="p">)</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span> <span class="o">=</span> <span class="n">NtfsMount</span><span class="p">(</span><span class="n">DeviceId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span><span class="p">)</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span> <span class="o">=</span> <span class="n">Ext2Mount</span><span class="p">(</span><span class="n">DeviceId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* Error, unable to detect file system */</span>
<span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">FuncTable</span><span class="o">-&gt;</span><span class="n">Close</span><span class="p">(</span><span class="n">DeviceId</span><span class="p">);</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FuncTable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">return</span> <span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">DeviceId</span> <span class="o">=</span> <span class="n">DeviceId</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table>


现在FileData[DeviceId]已经代表刚刚打开的设备了，开始挂载分区。啥叫挂载分区，就是让文件系统提供个接口，能让我们操作分区里面的文件。而这个接口就是个DEVVTBL指针，和直接操作硬盘的接口一样，只不过这次这个可以操作文件了。如果分区识别成功，XxxMount函数将会返回另外一个DEVVTBL指针数组，这个指针赋值给设备对象的FileFuncTable成员。使用这个指针数组就可以在文件级别操作了。比如打开freeldr.sys文件就可以调用FileData[DeviceId].FileFuncTable-&gt;open函数。FileFuncTable和FuncTable是不同的哦！ ：）
注意FileFuncTable其实是不直接使用的，这个指针的作用是为之后打开的文件对应的FileData.FileTable赋值。于是操作文件和操作磁盘都是用对应的FileData.FileTable，实现形式上的统一。而且这种架构还可以轻易的实现将一个文件虚拟成为一个分区，只要为文件对象调用XxxMount并且给FileFuncTable域赋值就可以了，非常易于扩展。Freeldr并没有实现这种功能，文件的FileData.FileFuncTable没有使用～
下面我们就来看看第二步，打开文件
首先为文件找一个空闲的FileData


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_FDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileData</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">FuncTable</span><span class="p">)</span>
<span class="k">break</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_FDS</span><span class="p">)</span>
<span class="k">return</span> <span class="n">EMFILE</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table>


跳过文件名开始的 "\" 字符


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">FileName</span> <span class="o">==</span> <span class="sc">'\\'</span><span class="p">)</span>
<span class="n">FileName</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table>


我们前面说的，为FileData.FuncTable赋值。FileData.DeviceId是文件所在分区的句柄。FuncTable内部函数将通过这个句柄调用读写分区内容，为用户提供文件的读写接口。


<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="n">FileData</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">FuncTable</span> <span class="o">=</span> <span class="n">FileData</span><span class="p">[</span><span class="n">DeviceId</span><span class="p">].</span><span class="n">FileFuncTable</span><span class="p">;</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">DeviceId</span> <span class="o">=</span> <span class="n">DeviceId</span><span class="p">;</span>
<span class="o">*</span><span class="n">FileId</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">FileData</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">FuncTable</span><span class="o">-&gt;</span><span class="n">Open</span><span class="p">(</span><span class="n">FileName</span><span class="p">,</span> <span class="n">OpenMode</span><span class="p">,</span> <span class="n">FileId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ESUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">FileData</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">FuncTable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="o">*</span><span class="n">FileId</span> <span class="o">=</span> <span class="n">MAX_FDS</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>


至此打开文件的操作结束。这里略去了XxxMount和文件的Open函数。以后再说。 ：）
</code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div></code></pre></div>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">0CCh</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>0CCh</li>
          <!--<li><a href="mailto:"></a></li>-->
		  <li><a href="/uploads/2011/02/1363142043-59.gif"><img alt="1363142043-59" src="/uploads/2011/02/1363142043-59.gif" width="161" height="22"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/0CCh">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">0CCh</span>
            </a>
          </li>
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">printf("I am programmer!");
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
