<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>0CCh</title>
    <description>printf(&quot;I am programmer!&quot;);
</description>
    <link>http://0cch.com/</link>
    <atom:link href="http://0cch.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 17 Mar 2016 13:48:08 +0800</pubDate>
    <lastBuildDate>Thu, 17 Mar 2016 13:48:08 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>查看消息窗口工具</title>
        <description>&lt;p&gt;我们都知道用Spy++去查看窗口句柄的相关信息，但是这款工具无法找到消息窗口(Message-Only Windows)。所以写了个查看消息窗口的工具，帮我排查一些这方面的问题。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2016/03/20160317120246.png&quot;&gt;&lt;img src=&quot;/uploads/2016/03/20160317120246.png&quot; alt=&quot;20160317120246&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载：&lt;a href=&quot;/uploads/2016/03/MsgOnlyWnd.zip&quot;&gt;MsgOnlyWnd&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 20:00:45 +0800</pubDate>
        <link>http://0cch.com/tips/2016/03/17/msg-wnd-view.html</link>
        <guid isPermaLink="true">http://0cch.com/tips/2016/03/17/msg-wnd-view.html</guid>
        
        
        <category>tips</category>
        
      </item>
    
      <item>
        <title>c06d007f异常的解决方法</title>
        <description>&lt;p&gt;c06d007f这个异常通常是在PE的延迟加载dll的时候发生的，加载器找不到对应的dll就会抛出这个异常。如果我们对这个异常不熟悉，按照常规方式去找上下文，那么结果肯定会让你失望。例如3.2526.1373.0版本的libcef在XP上运行的情况。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; kb
 # ChildEBP RetAddr  Args to Child              
00 0012f218 7c92d9ac 7c86449d d0000144 00000004 ntdll!KiFastSystemCallRet
01 0012f21c 7c86449d d0000144 00000004 00000000 ntdll!ZwRaiseHardError+0xc
02 0012f4a0 7c843892 0012f4c8 7c839b21 0012f4d0 kernel32!UnhandledExceptionFilter+0x628
03 0012f4a8 7c839b21 0012f4d0 00000000 0012f4d0 kernel32!BaseProcessStart+0x39
04 0012f4d0 7c9232a8 0012f5bc 0012ffe0 0012f5d4 kernel32!_except_handler3+0x61
05 0012f4f4 7c92327a 0012f5bc 0012ffe0 0012f5d4 ntdll!ExecuteHandler2+0x26
06 0012f5a4 7c92e46a 00000000 0012f5d4 0012f5bc ntdll!ExecuteHandler+0x24
07 0012f5a4 00000000 00000000 0012f5d4 0012f5bc ntdll!KiUserExceptionDispatcher+0xe
WARNING: Frame IP not in any known module. Following frames may be wrong.
08 0012fff4 004a991e 00000000 78746341 00000020 0x0
09 0012fff8 00000000 78746341 00000020 00000001 cefclient!pre_c_init+0xb9 [f:\dd\vctools\crt_bld\self_x86\crt\src\crtexe.c @ 261]

0:000&amp;gt; .cxr 0012f5d4;k
eax=0012f8a4 ebx=1314a58c ecx=00000000 edx=00000001 esi=0012f954 edi=68d60000
eip=00000000 esp=0012fff8 ebp=00000000 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
00000000 ??              ???
  *** Stack trace for last set context - .thread/.cxr resets it
 # ChildEBP RetAddr  
WARNING: Frame IP not in any known module. Following frames may be wrong.
00 0012fff4 004a991e 0x0
01 0012fff8 00000000 cefclient!pre_c_init+0xb9 [f:\dd\vctools\crt_bld\self_x86\crt\src\crtexe.c @ 261]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;直接看栈回溯或者通过设置cxr看栈回溯，并没有帮助我们找到什么有用的信息。&lt;/p&gt;

&lt;p&gt;这里要使用的方法是，利用异常的参数来找到具体延迟加载谁的时候发生了异常。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; .exr 0012f5bc 
ExceptionAddress: 7c812aeb (kernel32!RaiseException+0x00000053)
   ExceptionCode: c06d007f
  ExceptionFlags: 00000000
NumberParameters: 1
   Parameter[0]: 0012f918&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里的参数0，就是我们要找的目标，记录了出错时候ebp-0x30的数据，也就是含有关键信息的地方。让我们仔细看看：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; dds 0012f918
0012f918  00000024
0012f91c  1314a58c libcef!_DELAY_IMPORT_DESCRIPTOR_dbghelp_dll
0012f920  13181dbc libcef!_imp__SymGetSearchPathW
0012f924  12ebdd20 libcef!_sz_dbghelp_dll
0012f928  00000001
0012f92c  1314ac8e libcef!dxva2_NULL_THUNK_DATA_DLN+0x7e
0012f930  68d60000 dbghelp!_imp__CryptAcquireContextA &amp;lt;PERF&amp;gt; (dbghelp+0x0)
0012f934  00000000
0012f938  0000007f
0012f93c  1314c138 libcef!dxva2_NULL_THUNK_DATA_DLN+0x1528
0012f940  00000003
0012f944  00000000
0012f948  0012f9f8
0012f94c  11d17587 libcef!_tailMerge_dbghelp_dll+0xd
0012f950  0012f918
0012f954  13181dbc libcef!_imp__SymGetSearchPathW
0012f958  00000008
0012f95c  7c9301bb ntdll!RtlAllocateHeap+0xeac
0012f960  1019014e libcef!base::debug::`anonymous namespace&#39;::InitializeSymbols+0x9e [f:\stnts\browser\cef\ws\src\chromium\src\base\debug\stack_trace_win.cc @ 79]
0012f964  ffffffff
0012f968  00170880&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以清楚的看到加载器延迟加载SymGetSearchPathW的时候发生了问题。让我们进一步用depends工具验证一下&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2016/02/20160223003624.png&quot;&gt;&lt;img src=&quot;/uploads/2016/02/20160223003624.png&quot; alt=&quot;20160223003624&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，XP自带的dbghelp里没有SymGetSearchPathW这个导出函数。要解决这个异常，实际上就需要在运行目录里添加一个稍微新一点的dbghelp文件，我这里替换的是6.2.9200.16384的dbghelp，替换过后问题已经不再出现了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2016/02/20160223003711.png&quot;&gt;&lt;img src=&quot;/uploads/2016/02/20160223003711.png&quot; alt=&quot;20160223003711&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 23 Feb 2016 08:55:58 +0800</pubDate>
        <link>http://0cch.com/debugging/2016/02/23/delay-load-error.html</link>
        <guid isPermaLink="true">http://0cch.com/debugging/2016/02/23/delay-load-error.html</guid>
        
        
        <category>debugging</category>
        
      </item>
    
      <item>
        <title>调试器最早的中断应用程序的方法</title>
        <description>&lt;p&gt;这篇Blog分享一个Windbg的小技巧，就是让被调试程序更早的中断到调试器。熟悉Windbg的朋友都知道，用调试器运行程序，默认情况下都会中断到ntdll!LdrpDoDebuggerBreak。但是有时候我们会想去调试程序加载的过程，这个时候就需要我们更早的中断下来。那么这里就用利用到调试器最早接受到的调试事件了。CREATE_PROCESS_DEBUG_EVENT，这个调试事件是创建进程的时候进程发给调试器的，在这个时候，你甚至连ntdll都没有完成加载，这也导致ntdll的符号无法加载，很多有用的功能用不上。但幸运的是，虽然ntdll没有完成加载，但是已经加载到了内存，另外我们可以用手动加载符号的方法，把符号文件加载到ntdll的内存上去。&lt;/p&gt;

&lt;p&gt;演示如下：&lt;/p&gt;

&lt;p&gt;windbg.EXE -xe cpr -xe ld notepad.exe&lt;/p&gt;

&lt;p&gt;这里设置中断系统事件cpr，也就是CREATE_PROCESS_DEBUG_EVENT&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; lm
start             end                 module name
00007ff7`3f6e0000 00007ff7`3f721000   notepad    (deferred)             
0:000&amp;gt; !teb
TEB at 000000d995d21000
error InitTypeRead( TEB )...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;中断下来后我们可以看到，!teb是没法用的&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; .imgscan
MZ at 00007ff7`3f6e0000, prot 00000002, type 01000000 - size 41000
  Name: notepad.exe
MZ at 00007ffb`7c7b0000, prot 00000002, type 01000000 - size 1c1000
  Name: ntdll.dll
0:000&amp;gt; .reload /f ntdll.dll=00007ffb`7c7b0000&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们需要找到ntdll的模块，然后手动加载符号，然后就可以使用和ntdll有关系的命令了。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; lm
start             end                 module name
00007ff7`3f6e0000 00007ff7`3f721000   notepad    (deferred)             
00007ffb`7c7b0000 00007ffb`7c971000   ntdll      (pdb symbols)          e:\workspace\mysymbols\ntdll.pdb\F296699DB5314A06935E88564D8CD2731\ntdll.pdb

0:000&amp;gt; !teb
TEB at 000000d995d21000
    ExceptionList:        0000000000000000
    StackBase:            000000d995af0000
    StackLimit:           000000d995adf000
    SubSystemTib:         0000000000000000
    FiberData:            0000000000001e00
    ArbitraryUserPointer: 0000000000000000
    Self:                 000000d995d21000
    EnvironmentPointer:   0000000000000000
    ClientId:             0000000000001c8c . 00000000000017c4
    RpcHandle:            0000000000000000
    Tls Storage:          0000000000000000
    PEB Address:          000000d995d20000
    LastErrorValue:       0
    LastStatusValue:      0
    Count Owned Locks:    0
    HardErrorMode:        0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 01 Feb 2016 21:15:03 +0000</pubDate>
        <link>http://0cch.com/debugging/2016/02/01/app-cpr-event.html</link>
        <guid isPermaLink="true">http://0cch.com/debugging/2016/02/01/app-cpr-event.html</guid>
        
        
        <category>debugging</category>
        
      </item>
    
      <item>
        <title>总结和展望：转折的一年</title>
        <description>&lt;p&gt;过去的2015年应该是我工作和生活中的一个大转折。&lt;/p&gt;

&lt;p&gt;这一年里，我选择从北京回到了武汉。这件事情上还是需要一些魄力的，最主要的就是收入拦腰截断，剩下原来的二分之一。其次发展空间上也不能和帝都相提并论。就拿接到猎头电话这件事情上说，回来大半年里，猎头电话一个接一个，但是绝大部分都是北京打来的。不过，在家乡有父母，有亲戚，有未婚妻，这种“交换”也是值得的，毕竟我不能期待什么都能得到。回来后，健身依然在坚持，只不过没有跑步机，还是觉得缺少了很多东西。自己的兴趣方面，MiniKernel，编译器和虚拟机依旧没什么进展，有一种写不动了的感觉，有进展的依旧是小工具合集，有些工具增加了一些新的功能，比如everything_study就优化了算法，现在查找速度已经和everthing看不出区别了。今年最美好的事情就是求婚，最悲催的事情就是学车。求婚对每个人来说想必都是最美好的事情，这个自然不必多说。至于学车，也是找了个不靠谱的驾校，被坑的不轻。幸运的是自己对车接受的比较快，没被教练坑的太惨，科目一到科目三都是满分通过，现在就剩下科目四了，春节前就把驾照给拿了。另外IXWebhosting这个主机我也不准备用了，换成GitHub Page来当blog，过段时间把0CCh.net这个域名也转移的godaddy算了。&lt;/p&gt;

&lt;p&gt;新的2016将会是一个真正新的开始！我将在这一年组建自己的小家，要买车，要装修房子。工作上希望武汉的互联网大环境会更好，希望我的劳动能给公司带来更高的价值。健身方面，我打算在新家里买上一个跑步机，过时如同北京时那样的健康生活。另外，练字也应该继续。兴趣方面，小工具集可以继续壮大，MiniKernel，编译器和虚拟机中，我更倾向多花时间写写编译器。&lt;/p&gt;

&lt;p&gt;另外，好友初步完成了自己的梦想，去美国工作了。很羡慕，祝福他能扎根那边，别回来吸雾霾了=v=。&lt;/p&gt;

&lt;p&gt;最后，还是祝愿家人，朋友，在新的2016健健康康，平平安安，开开心心，财源广进！&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Jan 2016 20:22:08 +0800</pubDate>
        <link>http://0cch.com/2016/01/11/2016-zjzw.html</link>
        <guid isPermaLink="true">http://0cch.com/2016/01/11/2016-zjzw.html</guid>
        
        
      </item>
    
      <item>
        <title>C++异常的参数分析(0xE06D7363)</title>
        <description>&lt;p&gt;Visual C++ 的编译器用0xE06D7363表示C++异常。 0xE06D7363表示的意思就是.msc。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:025&amp;gt; .formats 0xE06D7363
Evaluate expression:
  Hex:     e06d7363
  Decimal: -529697949
  Octal:   34033271543
  Binary:  11100000 01101101 01110011 01100011
  Chars:   .msc
  Time:    ***** Invalid
  Float:   low -6.84405e+019 high 0
  Double:  1.86029e-314&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抛出异常代码的同时，还会带有三个到四个参数：&lt;br /&gt;
参数0是一个magic code，一般为0x19930520，我们不用管他&lt;br /&gt;
参数1是时异常抛出的对象指针&lt;br /&gt;
参数2是抛出异常的基本信息&lt;br /&gt;
参数3是抛出异常的模块基址(只有64位的程序才会有这个参数)，该基址加上异常信息的偏移才能获得信息的真正内存地址。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:025&amp;gt; .exr -1
ExceptionAddress: 75c8c41f (KERNELBASE!RaiseException+0x00000058)
   ExceptionCode: e06d7363 (C++ EH exception)
  ExceptionFlags: 00000001
NumberParameters: 3
   Parameter[0]: 19930520
   Parameter[1]: 09c9f324
   Parameter[2]: 6b5d0298&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6b5d0298就是我们想要取得的信息，信息存储的格式为_s__ThrowInfo。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:025&amp;gt; dt 6b5d0298 ole32!_s__ThrowInfo
   +0x000 attributes       : 0
   +0x004 pmfnUnwind       : 0x6b523b50     void  +0
   +0x008 pForwardCompat   : (null) 
   +0x00c pCatchableTypeArray : 0x6b5d028c _s__CatchableTypeArray&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后可以取得pCatchableTypeArray，我们可以从中获取抛出异常的类型信息。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:025&amp;gt; dt 0x6b5d028c ole32!_s__CatchableTypeArray -r1
   +0x000 nCatchableTypes  : 0n2
   +0x004 arrayOfCatchableTypes : [0] 0x6b5d0270 _s__CatchableType
      +0x000 properties       : 0
      +0x004 pType            : 0x6b5e58f0 _TypeDescriptor
      +0x008 thisDisplacement : _PMD
      +0x014 sizeOrOffset     : 0n48
      +0x018 copyFunction     : 0x6b523cc0        void  +0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;到这里我们就取得了类型的描述结构体了，最后就能从中获取抛出的异常类型&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:025&amp;gt; dt 0x6b5e58f0 ole32!_TypeDescriptor
   +0x000 pVFTable         : 0x6b5c36e8 Void
   +0x004 spare            : (null) 
   +0x008 name             : [0]  &quot;.?AVinterprocess_exception@interprocess@boost@@&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 07 Dec 2015 05:57:50 +0800</pubDate>
        <link>http://0cch.com/debugging/2015/12/07/cpp-exception-params.html</link>
        <guid isPermaLink="true">http://0cch.com/debugging/2015/12/07/cpp-exception-params.html</guid>
        
        
        <category>debugging</category>
        
      </item>
    
      <item>
        <title>gotcha sdk 全盘文件名搜索开发库</title>
        <description>&lt;p&gt;想必大家都知道著名的全盘搜索工具everything，它极速的搜索速度让人眼前一亮。虽然everything提供了SDK，但是SDK是通过IPC的方式，获得everything程序里的数据。也就是说想在自己的程序中使用搜索功能那么必须带everything的主程序，这就是我开发gotcha sdk的主要原因，他能集成到程序当中，不需要依赖其他主程序，只需要你的程序是管理员权限运行，因为这样才能直接访问磁盘数据。另外网上也有一些关于everything原理和实现的代码，但是大部分都有问题，比如崩溃，死锁，内存占用过高等，并不适合直接用到产品当中。而gotcha sdk在自己开发了everything_study，并且使用了相当长的时间，解决性能，内存占用，死锁等问题的基础上提炼出来的开发库，我对其稳定性还是比较有信心的。&lt;/p&gt;

&lt;p&gt;利用gotcha sdk，既可以开发出everything_study这样用C++写的程序，也能够开发出如gotcha sdk的sample里的gotcha，一个C#编写的全盘搜索程序，该程序也展示了gotcha sdk的用法。&lt;/p&gt;

&lt;p&gt;gotcha sdk的用法非常简单，详细情况可以参考sample里的simple例子，该例子展示了sdk最简单的使用方式，我下一篇blog会介绍这套sdk的用法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2015/11/20151124233627.png&quot;&gt;&lt;img src=&quot;/uploads/2015/11/20151124233627.png&quot; alt=&quot;20151124233627&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;gotcha sdk 代码SVN:
&lt;a href=&quot;http://code.taobao.org/svn/gotcha_sdk/&quot;&gt;http://code.taobao.org/svn/gotcha_sdk/&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 25 Nov 2015 07:43:26 +0800</pubDate>
        <link>http://0cch.com/ntinternals/2015/11/25/gotcha-sdk.html</link>
        <guid isPermaLink="true">http://0cch.com/ntinternals/2015/11/25/gotcha-sdk.html</guid>
        
        
        <category>ntinternals</category>
        
      </item>
    
      <item>
        <title>程序初始化失败DUMP分析</title>
        <description>&lt;p&gt;拿到程序初始化失败的DUMP，一般情况下我们看到的栈是这个样子的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; kb
ChildEBP RetAddr  Args to Child              
0012fc7c 7c92d9ca 7c972b53 c0000145 00000001 ntdll!KiFastSystemCallRet
0012fc80 7c972b53 c0000145 00000001 00000000 ntdll!NtRaiseHardError+0xc
0012fca4 7c960f9f c0000005 0012fd30 00370034 ntdll!LdrpInitializationFailure+0x2d
0012fd1c 7c92e457 0012fd30 7c920000 00000000 ntdll!_LdrpInitialize+0x1f9
00000000 00000000 00000000 00000000 00000000 ntdll!KiUserApcDispatcher+0x7

0:000&amp;gt; !error c0000145
Error code: (NTSTATUS) 0xc0000145 (3221225797) - {Application Error}  The application was unable to start correctly (0x%lx). Click OK to close the application.

0:000&amp;gt; !error c0000005
Error code: (NTSTATUS) 0xc0000005 (3221225477) - The instruction at 0x%p referenced memory at 0x%p. The memory could not be %s.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到最后报错是c0000145，应用程序无法运行。而引起出错的是LdrpInitializationFailure，出错原因内存访问异常。但是具体是哪出错还不无法从此刻的栈看到，我们需要进一步分析。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; dds esp-1000 esp
...
0012f3c0  7c92e920 ntdll!_except_handler3
0012f3c4  00000001
0012f3c8  0012f470
0012f3cc  0012fd0c
0012f3d0  7c953fdc ntdll!RtlDispatchException+0xb1
0012f3d4  0012f470
0012f3d8  0012fd0c
0012f3dc  0012f48c
0012f3e0  0012f444
0012f3e4  7c92e920 ntdll!_except_handler3
0012f3e8  003d3810 someapp!PostMsg+0x27aa0
0012f3ec  0012f470
0012f3f0  b36caf32
0012f3f4  00153960
0012f3f8  7c93e584 ntdll!DbgPrint+0x1c
0012f3fc  00150178
0012f400  000000e8
0012f404  00000668
0012f408  00150000
0012f40c  0012f204
0012f410  7c940571 ntdll!RtlCreateActivationContext+0x2c
0012f414  c0000000
0012f418  00153960
0012f41c  003f0000
0012f420  00000000
0012f424  0012f444
0012f428  7c940610 ntdll!RtlCreateActivationContext+0xed
0012f42c  001539b4
0012f430  00000002
0012f434  00000008
0012f438  00000000
0012f43c  00000000
0012f440  00000000
0012f444  0012f750
0012f448  7c814880 kernel32!CreateActCtxW+0x75c
0012f44c  00130000
0012f450  0012d000
0012f454  00000000
0012f458  0012f76c
0012f45c  7c92e48a ntdll!KiUserExceptionDispatcher+0xe
0012f460  00000000
0012f464  0012f48c
0012f468  0012f470
0012f46c  0012f48c
0012f470  c0000005
0012f474  00000000
0012f478  00000000
0012f47c  7c93ccf2 ntdll!LdrpHandleOneOldFormatImportDescriptor+0x21
0012f480  00000002
0012f484  00000000
0012f488  d16cca32
0012f48c  0001003f
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里我们就可以看到异常发生的栈了。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; .exr 0012f470
ExceptionAddress: 7c93ccf2 (ntdll!LdrpHandleOneOldFormatImportDescriptor+0x00000021)
   ExceptionCode: c0000005 (Access violation)
  ExceptionFlags: 00000000
NumberParameters: 2
   Parameter[0]: 00000000
   Parameter[1]: d16cca32
Attempt to read from address d16cca32

0:000&amp;gt; .cxr 0012f48c
eax=003a0000 ebx=00253010 ecx=d132ca32 edx=00033810 esi=b36caf32 edi=003d3810
eip=7c93ccf2 esp=0012f758 ebp=0012f76c iopl=0         nv up ei ng nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010282
ntdll!LdrpHandleOneOldFormatImportDescriptor+0x21:
7c93ccf2 833c0800        cmp     dword ptr [eax+ecx],0 ds:0023:d16cca32=????????
0:000&amp;gt; kb
  *** Stack trace for last set context - .thread/.cxr resets it
ChildEBP RetAddr  Args to Child              
0012f76c 7c93ccc4 7ffd9000 00020498 00253010 ntdll!LdrpHandleOneOldFormatImportDescriptor+0x21
0012f784 7c93bc1e 7ffd9000 00020498 00253010 ntdll!LdrpHandleOldFormatImportDescriptors+0x1f
0012f800 7c93d216 00020498 00253010 00434398 ntdll!LdrpWalkImportDescriptor+0x19e
0012fa50 7c93cd1d 00020498 004396ca 00400000 ntdll!LdrpLoadImportModule+0x1c8
0012fa80 7c93ccc4 7ffd9000 00020498 00251ec0 ntdll!LdrpHandleOneOldFormatImportDescriptor+0x5e
0012fa98 7c93bc1e 7ffd9000 00020498 00251ec0 ntdll!LdrpHandleOldFormatImportDescriptors+0x1f
0012fb14 7c9418b5 00020498 00251ec0 7ffdf000 ntdll!LdrpWalkImportDescriptor+0x19e
0012fc94 00000000 0012fca0 00000000 0012fd1c ntdll!LdrpInitializeProcess+0xe02

0:000&amp;gt; dt ntdll!_LDR_DATA_TABLE_ENTRY 00253010 
   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x251e9c - 0x252ee0 ]
   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x251ea4 - 0x252ee8 ]
   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]
   +0x018 DllBase          : 0x003a0000 Void
   +0x01c EntryPoint       : 0x003c1ae4 Void
   +0x020 SizeOfImage      : 0x43000
   +0x024 FullDllName      : _UNICODE_STRING &quot;C:\Program Files\S-dir\Some-dir\someapp.dll&quot;
   +0x02c BaseDllName      : _UNICODE_STRING &quot;someapp.dll&quot;
   +0x034 Flags            : 0x200006
   +0x038 LoadCount        : 0
   +0x03a TlsIndex         : 0
   +0x03c HashLinks        : _LIST_ENTRY [ 0x7c99e2f0 - 0x252a5c ]
   +0x03c SectionPointer   : 0x7c99e2f0 Void
   +0x040 CheckSum         : 0x252a5c
   +0x044 TimeDateStamp    : 0x5618c3dc
   +0x044 LoadedImports    : 0x5618c3dc Void
   +0x048 EntryPointActivationContext : 0x00153960 Void
   +0x04c PatchInformation : (null)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到正在加载someapp.dll，并且处理导入表的时候出了错。来看看这个模块的导入表&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; !dh someapp -f

File Type: DLL
FILE HEADER VALUES
     14C machine (i386)
       6 number of sections
5618C3DC time date stamp Sat Oct 10 15:53:00 2015

       0 file pointer to symbol table
       0 number of symbols
      E0 size of optional header
    2102 characteristics
            Executable
            32 bit word machine
            DLL

OPTIONAL HEADER VALUES
     10B magic #
   10.00 linker version
   27A00 size of code
   15C00 size of initialized data
       0 size of uninitialized data
   21AE4 address of entry point
    1000 base of code
         ----- new -----
10000000 image base
    1000 section alignment
     200 file alignment
       2 subsystem (Windows GUI)
    5.01 operating system version
    0.00 image version
    5.01 subsystem version
   43000 size of image
     400 size of headers
   4943E checksum
00100000 size of stack reserve
00001000 size of stack commit
00100000 size of heap reserve
00001000 size of heap commit
     140  DLL characteristics
            Dynamic base
            NX compatible
   34BE0 [     1E0] address [size] of Export Directory
   33810 [      B4] address [size] of Import Directory
   3A000 [     4CC] address [size] of Resource Directory
       0 [       0] address [size] of Exception Directory
       0 [       0] address [size] of Security Directory
   3B000 [    3954] address [size] of Base Relocation Directory
   29340 [      1C] address [size] of Debug Directory
       0 [       0] address [size] of Description Directory
       0 [       0] address [size] of Special Directory
   2DD80 [      18] address [size] of Thread Storage Directory
   2DD38 [      40] address [size] of Load Configuration Directory
       0 [       0] address [size] of Bound Import Directory
   29000 [     2CC] address [size] of Import Address Table Directory
       0 [       0] address [size] of Delay Import Directory
       0 [       0] address [size] of COR20 Header Directory
       0 [       0] address [size] of Reserved Directory

0:000&amp;gt; dc someapp+33810 someapp+33810+B4
003d3810  60325c32 68326432 90326c32 b332af32  2\2`2d2h2l2.2.2.
003d3820  d132ca32 df32db32 0032fc32 30332033  2.2.2.2.2.2.3 30
003d3830  40333833 4c334833 54335033 5c335833  383@3H3L3P3T3X3\
003d3840  64336033 6c336833 74337033 7c337833  3`3d3h3l3p3t3x3|
003d3850  84338033 8c338833 94339033 ce33b433  3.3.3.3.3.3.3.3.
003d3860  e933d233 f733f333 b134a633 0434e134  3.3.3.3.3.4.4.4.
003d3870  44353935 94357135 d435c935 57361a35  595D5q5.5.5.5.6W
003d3880  be366736 0c36d036 4b374037 b3377b37  6g6.6.6.7@7K7{7.
003d3890  ea37cf37 45380e37 81385e38 a0388a38  7.7.7.8E8^8.8.8.
003d38a0  fb38d338 4b392438 a4399939 0039dd39  8.8.8$9K9.9.9.9.
003d38b0  403a353a c33a863a 2a3ad33a 6b3b3c3b  :5:@:.:.:.:*;&amp;lt;;k
003d38c0  cf3b933b 1d3bea3b                    ;.;.;.;.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以这样就清楚了，someapp.dll的输入表被破坏了，导致加载他的程序无法运行起来。&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Nov 2015 05:17:15 +0800</pubDate>
        <link>http://0cch.com/debugging/2015/11/02/app-startup-fail-dump.html</link>
        <guid isPermaLink="true">http://0cch.com/debugging/2015/11/02/app-startup-fail-dump.html</guid>
        
        
        <category>debugging</category>
        
      </item>
    
      <item>
        <title>Windbg插件0cchext</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/0cch/0cchext&quot;&gt;0cchext.dll&lt;/a&gt;是我一直在开发和维护的一个Windbg扩展程序。扩展程序中包含了一些或者有趣，或者实用，或者纯个人偏好的功能。这篇文章就来介绍一些主要的功能：&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;a&quot;&gt;!a&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!a               - Assembles instruction mnemonics and puts the resulting
                     instruction codes into memory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个指令是写入汇编代码的扩展，虽然Windbg有自己的汇编命令a，但是这个命令无法配合脚本使用。你一旦输入命令a，Windbg就会进入汇编模式，此时你就无法让脚本继续进行了。所以我开发了!a，这个命令只会对一条命令进行汇编，并且将下一条汇编的地址存储在@#LastAsmAddr中，然后马上执行下面的命令，对脚本而已再好不过了。
例如下面这个脚本，他可以注入dll到debuggee&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;ad /q ${/v:alloc_addr}
ad /q ${/v:@#LastAsmAddr}
x kernel32!LoadlibraryA
.foreach /pS 5 (alloc_addr {.dvalloc 0x200}) {r $.u0 = alloc_addr}
.block {aS ${/v:@#LastAsmAddr} 0; !a $u0 pushfd};
.block {!a ${@#LastAsmAddr} pushad}
.block {!a ${@#LastAsmAddr} push 0x$u0+0x100}
.block {!a ${@#LastAsmAddr} call kernel32!LoadLibraryA}
.block {!a ${@#LastAsmAddr} popad}
.block {!a ${@#LastAsmAddr} popfd}
.block { eza 0x$u0+0x100 &quot;${$arg1}&quot;}
r @$t0=@eip
r @eip=$u0
.block {g ${@#LastAsmAddr}}
r @eip=@$t0
.dvfree 0x$u0 0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;autocmd&quot;&gt;!autocmd&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!autocmd         - Execute the debugger commands.(The config file is
                     autocmd.ini)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;自动执行特定指令。有的时候我希望调试器附加到进程或者运行程序的时候能够自动运行一连串的命令，这个功能虽然可以由脚本完成，但是对我而言还是不够简洁，所以就有了这个命令。我可以在0cchext.dll的目录下，创建autocmd.ini文件，然后输入以下内容：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;[notepad.exe]
.sympath+ c:\notepad_pdb
~*k

[calc.exe]
.sympath+ c:\calc_pdb
~*k&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样，在调试不同程序的时候输入!autocmd会执行不同的命令。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;bing--google&quot;&gt;!bing &amp;amp; !google&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!bing            - Use bing to search.
!google          - Use google to search.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个命令非常简单，就是用bing和google去搜索指定的字符串。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;favcmd&quot;&gt;!favcmd&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!favcmd           - Display the favorite debugger commands.(The config file is
                     favcmd.ini)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个命令也非常简单，只需要把自己喜欢的命令一行一行的写在favcmd.ini文件里就行了，当然这个文件也需要和0cchext.dll在同一个目录。然后运行这个命令后，你所喜欢的命令就会打印到Windbg上，你可以用鼠标选择执行这些命令。&lt;/p&gt;

&lt;p&gt;例如在文件中分别写入：
&amp;gt;~*k
!address
!heap&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2015/10/20151005162754.png&quot;&gt;&lt;img src=&quot;/uploads/2015/10/20151005162754.png&quot; alt=&quot;20151005162754&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;hwnd&quot;&gt;!hwnd&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!hwnd            - Show window information by handle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个命令很简单，可以输入窗口句柄为参数，查看窗口相关信息。主要作用是在内核调试的时候，用调试器看到窗口信息会比较方便。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;url&quot;&gt;!url&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!url             - Open a URL in a default browser.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个命令会打开一个url，实际上他就是一个ShellExecute。Windbg本来就有.shell功能了，这个似乎是多余了一点。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;initscriptenv&quot;&gt;!init_script_env&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!init_script_env - Initialize script environment.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个命令是我给脚本准备的，他方便了脚本判断系统环境。如下图所示&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2015/10/20151005163744.png&quot;&gt;&lt;img src=&quot;/uploads/2015/10/20151005163744.png&quot; alt=&quot;20151005163744&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;importvsbps&quot;&gt;!import_vs_bps&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!import_vs_bps   - Import visual studio breakpoints.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个命令可以将VS存储在suo文件的断点导入到Windbg中。我有的时候会碰到这样的情况，VS里设置了一堆断点，但是调试环境里只有Windbg，那么我需要把这些断点转移到Windbg，有了这个命令，我只需要将VS解决方案的suo文件拷贝到调试环境中，然后运行这条命令即可。&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;!import_vs_bps c:\proj\xxx.suo&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;setvprot&quot;&gt;!setvprot&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!setvprot        - Set the protection on a region of committed pages in the
                     virtual address space of the debuggee process.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个命令能帮助我设置debuggee的内存属性，一个有趣的用法就是模仿Ollydbg的内存断点功能，比如给目标内存设置一个PAGE_GUARD属性，这样访问这部分内存的时候就会触发访问异常，调试器就能捕获到它了。&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;!setvprot 0x410000 0x1000 0x100&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;peexport--peimport&quot;&gt;!pe_export &amp;amp; !pe_import&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!pe_export       - Dump PE export functions
!pe_import       - Dump PE import modules and functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这两个命令可以分别帮助我们查看导出和导入函数，他们都支持通配符查找函数，在没有符号的情况下有时候会起到很好的作用。另外，他们配合好参数/b和.foreach命令，可以发挥出API Monitor的作用。&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;.foreach( place  { !pe_export /b kernel32 *Create* } ) { bp place “g” }&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;wql&quot;&gt;!wql&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!wql             - Query system information with WMI.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这也是我比较喜欢的一个功能，他可以在调试的时候通过WQL来查询系统的一些信息，例如：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; !0cchext.wql select * from win32_process where name=&quot;explorer.exe&quot;
-------------------------------------------------------------
  Caption                                   local       CIM_STRING  explorer.exe
  CommandLine                               local       CIM_STRING  C:\Windows\Explorer.EXE
  CreationClassName                         local       CIM_STRING  Win32_Process
  CreationDate                              local       CIM_DATETIME  2015-09-17 09:41:53.959
  CSCreationClassName                       local       CIM_STRING  Win32_ComputerSystem
  ...
  ...
  ThreadCount                               local       CIM_UINT32  40
  UserModeTime                              local       CIM_UINT64  605439881
  VirtualSize                               local       CIM_UINT64  435580928
  WindowsVersion                            local       CIM_STRING  6.1.7601
  WorkingSetSize                            local       CIM_UINT64  109813760
  WriteOperationCount                       local       CIM_UINT64  399
  WriteTransferCount                        local       CIM_UINT64  1545945
-------------------------------------------------------------&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;logcmd&quot;&gt;!logcmd&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!logcmd          - Log command line to log file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个命令是一个开关，打开后，他会记录调试的命令到文件中，这样下次调试相同的程序的时候就不需要在此去输入这些命令了，只需要读取这个命令文件，就可以用鼠标点击执行命令了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2015/10/20151005170422.png&quot;&gt;&lt;img src=&quot;/uploads/2015/10/20151005170422.png&quot; alt=&quot;20151005170422&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;dpx&quot;&gt;!dpx&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!dpx             - Display the contents of memory in the given range.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个命令是集dps dpa dpu大成者。他的会对目标指针做一个简单的判断，判断是符号，字符串，还是宽字符串。这样在我们查看栈信息的时候就不会漏掉一些有用的线索了。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; !dpx esp 100
00c3f28c  7605cb33  [S] USER32!GetMessageA+0x53 (7605cb33)
...
00c3f2b4  012b6ca9  [S] usbview!WinMain+0xe3 (012b6ca9)
...
00c3f2f4  012ce723  [S] usbview!WinMainCRTStartup+0x151 (012ce723)
00c3f2f8  01260000  [S] usbview!__guard_check_icall_fptr &amp;lt;PERF&amp;gt; (usbview+0x0) 
...
00c3f320  01025618  [A] &quot;Winsta0\Default&quot;
00c3f324  01025640  [A] &quot;C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\usbview.exe&quot;
00c3f328  00000000  [D] ....&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;dtx&quot;&gt;!dtx&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;!dtx             - Displays information about structures. (The config file is
                     struct.ini)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个命令主要用在逆向工程的时候。因为逆向工程的时候，我们往往没有符号文件，就不可能直接知道内存数据的结构是什么样子的，我们需要自己通过代码推断出来。在IDA中，我们可以自己设置结构体帮助分析。但是在Windbg中，并没有一个功能能方便的帮助我们用这推断的结构体去显示内存。不可否认我们其实可以用其他的办法来完成这个目的，但操作很繁琐。那么这个命令就解决了这些问题。我们可以在struct.ini文件中写入我们推断的结构体，然后通过这个命令去打印内存数据。当然，这个文件也必须在0cchext.dll的同目录下。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2015/10/20151005172455.png&quot;&gt;&lt;img src=&quot;/uploads/2015/10/20151005172455.png&quot; alt=&quot;20151005172455&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;到目前位置脚本解析器支持的基本类型有BYTE WORD DWORD CHAR WCHAR，支持数组和指针，支持结构体嵌套，有了这些，对于基本的逆向就能够满足需求了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;现在0cchext.dll就是这些命令了，我也会根据自己的需求继续添加命令，如果你有什么有趣或者实用的想法，可以通过邮件或者留言告诉我。&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Oct 2015 02:56:46 +0800</pubDate>
        <link>http://0cch.com/debugging/2015/10/06/0cchext.html</link>
        <guid isPermaLink="true">http://0cch.com/debugging/2015/10/06/0cchext.html</guid>
        
        
        <category>debugging</category>
        
      </item>
    
      <item>
        <title>Foxmail无法响应</title>
        <description>&lt;p&gt;Foxmail是一款不错的邮件客户端软件，小巧实用，我在公司就是用的它。早上一如既往的先打开Foxmail，然后去倒杯水，回来发现Foxmail还在收取邮件的状态，“这也太慢了”，我心想。用鼠标点了点，出现了程序挂起的特征，标题栏上显示无法响应，程序界面变白。经验告诉我挂起的问题70%都还是比较容易调的，好吧，就让我看看这是怎么回事。&lt;/p&gt;

&lt;p&gt;打开Windbg，Attach到Foxmail上，习惯做的第一件事情就是保存Full dump&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;.dump /ma /u e:\foxmail.dmp&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于程序的主界面出现了挂起的现象，而一般情况下主线程就是程序的界面线程，所以此时根本没必要去查看所有线程的情况，直接看看主线程的栈信息吧。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; k
ChildEBP RetAddr  
0018f454 770fd993 ntdll!ZwWaitForSingleObject+0x15
0018f4b8 770fd877 ntdll!RtlpWaitOnCriticalSection+0x13e
0018f4e0 770f84ca ntdll!RtlEnterCriticalSection+0x150
0018f514 76734e8c ntdll!RtlLockHeap+0x3d
0018f558 004091af KERNELBASE!GlobalAlloc+0x92
WARNING: Stack unwind information not available. Following frames may be wrong.
0018f578 0042bf97 Foxmail+0x91af
0018f588 0042c115 Foxmail+0x2bf97
0018f5a4 007c5f25 Foxmail+0x2c115
0018f9fc 007c50ce Foxmail+0x3c5f25
0018fa34 007c516a Foxmail+0x3c50ce
0018fa44 007c9e57 Foxmail+0x3c516a
0018faac 007ca28b Foxmail+0x3c9e57
0018fae0 007c9370 Foxmail+0x3ca28b
0018fb10 007ca3fb Foxmail+0x3c9370
0018fb1c 00dd8a96 Foxmail+0x3ca3fb
0018fb44 007c93bb Foxmail+0x9d8a96
0018fb64 007c9479 Foxmail+0x3c93bb
0018fba8 00dd0492 Foxmail+0x3c9479
0018fcd4 00dd019d Foxmail+0x9d0492
0018fd00 00dd454a Foxmail+0x9d019d
0018fd44 00dcf20d Foxmail+0x9d454a
0018fd60 007ca59d Foxmail+0x9cf20d
0018fd84 0044e9d6 Foxmail+0x3ca59d
0018fd94 0044e844 Foxmail+0x4e9d6
0018fdbc 00434a96 Foxmail+0x4e844
0018fdd4 74aa62fa Foxmail+0x34a96
0018fe00 74aa6d3a user32!InternalCallWinProc+0x23
0018fe78 74aa77c4 user32!UserCallWinProcCheckWow+0x109
0018fed8 74aa7bca user32!DispatchMessageWorker+0x3bc
0018fee8 00dc5e7a user32!DispatchMessageA+0xf
0018ff04 00dc5ee4 Foxmail+0x9c5e7a
0018ff2c 00dc61bf Foxmail+0x9c5ee4
0018ff5c 00ded3a0 Foxmail+0x9c61bf
0018ff88 75b9336a Foxmail+0x9ed3a0
0018ff94 770f9882 kernel32!BaseThreadInitThunk+0xe
0018ffd4 770f9855 ntdll!__RtlUserThreadStart+0x70
0018ffec 00000000 ntdll!_RtlUserThreadStart+0x1b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到界面线程调用GlobalAlloc的时候在等HeapLock被释放。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; kb L5
ChildEBP RetAddr  Args to Child              
0018f454 770fd993 00000698 00000000 00000000 ntdll!ZwWaitForSingleObject+0x15
0018f4b8 770fd877 00000000 00000000 00000000 ntdll!RtlpWaitOnCriticalSection+0x13e
0018f4e0 770f84ca 014d0138 0044e9b8 0018f4ac ntdll!RtlEnterCriticalSection+0x150
0018f514 76734e8c 014d0000 4d5402d1 00000000 ntdll!RtlLockHeap+0x3d
0018f558 004091af 00000002 00002000 0042c07c KERNELBASE!GlobalAlloc+0x92&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么014d0138比如是默认堆的Critical Section了。来看看这个cs的数据&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; !cs 014d0138 
*************************************************************************
***                                                                   ***
***                                                                   ***
***    Either you specified an unqualified symbol, or your debugger   ***
***    doesn&#39;t have full symbol information.  Unqualified symbol      ***
***    resolution is turned off by default. Please either specify a   ***
***    fully qualified symbol module!symbolname, or enable resolution ***
***    of unqualified symbols by typing &quot;.symopt- 100&quot;. Note that   ***
***    enabling unqualified symbol resolution with network symbol     ***
***    server shares in the symbol path may cause the debugger to     ***
***    appear to hang for long periods of time when an incorrect      ***
***    symbol name is typed or the network symbol server is down.     ***
***                                                                   ***
***    For some commands to work properly, your symbol path           ***
***    must point to .pdb files that have full type information.      ***
***                                                                   ***
***    Certain .pdb files (such as the public OS symbols) do not      ***
***    contain the required information.  Contact the group that      ***
***    provided you with these symbols if you need this command to    ***
***    work.                                                          ***
***                                                                   ***
***    Type referenced: ntdll!_RTL_CRITICAL_SECTION                   ***
***                                                                   ***
*************************************************************************
Bad symbols for NTDLL (error 3). Aborting.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;嗯，ntdll的符号文件的结构体信息没有了！这个问题发生在2015年7月份的，安装KB3071756和KB3060716补丁后产生的。详情可以查看&lt;br /&gt;
http://www.osronline.com/showthread.cfm?link=269221&lt;/p&gt;

&lt;p&gt;既然新的符号不让用，那就只有用老的了&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:000&amp;gt; .reload /f /i E:\WorkSpace\MySymbols\ntdll.dll\49900AFA96000\ntdll.dll=77ffe000   
0:000&amp;gt; lm m ntdll*
start    end        module name
770c0000 77240000   ntdll      (pdb symbols)          e:\workspace\mysymbols\wntdll.pdb\FA9C48F9C11D4E0894B8970DECD92C972\wntdll.pdb
77ffe000 78094000   ntdll_77ffe000   (pdb symbols)          e:\workspace\mysymbols\ntdll.pdb\6992F4DAF4B144068D78669D6CB5D2072\ntdll.pdb
0:000&amp;gt; dt ntdll_77ffe000!_RTL_CRITICAL_SECTION 014d0138
   +0x000 DebugInfo        : 0x771c4960 _RTL_CRITICAL_SECTION_DEBUG
   +0x004 LockCount        : 0n-30
   +0x008 RecursionCount   : 0n1
   +0x00c OwningThread     : 0x00001730 Void
   +0x010 LockSemaphore    : 0x00000698 Void
   +0x014 SpinCount        : 0xfa0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好了，这样就够用了。可以看到TID=1730的线程正在占用这个cs，马上去看看这个线程在干什么。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:041&amp;gt; k
ChildEBP RetAddr  
06e1f214 770fd993 ntdll!ZwWaitForSingleObject+0x15
06e1f278 770fd877 ntdll!RtlpWaitOnCriticalSection+0x13e
06e1f2a0 770f84ca ntdll!RtlEnterCriticalSection+0x150
06e1f2d4 7717fd7d ntdll!RtlLockHeap+0x3d
06e1f3bc 7714de8e ntdll!RtlpQueryExtendedHeapInformation+0xbd
06e1f3fc 7716476b ntdll!RtlQueryHeapInformation+0x4a
06e1f4a0 77143320 ntdll!RtlQueryProcessHeapInformation+0x288
06e1f51c 75c15f4b ntdll!RtlQueryProcessDebugInformation+0x28a
Unable to load image D:\Program Files\Foxmail 7.2\libeay32.dll, Win32 error 0n2
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for libeay32.dll - 
06e1f54c 0606ad6a kernel32!Heap32Next+0x4d
WARNING: Stack unwind information not available. Following frames may be wrong.
06e1fab0 06069c77 libeay32!RAND_poll+0x5fa
06e1facc 06023db7 libeay32!RAND_SSLeay+0x447
06e1fb00 06069f71 libeay32!CRYPTO_set_ex_data_implementation+0x387
00000000 00000000 libeay32!RAND_SSLeay+0x741&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从栈的信息看来，这个线程是OpenSSL的一个线程，正在做随机数处理，而枚举Heap的信息应该也是随机数的一个组成部分。在枚举Heap的时候也处于等待一个HeapLock的情况，来具体看看&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:041&amp;gt; kb L5
ChildEBP RetAddr  Args to Child              
06e1f214 770fd993 00000b10 00000000 00000000 ntdll!ZwWaitForSingleObject+0x15
06e1f278 770fd877 00000000 00000000 06e1f428 ntdll!RtlpWaitOnCriticalSection+0x13e
06e1f2a0 770f84ca 04560138 00000000 00000000 ntdll!RtlEnterCriticalSection+0x150
06e1f2d4 7717fd7d 04560000 71edefe5 06e1f468 ntdll!RtlLockHeap+0x3d
06e1f3bc 7714de8e 06e1f428 771640d3 00000000 ntdll!RtlpQueryExtendedHeapInformation+0xbd&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看来正在等一个基地址是04560000的Heap的cs。顺藤摸瓜看看这个cs又被谁占用了。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:041&amp;gt; dt ntdll_77ffe000!_RTL_CRITICAL_SECTION 04560138 
   +0x000 DebugInfo        : 0x0151df40 _RTL_CRITICAL_SECTION_DEBUG
   +0x004 LockCount        : 0n-6
   +0x008 RecursionCount   : 0n1
   +0x00c OwningThread     : 0x00001994 Void
   +0x010 LockSemaphore    : 0x00000b10 Void
   +0x014 SpinCount        : 0xfa0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;继续看看0x00001994这个线程在做什么事情&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-windbg&quot; data-lang=&quot;windbg&quot;&gt;0:002&amp;gt; kb
ChildEBP RetAddr  Args to Child              
0438d2c4 770fd993 00000698 00000000 00000000 ntdll!ZwWaitForSingleObject+0x15
0438d328 770fd877 00000000 00000000 014d0000 ntdll!RtlpWaitOnCriticalSection+0x13e
0438d350 770fdaf8 014d0138 7334c875 00078000 ntdll!RtlEnterCriticalSection+0x150
0438d42c 770f2fe3 000001f8 00000200 00000000 ntdll!RtlpAllocateHeap+0x159
0438d4b0 770f7bfb 014d0000 00800000 000001f8 ntdll!RtlAllocateHeap+0x23a
0438d4fc 770f70f1 00000028 7334c9d5 07240048 ntdll!RtlpAllocateUserBlock+0xae
0438d58c 770ee0e2 07240048 07240048 00000000 ntdll!RtlpLowFragHeapAllocFromContext+0x802
0438d600 770f8129 014d0000 00000000 00000020 ntdll!RtlAllocateHeap+0x206
0438d610 770f3f21 04560000 07240048 00000000 ntdll!RtlpAllocateDebugInfo+0x28
0438d64c 770f4262 07240048 00000000 00000000 ntdll!RtlInitializeCriticalSectionEx+0x93
0438d660 771031e2 07240048 07240048 04560000 ntdll!RtlInitializeCriticalSection+0x12
0438d674 771031b0 00000000 00000800 04560000 ntdll!RtlpInitializeLowFragHeap+0x28
0438d684 77102f5a 7334cae5 045600cc 04560000 ntdll!RtlpCreateLowFragHeap+0x28
0438d6bc 77103002 04560000 04560194 0438d7a8 ntdll!RtlpActivateLowFragmentationHeap+0xc9
0438d6cc 77102fce 04560000 7334cbf1 00000000 ntdll!RtlpPerformHeapMaintenance+0x2a
0438d7a8 770f2fe3 00000008 00000010 04560194 ntdll!RtlpAllocateHeap+0x172
0438d82c 6fef1e62 04560000 00000008 00000008 ntdll!RtlAllocateHeap+0x23a
0438d844 6fef20f9 0438d858 04560984 00000007 nlaapi!NlapAllocNlaDataSet+0x18
0438d85c 6fef2096 00000007 00000003 045608f0 nlaapi!QueryCtxtDeserializeTuplesToTrieMap+0x20
0438d888 6fef23a7 045608f0 000003c8 04560958 nlaapi!QueryCtxtDeserializeEntityToTrieMap+0x38
0438d924 6fef58e0 7972514e 00000001 00000000 nlaapi!NLA_QUERY_HANDLE_completion_internal+0x21f
0438d944 6fef5cd7 00000000 00000000 0c7507d0 nlaapi!NlaRegisterQuery+0x7d
0438d99c 6fef5bac 044907d0 4e3f415a 014587b0 nlaapi!GetNlaV2Handle+0x7e
0438d9d0 769d59b1 01435244 0438db88 044907d0 nlaapi!WSM_NSPLookupServiceBegin_v2+0xc9
0438d9ec 769d598d 01435208 0438db88 00000000 ws2_32!NSPROVIDER::NSPLookupServiceBegin+0x1b
0438da08 769d591c 01458960 0438db88 00000000 ws2_32!NSPROVIDERSTATE::LookupServiceBegin+0x1d
0438da6c 769d57cc 014587b0 0438db88 00000ff0 ws2_32!NSQUERY::LookupServiceBegin+0x18d
0438dabc 0fd7fca2 0438db88 00000ff0 0438dbd0 ws2_32!WSALookupServiceBeginW+0x7f
WARNING: Stack unwind information not available. Following frames may be wrong.
0438dd18 0fd0c6a1 0fa9df49 03ac9c20 03b5da80 libcef!cef_time_delta+0x3ddc22
0438e2f0 0fa9ec71 0438e698 03a91e00 0438e310 libcef!cef_time_delta+0x36a621
0438e37c 0fa8d58f 0438e698 03ac9c00 03b5da80 libcef!cef_time_delta+0xfcbf1
0438eb88 0fa9915f 0438ebc8 fffffffe ffffffff libcef!cef_time_delta+0xeb50f
0438ebe8 0fb3605d 03b5da80 fffffffe 03ac9d20 libcef!cef_time_delta+0xf70df
0438ec04 0fb3744d 03b5da80 fffffffe fffffffe libcef!cef_time_delta+0x193fdd
0438ecd8 0fb37ad2 00000003 fffffffe 00000000 libcef!cef_time_delta+0x1953cd
0438edc0 0fb37f5d 03ac9400 11c9bee1 03ac9400 libcef!cef_time_delta+0x195a52
0438edfc 0fa9ab19 03ac9400 03ac9c38 03ac9c00 libcef!cef_time_delta+0x195edd
0438f20c 0fa9b466 03ac9400 00000000 03ac9c38 libcef!cef_time_delta+0xf8a99
0438f220 0fb3c815 00000000 03ac9400 0fb3aee5 libcef!cef_time_delta+0xf93e6
0438f2e8 0fb3d2e3 00000000 03b53384 03ac9c38 libcef!cef_time_delta+0x19a795
0438f690 0fb3ad7b 0438f600 03b53384 03b2ddc0 libcef!cef_time_delta+0x19b263
0438f8ac 0f985613 0438fb64 03b53384 00000001 libcef!cef_time_delta+0x198cfb
0438fbec 0f98016a ffffffff ffffffff 03b53368 libcef!cef_string_multimap_free+0x18b63
0438fc28 0fa208a4 03b53340 03ac0dd0 03a87b00 libcef!cef_string_multimap_free+0x136ba
0438fd70 0fa223ba 0438fdd0 03a878c0 03ac0d00 libcef!cef_time_delta+0x7e824
0438fe0c 0fa4edfc 00000000 03a878c0 03ac0dd0 libcef!cef_time_delta+0x8033a
0438fe3c 0fa4ec2e 00000000 03ac0dd0 03ac0dd0 libcef!cef_time_delta+0xacd7c
0438fe5c 0fa2177f 03ac0dd0 0438ff34 03ac0dd0 libcef!cef_time_delta+0xacbae
0438ff24 0fa3a323 03a8d7d0 0fa1fc56 03ac0dd0 libcef!cef_time_delta+0x7f6ff
0438ff50 0fa39b9b 0438ff74 0fa39c6a 03ac0dd0 libcef!cef_time_delta+0x982a3
0438ff58 0fa39c6a 03ac0dd0 03a80f40 03a8d7d0 libcef!cef_time_delta+0x97b1b
0438ff74 0fa22ad8 00000000 00000000 03a80f40 libcef!cef_time_delta+0x97bea
0438ff88 75b9336a 000001a8 0438ffd4 770f9882 libcef!cef_time_delta+0x80a58
0438ff94 770f9882 03a80f40 7334e38d 00000000 kernel32!BaseThreadInitThunk+0xe
0438ffd4 770f9855 0fa22a80 03a80f40 00000000 ntdll!__RtlUserThreadStart+0x70
0438ffec 00000000 0fa22a80 03a80f40 00000000 ntdll!_RtlUserThreadStart+0x1b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个线程正在为04560000这个heap创建LowFragHeap，但是在获取014d0138的cs的时候被卡住了。这里就发现问题所在了！014d0138不正是我们主线程在等待的cs么，这个线程的10f0和1994都在等待1730的cs=014d0138，而1730却在等待1994的cs=04560138。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2015/09/20150908002438.png&quot;&gt;&lt;img src=&quot;/uploads/2015/09/20150908002438.png&quot; alt=&quot;20150908002438&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;反汇编RtlpQueryExtendedHeapInformation就能知道这里造成死锁的真正原因。实际上Heap32Next函数枚举所有Heap信息的时候，先统一锁住进程里面所有的Heap，然后做枚举工作，最后再统一释放锁。所以它在正在锁住所有HeapLock过程中的时候，例如锁住了一半，正在尝试锁住另一半，另外一个线程正好拥有他没锁住的HeapLock，但是不巧的时候他在给这个Heap创建LowFragHeap，而创建LowFragHeap需要初始化HeapLock，其中HeapLock的DebugInfo又是用默认Heap去分配内存的，默认堆的锁正好在第一个线程被锁住的那一半里，这就是事情的真相！&lt;/p&gt;

&lt;p&gt;那么微软为什么要提供一个会造成死锁的API，而且不去修复呢？按照Raymond的说法，这个系列的函数目的只是诊断，性能很低，不应该用于普通程序中。&lt;br /&gt;
&lt;a href=&quot;http://blogs.msdn.com/b/oldnewthing/archive/2012/03/23/10286665.aspx&quot;&gt;http://blogs.msdn.com/b/oldnewthing/archive/2012/03/23/10286665.aspx&lt;/a&gt;&lt;br /&gt;
但是，我觉得既然是文档化的接口，而且文档里面没有提到会造成死锁，那么它就应该是安全的。&lt;/p&gt;

</description>
        <pubDate>Tue, 08 Sep 2015 07:06:45 +0800</pubDate>
        <link>http://0cch.com/debugging/2015/09/08/foxmail-hung.html</link>
        <guid isPermaLink="true">http://0cch.com/debugging/2015/09/08/foxmail-hung.html</guid>
        
        
        <category>debugging</category>
        
      </item>
    
      <item>
        <title>介绍三个有趣的API</title>
        <description>&lt;h4 id=&quot;pickicondlg&quot;&gt;PickIconDlg&lt;/h4&gt;

&lt;p&gt;相信给快捷方式指定过图标的朋友肯定看过一个这样的对话框吧，如果你看到过，你肯定已经知道了这个API是怎么一回事。这个API会弹出一个选择图标的窗口给你选择，确定后返回图标在资源中的索引值。这样你可以通过这个索引值和ExtractIcon函数获得这个图标的句柄。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2015/08/20150827113011.png&quot;&gt;&lt;img src=&quot;/uploads/2015/08/20150827113011.png&quot; alt=&quot;20150827113011&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;示例代码如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BuffSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_PATH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;TCHAR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BuffSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;system32&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;shell32.dll&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PickIconDlg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BuffSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;HMODULE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hMod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoadLibrary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;HICON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hIcon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExtractIcon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hMod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;FreeLibrary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hMod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;wnetconnectiondialogwnetconnectiondialog1&quot;&gt;WNetConnectionDialog和WNetConnectionDialog1&lt;/h4&gt;

&lt;p&gt;这两个函数是帮助我们在程序中显示映射网络驱动器对话框的，虽然用的不多，但是也应该见到过它。这两个函数区别不大，只不过WNetConnectionDialog1比WNetConnectionDialog提供了更多的参数去设置。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2015/08/20150827114516.png&quot;&gt;&lt;img src=&quot;/uploads/2015/08/20150827114516.png&quot; alt=&quot;20150827114516&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;示例代码如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#pragma comment(lib, &quot;Mpr.lib&quot;)
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CONNECTDLGSTRUCT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condlg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;condlg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cbStructure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condlg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;condlg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hwndOwner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetConsoleWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;condlg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dwFlags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;CONNDLG_USE_MRU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;NETRESOURCE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dwScope&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RESOURCE_GLOBALNET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dwType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RESOURCETYPE_DISK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lpRemoteName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dwDisplayType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RESOURCEDISPLAYTYPE_DOMAIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;condlg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lpConnRes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RetVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WNetConnectionDialog1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condlg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;shopenwithdialog&quot;&gt;SHOpenWithDialog&lt;/h4&gt;

&lt;p&gt;这个API所显示的对话框我们应该是最多见的，它显示了一个打开方式的对话框。不过有点可惜的是，XP并不支持这个API，我们只能将它用在Vista开始的系统上。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/uploads/2015/08/20150827115225.png&quot;&gt;&lt;img src=&quot;/uploads/2015/08/20150827115225.png&quot; alt=&quot;20150827115225&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;示例代码如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;OPENASINFO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pcszFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;win.ini&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oaifInFlags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OAIF_EXEC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OAIF_ALLOW_REGISTRATION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SHOpenWithDialog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Thu, 27 Aug 2015 20:04:23 +0800</pubDate>
        <link>http://0cch.com/tips/2015/08/27/3-interesting-API.html</link>
        <guid isPermaLink="true">http://0cch.com/tips/2015/08/27/3-interesting-API.html</guid>
        
        
        <category>tips</category>
        
      </item>
    
  </channel>
</rss>
