<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>0CCh Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="0CCh Blog">
<meta property="og:url" content="http://0cch.com/page/17/index.html">
<meta property="og:site_name" content="0CCh Blog">
<meta property="og:locale">
<meta property="article:author" content="0CCh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="0CCh Blog" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">0CCh Blog</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-pioe8afbbide" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/02/12/pioe8afbbide/">PIO读IDE</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2012/02/12/pioe8afbbide/" class="article-date"><time datetime="2012-02-11T23:26:09.000Z" itemprop="datePublished">2012-02-12</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MiniKernel/">MiniKernel</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="/uploads/2012/02/read.jpg"><img src="/uploads/2012/02/read.jpg"></a></p>
<p>经过各种代码的东拼西凑、改来改去，总算是把PIO读取硬盘信息的代码“写”好了，上图是读取硬盘的前512字节的效果图。目前看来还是很挫，原因有两点：</p>
<p>1.只支持LBA48的读取方法，不支持CHS，LBA28，虽然这两个方法的读取范围很有限，但是感觉至少要把LBA28给支持了才行。<br>2.很郁闷的一点，这个读取代码读取成功了，但是IO后返回的状态值是错误的。不知道哪里出了问题，会不会是虚拟硬盘太小而不能用LBA48的问题呢？没有头绪。  </p>
<hr>
<p>补充1.通过IDENTIFY DEVICE命令发现，可能由于设置的虚拟硬盘比较小的原因，虚拟硬盘不支持48bit的地址。IDENTIFY DEVICE会通过PIO方式返回一个256字（512字节）的数据。其中第83个字的第10位表示是否支持48bit的地址。如下图（来自ATA官方手册AT Attachment with Packet Interface - 6）。<br><a href="/uploads/2012/02/48bitaddress.jpg"><img src="/uploads/2012/02/48bitaddress.jpg"></a><br>补充2.由于不支持LBA48，我还是实现了LBA28。不过这个只能访问128G的硬盘了。至于CHS目前还是不考虑实现。<br>补充3.PIO写的方式大概也是差不多的。准备慢慢实现，还有DMA读写硬盘也需要了解下。不过好消息是现在基本能看懂ATA的手册了。<br>补充4.MiniKernel的代码依然写得很挫，暂时不准备共享出来，因为共享出来也没啥用，想学写系统的也看不懂那种烂代码。<br>补充5.感觉读写硬盘是一个挺有意思地方，完全可以单独拿出来写一个系列的blog。只是有没有时间和懒不懒的问题。<br>补充6.补充5的最后一句是P话，时间肯定是有的，就是懒而已。。。  </p>
<p>一个月一篇文章。。。多一点都没有。。。我果然是个需要被监督的人。。。  </p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2012/02/12/pioe8afbbide/" data-id="cktihnvmw000qnoupfy0075bs" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDE/" rel="tag">IDE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MiniKernel/" rel="tag">MiniKernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PIO/" rel="tag">PIO</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-e680bbe7bb932011efbc8ce5b195e69c9b2012" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/12/31/e680bbe7bb932011efbc8ce5b195e69c9b2012/">总结2011，展望2012</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/12/31/e680bbe7bb932011efbc8ce5b195e69c9b2012/" class="article-date"><time datetime="2011-12-31T09:47:26.000Z" itemprop="datePublished">2011-12-31</time></a>
</div>

    <div class="article-author">admin</div>
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>2011还是过去了，2012来了。觉得有点必要写点东西，总结一下过去，展望一下未来。如果要用几个词来总结我的2011，那应该是天真，失望，浮躁。可以说我对我的2011是比较不满意的。</p>
<p>天真，我自认为自己还算是个性情中人，所以很多事情对我来说就是讲得就是个胃口。我是很愿意把结识的人当作朋友处。但是，在工作中，有些“朋友”确实是建立在利益基础上的。如果把所有说过“我们是朋友”的人当作朋友，很有可能吃亏是自己。工作也是一样，代入太多感情色彩也是很天真的一种做法。为了讲胃口，有时候退一步，多干一些活。做的好当然没事，但是做的不尽如人意有时候给你带来的真的会是麻烦。</p>
<p>失望，在去年对一些人失望了，对工作的事情也失望，对自己也挺失望的。有些事情自己也不想拿出来说，也不想以后看到在想起，能快点忘记就忘记。但是对自己失望需要深刻的自我剖析检讨了。技术上提高真的不大，基本上都看不出自己做成了什么厉害的事情，决定的事情大部分没有坚持下来，空余的时间大部分花在娱乐上。</p>
<p>浮躁，一整年，都是浮躁的。买的书一本一本的增多，耐心看完的，甚至说看了一大半的都没几本。想学习的东西很多很多，但是没有一个耐心去学习的。给自己开的代码项目很多，也没见过几个写成的。做事情的思路大概是这样的：哎哟，这个东西挺好玩，去实现一个呗；恩，找点资料吧；我靠，资料不是很多嘛；晕，环境怎么这么难搭建；耐心点，慢慢来；好，环境搭建好了，可以开始了；哎，细节问题好多啊，一个人写这个真的大丈夫么；妈的，确实很难写，比想的难好多啊；不行了，弄不下去了；哎哟，弄这个意义大么；意义不是很多大吧，哎，还是弄点别的吧……</p>
<p>所以我觉得，我的2011基本上就是失败的。但是，我的字典里面没有后悔，因为后悔不能改变任何事情。而且不也不会激励自己明年一定要怎么样。因为貌似这种自我暗示已经被我免疫了。当然如果从过得怎么样的角度来看，我的2011还是相当精彩和快乐的。只不过说，这个人有点贱，快乐的事情总是记不住。</p>
<p>虽然说我现在已经不喜欢那些所谓的立志大湿，但是还是应该给自己一个2012的展望。怎么说呢？继续浮躁吧，想做的事情很多很多。</p>
<p>1.写完自己的mini kernel。</p>
<p>2.看完几本书，包括：nt 文件系统的后半部分，编译原理，算法导论。说实话，我还是感觉自己能看完其中两本就算不错了。</p>
<p>3.完善自己的BaseLib，加上自己实现各种算法。</p>
<p>4.实现一个简单的脚本语言。</p>
<p>5.最后多看两眼wrk吧。</p>
<p>看吧，我真的很浮躁很浮躁，如果明年的这个时候的总结（当然，前提是别2012-12-21就结束了），其中有三条圆满完成，我就觉得很奇迹了。</p>
<p>最后，无论怎么说，2011已经过去，过去的事情无论好坏都过去了。期待2012自己的改变吧。祝福我的家人，朋友和我自己，新年快乐，健康平安，家庭和睦温馨。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/12/31/e680bbe7bb932011efbc8ce5b195e69c9b2012/" data-id="cktihnvmu000knoupa14l2tfu" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-e68891e69cace69da5e4b88de683b3e58699kernelefbc8ce79bb4e588b0e68891e79a84e8869de79b96e4b8ade4ba86e4b880e7aead" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/12/11/e68891e69cace69da5e4b88de683b3e58699kernelefbc8ce79bb4e588b0e68891e79a84e8869de79b96e4b8ade4ba86e4b880e7aead/">我本来不想写kernel，直到我的膝盖中了一箭</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/12/11/e68891e69cace69da5e4b88de683b3e58699kernelefbc8ce79bb4e588b0e68891e79a84e8869de79b96e4b8ade4ba86e4b880e7aead/" class="article-date"><time datetime="2011-12-11T02:32:55.000Z" itemprop="datePublished">2011-12-11</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MiniKernel/">MiniKernel</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>最近中箭体很火，我也凑个热闹。话说自从delete那篇文章过后，又有一个多月没写了。其实不是不想写，是不知道些什么才好。简单的东西不想写，难的东西写不出来。</p>
<p>正像标题写的，恩，我开始写kernel玩了。其实写一个简单，功能单一的kernel并不难。麻烦的只是搭建环境等等。kernel的编写资料也很多，但是可惜的是，绝大部分都是应用在linux环境。我是那种看到linux就头晕的人。所以还是坚持用windows和vc来开发kernel。令人惊喜的是grub能够帮助我们map kernel到内存中，所以boot loader这一步可以想放下。等kernel写了个大概再来写boot loader也不迟。</p>
<p>环境和工具：<br>环境正如我上面提到了windows xp 和 vs 2008。其他工具包括winimage，virtual pc，bochsdbg（+ IDA）。当然还有grub4dos。</p>
<p>要高效的起步，先要了解mulitBoot的一些知识。还有就是写一套能够在text mode下打印信息的函数，例如printf。这样在不用调试的情况下，就能了解一些信息。说实在的bochsdbg的调试功能真心不好用，但是加上IDA可能是一个比较好的做法。具备以上条件后，就可以开始kernel之旅了。</p>
<p><a href="/uploads/2011/12/20111211174748.png"><img src="/uploads/2011/12/20111211174748.png"></a></p>
<p>可以看出内存的基本状况已经可以从boot_info中获取了。接下来要做的事情也很明了。就是需要一个物理内存管理器，实现最基本的物理内存管理器也不算难，不过那就是下篇文章的事情了。现在的kernel大小为7168字节，慢慢玩，看我能坚持多久。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/12/11/e68891e69cace69da5e4b88de683b3e58699kernelefbc8ce79bb4e588b0e68891e79a84e8869de79b96e4b8ade4ba86e4b880e7aead/" data-id="cktihnvms000hnoupa485h98g" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/grub/" rel="tag">grub</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-e4b8bae4bb80e4b988e5bf85e9a1bbe794a8deletee9878ae694bee695b0e7bb84" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/10/31/e4b8bae4bb80e4b988e5bf85e9a1bbe794a8deletee9878ae694bee695b0e7bb84/">为什么必须用delete[]释放数组</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/10/31/e4b8bae4bb80e4b988e5bf85e9a1bbe794a8deletee9878ae694bee695b0e7bb84/" class="article-date"><time datetime="2011-10-31T08:54:55.000Z" itemprop="datePublished">2011-10-31</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>最近不知哪来的好奇心，对C++产生了一些兴趣，要知道我通常情况下都是cpp文件中写c代码，c代码中嵌汇编。不过，在做了一些大点的项目之后，确确实实发现了，这种编码方式麻烦的一面。有时候甚至自己都难得维护以前写的东西。所以选择性看了google的c++编程规范，而且对scoped_ptr和auto_ptr的区别参数兴趣。然后我得出的结论是这两种实际上是其实差不多，只不过scoped_ptr拷贝构造函数和赋值构造函数都是私有的。这样就避免粗心大意的程序员调用他。其他的区别还真没看出来。</p>
<p>OK，这些都不是记录这篇tip的重点。重点在于boost，或者说是google的scoped_ptr代码里面实现了scoped_array。而要用在数组上使用智能指针，就必须用数组的智能指针类。而auto_ptr刚好没有数组部分，所以对于数组，就不能用auto_ptr了。（为什么不用vector？这也不是重点）</p>
<p>作为一个蹩脚的C++程序员，我这时候开始犯晕了。我们知道只能指针都是帮助程序员去释放资源，让程序员把精力放到更重要的地方。那么在我看来那么所需要做的就是析构的时候 delete 或者 delete[] 就行了。要知道，delete[] 就是调用的delete，他们只是单纯的释放内存。那么数组和非数组又有什么区别？</p>
<p>光想肯定不行，写两个例子。</p>
<p>首先是new 一个char数组，分别用delete和delete[]释放。结果表明，没有任何问题，而且不会产生内存泄露。坑爹么？NO，还没完，其实咱们最怀疑的一直都是数组对象，因为他们都有构造和析构函数。而char这样的系统内建类型，想象得出不会出什么问题。new一个对象数组，分别用delete和delete[] 释放。果然问题暴露了，delete的时候出了问题。</p>
<p>知其然，不足以满足好奇心。下面才是拿手的，精彩的要放在后面嘛。</p>
<p>先看测试代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123;cout &lt;&lt; <span class="string">&quot;start 1&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123;cout &lt;&lt; <span class="string">&quot;End 1&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A *a = <span class="keyword">new</span> A[<span class="number">10</span>]();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>编译后看到代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0040103D push 0Eh</span><br><span class="line">0040103F call operator new[] (403ED0h)</span><br></pre></td></tr></table></figure>  
<p>注意到这里传入的大小时0Eh，也就是说申请分配14个字节大小的内存。但是我们知道C++标准中空类的大小应该是1字节。那么多出的dword我们就很容易想到他的用处，应该是记录数组大小的。事实也确实如此。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dword ptr [eax],0Ah</span><br></pre></td></tr></table></figure>  
<p>这里明确交代，给分配内存的第一个dword传入10。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401069 push offset A::~A (4011D0h)</span><br><span class="line">0040106E push offset A::A (401120h)</span><br><span class="line">00401073 push 0Ah</span><br><span class="line">00401075 push 1</span><br><span class="line">00401077 mov ecx,dword ptr [ebp-0F8h]</span><br><span class="line">0040107D add ecx,4</span><br><span class="line">00401080 push ecx</span><br><span class="line">00401081 call `eh vector constructor iterator&#x27; (40A010h)</span><br></pre></td></tr></table></figure>  
<p>这里是调用构造函数，注意是vector版本的构造函数。参数分别是数组的this指针，sizeof(A)，数组数量，构造和析构函数。这样，在这个函数内部循环10次调用构造函数，构造完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">004010BD mov eax,dword ptr [ebp-14h]</span><br><span class="line">004010C0 mov dword ptr [ebp-0E0h],eax</span><br><span class="line">004010C6 mov ecx,dword ptr [ebp-0E0h]</span><br><span class="line">004010CC mov dword ptr [ebp-0ECh],ecx</span><br><span class="line">004010D2 cmp dword ptr [ebp-0ECh],0</span><br><span class="line">004010D9 je main+0F0h (4010F0h)</span><br><span class="line">004010DB push 3</span><br><span class="line">004010DD mov ecx,dword ptr [ebp-0ECh]</span><br><span class="line">004010E3 call A::`vector deleting destructor&#x27; (401230h)</span><br></pre></td></tr></table></figure>  
<p>这里是析构部分传入数组的this指针，传入flag(3)，调用析构函数。</p>
<p>继续看call之后的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401253 mov eax,dword ptr [ebp+8]</span><br><span class="line">00401256 and eax,2</span><br><span class="line">00401259 je A::`vector deleting destructor&#x27;+61h (401291h)</span><br><span class="line">0040125B push offset A::~A (4011D0h)</span><br><span class="line">00401260 mov eax,dword ptr [this]</span><br><span class="line">00401263 mov ecx,dword ptr [eax-4]</span><br><span class="line">00401266 push ecx</span><br><span class="line">00401267 push 1</span><br><span class="line">00401269 mov edx,dword ptr [this]</span><br><span class="line">0040126C push edx</span><br><span class="line">0040126D call `eh vector destructor iterator&#x27; (40A920h)</span><br><span class="line">00401272 mov eax,dword ptr [ebp+8]</span><br></pre></td></tr></table></figure>
<p>如果flag中位1是set，那么调用eh_vector_destructor_iterator调用每个析构函数。参数分别是this，sizeof(A)，数组个数（这里很明显是从eax-4中拿出来的）以及析构函数地址。</p>
<p>OK，明白了delete[]的做法，我们看看delete为什么失败。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">004010BD mov eax,dword ptr [ebp-14h]</span><br><span class="line">004010C0 mov dword ptr [ebp-0E0h],eax</span><br><span class="line">004010C6 mov ecx,dword ptr [ebp-0E0h]</span><br><span class="line">004010CC mov dword ptr [ebp-0ECh],ecx</span><br><span class="line">004010D2 cmp dword ptr [ebp-0ECh],0</span><br><span class="line">004010D9 je main+0F0h (4010F0h)</span><br><span class="line">004010DB push 1</span><br><span class="line">004010DD mov ecx,dword ptr [ebp-0ECh]</span><br><span class="line">004010E3 call A::`scalar deleting destructor&#x27; (4012D0h)</span><br></pre></td></tr></table></figure>
<p>这里调用的析构函数都不一样是一个scalar版本的函数。</p>
<p>继续看这个函数的关键部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">004012F3 mov ecx,dword ptr [this]</span><br><span class="line">004012F6 call A::~A (4011D0h)</span><br><span class="line">004012FB mov eax,dword ptr [ebp+8]</span><br><span class="line">004012FE and eax,1</span><br><span class="line">00401301 je A::`scalar deleting destructor&#x27;+3Fh (40130Fh)</span><br><span class="line">00401303 mov eax,dword ptr [this]</span><br><span class="line">00401306 push eax</span><br><span class="line">00401307 call operator delete (40A890h)</span><br></pre></td></tr></table></figure>
<p>这里很清楚的看到，只进行一次析构，然后就释放内存。所以我们看到的现象是只调用一次析构函数。那么为什么会崩溃呢？因为delete错了地址。看上面的对比的值，eax-4才是new返回的地址，所以delete的不应该是eax，而是eax-4。</p>
<p>真相大白？NO，还有一个问题，delete[] 和delete 内建类型真的成功了么？<br>看看我贴出的代码吧，这里不解释了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;delete[] version</span><br><span class="line">0040101E push 0Ah</span><br><span class="line">00401020 call operator new[] (4014C0h)</span><br><span class="line">00401025 add esp,4</span><br><span class="line">00401028 mov dword ptr [ebp-0E0h],eax</span><br><span class="line">0040102E mov eax,dword ptr [ebp-0E0h]</span><br><span class="line">00401034 mov dword ptr [a],eax</span><br><span class="line">00401037 mov eax,dword ptr [a]</span><br><span class="line">0040103A mov dword ptr [ebp-0D4h],eax</span><br><span class="line">00401040 mov ecx,dword ptr [ebp-0D4h]</span><br><span class="line">00401046 push ecx</span><br><span class="line">00401047 call operator delete[] (401600h) `</span><br><span class="line"></span><br><span class="line">;delete version</span><br><span class="line">0040101E push 0Ah</span><br><span class="line">00401020 call operator new[] (4014C0h)</span><br><span class="line">00401025 add esp,4</span><br><span class="line">00401028 mov dword ptr [ebp-0E0h],eax</span><br><span class="line">0040102E mov eax,dword ptr [ebp-0E0h]</span><br><span class="line">00401034 mov dword ptr [a],eax</span><br><span class="line">00401037 mov eax,dword ptr [a]</span><br><span class="line">0040103A mov dword ptr [ebp-0D4h],eax</span><br><span class="line">00401040 mov ecx,dword ptr [ebp-0D4h]</span><br><span class="line">00401046 push ecx</span><br><span class="line">00401047 call operator delete (401600h)</span><br></pre></td></tr></table></figure>

<p>就像我刚刚所说的delete[]会调用delete。所以不会出任何问题。</p>
<p>如果汇编看的头疼的话，这里我写了两个函数的逆向代码（说了精彩的应该放在后面的）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> A::<span class="string">&#x27;scalar deleting destructor&#x27;</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;~<span class="built_in">A</span>();</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="function">A::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> A::<span class="string">&#x27;vector deleting destructor&#x27;</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; <span class="number">2</span>) &#123;</span><br><span class="line">        count = *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)<span class="keyword">this</span> - <span class="number">4</span>);</span><br><span class="line">        <span class="string">&#x27;eh vector destructor iterator&#x27;</span>(<span class="keyword">this</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(A), count, A::~A);</span><br><span class="line">        <span class="keyword">if</span> (flags&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">A::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">((<span class="keyword">void</span> *)((<span class="keyword">int</span>)<span class="keyword">this</span> - <span class="number">4</span>))</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;~<span class="built_in">A</span>();</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">A::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>分析到这，终于明白。数组一定要用delete[]释放才安全。所以千万不要用auto_ptr作为数组的智能指针，不然会死的很惨。这里还要提一点，auto_ptr也不要用到容器里面去了，也是不允许的。非要这么做就用shared_ptr吧， C++0x已经在stl中加入的这部分。从vs2008 sp1开始支持。低版本的vs的话就去boost里面找吧。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/10/31/e4b8bae4bb80e4b988e5bf85e9a1bbe794a8deletee9878ae694bee695b0e7bb84/" data-id="cktihnvmq000enoup8q1qf7oj" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-volume-snapshot" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/10/30/volume-snapshot/">Volume snapshot</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/10/30/volume-snapshot/" class="article-date"><time datetime="2011-10-30T01:03:12.000Z" itemprop="datePublished">2011-10-30</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/NTInternals/">NTInternals</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>上个月说了，准备放一份基于卷磁盘快照代码。拖到现在也没有更新了，就把它放出来，留着也没啥用。本来就是为了做一个演示demo，没考虑效率和稳定性，只是提供一种思路，其实思路也很简单，有人已经把他完善的很好了。感觉博客更新确实慢，但是也没什么想写的，其实也写不出来什么。悲剧啊！</p>
<p>和我其他代码一样，这么代码同样没有注释。需要的讲究读读吧。那啥，最近昨天把google的代码规范看了看，确实有很多值得学习的地方。不过呢，有些地方可能个性使然，不太认同。不过风格的问题，其实也没什么。</p>
<p>最近还写了hive文件读解析的代码，还没完善，然后又转去看系统缓存那部分的东西了。有时间完善完善。还要完善了是自己写的一个ini文件解析的类。哎，都是一些自己造轮子的活。不过还挺有意思。</p>
<p>下载：<a href="/uploads/2011/10/SectorMon.zip">SectorMon</a></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/10/30/volume-snapshot/" data-id="cktihnvmp000cnouphub80zzx" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volume/" rel="tag">Volume</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/snapshot/" rel="tag">snapshot</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-ntstatus-lookup" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/09/17/ntstatus-lookup/">NTSTATUS Lookup</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/09/17/ntstatus-lookup/" class="article-date"><time datetime="2011-09-17T06:39:26.000Z" itemprop="datePublished">2011-09-17</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Debugging/">Debugging</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>磁盘快照写好了后，闲着无聊写了个nslookup，用来看驱动返回值解释的。写这个程序还先写了个nsstatus.h的解析工具。生成了一个超大的switch case。没啥技术含量。至于那个磁盘快照的代码，过段时间如果合适也可以共享出来。</p>
<p><a href="/uploads/2011/09/ntstatus.jpg"><img src="/uploads/2011/09/ntstatus.jpg"></a></p>
<p>1.0.0.2 更新：</p>
<p>1.增加程序初始化时，直接读取剪切板中的数据功能。<br>2.增加对输入的判断，支持“0x”前缀。</p>
<p>下载：<a href="/uploads/2011/09/nslookup1002.zip">nslookup</a></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/09/17/ntstatus-lookup/" data-id="cktihnvmo000anoup0xvmg5l9" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTSTATUS/" rel="tag">NTSTATUS</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/08/28/e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081/">一份简陋的NTFS Parse代码</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/08/28/e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081/" class="article-date"><time datetime="2011-08-28T01:20:09.000Z" itemprop="datePublished">2011-08-28</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/NTInternals/">NTInternals</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>研究了近两周的NTFS文件格式，初步了解了一些NTFS基本属性的解析方法。<br>为了自己研究方便，写了点简单的解析代码。发出来以方便需要的人。<br>话说这份代码的解析类只是属于demo阶段，而且没有注释。不过代码写的还算清晰。  </p>
<p>参考资料方面，我是转了一份NTFS 3G的文档，这份文档把NTFS的基本特点写的比较清晰了。值得一看</p>
<p><a target="_blank" rel="noopener" href="http://0cch.net/ntfsdoc/">http://0cch.net/ntfsdoc/</a></p>
<p>代码：<a href="/uploads/2011/08/NtfsParse.zip">NtfsParse</a></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/08/28/e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081/" data-id="cktihnvmn0009noupa00vbvqv" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTFS/" rel="tag">NTFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/" rel="tag">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/06/10/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862/">ReactOS-Freeldr磁盘及文件管理2</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/06/10/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862/" class="article-date"><time datetime="2011-06-09T18:17:00.000Z" itemprop="datePublished">2011-06-10</time></a>
</div>

    <div class="article-author">cradiator</div>
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>ArcOpen的大体流程我们看过了。大致分为这几步</p>
<ol>
<li><p>函数会尝试找到文件所在分区的设备句柄，如果还没有对应的句柄。那么使用DEVICE.FuncTable中的Open函数打开设备，并为这个设备分配句柄。</p>
</li>
<li><p>打开设备后条用XxxMount识别分区格式，识别成功返回另外的FuncTable，存储到设备的FileData.FileFuncTable域。</p>
</li>
<li><p>为文件分配一个句柄，在对应的FileData.DeviceId为上面创建设备句柄，FileData.FuncTable为设备的FileData.FileFuncTable。</p>
</li>
<li><p>最后调用文件的FileData.FuncTable.Open函数打开文件。</p>
</li>
</ol>
<p><strong>挂载分区时做了什么</strong></p>
<p>之前我们忽略了XxxMount函数。现在来读读比较简单的FatMount (freeldr\freeldr\fs\fat.c)。</p>
<ol>
<li><em>const</em> DEVVTBL***** FatMount**(<strong>ULONG DeviceId</strong>)**</li>
<li><strong>{</strong></li>
<li><strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.****.</strong></li>
<li>// 生成一个FAT_VOLUME_INFO结构</li>
<li>Volume <strong>=</strong> MmHeapAlloc**(<strong><em>sizeof</em></strong>(<strong>FAT_VOLUME_INFO</strong>)<strong><strong>)</strong></strong>;**</li>
<li><em>if</em> <strong>(****!<strong>Volume</strong>)</strong></li>
<li><em>return</em> <em>NULL</em><strong>;</strong></li>
<li><em>RtlZeroMemory</em><strong>(<strong>Volume, <em>sizeof</em></strong>(<strong>FAT_VOLUME_INFO</strong>)<strong><strong>)</strong></strong>;</strong></li>
<li>// 读第一个扇区</li>
<li>Position**.<strong>HighPart <strong>=</strong> 0</strong>;**</li>
<li>Position**.<strong>LowPart <strong>=</strong> 0</strong>;**</li>
<li>ret <strong>=</strong> ArcSeek**(*<em>DeviceId, <strong>&amp;<strong>Position, SeekAbsolute</strong>)</strong></em><em>;</em>*</li>
<li><em>if</em> <strong>(<strong>ret <strong>!****=</strong> ESUCCESS</strong>)</strong></li>
<li><strong>{</strong></li>
<li>MmHeapFree**(<strong>Volume</strong>)****;**</li>
<li><em>return</em> <em>NULL</em><strong>;</strong></li>
<li><strong>}</strong></li>
<li>ret <strong>=</strong> ArcRead**(<strong>DeviceId, Buffer, <em>sizeof</em></strong>(<strong>Buffer</strong>)**, <strong>&amp;<strong>Count</strong>)****;</strong></li>
<li><em>if</em> <strong>(<strong>ret <strong>!****=</strong> ESUCCESS <strong>|****|</strong> Count <strong>!****=</strong> <em>sizeof</em></strong>(<strong>Buffer</strong>)****)</strong></li>
<li><strong>{</strong></li>
<li>MmHeapFree**(<strong>Volume</strong>)****;**</li>
<li><em>return</em> <em>NULL</em><strong>;</strong></li>
<li><strong>}</strong></li>
<li>// 判断是否有fat分区标志</li>
<li><em>if</em> <strong>(<strong><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector</strong>-</strong></strong>&gt;<strong>FileSystemType, “FAT12 “, 8</strong>)</strong> <strong>&amp;****&amp;</strong></li>
<li><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector</strong>-****&gt;<strong>FileSystemType, “FAT16 “, 8</strong>)</strong> <strong>&amp;****&amp;</strong></li>
<li><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector32</strong>-****&gt;<strong>FileSystemType, “FAT32 “, 8</strong>)</strong> <strong>&amp;****&amp;</strong></li>
<li><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSectorX</strong>-<strong><strong>&gt;<strong>FileSystemType, “FATX”, 4</strong>)</strong></strong>)</strong></li>
<li><strong>{</strong></li>
<li>MmHeapFree**(<strong>Volume</strong>)****;**</li>
<li><em>return</em> <em>NULL</em><strong>;</strong></li>
<li><strong>}</strong></li>
<li>// 获得分区大小等信息</li>
<li>ret <strong>=</strong> ArcGetFileInformation**(*<em>DeviceId, <strong>&amp;<strong>FileInformation</strong>)</strong></em><em>;</em>*</li>
<li><em>if</em> <strong>(<strong>ret <strong>!****=</strong> ESUCCESS</strong>)</strong></li>
<li><strong>{</strong></li>
<li>MmHeapFree**(<strong>Volume</strong>)****;**</li>
<li><em>return</em> <em>NULL</em><strong>;</strong></li>
<li><strong>}</strong></li>
<li>SectorCount**.<strong>HighPart <strong>=</strong> FileInformation</strong>.<strong>EndingAddress</strong>.<strong>HighPart</strong>;**</li>
<li>SectorCount**.<strong>LowPart <strong>=</strong> FileInformation</strong>.<strong>EndingAddress</strong>.<strong>LowPart</strong>;**</li>
<li>SectorCount**.<strong>QuadPart <strong>/****=</strong> SECTOR_SIZE</strong>;**</li>
<li>Volume**-****&gt;<strong>DeviceId <strong>=</strong> DeviceId</strong>;**</li>
<li>// 打开分区</li>
<li><em>if</em> <strong>(<strong><strong>!<strong>FatOpenVolume</strong>(<strong>Volume, BootSector, SectorCount</strong>.<strong>QuadPart</strong>)</strong></strong>)</strong></li>
<li><strong>{</strong></li>
<li>MmHeapFree**(<strong>Volume</strong>)****;**</li>
<li><em>return</em> <em>NULL</em><strong>;</strong></li>
<li><strong>}</strong></li>
<li>// 存储FAT_VOLUME_INFO结构</li>
<li>FatVolumes**[<strong>DeviceId</strong>]** <strong>=</strong> Volume**;**</li>
<li>// 返回fat文件读写的FuncTable</li>
<li><em>return</em> <strong>&amp;<strong>FatFuncTable</strong>;</strong></li>
<li><strong>}</strong></li>
<li>**           </li>
</ol>
<p>**</p>
<p>函数中的DeviceId是设备的句柄。</p>
<p>生成FAT_VOLUME_INFO结构。这个结构里面存储了FAT分区的基本信息。包括扇区大小，每个簇的扇区数等等。</p>
<ol>
<li><em>typedef</em> <em>struct</em> _FAT_VOLUME_INFO </li>
<li><strong>{</strong></li>
<li>ULONG BytesPerSector**;** /* Number of bytes per sector */</li>
<li>ULONG SectorsPerCluster**;** /* Number of sectors per cluster */</li>
<li>ULONG FatSectorStart**;** /* Starting sector of 1st FAT table */</li>
<li>ULONG ActiveFatSectorStart**;** /* Starting sector of active FAT table */</li>
<li>ULONG NumberOfFats**;** /* Number of FAT tables */</li>
<li>ULONG SectorsPerFat**;** /* Sectors per FAT table */</li>
<li>ULONG RootDirSectorStart**;** /* Starting sector of the root directory (non-fat32) */</li>
<li>ULONG RootDirSectors**;** /* Number of sectors of the root directory (non-fat32) */</li>
<li>ULONG RootDirStartCluster**;** /* Starting cluster number of the root directory (fat32 only) */</li>
<li>ULONG DataSectorStart**;** /* Starting sector of the data area */</li>
<li>ULONG FatType**;** /* FAT12, FAT16, FAT32, FATX16 or FATX32 */</li>
<li>ULONG DeviceId**;**</li>
<li><strong>}</strong> FAT_VOLUME_INFO**;**</li>
<li>**             </li>
</ol>
<p>**</p>
<p>  读取第一个山区，判断是否有fat标志。如果没有直接返回，挂载失败。之后使用ArcGetFileInformation获得分区大小。ArcGetFileInformation里面调用了FileData.FuncTable.GetFileInformation。因为当前DeviceId是设备句柄，所以他实际调用的是DiskGetFileInformation(freeldr\freeldr\arch\i386\hardware.c)。这个函数很简单，通过FileInformation返回分区开始和结束的地址，这里就不列出了。     </p>
<p>这里的代码用FileInformation**.**EndingAddress / SECTOR_SIZE计算出了该分区的扇区数SectorCount。这里应该BUG。因为EndingAddress是分区结束地址，真的扇区数应该是 (分区开始地址 - EndingAddress ) / SECTOR_SIZE。好在SectorCount只是判断fat分区的一个依据，而且一般C盘计算出的SectorCount误差不会很大，影响不大。</p>
<p>最后执行FatOpenVolume真正执行分区的挂载、初始化。初始化结束后将生成的Volume放到fat.c维护的全局数组FatVolumes里，之后对fat分区进行操作（读写）时，通过设备的DeviceId就可以找到对应的FAT_VOLUME_INFO结构。</p>
<p>最后函数返回FatFuncTable函数数组</p>
<ol>
<li><em>const</em> DEVVTBL FatFuncTable <strong>=</strong></li>
<li><strong>{</strong></li>
<li>FatClose, </li>
<li>FatGetFileInformation, </li>
<li>FatOpen, </li>
<li>FatRead, </li>
<li>FatSeek, </li>
<li>L”fastfat”, </li>
<li><strong>}****;</strong></li>
<li></li>
</ol>
<p>用户可以通过这些函数就读写改fat分区啦。</p>
<p>那么FatOpenVolume都干了什么呢。</p>
<p>这个函数简单来说就是根据分区内容填写了Volume结构，已经算是一个分区的具体实现细节了，和整体架构无关，不多说了。这个函数在freeldr\freeldr\fs\fat.c中。</p>
<p><strong><strong>打开文件时做了什么</strong></strong></p>
<p>上一篇文章中还有一个地方没说，就是打开设备并创建完文件的句柄后，ArcOpen调用了文件对应的FileData.FuncTable.Open。对于fat分区而言这个函数是FatOpen(freeldr\freeldr\fs\fat.c). 这个函数也是和分区结构有关的了，有一点比较重要就是函数最后调用了FsSetDeviceSpecific把一个和文件相关的内部结构与文件句柄相关联。以后使用FatRead对文件句柄进行读操作时直接就可以获得这个结构啦。</p>
<ol>
<li>LONG FatOpen**(<strong>CHAR</strong>*** Path, OPENMODE OpenMode, ULONG***** FileId**)**</li>
<li><strong>{</strong></li>
<li><strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.****.</strong></li>
<li></li>
<li>// 根据文件的FileId获得文件所在的设备句柄FileData.DeviceId, 从而获得FatMount时生成的Volume结构。</li>
<li>DeviceId <strong>=</strong> FsGetDeviceId**(<em><strong><strong><strong>FileId</strong>)</strong></strong>;</em>*</li>
<li>FatVolume <strong>=</strong> FatVolumes**[<strong>DeviceId</strong>]****;**</li>
<li>// 从DeviceId设备中读取并查询fat表，判断path表示的文件是否存在</li>
<li><em>RtlZeroMemory</em><strong>(<strong><strong>&amp;<strong>TempFileInfo, <em>sizeof</em></strong>(<strong>TempFileInfo</strong>)****)</strong></strong>;</strong></li>
<li>ret <strong>=</strong> FatLookupFile**(*<em>FatVolume, Path, DeviceId, <strong>&amp;<strong>TempFileInfo</strong>)</strong></em><em>;</em>*</li>
<li><em>if</em> <strong>(<strong>ret <strong>!****=</strong> ESUCCESS</strong>)</strong></li>
<li><em>return</em> ENOENT**;**</li>
<li>// 判断是否是目录</li>
<li>IsDirectory <strong>=</strong> <strong>(<strong>TempFileInfo</strong>.<strong>Attributes <strong>&amp;</strong> ATTR_DIRECTORY</strong>)</strong> <strong>!****=</strong> 0**;**</li>
<li><em>if</em> <strong>(<strong>IsDirectory <strong>&amp;****&amp;</strong> OpenMode <strong>!****=</strong> OpenDirectory</strong>)</strong></li>
<li><em>return</em> EISDIR**;**</li>
<li><em>else</em> <em>if</em> <strong>(<strong>**!*<em>IsDirectory <strong>&amp;</strong></em><em>&amp;</em>* OpenMode <strong>!</strong></strong>=** OpenReadOnly**)</strong></li>
<li><em>return</em> ENOTDIR**;**</li>
<li>// 生成FAT_FILE_INFO结构，里面存放了文件的信息(开始的扇区等)</li>
<li>FileHandle <strong>=</strong> MmHeapAlloc**(<strong><em>sizeof</em></strong>(<strong>FAT_FILE_INFO</strong>)<strong><strong>)</strong></strong>;**</li>
<li><em>if</em> <strong>(****!<strong>FileHandle</strong>)</strong></li>
<li><em>return</em> ENOMEM**;**</li>
<li>RtlCopyMemory**(*<em>FileHandle, <strong>&amp;<strong>TempFileInfo, <em>sizeof</em></strong>(<strong>FAT_FILE_INFO</strong>)****)</strong></em><em>;</em>*</li>
<li>FileHandle**-****&gt;<strong>Volume <strong>=</strong> FatVolume</strong>;**</li>
<li>// 把这个结构和文件对应的FileData.Specific关联。之后进行FatRead等操作时可以直接获得这个结构了</li>
<li>FsSetDeviceSpecific**(<em><strong><strong><strong>FileId, FileHandle</strong>)</strong></strong>;</em>*</li>
<li><em>return</em> ESUCCESS**;**</li>
<li><strong>}</strong></li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/06/10/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862/" data-id="cktihnvml0007noup8qa521mm" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086/">ReactOS-Freeldr磁盘及文件管理</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086/" class="article-date"><time datetime="2011-06-02T06:33:19.000Z" itemprop="datePublished">2011-06-02</time></a>
</div>

    <div class="article-author">cradiator</div>
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Freeldr提供了对fat12、fat32、fatx、ntfs等文件系统的只读功能。这部分代码主要集中在boot\freeldr\freeldr\fs\fs.c文件中。<br>首先计算机加电后会把mbr读取到物理内存的0x7c00位置，mbr搜索活动分区并加载活动分区根目录下的Freeldr.sys文件。加载后跳入Freeldr入口start。Freeldr进行32为初始化后跳入主初始化函数BootMain(boot\freeldr\freeldr\Freeldr.c)中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">BootMain</span><span class="params">(LPSTR CmdLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">MachInit</span>(CmdLine);</span><br><span class="line"><span class="built_in">FsInit</span>();</span><br><span class="line">......</span><br><span class="line"><span class="built_in">RunLoader</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>BootMain会对硬件(MachInit)和文件系统(FsInit)进行检测和初始化。所有准备工作进行完毕后就会调用RunLoader进行系统的加载工作。<br>Fs初始化和DEVICE、FILEDATA结构<br>下面看一下文件系统的初始化 FsInit(boot\freeldr\freeldr\fs\fs.c)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FsInit</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ULONG i;</span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(FileData, <span class="built_in"><span class="keyword">sizeof</span></span>(FileData));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FDS; i++)</span><br><span class="line">FileData[i].DeviceId = (ULONG)<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">InitializeListHead</span>(&amp;DeviceListHead);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>FsInit初始化FileData数组。和一个和磁盘分区相关的链表DeviceListHead。<br>首先fs.c维护了一个MAX_FDS(60)大小的数组 static FILEDATA FileData[MAX_FDS];  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDEVVTBL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ARC_CLOSE Close;</span><br><span class="line">ARC_GET_FILE_INFORMATION GetFileInformation;</span><br><span class="line">ARC_OPEN Open;</span><br><span class="line">ARC_READ Read;</span><br><span class="line">ARC_SEEK Seek;</span><br><span class="line">LPCWSTR ServiceName;</span><br><span class="line">&#125; DEVVTBL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagFILEDATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ULONG DeviceId;            <span class="comment">// 文件所在磁盘的磁盘文件句柄, 同样也是FileData的索引</span></span><br><span class="line">ULONG ReferenceCount;       <span class="comment">// 引用计数</span></span><br><span class="line"><span class="keyword">const</span> DEVVTBL* FuncTable;    <span class="comment">// 对文件进行读写的指针</span></span><br><span class="line"><span class="keyword">const</span> DEVVTBL* FileFuncTable; <span class="comment">// 对文件进行读写的函数数组</span></span><br><span class="line">VOID* Specific;             <span class="comment">// 文件系统自定义指针</span></span><br><span class="line">&#125; FILEDATA;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>每一个成功打开的文件会返回一个文件句柄，这个句柄实际上就是FileData数组的索引。所以每个打开的文件都有一个对应的FileData。这个结构就类似windows中的FILE_OBJECT<br>FileData中DeviceId是文件所在磁盘的句柄。这个句柄同样也是FileData数组的索引，通过这个句柄可以找到”磁盘文件”，对”磁盘文件”的读写就是直接对相应的磁盘或磁盘分区的读写。类似Windows中直接对磁盘分区进行CreateFile返回的句柄。”磁盘文件”的DeviceId没有意义。<br>ReferenceCount是该文件的引用计数。<br>FuncTable这是一个函数数组指针，里面存放了对文件进行读写、SEEK等操作的函数指针。<br>FileFuncTable只对”磁盘文件”有意义。当Freeldr确定了磁盘文件对应的分区的分区格式后，会把与分区格式相关的函数指针数组放到这个字段里面。如Fat12分区”磁盘文件”的FileFuncTable字段存放的就是FatFuncTable指针。<br>Specific存放于文件有关的结构。磁盘文件就是DISKCONTEXT指针，fat12下的文件就是FAT_FILE_INFO指针 等等。<br>之后是DeviceListHead，这是DEVICE结构的链表头  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDEVICE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LIST_ENTRY ListEntry;        <span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">const</span> DEVVTBL* FuncTable;    <span class="comment">// 操作该分区的函数表</span></span><br><span class="line">CHAR* Prefix;              <span class="comment">// 分区对应的ArcName</span></span><br><span class="line">ULONG DeviceId;            <span class="comment">// FILEDATA中该分区对应的句柄</span></span><br><span class="line">ULONG ReferenceCount;      <span class="comment">// 引用计数</span></span><br><span class="line">&#125; DEVICE;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>用户电脑中的每一个硬盘和硬盘中的每一分区都对应了一个DEVICE结构。<br>FuncTable里面存放了对该分区进行读写等操作的指针，对于硬盘而言这个数组就是DiskVtbl。<br>Prefix是该分区或硬盘的ArcName。(如multi(0)disk(0)rdisk(0)partition(0))。Freeldr中的文件路径都是Arc形式的路径。而且0号分区代表整个硬盘，真正的分区从1号开始。如multi(0)disk(0)rdisk(0)partition(0)便代表第0块硬盘本身。multi(0)disk(0)rdisk(0)partition(1)代表第0块硬盘的第0个分区。<br>通过DeviceId字段可以找到该DEVICE的文件句柄。这个字段和FILEDATA相互配合，使系统可以遍历DEVICE结构快速找到某个分区的文件句柄。<br>DEVICE(磁盘及分区)的检测<br>上面说到Freeldr操作的路径都是存储在DEVICE结构中的ArcPath。那么这些DEVICE是怎么来的呢？<br>首先我们看一下DEVICE的注册函数，FsRegisterDevice(boot\freeldr\freeldr\fs\fs.c)  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FsRegisterDevice</span><span class="params">(CHAR* Prefix, <span class="keyword">const</span> DEVVTBL* FuncTable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DEVICE* pNewEntry;</span><br><span class="line">ULONG dwLength;</span><br><span class="line">dwLength = <span class="built_in">strlen</span>(Prefix) + <span class="number">1</span>;</span><br><span class="line">pNewEntry = <span class="built_in">MmHeapAlloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DEVICE) + dwLength);</span><br><span class="line"><span class="keyword">if</span> (!pNewEntry)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">pNewEntry-&gt;FuncTable = FuncTable;</span><br><span class="line">pNewEntry-&gt;ReferenceCount = <span class="number">0</span>;</span><br><span class="line">pNewEntry-&gt;Prefix = (CHAR*)(pNewEntry + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(pNewEntry-&gt;Prefix, Prefix, dwLength);</span><br><span class="line"><span class="built_in">InsertHeadList</span>(&amp;DeviceListHead, &amp;pNewEntry-&gt;ListEntry);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这么函数非常简单。Prefix就是Arc路径，FuncTable是操作这个分区（磁盘）对应的函数数组。FsRegisterDevice生成了一个DEVICE结构，把ArcName和FuncTable复制进去。之后连入了DeviceListHead链表。<br>那么又是谁调用的FsRegisterDevice呢？是DetectBiosDisks(boot\freeldr\freeldr\arch\i386\hardware.c)函数。虽然这一部分已经不属于FS的范畴，还是在这里简单讲一下便于理解。这里我略去了不必要的代码。<br>DetectBiosDisks的调用顺序是 RunLoader -&gt; MachHwDetect (PcHwDetect)-&gt; DetectISABios -&gt; DetectBiosDisks</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> VOID</span></span><br><span class="line"><span class="function"><span class="title">DetectBiosDisks</span><span class="params">(PCONFIGURATION_COMPONENT_DATA BusKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOLEAN BootDriveReported = FALSE;</span><br><span class="line">ULONG i;</span><br><span class="line">ULONG DiskCount = <span class="built_in">GetDiskCount</span>(BusKey);</span><br><span class="line">CHAR BootPath[<span class="number">512</span>];</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DiskCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">ULONG Size;</span><br><span class="line">CHAR Identifier[<span class="number">20</span>];</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (BootDrive == <span class="number">0x80</span> + i)</span><br><span class="line">BootDriveReported = TRUE;</span><br><span class="line"><span class="comment">/* Get disk values */</span></span><br><span class="line"><span class="built_in">GetHarddiskIdentifier</span>(Identifier, <span class="number">0x80</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>首先使用GetDiskCount从Freeldr注册表的System键中读取硬盘总数。System键的初始化在DetectSystem(freeldr\freeldr\arch\i386\hardware.c)中，一会儿再看。<br>于是进入一个for循环，为每个硬盘调用GetHarddiskIdentifier函数。在BIOS中硬盘号是从0x80开始的，所以GetHarddiskIdentifier的硬盘号加了0x80。<br>GetHarddiskIdentifier的作用是为制定硬盘生成一个唯一的ID，并通过Identifier参数返回。但这个函数名起得并不好，因为生成ID其实只是这个函数的功能之一。另外的一大功能是检测硬盘，并且为硬盘本身和硬盘分区调用FsRegisterDevice函数进行注册。通过这个注册后硬盘才能真正被文件系统识别。<br>freeldr\freeldr\arch\i386\hardware.c中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> VOID</span></span><br><span class="line"><span class="function"><span class="title">GetHarddiskIdentifier</span><span class="params">(PCHAR Identifier,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG DriveNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PMASTER_BOOT_RECORD Mbr;</span><br><span class="line">ULONG *Buffer;</span><br><span class="line">ULONG i;</span><br><span class="line">ULONG Checksum;</span><br><span class="line">ULONG Signature;</span><br><span class="line">CHAR ArcName[<span class="number">256</span>];</span><br><span class="line">PARTITION_TABLE_ENTRY PartitionTableEntry;</span><br><span class="line"><span class="comment">/* Read the MBR */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">MachDiskReadLogicalSectors</span>(DriveNumber, <span class="number">0ULL</span>, <span class="number">1</span>, (PVOID)DISKREADBUFFER))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DPRINTM</span>(DPRINT_HWDETECT, <span class="string">&quot;Reading MBR failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Buffer = (ULONG*)DISKREADBUFFER;</span><br><span class="line">Mbr = (PMASTER_BOOT_RECORD)DISKREADBUFFER;</span><br><span class="line">Signature = Mbr-&gt;Signature;</span><br><span class="line"><span class="built_in">DPRINTM</span>(DPRINT_HWDETECT, <span class="string">&quot;Signature: %x\n&quot;</span>, Signature);</span><br><span class="line"><span class="comment">/* Calculate the MBR checksum */</span></span><br><span class="line">Checksum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Checksum += Buffer[i];</span><br><span class="line">&#125;</span><br><span class="line">Checksum = ~Checksum + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">DPRINTM</span>(DPRINT_HWDETECT, <span class="string">&quot;Checksum: %x\n&quot;</span>, Checksum);</span><br><span class="line"><span class="comment">/* Fill out the ARC disk block */</span></span><br><span class="line">reactos_arc_disk_info[reactos_disk_count].Signature = Signature;</span><br><span class="line">reactos_arc_disk_info[reactos_disk_count].CheckSum = Checksum;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)&quot;</span>, reactos_disk_count);</span><br><span class="line"><span class="built_in">strcpy</span>(reactos_arc_strings[reactos_disk_count], ArcName);</span><br><span class="line">reactos_arc_disk_info[reactos_disk_count].ArcName =</span><br><span class="line">reactos_arc_strings[reactos_disk_count];</span><br><span class="line">reactos_disk_count++;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)partition(0)&quot;</span>, DriveNumber - <span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">FsRegisterDevice</span>(ArcName, &amp;DiskVtbl);</span><br><span class="line"><span class="comment">/* Add partitions */</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">DiskReportError</span>(FALSE);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">DiskGetPartitionEntry</span>(DriveNumber, i, &amp;PartitionTableEntry))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (PartitionTableEntry.SystemIndicator != PARTITION_ENTRY_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)partition(%lu)&quot;</span>, DriveNumber - <span class="number">0x80</span>, i);</span><br><span class="line"><span class="built_in">FsRegisterDevice</span>(ArcName, &amp;DiskVtbl);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DiskReportError</span>(TRUE);</span><br><span class="line"><span class="comment">/* Convert checksum and signature to identifier string */</span></span><br><span class="line">Identifier[<span class="number">0</span>] = Hex[(Checksum &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">1</span>] = Hex[(Checksum &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">2</span>] = Hex[(Checksum &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">3</span>] = Hex[(Checksum &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">4</span>] = Hex[(Checksum &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">5</span>] = Hex[(Checksum &gt;&gt; <span class="number">8</span> ) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">6</span>] = Hex[(Checksum &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">7</span>] = Hex[Checksum &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">8</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">Identifier[<span class="number">9</span>] = Hex[(Signature &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">10</span>] = Hex[(Signature &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">11</span>] = Hex[(Signature &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">12</span>] = Hex[(Signature &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">13</span>] = Hex[(Signature &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">14</span>] = Hex[(Signature &gt;&gt; <span class="number">8</span> ) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">15</span>] = Hex[(Signature &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">16</span>] = Hex[Signature &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">17</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">Identifier[<span class="number">18</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">Identifier[<span class="number">19</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>函数首先使用MachDiskReadLogicalSectors读取指定硬盘的MBR。对于PC机而言MachDiskReadLogicalSectors使用int 13h中断实现对硬盘的读操作。里面包括了16、32位代码的互转，和本节内容无关，以后再做说明。<br>MBR结构为。详细信息可以参考(<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Master_boot_record">http://en.wikipedia.org/wiki/Master_boot_record</a>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MASTER_BOOT_RECORD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">UCHAR        MasterBootRecordCodeAndData[<span class="number">0x1b8</span>];   <span class="comment">/* 0x000 */</span></span><br><span class="line">ULONG        Signature;          <span class="comment">/* 0x1B8 */</span></span><br><span class="line">USHORT        Reserved;          <span class="comment">/* 0x1BC */</span></span><br><span class="line">PARTITION_TABLE_ENTRY   PartitionTable[<span class="number">4</span>];        <span class="comment">/* 0x1BE */</span></span><br><span class="line">USHORT        MasterBootRecordMagic;        <span class="comment">/* 0x1FE */</span></span><br><span class="line">&#125; MASTER_BOOT_RECORD, *PMASTER_BOOT_RECORD;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>GetHarddiskIdentifier在获取了Signature、计算了Checksum后 。<br>sprintf(ArcName, “multi(0)disk(0)rdisk(%lu)partition(0)”, DriveNumber - 0x80);<br>FsRegisterDevice(ArcName, &amp;DiskVtbl);<br>生成对应硬盘的ArcName，使用FsRegisterDevice注册这块硬盘，这个函数我们已经看过。注意这里Partition为0，所以0号分区实际表示硬盘本身。<br>之后</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">DiskGetPartitionEntry</span>(DriveNumber, i, &amp;PartitionTableEntry))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (PartitionTableEntry.SystemIndicator != PARTITION_ENTRY_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)partition(%lu)&quot;</span>, DriveNumber - <span class="number">0x80</span>, i);</span><br><span class="line"><span class="built_in">FsRegisterDevice</span>(ArcName, &amp;DiskVtbl);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>DiskGetParititionEntry将会解析DriveNumber对应磁盘的分区表，填充第i个分区的信息到PartitionTableEntry结构。如果分区存在则使用FsRegisterDevice注册分区。<br>使用刚才计算的CheckSum和Signature组合一个ID返回给调用者。其实这个ID没有被使用过。。。<br>最后看一下调用FsRegisterDevice时的第二个参数DiskVtbl  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> DEVVTBL DiskVtbl = &#123;</span><br><span class="line">DiskClose,</span><br><span class="line">DiskGetFileInformation,</span><br><span class="line">DiskOpen,</span><br><span class="line">DiskRead,</span><br><span class="line">DiskSeek,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这里面包含了对磁盘扇区读写的全部函数。我们之后再介绍。<br>至此硬盘的及硬盘分区的注册完成。<br>执行完DetectBiosDisks后，DeviceListHead里面就存放了当前计算机所有的磁盘和分区对应的DEVICE结构。<br>文件系统的识别和文件的打开<br>这时Fs模块已经知道的硬盘数量，分区信息。下面来看看一个文件的打开流程。<br>首先，Freeldr使用的是Arc路径，IDE硬盘以multi(0)disk(0)rdisk(n)开头，文件也是以Arc路径表示的。打开文件的函数在Freeldr\Freeldr\fs\fs.c中。这函数比较长，我们分段阅读。<br>Freeldr\Freeldr\fs\fs.c</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">ArcOpen</span><span class="params">(CHAR* Path, OPENMODE OpenMode, ULONG* FileId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">*FileId = MAX_FDS;</span><br><span class="line"><span class="comment">/* Search last &#x27;)&#x27;, which delimits device and path */</span></span><br><span class="line">FileName = <span class="built_in">strrchr</span>(Path, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!FileName)</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line">FileName++;</span><br><span class="line"><span class="comment">/* Count number of &quot;()&quot;, which needs to be replaced by &quot;(0)&quot; */</span></span><br><span class="line">dwCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (p = Path; p != FileName; p++)</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">&#x27;(&#x27;</span> &amp;&amp; *(p + <span class="number">1</span>) == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">dwCount++;</span><br><span class="line"><span class="comment">/* Duplicate device name, and replace &quot;()&quot; by &quot;(0)&quot; (if required) */</span></span><br><span class="line">dwLength = FileName - Path + dwCount;</span><br><span class="line"><span class="keyword">if</span> (dwCount != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">DeviceName = <span class="built_in">MmHeapAlloc</span>(FileName - Path + dwCount);</span><br><span class="line"><span class="keyword">if</span> (!DeviceName)</span><br><span class="line"><span class="keyword">return</span> ENOMEM;</span><br><span class="line"><span class="keyword">for</span> (p = Path, q = DeviceName; p != FileName; p++)</span><br><span class="line">&#123;</span><br><span class="line">*q++ = *p;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">&#x27;(&#x27;</span> &amp;&amp; *(p + <span class="number">1</span>) == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">*q++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">DeviceName = Path;</span><br><span class="line">......</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这个函数有三个参数Path是文件名的Arc路径，如multi(0)disk(0)rdisk(0)partition(1)Freeldr.sys就表示C盘中的Freeldr.sys文件。<br>OpenMode是打开模式(OpenReadOnly、OpenReadWrite等)。<br>如果打开成功，文件句柄将通过FileId参数返回。<br>首先这一部分代码分理出Arc磁盘路径中的”()”替换成”(0)”并存入DeviceName中，如multi()disk()rdisk()partition(1)Freeldr.sys处理后，DeviceName将指向multi(0)disk(0)rdisk(0)partition(1)。注意这个DeviceName是不以NULL结尾的。。。这是个很蛋疼的设计。<br>FileName会指向Arc路径中的文件名部分，上面的例子将是Freeldr.sys。<br>文件打开分为两步，第一步是开个文件所在的设备、创建设备的句柄。第二部才是打开文件本身。<br>这里是第一步打开设备的代码。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">pEntry = DeviceListHead.Flink;</span><br><span class="line"><span class="keyword">while</span> (pEntry != &amp;DeviceListHead)</span><br><span class="line">&#123;</span><br><span class="line">pDevice = <span class="built_in">CONTAINING_RECORD</span>(pEntry, DEVICE, ListEntry);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(pDevice-&gt;Prefix, DeviceName, dwLength) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* OK, device found. It is already opened? */</span></span><br><span class="line"><span class="keyword">if</span> (pDevice-&gt;ReferenceCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Search some room for the device */</span></span><br><span class="line"><span class="keyword">for</span> (DeviceId = <span class="number">0</span>; DeviceId &lt; MAX_FDS; DeviceId++)</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FuncTable)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (DeviceId == MAX_FDS)</span><br><span class="line"><span class="keyword">return</span> EMFILE;</span><br><span class="line"><span class="comment">/* Try to open the device */</span></span><br><span class="line">FileData[DeviceId].FuncTable = pDevice-&gt;FuncTable;</span><br><span class="line">ret = pDevice-&gt;FuncTable-&gt;<span class="built_in">Open</span>(pDevice-&gt;Prefix, DeviceOpenMode, &amp;DeviceId);</span><br><span class="line"><span class="keyword">if</span> (ret != ESUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!*FileName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Done, caller wanted to open the raw device */</span></span><br><span class="line">*FileId = DeviceId;</span><br><span class="line">pDevice-&gt;ReferenceCount++;</span><br><span class="line"><span class="keyword">return</span> ESUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Try to detect the file system */</span></span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">FatMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">NtfsMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">Ext2Mount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Error, unable to detect file system */</span></span><br><span class="line">pDevice-&gt;FuncTable-&gt;<span class="built_in">Close</span>(DeviceId);</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">pDevice-&gt;DeviceId = DeviceId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">DeviceId = pDevice-&gt;DeviceId;</span><br><span class="line">&#125;</span><br><span class="line">pDevice-&gt;ReferenceCount++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pEntry = pEntry-&gt;Flink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pEntry == &amp;DeviceListHead)</span><br><span class="line"><span class="keyword">return</span> ENODEV;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>一个循环，遍历DEVICE链表，找到DEVICE-&gt;Prefix (磁盘、分区的Arc路径，上一节说过)和刚刚分解出来的DeviceName相等的节点。如果没有则函数直接失败。<br>找到DEVICE节点后判断DEVICE-&gt;ReferenceCount是否为0。这个代表该DEVICE被打开的次数，如果ReferenceCount不为0，说明DEVICE已经被打开。那个直接从Device-&gt;DeviceId中获得设备的文件句柄。可以看出无论打开一个设备多少次，只会有ReferenceCount的变化，而句柄都是相同的。所以如果设备打开两次，SEEK时会相互影响。读写之前最好重新调用SEEK函数。<br>当DEVICE-&gt;ReferenceCount为0时是Freeldr需要调用进行打开和文件系统的识别。我们仔细读读。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Search some room for the device */</span></span><br><span class="line"><span class="keyword">for</span> (DeviceId = <span class="number">0</span>; DeviceId &lt; MAX_FDS; DeviceId++)</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FuncTable)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (DeviceId == MAX_FDS)</span><br><span class="line"><span class="keyword">return</span> EMFILE;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>首先在FileData数组中找到空闲项，数组的索引即将成为设备句柄。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Try to open the device */</span></span><br><span class="line">FileData[DeviceId].FuncTable = pDevice-&gt;FuncTable;</span><br><span class="line">ret = pDevice-&gt;FuncTable-&gt;<span class="built_in">Open</span>(pDevice-&gt;Prefix, DeviceOpenMode, &amp;DeviceId);</span><br><span class="line"><span class="keyword">if</span> (ret != ESUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!*FileName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Done, caller wanted to open the raw device */</span></span><br><span class="line">*FileId = DeviceId;</span><br><span class="line">pDevice-&gt;ReferenceCount++;</span><br><span class="line"><span class="keyword">return</span> ESUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>之后把DEVICE中存储的设别操作函数数组FuncTable赋值给对应FileData中的FuncTable。之后对该句柄的读写操作将直接传递给FileData.FuncTable中的函数。<br>调用FuncTable-&gt;Open打开设备。上面我们看过这个函数实际是freeldr\freeldr\arch\i386\hardware.c中的DiskOpen。<br>打开成功后，如果FileName（需要打开的文件名）为空，说明这次请求只打开设备，于是直接返回设备的句柄。<br>如果不为空，则下面开始识别分区格式，打开文件的操作。<br>在继续读ArcOpen函数前我们先看看DiskOpen在打开设备时都做了什么。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ArcOpen -&gt; <span class="built_in">DiskOpen</span> (freeldr\freeldr\arch\i386\hardware.c)</span><br><span class="line"><span class="function"><span class="keyword">static</span> LONG <span class="title">DiskOpen</span><span class="params">(CHAR* Path, OPENMODE OpenMode, ULONG* FileId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DissectArcPath</span>(Path, FileName, &amp;DriveNumber, &amp;DrivePartition))</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line"><span class="keyword">if</span> (DrivePartition == <span class="number">0xff</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* This is a CD-ROM device */</span></span><br><span class="line">SectorSize = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SectorSize = <span class="number">512</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DrivePartition != <span class="number">0xff</span> &amp;&amp; DrivePartition != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DiskGetPartitionEntry</span>(DriveNumber, DrivePartition, &amp;PartitionTableEntry))</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line">SectorOffset = PartitionTableEntry.SectorCountBeforePartition;</span><br><span class="line">SectorCount = PartitionTableEntry.PartitionSectorCount;</span><br><span class="line">&#125;</span><br><span class="line">Context = <span class="built_in">MmHeapAlloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DISKCONTEXT));</span><br><span class="line"><span class="keyword">if</span> (!Context)</span><br><span class="line"><span class="keyword">return</span> ENOMEM;</span><br><span class="line">Context-&gt;DriveNumber = DriveNumber;</span><br><span class="line">Context-&gt;SectorSize = SectorSize;</span><br><span class="line">Context-&gt;SectorOffset = SectorOffset;</span><br><span class="line">Context-&gt;SectorCount = SectorCount;</span><br><span class="line">Context-&gt;SectorNumber = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">FsSetDeviceSpecific</span>(*FileId, Context);</span><br><span class="line"><span class="keyword">return</span> ESUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这个函数非常简单，使用DissectArcPath根据设备的Arc路径分解出文件名FileName、BIOS驱动器号DriveNumber、和分区号DrivePartition（第0个分区的编号是1，0代表整个硬盘）<br>之后确定扇区大小，分区开始的扇区号、分区扇区数等信息，存入DISKCONTEXT结构。使用FsSetDeviceSpecific和FildId相关联。<br>还记得FILEDATA的结构么？FsSetDeviceSpecific就是填充里面的Specific指针 ：）  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FsSetDeviceSpecific</span><span class="params">(ULONG FileId, VOID* Specific)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (FileId &gt;= MAX_FDS || !FileData[FileId].FuncTable)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">FileData[FileId].Specific = Specific;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>实际上DiskOpen的作用就是获得该设备（分区）的基本信息——BIOS驱动器号、扇区大小、开始扇区号、扇区数量和当前读写指针（SectorNumber）。生成DISKCONTENT结构使用FsSetDeviceSpecific和FileID绑定。<br>现在我们回到ArcOpen函数，希望你还记得 ：）  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Try to detect the file system */</span></span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">FatMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">NtfsMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">Ext2Mount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Error, unable to detect file system */</span></span><br><span class="line">pDevice-&gt;FuncTable-&gt;<span class="built_in">Close</span>(DeviceId);</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">pDevice-&gt;DeviceId = DeviceId;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>现在FileData[DeviceId]已经代表刚刚打开的设备了，开始挂载分区。啥叫挂载分区，就是让文件系统提供个接口，能让我们操作分区里面的文件。而这个接口就是个DEVVTBL指针，和直接操作硬盘的接口一样，只不过这次这个可以操作文件了。如果分区识别成功，XxxMount函数将会返回另外一个DEVVTBL指针数组，这个指针赋值给设备对象的FileFuncTable成员。使用这个指针数组就可以在文件级别操作了。比如打开freeldr.sys文件就可以调用FileData[DeviceId].FileFuncTable-&gt;open函数。FileFuncTable和FuncTable是不同的哦！ ：）<br>注意FileFuncTable其实是不直接使用的，这个指针的作用是为之后打开的文件对应的FileData.FileTable赋值。于是操作文件和操作磁盘都是用对应的FileData.FileTable，实现形式上的统一。而且这种架构还可以轻易的实现将一个文件虚拟成为一个分区，只要为文件对象调用XxxMount并且给FileFuncTable域赋值就可以了，非常易于扩展。Freeldr并没有实现这种功能，文件的FileData.FileFuncTable没有使用～<br>下面我们就来看看第二步，打开文件<br>首先为文件找一个空闲的FileData  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FDS; i++)</span><br><span class="line"><span class="keyword">if</span> (!FileData[i].FuncTable)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i == MAX_FDS)</span><br><span class="line"><span class="keyword">return</span> EMFILE;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>跳过文件名开始的 “&quot; 字符  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*FileName == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">FileName++;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>我们前面说的，为FileData.FuncTable赋值。FileData.DeviceId是文件所在分区的句柄。FuncTable内部函数将通过这个句柄调用读写分区内容，为用户提供文件的读写接口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FileData[i].FuncTable = FileData[DeviceId].FileFuncTable;</span><br><span class="line">FileData[i].DeviceId = DeviceId;</span><br><span class="line">*FileId = i;</span><br><span class="line">ret = FileData[i].FuncTable-&gt;<span class="built_in">Open</span>(FileName, OpenMode, FileId);</span><br><span class="line"><span class="keyword">if</span> (ret != ESUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">FileData[i].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line">*FileId = MAX_FDS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>至此打开文件的操作结束。这里略去了XxxMount和文件的Open函数。以后再说。 ：）  </p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086/" data-id="cktihnvqn00b0noup3dg7cl88" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-e585b3e4ba8ee69687e4bbb6shareaccess" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/">关于文件ShareAccess</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/" class="article-date"><time datetime="2011-05-22T10:26:22.000Z" itemprop="datePublished">2011-05-22</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/NTInternals/">NTInternals</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>我是真心太懒了，虽然平时也在研究一些东西，但是总是理解了就算了，没有把他们记录下来的想法。虽然不记录下来也不至于会忘记，但是人的记忆总是有限的我也不敢保证记忆完全不错。好不容易说服自己写点东西，就从今天看的那点东西写起吧。</p>
<p>（吐槽：我尽量把以后的文章写得详细以至于啰嗦，免得以后自己又看不懂了。）</p>
<p>什么是ShareAccess。我们做一个简单的实验，进入系统目录(一般就是C:\Windows)。在C:\Windows\system32\config中，复制一个SYSTEM文件，然后把文件粘贴到另一个地方。如果我们的系统正常，那么我们看到肯定是一个错误框。（图1）“无法复制 system: 文件正在被另一个人或程序使用。关闭任何可能使用这个文件的程序，重新试一次。”无论懂不懂编程，这样一个令人蛋疼的错误框应该会看过无数次吧。这里我就不解释Windows为什么要这么做，假设所有读者都是了解其中的原因了。这篇文章想介绍的是，Windows怎么做到“访问拒绝”的。简单的来说就是当一个进程打开该文件的时候ShareAccess中没有ShareRead属性，所以其他的进程无法访问他。</p>
<p><a href="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-51-31.png"><img src="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-51-31-300x225.png"></a></p>
<p>（图1）</p>
<p>在我们平时打开文件中（CreateFile）总是需要我们传入一个dwShareMode的参数。它有三个值分别是FILE_SHARE_DELETE，FILE_SHARE_READ，FILE_SHARE_WRITE。如果一个打开一个文件的时候，没有传入了FILE_SHARE_READ，那么如果有另一段代码对文件用FILE_READ_DATA权限打开的时候一定返回的是一个失败。其他两个SHARE也是一样。那么是不是设置了FILE_SHARE_READ，其他代码用FILE_READ_DATA权限打开该文件都会成功呢？答案是不一定，主要要看在这段代码CreateFile的dwShareMode。如果也设置的FILE_SHARE_READ，那么打开文件就会成功，否则返回一个SHARE错误。</p>
<p>（吐槽：上面说了一堆，还是没进入正题，貌似有点太详细了。接下来才是重头戏。）</p>
<p>来看看NTFS文件系统是怎么来Check权限的。<br>每个文件打开的时候系统会为文件分配一个FILE_OBJECT（文件对象）。在这里我们主要关注的是以下几个域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nt!_FILE_OBJECT</span><br><span class="line">...</span><br><span class="line">+0x00c FsContext        : Ptr32 Void</span><br><span class="line">...</span><br><span class="line">+0x026 ReadAccess       : UChar</span><br><span class="line">+0x027 WriteAccess      : UChar</span><br><span class="line">+0x028 DeleteAccess     : UChar</span><br><span class="line">+0x029 SharedRead       : UChar</span><br><span class="line">+0x02a SharedWrite      : UChar</span><br><span class="line">+0x02b SharedDelete     : UChar</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>熟悉NTFS文件系统的同学都知道FsContext实际上是对应着一个SCB。SCB的数据结构是未公开的，所以只有逆向或者通过其他途径获得。而这篇文章只需要关注的是SCB的SHARE_ACCESS。SHARE_ACCESS在SCB的0x60的偏移处，这个和NT的SCB有些不同。SHARE_ACCESS的数据结构是这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SHARE_ACCESS</span> &#123;</span></span><br><span class="line">ULONG OpenCount;</span><br><span class="line">ULONG Readers;</span><br><span class="line">ULONG Writers;</span><br><span class="line">ULONG Deleters;</span><br><span class="line">ULONG SharedRead;</span><br><span class="line">ULONG SharedWrite;</span><br><span class="line">ULONG SharedDelete;</span><br><span class="line">&#125; SHARE_ACCESS, *PSHARE_ACCESS;</span><br></pre></td></tr></table></figure>
<p>这个就是这篇文章的关键。</p>
<p>当一个文件被打开的时候，系统会初始化这个数据结构。根据CreateFile的权限设置来填充这个结构。<br>比如DesiredAccess中设置了FILE_READ_DATA，那么Readers，OpenCount就会增加1，如果在此同时设置了ShareMode为FILE_SHARE_READ，那么SharedRead也会加1。同时FILE_OBJECT的ReadAccess和SharedRead会被设置为TRUE。那么在文件被关闭的时候，如果FILE_OBJECT的ReadAccess和SharedRead为TRUE，那么SHARE_ACCESS的Readers，OpenCount，SharedRead就会减1。</p>
<p>在进程准备去打开一个已经打开的文件时，文件系统会做一系列的检查，包括文件权限（比如如果是只读文件，你却想要写权限，这样就会失败），安全描述符，以及共享权限（ShareAccess）。假设前面两个都符合要求，那么就到了共享权限的检查了。</p>
<p>还是以刚才那个SYSTEM文件为例，他打开的权限是FILE_READ_DATA，FILE_WRITE_DATA，DELETE。那么SHARE_ACCESS的OpenCount，Readers，Writers，Deleters都为1，而完全没有Share的意图，所以其他的域都是0。</p>
<p>当有另外一段代码去试图用FILE_READ_DATA权限打开这个文件的时候，那么文件系统就会去检查第一个打开这个文件的操作共享权限。这时的OpenCount是1，SharedRead是0，他会发现SharedRead小于OpenCount，那么他认为这个文件并没有SHARE_READ，所以参数检查返回失败，你会得到一个共享错误。这就是为什么我们复制粘贴SYSTEM文件的时候会失败。</p>
<p>原因分析到这里就结束了。但是我就这样满足了么？显然我没那么容易满足滴~</p>
<p>我想做的就是复制出这个SYSTEM文件，实际上网上已经有很多做法，什么底层磁盘解析读取数据，句柄复制大法。而我这次是修改底层SCB的ShareAccess来达到复制的目的。如果读懂了上面的原理，看下面这段代码就很轻松了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kfile File;</span><br><span class="line">ns = File.<span class="built_in">Create</span>(FILENAME, FILE_OPEN, FILE_READ_ATTRIBUTES, <span class="number">0</span>);</span><br><span class="line">FileObj = File.<span class="built_in">GetObject</span>();</span><br><span class="line">ShareAccess = (SHARE_ACCESS *)((ULONG)FileObj-&gt;FsContext + Offset);</span><br><span class="line">ShareAccess-&gt;SharedRead = ShareAccess-&gt;Readers;</span><br><span class="line">File.<span class="built_in">Release</span>();</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>OK，编写好测试代码，生成一个驱动。运行即可。接下来就是见证奇迹的时刻了。还是用同样的方法复制看看，完全没有问题了。（图2）</p>
<p><a href="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-53-40.png"><img src="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-53-40-300x225.png"></a></p>
<p>（图2）</p>
<p>（吐槽：好久没写这么长的文章，写的我都崩溃了。说到写文章，我发现现在我如果拿起笔去写字，经常会发生提笔忘字的情况！！！天啊！！！）</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/" data-id="cktihnvmj0005noupcchnevkh" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/File-System/" rel="tag">File System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTFS/" rel="tag">NTFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTInternals/" rel="tag">NTInternals</a></li></ul>


    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/16/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/15/">15</a></li><li><a class="page-number" href="/page/16/">16</a></li><li class="active"><span class="page-number">17</span></li><li><a class="page-number" href="/page/18/">18</a></li><li><a class="page-next" rel="next" href="/page/18/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>https://github.com/0cch</p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CPP/">CPP</a><span class="sidebar-module-list-count">27</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/">Debugging</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">5</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/Tips/">Tips</a><span class="sidebar-module-list-count">7</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/DeepLearner/">DeepLearner</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MiniKernel/">MiniKernel</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">4</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Tips/">Tips</a><span class="sidebar-module-list-count">69</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/debugging/">debugging</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/machinelearning/">machinelearning</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/File-System/" rel="tag">File System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/IDE/" rel="tag">IDE</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Kernel/" rel="tag">Kernel</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/MiniKernel/" rel="tag">MiniKernel</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTFS/" rel="tag">NTFS</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTInternals/" rel="tag">NTInternals</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTSTATUS/" rel="tag">NTSTATUS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/OS/" rel="tag">OS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/PIO/" rel="tag">PIO</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/System/" rel="tag">System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Test/" rel="tag">Test</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Volume/" rel="tag">Volume</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Windows/" rel="tag">Windows</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/grub/" rel="tag">grub</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/snapshot/" rel="tag">snapshot</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/File-System/" style="font-size: 10px;">File System</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Kernel/" style="font-size: 20px;">Kernel</a> <a href="/tags/MiniKernel/" style="font-size: 10px;">MiniKernel</a> <a href="/tags/NTFS/" style="font-size: 15px;">NTFS</a> <a href="/tags/NTInternals/" style="font-size: 10px;">NTInternals</a> <a href="/tags/NTSTATUS/" style="font-size: 10px;">NTSTATUS</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/PIO/" style="font-size: 10px;">PIO</a> <a href="/tags/System/" style="font-size: 10px;">System</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Volume/" style="font-size: 10px;">Volume</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/snapshot/" style="font-size: 10px;">snapshot</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/02/">February 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/01/">January 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/12/">December 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/11/">November 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/10/">October 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/09/">September 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/08/">August 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/06/">June 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/05/">May 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/04/">April 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/03/">March 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/02/">February 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/01/">January 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/12/">December 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/11/">November 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/10/">October 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/09/">September 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/08/">August 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/07/">July 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">June 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/05/">May 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/04/">April 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/03/">March 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/01/">January 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/12/">December 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/11/">November 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/07/">July 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/06/">June 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/05/">May 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">April 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">March 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">February 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">January 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">December 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">November 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">October 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">September 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">August 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">March 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">February 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">January 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">December 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/11/">November 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">October 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/09/">September 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">August 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">July 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">June 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/05/">May 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">April 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/03/">March 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/01/">January 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/12/">December 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/11/">November 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">October 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">September 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/08/">August 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/07/">July 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/06/">June 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/05/">May 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/04/">April 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/03/">March 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/02/">February 2016</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/01/">January 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/12/">December 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/11/">November 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/10/">October 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/09/">September 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/08/">August 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/07/">July 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/06/">June 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/05/">May 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/04/">April 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/03/">March 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/02/">February 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/01/">January 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/12/">December 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/11/">November 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/10/">October 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/09/">September 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/08/">August 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/07/">July 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/06/">June 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/05/">May 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/04/">April 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/03/">March 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/02/">February 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/01/">January 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/12/">December 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/11/">November 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/10/">October 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/09/">September 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/08/">August 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/07/">July 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/06/">June 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/05/">May 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/04/">April 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/03/">March 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/02/">February 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/01/">January 2013</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/12/">December 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/11/">November 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/08/">August 2012</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/02/">February 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/12/">December 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/10/">October 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/09/">September 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/08/">August 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/06/">June 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/05/">May 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/04/">April 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/02/">February 2011</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2022/02/12/k+2021/">2021K+软件峰会PPT</a>
        </li>
      
        <li>
          <a href="/2022/01/01/2021-summary/">2021小结</a>
        </li>
      
        <li>
          <a href="/2021/12/01/dpcpp/">DPC++中的现代C++语言特性</a>
        </li>
      
        <li>
          <a href="/2021/11/02/module-ext/">补编-模块(C++20)</a>
        </li>
      
        <li>
          <a href="/2021/10/07/moderncpp42/">《现代C++语言核心特性解析》上架感言</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 0CCh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
