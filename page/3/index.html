<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>0CCh Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="0CCh Blog">
<meta property="og:url" content="http://0cch.com/page/3/index.html">
<meta property="og:site_name" content="0CCh Blog">
<meta property="og:locale">
<meta property="article:author" content="0CCh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="0CCh Blog" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">0CCh Blog</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-yampl-seq-and-iterator-part1" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/yampl-seq-and-iterator-part1/">序列和迭代器(1)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/04/01/yampl-seq-and-iterator-part1/" class="article-date"><time datetime="2020-03-31T23:36:51.000Z" itemprop="datePublished">2020-04-01</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在前面的篇幅中我们已经看到了序列在模板元编程中的一部分作用。在本篇中我们将更加深入的探讨序列以及与之相关的算法，同时我们会使用建立迭代器的方法将这些算法抽象出来以方便它们运用到不同类型的序列中。在YAMPL中实现了两种类型的序列<code>list</code>和<code>vector</code>，本章中我将着重介绍<code>list</code>序列，这是因为该序列更好的使用了C++11的特性。另外本篇中介绍的算法基本上都是使用迭代器实现，所以它们可以顺利的移植到<code>vector</code>上。读者也可以将这些算法移植到自己实现的序列上，而这个移植过程也只需要实现少量代码。</p>
<h2 id="定义迭代器"><a href="#定义迭代器" class="headerlink" title="定义迭代器"></a>定义迭代器</h2><p>为了保证序列相关算法的通用性，我们需要将算法的实现建立在迭代器的基础之上，于是设计一个通用的迭代器就变得十分重要了。以下代码是YAMPL中通用迭代器类模板的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">B</span> =</span> <span class="keyword">void</span>, <span class="class"><span class="keyword">class</span> <span class="title">B2</span> =</span> <span class="keyword">void</span>, <span class="class"><span class="keyword">class</span> <span class="title">B3</span> =</span> <span class="keyword">void</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">  <span class="keyword">using</span> index = N;</span><br><span class="line">  <span class="keyword">using</span> backup = B;</span><br><span class="line">  <span class="keyword">using</span> backup2 = B2;</span><br><span class="line">  <span class="keyword">using</span> backup3 = B3;</span><br><span class="line">  <span class="keyword">using</span> tag = iterator_tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，迭代器<code>iterator</code>定义了5个模板形参。其中第一个形参<code>T</code>通常用于记录当前迭代器代表的元素本身或者是记录与该元素相关的序列；第二个形参<code>N</code>通常用于记录当前迭代器在序列中的位置；而剩下的3个形参可以用来记录一些额外的序列信息。</p>
<p>值得注意的是，以上描述是这5个形参在YAMPL序列中的惯用用法，它们并不是绝对的，所以序列的设计者可以根据序列本身的实际情况安排这5个形参的用途。比如YAMPL中的<code>list</code>使用了前3个形参，而<code>vector</code>只使用了前2个形参。</p>
<p>最后来说明一下内嵌类型<code>tag</code>的用途。在YAMPL中，和序列相关的类模板都有一个<code>tag</code>，比如迭代器的<code>tag</code>就是<code>iterator_tag</code>。这些<code>tag</code>的主要功能是对序列相关的类模板进行分类以方便通用算法在不同的序列上正常工作。例如YAMPL的<code>list</code>序列的<code>tag</code>为<code>list_tag</code>，那么为<code>list_tag</code>设计的基础元函数就能使用在<code>list</code>序列之上。同样的道理，若序列的设计者为了某特殊情况定义了一个<code>special_list</code>序列，并且将其<code>tag</code>定义为<code>list_tag</code>，那么为<code>list_tag</code>设计的算法就可以用于该序列了。</p>
<h2 id="序列和迭代器的基础元函数"><a href="#序列和迭代器的基础元函数" class="headerlink" title="序列和迭代器的基础元函数"></a>序列和迭代器的基础元函数</h2><p>为了让迭代器能顺利的移植到不同的序列上，我们需要定义几个抽象的元函数。这些元函数有些类似C++纯虚函数的概念，它们只提供一个元函数的轮廓，而具体是定义还是要由序列的设计者来实现。这些基础元函数包括：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">begin_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">begin</span> :</span> begin_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">end_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">end</span> :</span> end_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">next_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">next</span></span></span><br><span class="line"><span class="class">    :</span> next_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deref_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deref</span></span></span><br><span class="line"><span class="class">    :</span> deref_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">size_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">size</span> :</span> size_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clear_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clear</span> :</span> clear_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_back_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_back</span></span></span><br><span class="line"><span class="class">    :</span> push_back_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示了7组基础元函数，它们分别是<code>begin</code>、<code>end</code>、<code>next</code>、 <code>deref</code>、<code>size</code>、<code>clear</code>和<code>push_back</code>。之所以把它们列为基础元函数，是因为要让一个序列和与之相关的迭代器能正常工作这7组元函数是必不可少的。如果一个序列能实现这7组元函数，那么它的迭代器至少能完成一个正向迭代器的全部工作。</p>
<p>这7组元函数的功能具体为：</p>
<table>
<thead>
<tr>
<th align="left">元函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>begin</code></td>
<td align="left">返回序列中代表第一个元素的迭代器；</td>
</tr>
<tr>
<td align="left"><code>end</code></td>
<td align="left">返回序列中代表最后一个元素之后的迭代器；</td>
</tr>
<tr>
<td align="left"><code>next</code></td>
<td align="left">返回当前迭代器代表元素的下一个元素的迭代器；</td>
</tr>
<tr>
<td align="left"><code>deref</code></td>
<td align="left">解引用，返回当前迭代器代表的元素本身；</td>
</tr>
<tr>
<td align="left"><code>size</code></td>
<td align="left">返回序列中元素个数；</td>
</tr>
<tr>
<td align="left"><code>clear</code></td>
<td align="left">删除序列中的所有元素；</td>
</tr>
<tr>
<td align="left"><code>push_back</code></td>
<td align="left">在序列的最后新增一个元素。</td>
</tr>
</tbody></table>
<p>如果序列的设计者并不满足于正向迭代器的功能，那么还可以实现一个<code>prior</code>元函数的<code>_impl</code>版本来完成一个双向迭代器，<code>prior</code>元函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prior_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prior</span></span></span><br><span class="line"><span class="class">    :</span> prior_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>prior</code>函数的功能具体为：</p>
<table>
<thead>
<tr>
<th>元函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>prior</code></td>
<td>返回当前迭代器代表元素的上一个元素的迭代器。</td>
</tr>
</tbody></table>
<p>进一步的，如果序列的设计者希望该序列能支持一个随机访问迭代器，那么还需要实现以下2组基础元函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">advance_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">advance</span></span></span><br><span class="line"><span class="class">    :</span> advance_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T,</span><br><span class="line">                                                                            N&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">distance_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">distance</span></span></span><br><span class="line"><span class="class">    :</span> distance_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;</span><br><span class="line">          T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这2组元函数的功能具体为：</p>
<table>
<thead>
<tr>
<th>元函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>advance</code></td>
<td>返回当前迭代器代表元素的第N个递进元素的迭代器</td>
</tr>
<tr>
<td><code>distance</code></td>
<td>计算同序列中两个迭代器的间隔元素</td>
</tr>
</tbody></table>
<p>需要注意的是，序列需要实现的并不是<code>begin</code>、<code>end</code>、<code>next</code>这些元函数本身，而是它们间接调用的<code>_impl</code>版本的内嵌<code>apply</code>元函数。具体来说，想实现序列的<code>push_back</code>功能，那么应该对应的实现<code>push_back_impl</code>和<code>push_back_impl::apply</code>的元函数，具体的实现方法会在后面<code>list</code>序列的小节中介绍。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/04/01/yampl-seq-and-iterator-part1/" data-id="cktihnvqa009znoup38hrdkgy" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-yampl-base-components-part3" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/08/yampl-base-components-part3/">YAMPL的基础组件(3)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/03/08/yampl-base-components-part3/" class="article-date"><time datetime="2020-03-08T14:23:33.000Z" itemprop="datePublished">2020-03-08</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="逻辑运算符元函数"><a href="#逻辑运算符元函数" class="headerlink" title="逻辑运算符元函数"></a>逻辑运算符元函数</h2><p>在C++中逻辑运算符可以将两个或多个关系表达式连接成一个，例如<code>&amp;&amp;</code>和<code>||</code>，也能够使表达式的逻辑反转，例如<code>!</code>。在这个小节中，我们将根据C++的逻辑运算符实现一套YAMPL可以使用的逻辑运算符元函数，除此之外我们还将结合上面的内容来完成一个元编程例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">and_</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> inner = and_&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value &amp;&amp; inner::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">and_</span>&lt;</span>N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value &amp;&amp; N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>观察上面的代码会发现，<code>and_</code>元函数的实现和<code>plus</code>元函数几乎相同，除了使用了不同的运算符以外，唯一的区别就是返回类型。<code>and_</code>元函数的返回类型<code>using type = integral_const&lt;value_type, N1::value &amp;&amp; inner::value&gt;;</code>固定为<code>integral_const&lt;bool, true&gt;</code>或者<code>integral_const&lt;bool, false&gt;</code>之一，也就是<code>true_type</code>或者<code>false_type</code>。这个设计正好是对应<code>&amp;&amp;</code>运算符的返回值必须是<code>true</code>或者<code>false</code>之一。说明了这个区别之后，读者可以回味一下<code>plus</code>的实现应该就能理解<code>and_</code>元函数的实现细节了，这里也不再赘述。</p>
<p>如<code>and_</code>元函数一样，<code>or_</code>也可以通过这样的方式实现，而且只需要修改一个运算符而已。所以这里还是用宏简化代码的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_MULTI_OP_BOOL(name, op)                                  \</span></span><br><span class="line"><span class="meta">  template <span class="meta-string">&lt;class N1, class N2, class... Nargs&gt;</span>                         \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                                         \</span></span><br><span class="line"><span class="meta">    using inner = name<span class="meta-string">&lt;N2, Nargs...&gt;</span>;                                   \</span></span><br><span class="line"><span class="meta">    using value_type = bool;                                            \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="meta-string">&lt;value_type, N1::value op inner::value&gt;</span>; \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                    \</span></span><br><span class="line"><span class="meta">  &#125;;                                                                    \</span></span><br><span class="line"><span class="meta">  template <span class="meta-string">&lt;class N1, class N2&gt;</span>                                         \</span></span><br><span class="line"><span class="meta">  struct name<span class="meta-string">&lt;N1, N2&gt;</span> &#123;                                                 \</span></span><br><span class="line"><span class="meta">    using value_type = bool;                                            \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="meta-string">&lt;value_type, (N1::value op N2::value)&gt;</span>;  \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                    \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_MULTI_OP_BOOL</span>(and_, &amp;&amp;);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP_BOOL</span>(or_, ||);</span><br></pre></td></tr></table></figure>

<p>以上代码实现了逻辑与和逻辑或的运算符元函数，接下来我们需要实现一个逻辑非运算符元函数，也就是在C++中常用的<code>!</code>。逻辑非运算符元函数的实现相对于前两个就单纯多了，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">not_</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, !T::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里只需要注意<code>not_</code>元函数的返回类型也是固定为<code>integral_const&lt;bool, true&gt;</code>或者<code>integral_const&lt;bool, false&gt;</code>之一，剩下的代码和取负运算符元函数的代码几乎相同很容易理解。</p>
<p>现在，我们要利用上面介绍的内容实现一个特殊的函数模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">special_func</span><span class="params">(T)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该函数模板需要完成这样一个任务：当模板实参<code>T</code>是一个标量或者引用时，函数参数的<code>T</code>为实参本身；否则<code>T</code>为实参的引用。也就是说当<code>T</code>为<code>int</code>时，函数为<code>void special_func(int) &#123;&#125;</code>；当<code>T</code>为<code>int&amp;</code>时，函数为<code>void special_func(int&amp;) &#123;&#125;</code>；当T为<code>std::string</code>时，函数为<code>void special_func(std::string&amp;) &#123;&#125;</code>。</p>
<p>以下是我的一种实现方案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func_helper</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> cond = or_&lt;<span class="keyword">typename</span> std::is_scalar&lt;T&gt;::type,</span><br><span class="line">                   <span class="keyword">typename</span> std::is_reference&lt;T&gt;::type&gt;;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> if_&lt;<span class="keyword">typename</span> cond::type, T,</span><br><span class="line">                            <span class="keyword">typename</span> std::add_lvalue_reference&lt;T&gt;::type&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">special_func</span><span class="params">(<span class="keyword">typename</span> func_helper&lt;T&gt;::type)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中实现了一个<code>func_helper</code>元函数，该元函数会针对<code>special_func</code>的模板实参进行处理以满足函数需求。在<code>func_helper</code>的实现代码中，首先调用了逻辑或元函数<code>or_</code>，用于判断<code>T</code>是否为标量或者引用类型。然后根据返回结果调用<code>if_</code>元函数。当<code>cond::type</code>的结果为<code>true_type</code>时返回<code>T</code>本身，否则调用<code>std::add_lvalue_reference</code>返回<code>T</code>的引用类型，最终<code>type</code>为要求的返回类型。</p>
<p>来测试一下刚刚编写的函数模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">special_func&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">special_func&lt;<span class="keyword">int</span>&amp;&gt;(n);</span><br><span class="line">std::string s&#123; <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">special_func&lt;std::string&gt;(s);</span><br></pre></td></tr></table></figure>

<p>使用<code>-fdump-tree-gimple</code>命令让GCC生成gimple的中间代码，观察代码发现这样三份中间代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">special_func&lt;int&gt; (type v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br><span class="line">special_func&lt;int&amp;&gt; (int &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br><span class="line">special_func&lt;std::__cxx11::basic_string&lt;char&gt; &gt; (struct basic_string &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到当模板实参为<code>int</code>和<code>int&amp;</code>时，函数形参类型为模板实参本身，而当模板实参为<code>std::__cxx11::basic_string&lt;char&gt;</code>时，函数形参类型为<code>struct basic_string &amp;</code>，满足函数的设计要求。</p>
<h2 id="类型打印元函数"><a href="#类型打印元函数" class="headerlink" title="类型打印元函数"></a>类型打印元函数</h2><p>模板元程序之所以比普通C++程序更难编写主要是因为它很难调试。我们常用的调试方法在模板元程序上都没法正常使用，比如调试器只能调试动态运行的程序，但是却无法调试编译期执行的元程序。</p>
<p>另外打印日志的方法也许能帮上一点忙，因为C++为我们提供了<code>typeid</code>这个操作符，它返回的<code>std::type_info</code>结构中存在一个<code>const char* name()</code>的成员函数可以返回类型名称。于是我们想到可以使用以下方法打印类型信息帮助调试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure>

<p>不过遗憾的是，这种方法也并不完美。首先来说，成员函数<code>name()</code>返回的类型名称在不同编译器中有不同的展现方法，比如MSVC编译出来的程序返回的是一个可读的名称，而GCC编译出来的程序返回的类型名称则需要使用特定API（例如<code>abi::__cxa_demangle</code>）将其转换为可读的名称。其次，<code>typeid</code>也无法真实的反应类型的状态，因为C++标准中说明了<code>typeid</code>会忽略类型的<code>cv</code>属性，也就是说<code>typeid(const T) == typeid(T)</code>。所以<code>typeid</code>打印日志的方法也不满足需求。</p>
<p>为了准确是输出类型信息，我们需要将目光从程序本身移动到编译期上，因为只有编译期才是掌握类型信息最全面的程序。于是我们可以想到使用编译期的错误信息来打印类型信息。由于错误信息往往是帮助程序员排查错误，所以类型信息会非常的全面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">err_print_type</span>;</span></span><br><span class="line"></span><br><span class="line">err_print_type&lt;<span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type&gt;();</span><br></pre></td></tr></table></figure>

<p>在上面的代码中<code>err_print_type</code>是一个缺少实现的类模板，所以当编译器将其进行实例化的时候必然会报错，而错误信息正是我们想要的结果。<code>err_print_type&lt;typename minus&lt;int_&lt;10&gt;, int_&lt;2&gt;&gt;::type&gt;();</code>在MSVC中会显示错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error C2027: use of undefined type &#x27;err_print_type&lt;yampl::integral_const&lt;T,8&gt;&gt;&#x27;</span><br><span class="line">with</span><br><span class="line">[</span><br><span class="line">    T=int</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在GCC中显示错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: invalid use of incomplete type &#x27;struct err_print_type&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>可以看到，无论是哪种编译器都非常详细的显示了类型信息。</p>
<p>现在类型信息是完整了，但这种方法还是不太好，因为错误会阻止程序的编译导致无法生成可执行程序。我们需要一种方法既能在编译期产生可用的日志，与此同时也不能阻碍程序的正常编译。于是我们想到，如果能将错误信息转换为警告信息不久好了么！在YAMPL中，打印类型信息的方法就是用这种思路实现的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__clang__)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> tmp = <span class="number">1</span> / (<span class="built_in"><span class="keyword">sizeof</span></span>(T) - <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__GNUC__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic <span class="meta-keyword">warning</span> <span class="meta-string">&quot;-Wsign-compare&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(T) &gt; <span class="number">-1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push, 3)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>以上代码实现了一个类模板<code>dbg_print_type</code>，并且分别对MSVC、GCC和CLang做了支持。当编译期时MSVC时，使用了数组大小为0的技巧促使编译期发出警告；当编译器是CLang时，使用除数为0的方式让编译器发出警告；当编译器是GCC时，使用不同符号类型比较让编译器发出警告，值得注意的是这个警告需要手动开启。</p>
<p>将上面示例中的<code>err_print_type</code>修改为<code>dbg_print_type</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dbg_print_type&lt;<span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type&gt;();</span><br></pre></td></tr></table></figure>

<p>GCC会发出这样的警告：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In instantiation of &#x27;struct yampl::DbgPrintType&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#x27;:</span><br><span class="line">required from here</span><br><span class="line">warning: comparison of integer expressions of different signedness: &#x27;long long unsigned int&#x27; and &#x27;int&#x27; [-Wsign-compare]</span><br><span class="line">   15 |   enum &#123; n = sizeof(T) &gt; -1 &#125;;</span><br></pre></td></tr></table></figure>

<p>MSVC显示的警告为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">warning C4200: nonstandard extension used: zero-sized array in struct/union</span><br><span class="line">message : This member will be ignored by a defaulted constructor or copy/move assignment operator</span><br><span class="line">message : see reference to class template instantiation &#x27;yampl::DbgPrintType&lt;yampl::integral_const&lt;T,8&gt;&gt;&#x27; being compiled</span><br><span class="line">with</span><br><span class="line">[</span><br><span class="line">    T=int</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>请注意警告的信息确实比较多，但是仔细观察还是能看到<code>&#39;struct yampl::DbgPrintType&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#39;</code>这样类似的信息。另外值得高兴的是，这些警告信息也确实没有阻止程序的编译。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/03/08/yampl-base-components-part3/" data-id="cktihnvq9009ynoup4e2tbtds" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-yampl-base-components-part2" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/21/yampl-base-components-part2/">YAMPL的基础组件(2)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/02/21/yampl-base-components-part2/" class="article-date"><time datetime="2020-02-21T12:48:33.000Z" itemprop="datePublished">2020-02-21</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="整型转换等级"><a href="#整型转换等级" class="headerlink" title="整型转换等级"></a>整型转换等级</h2><p>考虑一个简单的问题，在C++中将两个不同类型的整型操作数相加的结果会是怎么样的？比如用<code>short</code>类型的变量和<code>long</code>类型的变量相加。答案很简单，相加的结果应该是一个<code>long</code>类型，因为<code>short</code>类型隐式转换为<code>long</code>，于是就需要我们使用一个<code>long</code>类型的变量来存储计算结果。在C++11以后，我们可以通过类型说明符<code>auto</code>把这件事情交给编译器来完成。但是在模板元编程中，这件事是需要我们亲力亲为的。因此需要一个有效的工具来选择合适的类型，那就是类型转换等级。所谓转换等级实际上是类型根据C++隐式类型转换规则的一种排序，简单来说整型转换等级的排序符合下面两条规则：</p>
<ol>
<li>若两操作数的类型所需的存储空间大小不同，则存储空间较小的操作数类型隐式转换到存储空间较大的操作数类型。</li>
<li>若两操作数的类型所需的存储空间大小相同但符号性不同，则有符号类型操作数会隐式转换成无符号类型。</li>
</ol>
<p>下面是YAMPL对整型转换等级的排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">bool</span>&gt; : int_&lt;<span class="number">1</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">signed</span> <span class="keyword">char</span>&gt; : int_&lt;<span class="number">2</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">char</span>&gt; : int_&lt;<span class="number">3</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; : int_&lt;<span class="number">4</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">wchar_t</span>&gt; : int_&lt;<span class="number">5</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">char16_t</span>&gt; : int_&lt;<span class="number">6</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">short</span>&gt; : int_&lt;<span class="number">7</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">short</span>&gt; : int_&lt;<span class="number">8</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">char32_t</span>&gt; : int_&lt;<span class="number">9</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">int</span>&gt; : int_&lt;<span class="number">10</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; : int_&lt;<span class="number">11</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">long</span>&gt; : int_&lt;<span class="number">12</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; : int_&lt;<span class="number">13</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">long</span> <span class="keyword">long</span>&gt; : int_&lt;<span class="number">14</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt; : int_&lt;<span class="number">15</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>integral_rank</code>是一个用于描述整型转换等级的类模板，它的实现非常简单，只是继承了类模板<code>int_</code>的实例，如此一来我们可以通过<code>::value</code>的方法访问类型等级的值，这个技巧在C++模板元编程中被称为元函数转发。</p>
<p>整体的来看这段代码，可以看出等级的排序顺序由小到大，在规则上转换也总是从小到大进行的。比如，<code>char</code>类型的等级为3，<code>int</code>类型的等级为10，于是这两个类型的操作数互相作用后的结果是一个等级数值更大的<code>int</code>类型。为了方便的选择转换等级，YAMPL还提供了一个元函数来完成这件事，该函数依赖元函数<code>if_c</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> largest_int =</span><br><span class="line">    if_c&lt;integral_rank&lt;T1&gt;::value &gt;= integral_rank&lt;T2&gt;::value, T1, T2&gt;;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">largest_int</span></span></span><br><span class="line"><span class="class">    :</span> if_c&lt;integral_rank&lt;T1&gt;::value &gt;= integral_rank&lt;T2&gt;::value, T1,</span><br><span class="line">                       T2&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这里无论是使用别名模板还是元函数转发都会调用元函数<code>if_c</code>比较对应类型的转换等级，最终给出拥有较大等级的类型。它们的结果是相同的，读者可以根据自己的喜好来选择<code>largest_int</code>的实现方案。</p>
<p>在下面这段代码中<code>largest_int</code>和<code>auto</code>具有相同的效果，<code>val1</code>和<code>val2</code>都会被编译器推导为<code>int</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> a2 = <span class="number">7</span>;</span><br><span class="line">largest_int&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;::type val1 = a1 + a2;</span><br><span class="line"><span class="keyword">auto</span> val2 = a1 + a2;</span><br></pre></td></tr></table></figure>

<h2 id="算术运算符元函数"><a href="#算术运算符元函数" class="headerlink" title="算术运算符元函数"></a>算术运算符元函数</h2><p>我们知道在YAMPL中，整型常量都被包装类模板包装成了特殊的类型。这种处理方式为类型序列和元函数提供了操作数值途径，但随之而来的后果是无法对包装类进行加减乘除等算术运算，同样的也无法对包装类进行逻辑运算。为了解决这类计算问题，我们需要为YAMPL提供一套打通数值计算和类型计算的元函数，让它们来完成算术和逻辑的运算工作。</p>
<p>事实上，上一篇中的<code>plus</code>元函数就可以被列出其中，不过我并不打算直接这么做，因为它还有进一步完善的空间，请看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> inner = plus&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> inner::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value + inner::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span>&lt;</span>N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value + N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>观察以上的代码可以发现它和以前的版本有两个显著的升级。首先，现在的元函数<code>plus</code>支持两个或两个以上的操作数参与到加法运算中，比如<code>plus&lt;int_&lt;3&gt;, int_&lt;2&gt;, int_&lt;5&gt;, int_&lt;6&gt;&gt;</code>。显然，为了完成这个目标我们需要实现一个递归，在代码中这个递归的发起点就是<code>using inner = plus&lt;N2, Nargs...&gt;;</code>，它使用<code>plus</code>计算除<code>N1</code>外剩余形参的结果。直到参数个数减少为2时触发结束条件，<code>struct plus&lt;N1, N2&gt;</code>计算两个形参之和并返回结果，递归结束。</p>
<p>另外还可以注意到，该版本的<code>plus</code>支持不同整型的包装类，这是因为在元函数中调用了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">largest_int&lt;<span class="keyword">typename</span> N1::value_type, <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br></pre></td></tr></table></figure>

<p>来获取计算结果的最终类型。因此<code>plus&lt;int_&lt;3&gt;, uint_&lt;2&gt;&gt;::type</code>这段代码可以顺利的编译，它的计算结果是<code>uint_&lt;5&gt;</code>。</p>
<p>当然，除了加法以外还有一些计算也可以支持多个操作数同时进行，例如乘法、位的与计算以及位的或计算等。而这些计算本质上与<code>plus</code>元函数只有运算符上的差别，以乘法为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">times</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> inner = times&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> inner::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value * inner::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">times</span>&lt;</span>N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value * N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比元函数<code>plus</code>，只是<code>N1::value + N2::value</code>被修改为了<code>N1::value * N2::value</code>。根据这样的规则，我们可以用宏来简化这类代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_MULTI_OP(name, op)                                              \</span></span><br><span class="line"><span class="meta">  template <span class="meta-string">&lt;class N1, class N2, class... Nargs&gt;</span>                                \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                                                \</span></span><br><span class="line"><span class="meta">    using inner = name<span class="meta-string">&lt;N2, Nargs...&gt;</span>;                                          \</span></span><br><span class="line"><span class="meta">    using value_type = typename largest_int&lt;typename N1::value_type,           \</span></span><br><span class="line"><span class="meta">                                            typename inner::value_type&gt;::type; \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="meta-string">&lt;value_type, N1::value op inner::value&gt;</span>;        \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                           \</span></span><br><span class="line"><span class="meta">  &#125;;                                                                           \</span></span><br><span class="line"><span class="meta">  template <span class="meta-string">&lt;class N1, class N2&gt;</span>                                                \</span></span><br><span class="line"><span class="meta">  struct name<span class="meta-string">&lt;N1, N2&gt;</span> &#123;                                                        \</span></span><br><span class="line"><span class="meta">    using value_type = typename largest_int&lt;typename N1::value_type,           \</span></span><br><span class="line"><span class="meta">                                            typename N2::value_type&gt;::type;    \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="meta-string">&lt;value_type, (N1::value op N2::value)&gt;</span>;         \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                           \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(plus, +);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(times, *);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(bitand_, &amp;);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(bitor_, |);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(bitxor_, ^);</span><br></pre></td></tr></table></figure>

<p>可以看到我将<code>+</code>、<code>*</code>、<code>&amp;</code>、<code>|</code>和<code>^</code>归为了一类，并称它们为支持多运算符同时计算的二元运算符元函数。</p>
<p>与支持多操作数的二元运算符不同，减法、除法等运算对于操作数顺序有着严格的要求，所以对于这类运算而言，他们无法支持像加法这种多操作数的运算。也正因如此，减法、除法、移位等这些运算的模板元函数的实现更加的简单了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minus</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value - N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divides</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value / N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>观察以上代码可知，减法和除法元函数的实现基本上就是加法元函数的一个特化的实现。另外它们也只有一个运算符的区别，同样可以通过宏将其简化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_SINGLE_OP(name, op)                                          \</span></span><br><span class="line"><span class="meta">  template <span class="meta-string">&lt;class N1, class N2&gt;</span>                                             \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                                             \</span></span><br><span class="line"><span class="meta">    using value_type = typename largest_int&lt;typename N1::value_type,        \</span></span><br><span class="line"><span class="meta">                                            typename N2::value_type&gt;::type; \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="meta-string">&lt;value_type, (N1::value op N2::value)&gt;</span>;      \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                        \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(minus, -);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(divides, /);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(modulus, %);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(left_shift, &lt;&lt;);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(right_shift, &gt;&gt;);</span><br></pre></td></tr></table></figure>

<p>这里<code>-</code>、<code>/</code>、<code>%</code>、<code>&lt;&lt;</code>和<code>&gt;&gt;</code>被归为一类，也就是普通的二元运算符元函数。</p>
<p>除了以上算数运算符之外，还有一个容易被忽略的运算符——取负运算符。当然，相对于前两种运算符，它的实现就更加简单了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">negate</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> T::value_type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, -T::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>综合上述运算符元函数，我们来做一道计算题<code>-((5+(10-2)*3*5/2) &lt;&lt; 2)</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> step1 = minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;;                       <span class="comment">// step1 = 10-2</span></span><br><span class="line"><span class="keyword">using</span> step2 = times&lt;<span class="keyword">typename</span> step1::type, int_&lt;<span class="number">3</span>&gt;, int_&lt;<span class="number">5</span>&gt;&gt;;  <span class="comment">// step2 = step1*3*5</span></span><br><span class="line"><span class="keyword">using</span> step3 = divides&lt;<span class="keyword">typename</span> step2::type, int_&lt;<span class="number">2</span>&gt;&gt;;         <span class="comment">// step3 = step2/2</span></span><br><span class="line"><span class="keyword">using</span> step4 = plus&lt;int_&lt;<span class="number">5</span>&gt;, <span class="keyword">typename</span> step3::type&gt;;            <span class="comment">// step4 = 5+step3</span></span><br><span class="line"><span class="keyword">using</span> step5 = left_shift&lt;<span class="keyword">typename</span> step4::type, int_&lt;<span class="number">2</span>&gt;&gt;;      <span class="comment">// step5 = step4 &lt;&lt; 2</span></span><br><span class="line"><span class="keyword">using</span> result_step = negate&lt;<span class="keyword">typename</span> step5::type&gt;;             <span class="comment">// result_step = -step5</span></span><br><span class="line"><span class="keyword">auto</span> result_value = result_step::value;</span><br></pre></td></tr></table></figure>

<p>编译以上代码，编译器计算<code>result_step</code>的类型为<code>int_&lt;-260&gt;</code>，所以<code>result_value</code>为-260。</p>
<h2 id="关系运算符元函数"><a href="#关系运算符元函数" class="headerlink" title="关系运算符元函数"></a>关系运算符元函数</h2><p>在C++中，想获得两个整数之间的关系是很容易的一件事。比如比较3和7的大小，只需要使用关系运算符<code>&lt;</code>或者<code>&gt;</code>。但使用C++模板元编程事情就变得不那么容易了，我们需要比较的是整型常量包装类之间关系，比如比较<code>int_&lt;3&gt;</code>和<code>int_&lt;7&gt;</code>的大小。所以除了算数运算符元函数，YAMPL还应该提供一套描述整型常量包装类之间关系的元函数，这也是C++模板元编程中必不可少的一环。</p>
<p>好在我们已经有了实现算术运算符元函数的基础，再实现一套关系运算符元函数也并不会觉得很难，下面是<code>==</code>运算符元函数的实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">equal_to</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value == N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码十分简洁，甚至是在算术运算符元函数中一直发挥重要作用的<code>largest_int</code>也被省去了。在<code>equal_to</code>元函数中，<code>value_type</code>被直接定义为<code>bool</code>，这很容易理解，因为关系运算符的计算结果本就是布尔类型。因此，元函数返回的结果<code>type</code>就是<code>integral_const&lt;value_type, true&gt;</code>或者<code>integral_const&lt;value_type, false&gt;</code>。是不是看上去非常熟悉？没错，它们正是<code>true_type</code>和<code>false_type</code>的定义。</p>
<p>基于和算术类型的元函数同样的原因，关系运算符的元函数也能用宏来做统一的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_SINGLE_OP_BOOL(name, op)                                \</span></span><br><span class="line"><span class="meta">  template <span class="meta-string">&lt;class N1, class N2&gt;</span>                                        \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                                        \</span></span><br><span class="line"><span class="meta">    using value_type = bool;                                           \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="meta-string">&lt;value_type, (N1::value op N2::value)&gt;</span>; \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(equal_to, ==);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(not_equal_to, !=);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(greater, &gt;);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(greater_equal, &gt;=);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(less, &lt;);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(less_equal, &lt;=);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>和<code>&lt;=</code>被归为一类，可以称它们为返回布尔包装类的二元运算符元函数。调用它们将返回<code>true_type</code>或者<code>false_type</code>，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> step1 = <span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type;</span><br><span class="line"><span class="keyword">using</span> result_type1 = <span class="keyword">typename</span> equal_to&lt;step1, int_&lt;<span class="number">8</span>&gt;&gt;::type;<span class="comment">// true_type</span></span><br><span class="line"><span class="keyword">using</span> result_type2 = <span class="keyword">typename</span> greater&lt;step1, int_&lt;<span class="number">8</span>&gt;&gt;::type; <span class="comment">// false_type</span></span><br><span class="line"><span class="keyword">using</span> result_type3 = <span class="keyword">typename</span> less&lt;step1, int_&lt;<span class="number">8</span>&gt;&gt;::type;    <span class="comment">// false_type</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/02/21/yampl-base-components-part2/" data-id="cktihnvq8009vnoupgzju20fs" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-yampl-base-components-part1" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/09/yampl-base-components-part1/">YAMPL的基础组件(1)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/01/09/yampl-base-components-part1/" class="article-date"><time datetime="2020-01-09T04:15:47.000Z" itemprop="datePublished">2020-01-09</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>从本篇开始，我们将开始进入轻量级C++模板元编程库YAMPL(Yet Another MPL)的编写环节。不过，在深入探索元编程的序列和算法之前，有一些基础工作必须完成，比如定义命名空间、定义整型常量包装类模板，编写包装类的算数和逻辑运算元函数、编写用于调试的类型打印元函数等等。在完成了这些基础组件后，序列和算法的编写工作将会变得非常高效和有趣。</p>
<h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><p>在前面的文章中，我们定义了两个特殊的类型<code>true_type</code>和<code>false_type</code>。不巧的是，在STL中也有两个一模一样的类型名，而且这两个类型在STL的type_traits中被广泛的使用，例如：<code>std::is_same</code>、<code>std::is_class</code>、<code>std::is_const</code>等等，它们的返回类型就是上述两种类型的其中之一。无独有偶，在Boost中也有这样的两个类型。其实，有一点很容易想到，作为Boost.MPL的模仿者，YAMPL中一定会存在大量与Boost.MPL中相同的命名。所以为了解决以上这类问题，必须为YAMPL安排一个命名空间。为了直观，我就直接定义YAMPL的命名空间名为<code>yampl</code>。</p>
<p>那么现在对于<code>true_type</code>这样的类型有三种实现，包括：<code>yampl::true_type</code>、<code>stl::true_type</code>以及<code>boost::true_type</code>。面对这样的情况，我们有时候会需要一个类型的转换元函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_convert_to</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_convert_to</span>&lt;</span>T, T, V&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = V;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> stl_to_yampl_true_type = type_convert_to&lt;T, std::true_type, yampl::true_type&gt;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，元函数<code>stl_to_yampl_true_type</code>可以将<code>std::true_type</code>转换为<code>yampl::true_type</code>，如果该元函数的实参不是<code>std::true_type</code>则编译出错。如果有需要在库与库之间频繁切换的情况，实现一个这样的转换元函数是很有用的一种方法。</p>
<p>有一点需要指出的是，在后面的文章中会涉及到一些对YAMPL中元函数调用的示例，这些示例一般都默认认为已经使用<code>using namespace yampl;</code>打开过<code>yampl</code>的命名空间，所以没有使用前缀写法<code>yampl::xxx</code>。只有涉及到不同命名空间类型互相转换的情况才会用前缀的方式指明命名空间。</p>
<h2 id="整型常量包装类模板"><a href="#整型常量包装类模板" class="headerlink" title="整型常量包装类模板"></a>整型常量包装类模板</h2><p>在YAMPL中的元函数都是关于类型的计算，但有时候数值计算却又是不可避免的。为了让类型计算的元函数能兼容数值计算，我们需要一个特殊的类模板，它能够将数值转换为类型。这里我们称这个特殊的类模板为整型常量包装类模板。其实在上一篇中我们已经见到过它的简化版本，以下是它的完整版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_const</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = N;</span><br><span class="line">  <span class="keyword">using</span> next = integral_const&lt;T, N + <span class="number">1</span>&gt;;</span><br><span class="line">  <span class="keyword">using</span> prior = integral_const&lt;T, N - <span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>integral_const</code>是整型常量包装类模板，其模板形参<code>T</code>是包装常量的类型，形参<code>N</code>是包装的具体数值，例如：<code>integral_const&lt;int, 5&gt;</code>是一个包装了数值为1的<code>int</code>类型常量的类型。<code>integral_const</code>定义了静态数据成员<code>value</code>来返回包装类型代表的具体数值，定义<code>value_type</code>来指示返回数值的准确类型。另外为了元函数调用形式上的统一，<code>integral_const</code>还定义内嵌类型<code>type</code>为自身。最后我们还可以发现，<code>integral_const</code>为了方便完成数值的自增和自减操作，分别定义了<code>next</code>和<code>prior</code>来表示<code>integral_const&lt;T, N + 1&gt;</code>和<code>integral_const&lt;T, N - 1&gt;</code>，于是我们可以完成这样的操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::is_same_v&lt;integral_const&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt;::next, integral_const&lt;<span class="keyword">int</span>, <span class="number">6</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p><code>std::is_same_v</code>返回的结果为<code>true</code>。</p>
<p>到目前为止<code>integral_const</code>似乎已经满足要求了，这很好，但还有一点却令人厌烦。考虑一下如果我们需要在序列中声明一连串的<code>integral_const</code>会发生什么？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">seq&lt;integral_const&lt;<span class="keyword">int</span>, <span class="number">1</span>&gt;, integral_const&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt;, integral_const&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;, ...&gt;</span><br></pre></td></tr></table></figure>

<p>显然这种写法过于冗长，这里需要一种更简洁的表达方法，我选择使用别名模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> int_ = integral_const&lt;<span class="keyword">int</span>, N&gt;;</span><br></pre></td></tr></table></figure>

<p>这样一来定义上面的序列会简洁不少：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">seq&lt;int_&lt;<span class="number">1</span>&gt;, int_&lt;<span class="number">2</span>&gt;, int_&lt;<span class="number">3</span>&gt;, ...&gt;</span><br></pre></td></tr></table></figure>

<p>另外，读者还可以定义其他别名模板以满足自己的需求，比如定义一个无符号整型常量的包装类模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> uint_ = integral_const&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, N&gt;;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，布尔类型也可以使用<code>integral_const</code>来表示，因为它能和整型发生隐式转换，但会有一些不同之处，请看下面这个针对<code>bool</code>的特化版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_const</span>&lt;</span><span class="keyword">bool</span>, N&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = N;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> bool_ = integral_const&lt;<span class="keyword">bool</span>, N&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> true_type = bool_&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = bool_&lt;<span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>观察上面的代码可以发现，特化版本的<code>integral_const</code>删除了<code>next</code>和<code>prior</code>，这是因为布尔类型只有<code>true</code>和<code>false</code>之分，自增和自减对于它是没有意义的。另外还定义了<code>true_type</code>和<code>false_type</code>以方便后续使用，它们在YAMPL中使用的是比较频繁的。</p>
<h2 id="if元函数"><a href="#if元函数" class="headerlink" title="if元函数"></a>if元函数</h2><p><code>if</code>元函数是YAMPL中最常用的元函数之一，又因为它不依赖其他元函数，所以应该优先介绍它。不过实际上，我们在上一篇已经对<code>if</code>元函数做过了比较详细的介绍了，为了本篇知识体系的完整性这里将它拿出来总结一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_c</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = N1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_c</span>&lt;</span><span class="literal">false</span>, N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = N2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> if_c&lt;!!T::value, N1, N2&gt;::type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码有两个元函数<code>if</code>和<code>if_c</code>，其中<code>if_c</code>是真正实现选择逻辑的元函数，它接受的条件参数是布尔值。而元函数<code>if</code>对<code>if_c</code>进行了一次包装，这使得它接受的条件参数从一个布尔值转换为了类型，而且这种类型还有相当不错的兼容性，它只要求类型具有静态数据成员<code>value</code>即可，所以上一节提到的<code>true_type</code>、<code>false_type</code>、<code>int_&lt;7&gt;</code>甚至其他库的<code>std::true_type</code>、<code>boost::mpl::false_</code>等等都可以兼容<code>if</code>元函数。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/01/09/yampl-base-components-part1/" data-id="cktihnvq7009rnoupeld3dvep" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-metaprogramming-metafunction-part2" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/12/metaprogramming-metafunction-part2/">元函数和序列(2)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2019/12/12/metaprogramming-metafunction-part2/" class="article-date"><time datetime="2019-12-12T13:54:26.000Z" itemprop="datePublished">2019-12-12</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>接着上一篇的话题</p>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>一说到序列，我们很容易想到STL中的容器<code>vector</code>。相对于数组，C++程序员显然更喜欢<code>vector</code>，这不仅是因为<code>vector</code>可以动态的扩展容器的空间，更是因为STL为它提供了一系列使用算法，比如插入、查找等等。事实上，关于STL序列的设计思路放在C++模板元编程中也同样适用。要知道，Boost.MPL中的大多数算法都是操作于序列之上的，它能够发挥模板元编程更大潜力，也正因如此序列对于模板元编程才如此的重要。</p>
<p>当然，相对于STL的<code>vector</code>使用于运行期，模板元编程的序列必须是在编译阶段就能够存储数据的，所以我们能够使用的也只有类模板，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><code>seq</code>是一个最简单的序列，但千万别小瞧了它，因为它能够容纳任意多个元素。而实现这一能力的关键是C++11标准中引入的可变模板参数的特性，所以这里<code>seq</code>真正存储数据的是模板参数，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> integer_list = seq&lt;<span class="keyword">int</span>, <span class="keyword">short</span>, <span class="keyword">char</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，类模板实参<code>&lt;int, short, char&gt;</code>为序列<code>seq</code>的保存元素。好了，现在我们已经有了一个最基本的序列，接下来还需要准备一些配合序列的算法。继续对比STL的<code>vector</code>，最常用的<code>vector</code>算法应该是成员函数<code>push_back</code>，那么我们也来给<code>seq</code>实现一个编译阶段的<code>seq_push_back</code>元函数。这听起来似乎有些难度，不过事实上在可变模板形参的基础上实现<code>push_back</code>算法是很容易的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_push_back</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_push_back</span>&lt;</span>seq&lt;Args...&gt;, T&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = seq&lt;Args..., T&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，首先声明了一个元函数<code>seq_push_back</code>，它有两个形参分别为<code>S</code>和<code>T</code>，其中<code>S</code>表示序列，而<code>T</code>代表即将插入的元素。接着代码偏特化了一个<code>seq_push_back</code>，该版本对<code>S</code>为<code>seq</code>的情况定义了元函数的具体实现。请注意这里的实现细节，因为后文中很多算法的实现都基于这个思路。在这个版本中引入了可变形参<code>class... Args</code>，并且将其运用于特化的参数中<code>struct seq_push_back&lt;seq&lt;Args...&gt;, T&gt;</code>，这样就可以利用编译器推导出<code>Args</code>的具体实参。最终通过<code>Args</code>定义新的<code>seq</code>类型以达到<code>push_back</code>算法的目的：<code>using type = seq&lt;Args..., T&gt;;</code>。值得注意的是，元函数<code>seq_push_back</code>并没有提供通用版本的实现，所以当模板实参<code>S</code>不是<code>seq</code>类型的时候编译将无法正确进行。</p>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><p>在C++模板元编程中代码的选择结构是由元函数实现的。这一点比较容易理解，毕竟类模板的特化正好适合来做这件事，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> C, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_</span>&lt;</span><span class="literal">false</span>, T, F&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现了两个版本的<code>if_</code>元函数，其中通用版本无条件的返回模板形参<code>T</code>，而针对模板形参<code>C</code>为<code>false</code>的偏特化版本返回的则是模板形参<code>F</code>。这样一来元函数就可以根据模板形参<code>C</code>的具体值返回不同的类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">if_&lt;<span class="literal">false</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::type double_value;</span><br><span class="line">if_&lt;<span class="literal">true</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::type int_value;</span><br></pre></td></tr></table></figure>

<p>作为模板元编程中编写选择结构的常用技巧，STL也实现了一份类似的代码，不过在STL中元函数的函数名为<code>conditional</code>，除此以外基本上没有差异包括调用方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::conditional&lt;<span class="literal">true</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::type</span><br></pre></td></tr></table></figure>

<p>请注意，无论是上面的<code>if_</code>还是<code>std::conditional</code>都存在一个问题，那就是将数值和类型计算混合了。我们希望能有一个只有类型计算的<code>if_</code>版本。想达到这个目的需要用到编写<code>plus</code>元函数时的同一个技巧，即创建一个布尔值和类型之前的桥梁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> C&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bool_</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> true_type = bool_&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = bool_&lt;<span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们将数值和类型进行了转换，数值<code>true</code>和<code>false</code>分别转换为了类型<code>true_type</code>和<code>false_type</code>。于此同步的，<code>if_</code>也需要进行一些修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> C, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_c</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_c</span>&lt;</span><span class="literal">false</span>, T, F&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> if_c&lt;!!C::value, T, F&gt;::type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中存在两个选择元函数<code>if_c</code>和<code>if_</code>，其中<code>if_c</code>的实现和上一个版本的<code>if_</code>一样，通过布尔值<code>C</code>来确定返回的类型。相对的，当前版本的<code>if_</code>元函数的第一个参数<code>C</code>是类型而非是布尔值，进一步来说这个类型<code>C</code>必须是一个带有常量静态数据成员<code>value</code>的类型。元函数<code>if_</code>会通过<code>!!C::value</code>的方法将数值转换成布尔值，最终调用<code>if_c</code>返回目标类型。</p>
<p>由于元函数<code>if_</code>的形参发生了改变，其调用方法也需要做相应的调整：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">if_&lt;false_type, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::type double_value;</span><br><span class="line">if_&lt;true_type, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::type int_value;</span><br></pre></td></tr></table></figure>

<p>“<code>if_</code>是改写好了，但是我到目前为止并没有发现这样大动干戈改写的任何好处呀？”相信很多读者会有这样的疑问。这很好，不过现在还不是解释这个问题的最佳时机，请先相信这样的修改一定会带来某种优势吧。</p>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>与选择结构不同，循环结构没有惯用元函数的具体实现。一般来说，模板元编程中的循环都是根据实际需要来实现的。不过好在它们的实现都有固定的方法和模式，所以总体而言并不算难。让我们先看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;</span>N, Args...&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = N + sum&lt;Args...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;</span>N&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = N;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，元函数<code>sum</code>有3个版本，其中通用版本的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>;</span></span><br></pre></td></tr></table></figure>

<p>只有声明却没提供实现，而真正的实现是由它的两个特化版本来完成的。首先<code>struct sum&lt;N, Args...&gt;</code>是一个通过递归完成循环的元函数，它的返回值是第一个形参<code>N</code>与使用剩余形参调用的<code>sum</code>的返回值之和，这样理所当然的形成了一个循环结构。请注意，在普通的C++编程中，我们经常会用到无限循环，但是在模板元编程中无限循环不具有任何意义，毕竟谁也不想自己的程序永远无法通过编译。事实上也真不会发生这样的事情，因为编译器最终会由于递归过多而停止编译并报错。所以在元编程的循环结构中，我们需要为其准备一个有效的结束条件。在本例中，这个结束条件就是<code>struct sum&lt;N&gt;</code>，它定义当<code>sum</code>的形参只剩下一个时递归结束，直接返回形参<code>N</code>，至此整个递归开始折返。</p>
<p>调用元函数<code>sum</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = sum&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&gt;::value;</span><br></pre></td></tr></table></figure>

<p>这句代码在编译器中的计算顺序相当于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = <span class="number">1</span> + (<span class="number">2</span> + (<span class="number">3</span> + (<span class="number">4</span>)));</span><br></pre></td></tr></table></figure>

<p>也正是递归操作的顺序。</p>
<p>以上是一个数值计算的求和元函数，按照惯例我们实际期望的是类型计算元函数。接下来我们可以利用之前介绍的<code>plus</code>元函数来实现一个类型计算的求和元函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;</span>N, Args...&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> plus&lt;N, <span class="keyword">typename</span> sum&lt;Args...&gt;::type&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;</span>N&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = N;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = sum&lt;int_&lt;<span class="number">1</span>&gt;, int_&lt;<span class="number">2</span>&gt;, int_&lt;<span class="number">3</span>&gt;, int_&lt;<span class="number">4</span>&gt;&gt;::type::value;</span><br></pre></td></tr></table></figure>

<p>可以看到在上面的代码中关于数值计算的痕迹都被抹去，元函数的调用方式也发生了略微的变化。但是不变的是实现循环结构的方法。在代码中<code>using type = typename plus&lt;N, typename sum&lt;Args...&gt;::type&gt;::type;</code>虽然冗长但还算清晰，很明显<code>type</code>的结果依赖元函数<code>plus</code>计算的结果，而<code>plus</code>的计算结果又依赖于<code>sum</code>的第一个形参与剩余形参调用<code>sum</code>的计算结果，这样就形成了递归，除多了一步<code>plus</code>的调用以外其他过程基本上和上一个版本一致。另外，同样一致的还有递归的结束条件，<code>struct sum&lt;N&gt;</code>与上一个版本唯一的区别是返回类型本身而不是返回数值。</p>
<p>根据以上两个例子我们可以总结出模板元编程循环结构的两个关键点：更新形参递归并调用元函数本身以及定义有效的结束条件。让我们带上这两个关键点来看下一个例子，这个例子结合了上文提到的序列和选择结构，实际上循环和选择正是序列相关算法的关键，在真实的模板元编程代码中它们是最好的搭档。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">result_wrap</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_is_all_reference</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_is_all_reference</span>&lt;</span>seq&lt;T, Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> cond = <span class="keyword">typename</span> std::is_reference&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> result = <span class="keyword">typename</span> if_&lt;cond, seq_is_all_reference&lt;seq&lt;Args...&gt;&gt;, result_wrap&lt;false_type&gt;&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> result::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_is_all_reference</span>&lt;</span>seq&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> cond = <span class="keyword">typename</span> std::is_reference&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> if_&lt;cond, true_type, false_type&gt;::type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，元函数<code>seq_is_all_reference</code>的作用是判断序列<code>seq</code>中的元素是否全都是引用类型，如果都是引用类型就返回<code>true_type</code>，否则返回<code>false_type</code>。在实现上<code>seq_is_all_reference</code>相对复杂一些，因为代码中循环和选择发生了互相嵌套的情况。<code>seq_is_all_reference&lt;seq&lt;T, Args...&gt;&gt;</code>首先判断第一个参数<code>T</code>是否为引用类型，并将结果<code>cond</code>作为实参调用元函数<code>if_</code>。接下来<code>if_</code>判断<code>cond</code>的结果，如果结果为<code>std::true_type</code>则进入递归流程<code>seq_is_all_reference&lt;seq&lt;Args...&gt;</code>，目的是判断后续的参数是否为引用类型。如果<code>cond</code>的结果是<code>std::false_type</code>，那么循环终止并返回<code>false_type</code>。请注意，这里<code>cond</code>是<code>std::is_reference&lt;T&gt;</code>返回的结果，所以结果类型是<code>std::true_type</code>或者<code>std::false_type</code>，而<code>seq_is_all_reference</code>是我们自己的元函数，其返回结果是<code>true_type</code>或者<code>false_type</code>。另外，读者可能也发现了，在<code>seq_is_all_reference</code>的循环结束条件并非只有一个。比较明显的是<code>seq_is_all_reference&lt;seq&lt;T&gt;&gt;</code>，它定义当形参只剩一个的情况下元函数返回<code>cond</code>的结果。除此之外，<code>seq_is_all_reference&lt;seq&lt;Args...&gt;</code>还隐含了一个结束条件，就是当<code>cond</code>为<code>std::false_type</code>时递归中断并返回结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> test_seq1 = seq&lt;<span class="keyword">int</span>&amp;, <span class="keyword">double</span>, <span class="keyword">short</span>&amp;&gt;;</span><br><span class="line"><span class="keyword">using</span> test_seq2 = seq&lt;<span class="keyword">int</span>&amp;, <span class="keyword">double</span>&amp;, <span class="keyword">short</span>&amp;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> result_type1 = seq_is_all_reference&lt;test_seq1&gt;::type;	<span class="comment">// result_type1为false_type</span></span><br><span class="line"><span class="keyword">using</span> result_type2 = seq_is_all_reference&lt;test_seq2&gt;::type; <span class="comment">// result_type2为true_type</span></span><br></pre></td></tr></table></figure>

<p>以上代码演示了对<code>seq_is_all_reference</code>的使用方法。其中序列<code>test_seq1</code>中由于<code>double</code>不是引用类型的关系，所以返回结果是<code>false_type</code>。而序列<code>test_seq2</code>中的所有元素都是引用类型于是返回了<code>true_type</code>。来看一个更加实际的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_class_need_ref</span> &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(seq_is_all_reference&lt;seq&lt;Args...&gt;&gt;::type::value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_class_need_ref&lt;<span class="keyword">int</span>&amp;, <span class="keyword">double</span>&amp;&gt; obj1;	<span class="comment">// 编译成功</span></span><br><span class="line">some_class_need_ref&lt;<span class="keyword">int</span>&amp;, <span class="keyword">double</span>&gt; obj2;		<span class="comment">// 触发static_assert，编译失败</span></span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个特别的类模板，它要求模板参数必须都是引用类型。它在定义中加上了<code>static_assert(seq_is_all_reference&lt;seq&lt;Args...&gt;&gt;::type::value);</code>以检查调用者是否正确实例化了类模板。在编译的过程中，编译器发现<code>obj2</code>的类型<code>some_class_need_ref&lt;int&amp;, double&gt;</code>的模板参数并不是规定中的引用类型，于是<code>static_assert</code>被触发导致编译失败。</p>
<p>到目前为止，我们已经了解了C++模板元编程中元函数和序列的基本概念和使用方法。另外我们还看到了用元函数来控制选择和循环等代码流程的方法，之后我们将选择和循环结合在一起完成了一个判断序列中的所有元素是否为引用类型的元函数示例。可以说我们现在已经有办法独立编写一些模板元程序了。接下来的文章将会更进一步，我们将会接触到更为复杂的元程序，在那里我们会一起实现一个轻量级C++模板元编程库——YAMPL。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2019/12/12/metaprogramming-metafunction-part2/" data-id="cktihnvq8009tnoupg7ru24iz" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-metaprogramming-metafunction-part1" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/11/metaprogramming-metafunction-part1/">元函数和序列(1)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2019/11/11/metaprogramming-metafunction-part1/" class="article-date"><time datetime="2019-11-11T14:18:37.000Z" itemprop="datePublished">2019-11-11</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>元函数简单来说就是一种可以在编译期调用的函数，它操作的对象一定是编译期可以确定的，比如类型和常量。元函数也是模板元编程中最基础的组成部分，甚至代码中的选择和循环等控制流都是由元函数来完成。而序列则进一步释放了元函数的威力，我们可以通过元函数为序列提供丰富的算法以解决各种实际问题。</p>
<h2 id="元函数"><a href="#元函数" class="headerlink" title="元函数"></a>元函数</h2><p>一个普通的C++函数通常由函数名称、参数、返回类型以及函数主体这4个部分组成，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为对比，C++模板元编程的元函数同样也存在函数名称、参数以及函数主体3个部分，只不过它们的形式有一些不同罢了。还是以<code>plus</code>函数为例，将其改写为元函数后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> a, <span class="keyword">int</span> b&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到以上代码，有人可能会惊呼道：“这哪是什么函数，它明明就是一个类模板！”。是的没错！它确实是一个类模板，可同时也是一个元函数。让我们先接受这个定义，这样可以让我们很容易的找到它和普通函数版本的对应关系：首先<code>plus</code>作为类模板名也是元函数名，然后类模板形参<code>int a, int b</code>对应是元函数的形参，最后元函数的函数体就是类模板的定义。虽然在元函数中我们没有办法定义返回类型（实际上也没有必要定义，因为大多数时候元函数返回的就是类型本身），但是可以通过约定元函数的函数体中静态变量名称的方法定义数值的返回值，体现在<code>plus</code>中即为<code>static constexpr int value = a + b;</code>，通常情况下，元函数会约定<code>value</code>为数值类型的返回值名称。</p>
<p>另外还有一种特殊的情况，当元函数没有形参时，对应的则是类或者实例化的类模板。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kilometer</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> plus11 = plus&lt;<span class="number">3</span>, <span class="number">8</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>在C++模板元编程中，对于数值计算元函数的调用实际上就是访问起静态成员，根据约定会获取<code>value</code>的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = plus&lt;<span class="number">7</span>, <span class="number">11</span>&gt;::value;</span><br><span class="line"><span class="keyword">auto</span> x2 = kilometer::value;</span><br><span class="line"><span class="keyword">auto</span> x3 = plus11::value;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们看到的都是有关数值计算的元函数，但是我又强调过数值计算并非元函数的重点工作。其实这是有意为之，目的是为了方便元函数与普通函数的对比，接下来让我把数值转换为类型以帮助我们讨论类型计算元函数。</p>
<p>这里我并不打算让类型计算元函数的例子显得过于跳跃，所以还是以<code>plus</code>为例将其修改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int_</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = int_&lt;T1::value + T2::value&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中新增了一个类模板<code>int_</code>。<code>int_</code>的实现非常简单，只是将数值转换成了类型。不过请不要小看了它的作用，因为它为类型计算元函数提供了计算数值的桥梁。我们发现元函数<code>plus</code>的参数不再是数值类型而是类型本身，更有意思的是它也不再返回数值而是返回类型本身。请注意，对于类型计算的元函数，返回的是可公开访问的嵌套类型，我们通常约定该类型名为<code>type</code>。在这个例子中即是：<code>using type = int_&lt;T1::value + T2::value&gt;;</code>。当然，除了使用<code>using</code>来定义别名以外，使用<code>typedef</code>也是允许的。我选择使用<code>using</code>，一方面因为它是新标准推荐的做法，另一方面从语法上看它更像是一个赋值语句，作为元函数的一部分它更容易理解。</p>
<p>同样的道理，调用类型计算元函数也需要用到<code>using</code>或者<code>typedef</code>，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> new_type = <span class="keyword">typename</span> plus&lt;int_&lt;<span class="number">7</span>&gt;, int_&lt;<span class="number">11</span>&gt;&gt;::type;</span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(std::is_same_v&lt;new_type, int_&lt;<span class="number">18</span>&gt;&gt;);</span><br></pre></td></tr></table></figure>

<p>上面的代码可以成功编译，这表明通过元函数<code>plus&lt;int_&lt;7&gt;, int_&lt;11&gt;&gt;::type</code>得出的新类型<code>new_type</code>和预期结果<code>int_&lt;18&gt;</code>是符合的。</p>
<p>还有需要解释的一点是，虽然上文中介绍一些编写元函数的常规约定，但是有时候也可以灵活处理。比如，作为元函数的本体类模板，完全有能力返回多个嵌套类型或者常量数值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = int_&lt;T1::value + T2::value&gt;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样修改的好处是能够直接访问元函数计算的数值结果，而不必通过<code>::type</code>间接的访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = plus&lt;int_&lt;<span class="number">7</span>&gt;, int_&lt;<span class="number">11</span>&gt;&gt;::value;</span><br></pre></td></tr></table></figure>

<p>最后也是元函数最重要的一个特点：特化。特化是C++模板元编程能够成立的根基。我们知道通过特化可以针对类模板的特定参数来规定类模板的具体行为，而元函数正是利用这一点来实现选择和循环等控制流的。关于特化在元函数中具体的使用方法，我将在后面的内容中详细介绍。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2019/11/11/metaprogramming-metafunction-part1/" data-id="cktihnvq7009onoup3zzb9ihc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-metaprogramming-overview" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/20/metaprogramming-overview/">初探C++模板元编程</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2019/10/20/metaprogramming-overview/" class="article-date"><time datetime="2019-10-20T12:38:15.000Z" itemprop="datePublished">2019-10-20</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>C++模板元编程，通常来说是指利用模板控制编译器产生临时源代码的技术。该临时源代码可以和以后代码共同编译为可执行程序。由于模板元编程控制的是编译器，所以这个过程是在编译期进行，对于代码运行期的状态没有影响。</p>
<p>使用C++模板元编程编写的程序我们可以称之为模板元程序，最简单的模板元程序我们可以写成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> mytype = <span class="keyword">int</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;std::is_same&lt;mytype, int&gt;::value = &quot;</span></span><br><span class="line">            &lt;&lt; std::is_same&lt;mytype, <span class="keyword">int</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中<code>std::is_same&lt;mytype, int&gt;::value</code>是典型的模板元程序代码，编译器会在编译期对这句代码进行计算，最终产生以下临时代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;std::is_same&lt;mytype, int&gt;::value = &quot;</span></span><br><span class="line">            &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>进一步可以看出，由于<code>std::is_same&lt;mytype, int&gt;::value</code>在编译期已经得出结果，所以它并不会对程序的运行产生任何副作用。</p>
<p>解释到这里，我想读者应该对C++模板元编程和模板元程序有了一个大概的理解。实际上，在我刚刚接触到模板元程序的时候，最疑惑的问题就是它为什么叫做元程序（metaprogram）。经过一番研究后发现，meta起源于希腊语，有after和beyond的含义，作为前缀通常用于表达更高抽象水平的描述。比如在解释数据库元数据（MetaData）时，我们说它是定义数据的数据。而联想到元程序，同样也可以理解为定义程序的程序。熟悉编写编译器的读者应该会接触到flex和bison（或者lex和yacc）。它们是一对词法和语法的解析器生成器，我们可以通过定义词法和语法规则让它们生成出相当完善的词法和语法的解析器源代码，所以flex和bison就是一对最典型的元程序。</p>
<h2 id="最早的C-模板元程序"><a href="#最早的C-模板元程序" class="headerlink" title="最早的C++模板元程序"></a>最早的C++模板元程序</h2><p>1994年Erwin Unruh在C++委员会上提交了下面这份代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prime number computation by Erwin Unruh</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span> <span class="built_in">D</span>(<span class="keyword">void</span>*); <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> p, <span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> prim = (p%i) &amp;&amp; is_prime&lt;(i &gt; <span class="number">2</span> ? p : <span class="number">0</span>), i <span class="number">-1</span>&gt; :: prim &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">int</span> i &gt; <span class="class"><span class="keyword">struct</span> <span class="title">Prime_print</span> &#123;</span></span><br><span class="line">    Prime_print&lt;i<span class="number">-1</span>&gt; a;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> prim = is_prime&lt;i, i<span class="number">-1</span>&gt;::prim &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; D&lt;i&gt; d = prim; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span>&lt;</span><span class="number">0</span>,<span class="number">0</span>&gt; &#123; <span class="class"><span class="keyword">enum</span> &#123;</span>prim=<span class="number">1</span>&#125;; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span>&lt;</span><span class="number">0</span>,<span class="number">1</span>&gt; &#123; <span class="class"><span class="keyword">enum</span> &#123;</span>prim=<span class="number">1</span>&#125;; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Prime_print</span>&lt;</span><span class="number">2</span>&gt; &#123; <span class="class"><span class="keyword">enum</span> &#123;</span>prim = <span class="number">1</span>&#125;; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; D&lt;<span class="number">2</span>&gt; d = prim; &#125; &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">    Prime_print&lt;LAST&gt; a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从类模板命名上看，它似乎是一份打印质数的代码。但是请注意，这份代码在现在看来并不符合当前C++的语法规范，所以是无法通过编译的。实际上，当时Erwin Unruh使用的是一款叫做Metaware Compiler的编译器编译的上述代码，虽然仍然无法通过编译，但是却能输出一些有趣的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MetaWare High C/C++ Compiler R2.6</span><br><span class="line">(c) Copyright 1987-94, MetaWare Incorporated</span><br><span class="line">E &quot;primes.cpp&quot;,L16/C63(#416):   prim</span><br><span class="line">|    Type `enum&#123;&#125;´ can´t be converted to txpe `D&lt;2&gt;´ (&quot;primes.cpp&quot;,L2/C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21/C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11/C25(#416):   prim</span><br><span class="line">|    Type `enum&#123;&#125;´ can´t be converted to txpe `D&lt;3&gt;´ (&quot;primes.cpp&quot;,L2/C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21/C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11/C25(#416):   prim</span><br><span class="line">|    Type `enum&#123;&#125;´ can´t be converted to txpe `D&lt;5&gt;´ (&quot;primes.cpp&quot;,L2/C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21/C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11/C25(#416):   prim</span><br><span class="line">|    Type `enum&#123;&#125;´ can´t be converted to txpe `D&lt;7&gt;´ (&quot;primes.cpp&quot;,L2/C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21/C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11/C25(#416):   prim</span><br><span class="line">|    Type `enum&#123;&#125;´ can´t be converted to txpe `D&lt;11&gt;´ (&quot;primes.cpp&quot;,L2/C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21/C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11/C25(#416):   prim</span><br><span class="line">|    Type `enum&#123;&#125;´ can´t be converted to txpe `D&lt;13&gt;´ (&quot;primes.cpp&quot;,L2/C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21/C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11/C25(#416):   prim</span><br><span class="line">|    Type `enum&#123;&#125;´ can´t be converted to txpe `D&lt;17&gt;´ (&quot;primes.cpp&quot;,L2/C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21/C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11/C25(#416):   prim</span><br><span class="line">|    Type `enum&#123;&#125;´ can´t be converted to txpe `D&lt;19&gt;´ (&quot;primes.cpp&quot;,L2/C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21/C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11/C25(#416):   prim</span><br><span class="line">|    Type `enum&#123;&#125;´ can´t be converted to txpe `D&lt;23&gt;´ (&quot;primes.cpp&quot;,L2/C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21/C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11/C25(#416):   prim</span><br><span class="line">|    Type `enum&#123;&#125;´ can´t be converted to txpe `D&lt;29&gt;´ (&quot;primes.cpp&quot;,L2/C25).</span><br></pre></td></tr></table></figure>

<p>观察上面这份编译器输出的错误信息，我们发现每条错误信息都给出了一个质数，例如<code>D&lt;2&gt;</code>、<code>D&lt;3&gt;</code>、<code>D&lt;4&gt;</code>等等，这说明编译器在编译阶段已经开始了对模板的计算。在1994年之后，Erwin Unruh发现上述代码已经不能被新语法所支持，所以在2002年发布了新代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prime number computation by Erwin Unruh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span> <span class="built_in">D</span>(<span class="keyword">void</span>*); <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> p, <span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">enum</span> &#123;</span> prim = (p==<span class="number">2</span>) || (p%i) &amp;&amp; is_prime&lt;(i&gt;<span class="number">2</span>?p:<span class="number">0</span>), i<span class="number">-1</span>&gt; :: prim &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Prime_print</span> &#123;</span></span><br><span class="line"> Prime_print&lt;i<span class="number">-1</span>&gt; a;</span><br><span class="line"> <span class="class"><span class="keyword">enum</span> &#123;</span> prim = is_prime&lt;i, i<span class="number">-1</span>&gt;::prim &#125;;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; D&lt;i&gt; d = prim ? <span class="number">1</span> : <span class="number">0</span>; a.<span class="built_in">f</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span>&lt;</span><span class="number">0</span>,<span class="number">0</span>&gt; &#123; <span class="class"><span class="keyword">enum</span> &#123;</span>prim=<span class="number">1</span>&#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span>&lt;</span><span class="number">0</span>,<span class="number">1</span>&gt; &#123; <span class="class"><span class="keyword">enum</span> &#123;</span>prim=<span class="number">1</span>&#125;; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Prime_print</span>&lt;</span><span class="number">1</span>&gt; &#123;</span><br><span class="line"> <span class="class"><span class="keyword">enum</span> &#123;</span>prim=<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; D&lt;<span class="number">1</span>&gt; d = prim ? <span class="number">1</span> : <span class="number">0</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>() &#123;</span><br><span class="line"> Prime_print&lt;LAST&gt; a;</span><br><span class="line"> a.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份代码可以用较老版本的GCC编译，比如GCC 4.1，同样的它会让编译器计算并打印出关于质数的错误信息（由于错误信息过多影响阅读，所以这里省略了无用部分，想看完整错误信息的读者可以自己尝试编译上述代码。）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 17]&#x27;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 13]&#x27;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 11]&#x27;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 7]&#x27;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 5]&#x27;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 3]&#x27;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 2]&#x27;</span><br></pre></td></tr></table></figure>

<p>虽然这份代码可以使用GCC编译，不过有些遗憾的是，它依然无法编译成功。为了弥补这个缺憾，我再次对这份代码进行了修改，修改的目的有两个：</p>
<ol>
<li>使用现代C++语法；</li>
<li>消除错误信息，让代码能够顺利的编译。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>... args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prime_values</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>...(args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">t</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="title">template</span> &lt;</span>T...&gt; <span class="class"><span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add_to</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">t</span>, <span class="title">template</span> &lt;</span>T...&gt; <span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">template</span> &lt;</span>T...&gt; <span class="class"><span class="keyword">class</span> <span class="title">R</span>,</span></span><br><span class="line"><span class="class">          <span class="title">T</span>... <span class="title">args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add_to</span>&lt;</span>T, t, U&lt;args...&gt;, R&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> result = R&lt;t, args...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">is_prime2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n, <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prime_list</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> result = <span class="keyword">typename</span> prime_list&lt;n - <span class="number">1</span>, <span class="built_in">is_prime2</span>(n - <span class="number">1</span>)&gt;::result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prime_list</span>&lt;</span>n, <span class="number">1</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> result =</span><br><span class="line">      <span class="keyword">typename</span> add_to&lt;<span class="keyword">int</span>, n,</span><br><span class="line">                      <span class="keyword">typename</span> prime_list&lt;n - <span class="number">1</span>, <span class="built_in">is_prime2</span>(n - <span class="number">1</span>)&gt;::result,</span><br><span class="line">                      prime_values&gt;::result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prime_list</span>&lt;</span><span class="number">2</span>, <span class="number">1</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> result = prime_values&lt;<span class="number">2</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">get_prime_list_t</span> = <span class="keyword">typename</span> prime_list&lt;n, n - <span class="number">2</span>&gt;::result;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic <span class="meta-keyword">warning</span> <span class="meta-string">&quot;-Wsign-compare&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DbgPrintType</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(T) &gt; <span class="number">-1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_TYPE(x) DbgPrintType<span class="meta-string">&lt;x&gt;</span>();</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_VALUE_TYPE(x) DbgPrintType<span class="meta-string">&lt;decltype(x)&gt;</span>();</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get_prime_list_t</span>&lt;LAST&gt; x;</span><br><span class="line">  <span class="built_in">PRINT_VALUE_TYPE</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于不熟悉模板元编程的读者来说，上面的代码可能不是很好理解。不过没关系，后面会详细介绍模板元编程的细节。现在我只是想让读者看到模板元编程的强大和有趣之处。</p>
<p>使用支持C++17标准的GCC可以成功编译以上代码并且输出以下警告信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.cpp: In instantiation of &#x27;struct DbgPrintType&lt;prime_values&lt;17, 13, 11, 7, 5, 3, 2&gt; &gt;&#x27;:</span><br><span class="line">test.cpp:62:3:   required from here</span><br><span class="line">test.cpp:53:24: warning: comparison of integer expressions of different signedness: &#x27;long long unsigned int&#x27; and &#x27;int&#x27; [-Wsign-compare]</span><br><span class="line">   53 |   enum &#123; n = sizeof(T) &gt; -1 &#125;;</span><br><span class="line">      |              ~~~~~~~~~~^~~~</span><br></pre></td></tr></table></figure>

<p>在这些警告信息中，我们可以清晰的看到一组倒序的质数序列<code>17, 13, 11, 7, 5, 3, 2</code>。值得注意的是，这条警告是我有意而为之的，目的是为了让编译器打印出质数序列。</p>
<p>事实上，从语法角度来说模板元编程是图灵完备（Turing Complete）的，也就是说理论上能够解决所有可计算的问题。不过有些遗憾的是，从编译器的角度来说模板元编程是图灵不完备的，因为作为循环的实现方法，递归在编译器中是有明确的深度限制的。</p>
<h2 id="范型编程与C-模板元编程"><a href="#范型编程与C-模板元编程" class="headerlink" title="范型编程与C++模板元编程"></a>范型编程与C++模板元编程</h2><p>泛型编程是一种编程风格，它允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，并在实例化时作为参数指明这些类型。在C++语言中，实现范型编程的基础就是模板，换句话说模板也是为了让C++具有范型能力而设计的。</p>
<p>模板元编程则有些不同，正如我们在上文中看到的，它的出现更像是一个意外而并非有意设计。这也能解释模板元编程的语法为什么如此晦涩难懂。不过幸运的是，模板元编程除了晦涩难懂之外，还是带来了一些意外的惊喜。比如它可以为范型编程加入静态类型检查以及策略定制的能力。</p>
<h2 id="接下来做什么"><a href="#接下来做什么" class="headerlink" title="接下来做什么"></a>接下来做什么</h2><p>如果只是用C++模板元编程做数值计算，那么我敢肯定的说这种计算有90%是几乎没有意义的，因为使用运行期做数值计算往往是更好的方法。而真正让模板元编程具有价值的是它对类型的计算能力，通过类型计算能够让我们的代码更加通用且有更高的运行效率，当然代价是更加晦涩难懂的代码，更长的编译时间，以及更加复杂的错误信息。不过读者也不必担心这些代价，因为后续部分就是围绕着类型计算以及其相关问题展开的。</p>
<p>在后面的内容中，我们首先将接触到序列和元函数的概念以及它们的习惯用法。然后我们会使用序列和元函数完成基本的判断和循环操作。以上是模板元编程的基础部分，在此之后我们将实现一套轻量级的模板元编程库YAMPL（Yet Another MPL），YAMPL在接口上将非常接近Boost的MPL。请注意，实现YAMPL的目的并不是取代MPL，而是让我们牢牢掌握模板元编程的一种手段。</p>
<p>事实上，无论什么时候，只要用到模板元编程，STL的type_traits和Boost的MPL这些成熟的模板元编程库都应该是优先考虑的对象。其中STL的type_traits专注于完成关于类型的一些基本操作，它是模板元编程的基础设施，是一个正规模板元编程程序库必不可少的组成部分。而Boost的MPL则是一个强大的模板元编程框架，它构建于Boost的type_traits的基础之上，并且提供一套强大且连贯的工具集，这些工具能让C++模板元编程变得简单有趣。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2019/10/20/metaprogramming-overview/" data-id="cktihnvq6009mnoup9lw1fxjq" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-printer-api-tip" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/03/printer-api-tip/">打印机API相关的一点记录</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2019/09/03/printer-api-tip/" class="article-date"><time datetime="2019-09-03T12:01:29.000Z" itemprop="datePublished">2019-09-03</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>最近研究了一点Windows上打印相关的内容，发现打印这块的东西的确挺多的。比如纸张，分辨率，打印处理器，打印数据类型等等。</p>
<p>首先我们需要通过<code>EnumPrintersW</code>枚举打印机，为了方便我写了一个简单的类模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> PRINTER_INFO_2, <span class="keyword">int</span> level = <span class="number">2</span>&gt;</span><br><span class="line">class CEnumPrinter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">Init</span>(ULONG flags)</span><br><span class="line">    &#123;</span><br><span class="line">        ULONG bytes_needed = <span class="number">0</span>;</span><br><span class="line">        ULONG elems_returned = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">EnumPrintersW</span>(flags, <span class="literal">nullptr</span>, level, <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;bytes_needed, &amp;elems_returned);</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(bytes_needed);</span><br><span class="line">        <span class="built_in">EnumPrintersW</span>(flags, <span class="literal">nullptr</span>, level, buffer_.<span class="built_in">data</span>(), bytes_needed, &amp;bytes_needed, &amp;elems_returned);</span><br><span class="line">        elems_returned_ = elems_returned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ULONG <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems_returned_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] (ULONG idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(idx &lt; elems_returned_);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(buffer_.<span class="built_in">data</span>())[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;UCHAR&gt; buffer_;</span><br><span class="line">    ULONG elems_returned_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在枚举和选择目标打印机之后可以通过<code>PRINTER_INFO_2</code>中的<code>pPrinterName</code>获得打印机句柄。为了方便也写了一个类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPrinterHandle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">CPrinterHandle</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Open</span><span class="params">(LPCWSTR printer_name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        std::vector&lt;WCHAR&gt; name;</span><br><span class="line">        name.<span class="built_in">resize</span>(<span class="built_in">wcslen</span>(printer_name) + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">wcscpy_s</span>(name.<span class="built_in">data</span>(), name.<span class="built_in">size</span>(), printer_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">OpenPrinter</span>(name.<span class="built_in">data</span>(), &amp;printer_, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HANDLE <span class="title">Detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        HANDLE h = printer_;</span><br><span class="line">        printer_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HANDLE <span class="title">Attach</span><span class="params">(HANDLE printer)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        HANDLE h = printer_;</span><br><span class="line">        printer_ = printer;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (printer_) &#123;</span><br><span class="line">            <span class="built_in">ClosePrinter</span>(printer_);</span><br><span class="line">            printer_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">HANDLE</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> printer_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HANDLE printer_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而通过这个句柄就可以做很多的事情了，比如获取打印机的具体配置，弹出打印机属性对话框等等，这里以获取其支持的纸张类型为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> FORM_INFO_1, <span class="keyword">int</span> level = <span class="number">1</span>&gt;</span><br><span class="line">class CEnumPrinterForm &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">Init</span>(HANDLE hp)</span><br><span class="line">    &#123;</span><br><span class="line">        ULONG bytes_needed = <span class="number">0</span>;</span><br><span class="line">        ULONG elems_returned = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">EnumForms</span>(hp, level, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bytes_needed, &amp;elems_returned);</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(bytes_needed);</span><br><span class="line">        <span class="built_in">EnumForms</span>(hp, level, buffer_.<span class="built_in">data</span>(), bytes_needed, &amp;bytes_needed, &amp;elems_returned);</span><br><span class="line">        elems_returned_ = elems_returned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ULONG <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems_returned_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] (ULONG idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(idx &lt; elems_returned_);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(buffer_.<span class="built_in">data</span>())[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;UCHAR&gt; buffer_;</span><br><span class="line">    ULONG elems_returned_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以枚举出类似A3、A4、B5这种纸张类型。不过这套打印数据的函数有一些不太友好，因为通过打印机句柄打印数据，我们只能传输emf或者raw格式的数据。而我们比较熟悉的方法是通过DC绘制图形并且打印，这样所见即所得用起来会更舒适。不过，这套API没有提供用打印机句柄转换到HDC的方法。只能通过<code>PRINTER_INFO_2</code>中的<code>pPrinterName</code>和<code>pDevMode</code>重新打开一个HDC，然后通过HDC相关的API进行打印。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hdc = <span class="built_in">CreateDCW</span>(<span class="literal">NULL</span>, info.pPrinterName, <span class="literal">NULL</span>, info.pDevMode);</span><br><span class="line">DOCINFO docInfo = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">docInfo.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(docInfo);</span><br><span class="line">docInfo.lpszDocName = <span class="string">L&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">RECT rc = &#123; <span class="number">40</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">StartDoc</span>(hdc, &amp;docInfo);</span><br><span class="line"><span class="built_in">StartPage</span>(hdc);</span><br><span class="line"><span class="built_in">DrawTextA</span>(hdc, <span class="string">&quot;hello&quot;</span>, <span class="number">-1</span>, &amp;rc, DT_SINGLELINE | DT_NOCLIP);</span><br><span class="line"><span class="built_in">EndPage</span>(hdc);</span><br><span class="line"><span class="built_in">StartPage</span>(hdc);</span><br><span class="line"><span class="built_in">DrawTextA</span>(hdc, <span class="string">&quot;world&quot;</span>, <span class="number">-1</span>, &amp;rc, DT_SINGLELINE | DT_NOCLIP);</span><br><span class="line"><span class="built_in">EndPage</span>(hdc);</span><br><span class="line"><span class="built_in">EndDoc</span>(hdc);</span><br></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2019/09/03/printer-api-tip/" data-id="cktihnvq5009knoupa8vjan82" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-vs-with-qt4-natvis" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/01/vs-with-qt4-natvis/">vs使用qt4.natvis</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2019/08/01/vs-with-qt4-natvis/" class="article-date"><time datetime="2019-08-01T01:05:03.000Z" itemprop="datePublished">2019-08-01</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇blog讲到了windbg使用qt4.natvis解析qt数据结构的方法，那么接下来就该轮到VS了。在VS中使用natvis会更加简单，只需要将qt4.nativs拷贝到<code>%VSINSTALLDIR%\Common7\Packages\Debugger\Visualizers</code>即可。当然，这篇blog不可能只写这么点东西。qt4.natvis很好，它解析了很多QT的数据结构，比如QMap，QPoint，QVector，QMatrix等等，不过有一点很遗憾，它没有解析QObject。因为解析QObject可以获取对象的父子节点，这样很容易了解对象的树形结构。于是我这里对qt4.natvis进行了一点修改，添加了对QObject的解析：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Type</span> <span class="attr">Name</span>=<span class="string">&quot;QObject&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DisplayString</span>&gt;</span>&#123;&#123;&#123;*(char **)(*(char **)(*(char **)this - 4) + 12) + 12,sb&#125;&#125;&#125;<span class="tag">&lt;/<span class="name">DisplayString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Expand</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ExpandedItem</span>&gt;</span>d_ptr.d-&gt;children<span class="tag">&lt;/<span class="name">ExpandedItem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Expand</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解释一下这段xml，<code>&lt;Type Name=&quot;QObject&quot;&gt;&quot;</code>是指定匹配的对象类型名，这里当然就是QObject了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DisplayString</span>&gt;</span>&#123;&#123;&#123;*(char **)(*(char **)(*(char **)this - 4) + 12) + 12,sb&#125;&#125;&#125;<span class="tag">&lt;/<span class="name">DisplayString</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用于展示当前QObject的实际类型，也就是QObject的派生类名。这里采用的方法是获取虚表上的<code>RTTICompleteObjectLocator</code>对象指针，然后在获取<code>TypeDescriptor</code>。具体是怎么获取的那将是一篇长篇大论，这里就不展开了。最后<code>&lt;ExpandedItem&gt;d_ptr.d-&gt;children&lt;/ExpandedItem&gt;</code>则是将其子对象展示出来，这样就能一目了然的指定其子对象的真实类型了。</p>
<p><img src="/uploads/2019/08/20190801183332.png" alt="20190801183332"></p>
<p>从图中可以看到，除了str、str_list和str_map可以直接的看到数据之外，QMsgTest、QToolBar的子对象个数和类型也能一目了然。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2019/08/01/vs-with-qt4-natvis/" data-id="cktihnvq5009inoup70rsg48x" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-windbg-with-qt4-natvis" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/30/windbg-with-qt4-natvis/">windbg使用qt4.natvis</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2019/07/30/windbg-with-qt4-natvis/" class="article-date"><time datetime="2019-07-30T10:59:11.000Z" itemprop="datePublished">2019-07-30</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>用windbg调试QT程序或者分析QT程序的dump是一件痛苦的事情，因为windbg缺少对QT基础数据的展示能力，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    QList&lt;QString&gt; str_list;</span><br><span class="line">    str_list.<span class="built_in">append</span>(str);</span><br><span class="line">    QMap&lt;<span class="keyword">int</span>, QString&gt; str_map;</span><br><span class="line">    str_map[<span class="number">11</span>] = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份代码使用windbg查看str，str_list或者str_map简直是一件折磨的事情。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:000&gt; dv</span><br><span class="line">           argc = 0n1</span><br><span class="line">           argv = 0x02cc5e00</span><br><span class="line">            str = class QString</span><br><span class="line">       str_list = class QList&lt;QString&gt;</span><br><span class="line">        str_map = class QMap&lt;int,QString&gt;</span><br><span class="line">              a = class QApplication</span><br><span class="line">              w = class QMsgTest</span><br><span class="line">0:000&gt; dx str</span><br><span class="line">str                 [Type: QString]</span><br><span class="line">    [+0x000] d                : 0x2cc5d80 [Type: QString::Data *]</span><br><span class="line">0:000&gt; dx str_list</span><br><span class="line">str_list                 [Type: QList&lt;QString&gt;]</span><br><span class="line">    [+0x000] p                [Type: QListData]</span><br><span class="line">    [+0x000] d                : 0x2cc7258 [Type: QListData::Data *]</span><br><span class="line">0:000&gt; dx str_map</span><br><span class="line">str_map                 [Type: QMap&lt;int,QString&gt;]</span><br><span class="line">    [+0x000] d                : 0x2cc72b8 [Type: QMapData *]</span><br><span class="line">    [+0x000] e                : 0x2cc72b8 [Type: QMapData::Node *]</span><br></pre></td></tr></table></figure>

<p>可以看到，windbg只会告诉你类型，根本不会给你展示数据本身，如果要查看数据还得自己来算，以最复杂的QMap为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:000&gt; ?? str_map.d-&gt;forward[0]</span><br><span class="line">struct QMapData * 0x031470f8</span><br><span class="line">   +0x000 backward         : 0x03147068 QMapData</span><br><span class="line">   +0x004 forward          : [12] 0x03147068 QMapData</span><br><span class="line">   +0x034 ref              : QBasicAtomicInt</span><br><span class="line">   +0x038 topLevel         : 0n-17891602</span><br><span class="line">   +0x03c size             : 0n-17891602</span><br><span class="line">   +0x040 randomBits       : 0xfeeefeee</span><br><span class="line">   +0x044 insertInOrder    : 0y0</span><br><span class="line">   +0x044 sharable         : 0y1</span><br><span class="line">   +0x044 strictAlignment  : 0y1</span><br><span class="line">   +0x044 reserved         : 0y11111110111011101111111011101 (0x1fdddfdd)</span><br><span class="line"></span><br><span class="line">0:000&gt; ?? sizeof(@!&quot;qtmsgtest!QMapPayloadNode&lt;int,QString&gt;&quot;)-sizeof(qtmsgtest!QMapData::Node*)</span><br><span class="line">unsigned int 8</span><br><span class="line"></span><br><span class="line">0:000&gt; dt qtmsgtest!QMapNode&lt;int,QString&gt; (0x31470f8-8)</span><br><span class="line">   +0x000 key              : 0n11</span><br><span class="line">   +0x004 value            : QString</span><br><span class="line">   +0x008 backward         : 0x03147068 QMapData::Node</span><br><span class="line">   +0x00c forward          : [1] 0x03147068 QMapData::Node</span><br><span class="line"></span><br><span class="line">0:000&gt; ?? ((qtmsgtest!QString*)0x31470f4)-&gt;d</span><br><span class="line">struct QString::Data * 0x03145b30</span><br><span class="line">   +0x000 ref              : QBasicAtomicInt</span><br><span class="line">   +0x004 alloc            : 0n11</span><br><span class="line">   +0x008 size             : 0n11</span><br><span class="line">   +0x00c data             : 0x03145b42  -&gt; 0x68</span><br><span class="line">   +0x010 clean            : 0y0</span><br><span class="line">   +0x010 simpletext       : 0y0</span><br><span class="line">   +0x010 righttoleft      : 0y0</span><br><span class="line">   +0x010 asciiCache       : 0y0</span><br><span class="line">   +0x010 capacity         : 0y0</span><br><span class="line">   +0x010 reserved         : 0y11001101110 (0x66e)</span><br><span class="line">   +0x012 array            : [1] 0x68</span><br><span class="line"></span><br><span class="line">0:000&gt; du @@C++(((qtmsgtest!QString*)0x31470f4)-&gt;d-&gt;data)</span><br><span class="line">03145b42  &quot;hello world&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你们看，为了获取key=11、value=”hello world”需要这么折腾一通，如果数据多了那不得抓狂。</p>
<p>不过幸运了是windbg现在支持natvis了，简单的说就是通过natvis里的配置自动解析和符号匹配的数据结构。接下来要做的就是找一个好用的qt的natvis了。我这里找了一个qt配合vs2012里的qt4.natvis，让我们看看加载后的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:000&gt; .nvload qt4.natvis</span><br><span class="line">Successfully loaded visualizers in &quot;C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\Visualizers\qt4.natvis&quot;</span><br><span class="line">0:000&gt; dv</span><br><span class="line">           argc = 0n1</span><br><span class="line">           argv = 0x02cc5e00</span><br><span class="line">            str = hello world</span><br><span class="line">       str_list = &#123; size = 1 &#125;</span><br><span class="line">        str_map = &#123; size = 1 &#125;</span><br><span class="line">              a = class QApplication</span><br><span class="line">              w = class QMsgTest</span><br><span class="line">0:000&gt; dx str</span><br><span class="line">str                 : hello world [Type: QString]</span><br><span class="line">    [&lt;Raw View&gt;]     [Type: QString]</span><br><span class="line">    [size]           : 11 [Type: int]</span><br><span class="line">    [referenced]     : 3 [Type: long]</span><br><span class="line">    [0]              : 0x68 [Type: unsigned short]</span><br><span class="line">    [1]              : 0x65 [Type: unsigned short]</span><br><span class="line">    [2]              : 0x6c [Type: unsigned short]</span><br><span class="line">    [3]              : 0x6c [Type: unsigned short]</span><br><span class="line">    [4]              : 0x6f [Type: unsigned short]</span><br><span class="line">    [5]              : 0x20 [Type: unsigned short]</span><br><span class="line">    [6]              : 0x77 [Type: unsigned short]</span><br><span class="line">    [7]              : 0x6f [Type: unsigned short]</span><br><span class="line">    [8]              : 0x72 [Type: unsigned short]</span><br><span class="line">    [9]              : 0x6c [Type: unsigned short]</span><br><span class="line">    [10]             : 0x64 [Type: unsigned short]</span><br><span class="line">0:000&gt; dx str_list</span><br><span class="line">str_list                 : &#123; size = 1 &#125; [Type: QList&lt;QString&gt;]</span><br><span class="line">    [&lt;Raw View&gt;]     [Type: QList&lt;QString&gt;]</span><br><span class="line">    [referenced]     : 1 [Type: long]</span><br><span class="line">    [0x0]            : hello world [Type: QString]</span><br><span class="line">0:000&gt; dx str_map</span><br><span class="line">str_map                 : &#123; size = 1 &#125; [Type: QMap&lt;int,QString&gt;]</span><br><span class="line">    [&lt;Raw View&gt;]     [Type: QMap&lt;int,QString&gt;]</span><br><span class="line">    [referenced]     : 1 [Type: long]</span><br><span class="line">    [0x0]            : 0x2cc7340 : (11, hello world) [Type: QMapNode&lt;int,QString&gt; *]</span><br></pre></td></tr></table></figure>

<p>看到了么，无论是str，str_list还是str_map都直接打印出了内部的数据，无需大费周章的折腾，这简直是windbg爱好者调试qt程序的神器。</p>
<p>最后附上qt4.natvis的地址：<a target="_blank" rel="noopener" href="https://gist.github.com/gregseth/9bcd0112f8492fa7bfe7">https://gist.github.com/gregseth/9bcd0112f8492fa7bfe7</a></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2019/07/30/windbg-with-qt4-natvis/" data-id="cktihnvq4009gnoupa92m53ii" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li class="active"><span class="page-number">3</span></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/17/">17</a></li><li><a class="page-next" rel="next" href="/page/4/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>https://github.com/0cch</p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CPP/">CPP</a><span class="sidebar-module-list-count">27</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/">Debugging</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">5</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/Tips/">Tips</a><span class="sidebar-module-list-count">7</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/DeepLearner/">DeepLearner</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MiniKernel/">MiniKernel</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">4</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Tips/">Tips</a><span class="sidebar-module-list-count">67</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/debugging/">debugging</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/machinelearning/">machinelearning</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/File-System/" rel="tag">File System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/IDE/" rel="tag">IDE</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Kernel/" rel="tag">Kernel</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/MiniKernel/" rel="tag">MiniKernel</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTFS/" rel="tag">NTFS</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTInternals/" rel="tag">NTInternals</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTSTATUS/" rel="tag">NTSTATUS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/OS/" rel="tag">OS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/PIO/" rel="tag">PIO</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/System/" rel="tag">System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Test/" rel="tag">Test</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Volume/" rel="tag">Volume</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Windows/" rel="tag">Windows</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/grub/" rel="tag">grub</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/snapshot/" rel="tag">snapshot</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/File-System/" style="font-size: 10px;">File System</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Kernel/" style="font-size: 20px;">Kernel</a> <a href="/tags/MiniKernel/" style="font-size: 10px;">MiniKernel</a> <a href="/tags/NTFS/" style="font-size: 15px;">NTFS</a> <a href="/tags/NTInternals/" style="font-size: 10px;">NTInternals</a> <a href="/tags/NTSTATUS/" style="font-size: 10px;">NTSTATUS</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/PIO/" style="font-size: 10px;">PIO</a> <a href="/tags/System/" style="font-size: 10px;">System</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Volume/" style="font-size: 10px;">Volume</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/snapshot/" style="font-size: 10px;">snapshot</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/12/">December 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/11/">November 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/10/">October 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/09/">September 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/08/">August 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/06/">June 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/05/">May 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/04/">April 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/03/">March 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/02/">February 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/01/">January 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/12/">December 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/11/">November 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/10/">October 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/09/">September 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/08/">August 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/07/">July 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">June 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/05/">May 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/04/">April 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/03/">March 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/01/">January 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/12/">December 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/11/">November 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/07/">July 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/06/">June 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/05/">May 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">April 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">March 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">February 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">January 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">December 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">November 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">October 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">September 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">August 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">March 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">February 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">January 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">December 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/11/">November 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">October 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/09/">September 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">August 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">July 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">June 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/05/">May 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">April 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/03/">March 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/01/">January 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/12/">December 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/11/">November 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">October 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">September 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/08/">August 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/07/">July 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/06/">June 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/05/">May 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/04/">April 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/03/">March 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/02/">February 2016</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/01/">January 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/12/">December 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/11/">November 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/10/">October 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/09/">September 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/08/">August 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/07/">July 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/06/">June 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/05/">May 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/04/">April 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/03/">March 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/02/">February 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/01/">January 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/12/">December 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/11/">November 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/10/">October 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/09/">September 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/08/">August 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/07/">July 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/06/">June 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/05/">May 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/04/">April 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/03/">March 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/02/">February 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/01/">January 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/12/">December 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/11/">November 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/10/">October 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/09/">September 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/08/">August 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/07/">July 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/06/">June 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/05/">May 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/04/">April 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/03/">March 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/02/">February 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/01/">January 2013</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/12/">December 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/11/">November 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/08/">August 2012</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/02/">February 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/12/">December 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/10/">October 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/09/">September 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/08/">August 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/06/">June 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/05/">May 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/04/">April 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/02/">February 2011</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2021/12/01/dpcpp/">DPC++中的现代C++语言特性</a>
        </li>
      
        <li>
          <a href="/2021/11/02/module-ext/">补编-模块(C++20)</a>
        </li>
      
        <li>
          <a href="/2021/10/07/moderncpp42/">《现代C++语言核心特性解析》上架感言</a>
        </li>
      
        <li>
          <a href="/2021/09/12/optimization-details-in-qmutex/">QMutex中的优化小细节</a>
        </li>
      
        <li>
          <a href="/2021/08/05/pointer-to-implementation/">指向实现的指针Pointer to implementation</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2021 0CCh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
