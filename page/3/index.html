<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>0CCh Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="0CCh Blog">
<meta property="og:url" content="http://0cch.com/page/3/index.html">
<meta property="og:site_name" content="0CCh Blog">
<meta property="og:locale">
<meta property="article:author" content="0CCh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="0CCh Blog" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">0CCh Blog</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-use-span-instead-of-array-pointer-to-pass-parameters" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/">使用std::span代替数组指针传参</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/" class="article-date"><time datetime="2020-10-02T07:52:31.000Z" itemprop="datePublished">2020-10-02</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道<code>std::string_view</code>可以创建<code>std::string</code>的一个视图，视图本身并不拥有实例，它只是保持视图映射的状态。在不修改实例的情况下，使用<code>std::string_view</code>会让字符串处理的性能大幅提升。实际上，对于那些连续的序列对象我们都可以创建这样一份视图，对于<code>std::vector</code>这样的对象可以提高某些操作中的性能，另外对原生数组可以提高其访问的安全性。</p>
<p>过去如果一个函数想接受无法确定数组长度的数组作为参数，那么一定需要声明两个参数：数组指针和长度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_data</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">set_data</span>(buf, <span class="number">128</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种人工输入增加了编码的风险，数组长度的错误输入会引发程序的未定义行为，甚至是成为可被利用的漏洞。C++20标准库为我们提供了一个很好解决方案<code>std::span</code>，通过它可以定义一个基于连续序列对象的视图，包括原生数组，并且保留连续序列对象的大小。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_data</span><span class="params">(std::span&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arr.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">set_data</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了原生数组，<code>std::vector</code>和<code>std::array</code>也在<code>std::span</code>的处理之列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; buf1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; buf2&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">set_data</span>(buf1);</span><br><span class="line"><span class="built_in">set_data</span>(buf2);</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>std::span</code>还可以通过构造函数设置连续序列对象的长度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">set_data</span>(&#123; buf, <span class="number">16</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>从<code>std::string_view</code>到<code>std::span</code>，我们可以看出C++标准库很乐于这种视图设计，因为这种设计和抽象的实现可以提高C ++程序的可靠性而又不牺牲性能和可移植性。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/" data-id="cl4babrbs00a1m8ue94kscy7d" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-use-string_view-to-improve-string-processing-performance" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/25/use-string_view-to-improve-string-processing-performance/">使用std::string_view提升字符串处理性能</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/09/25/use-string_view-to-improve-string-processing-performance/" class="article-date"><time datetime="2020-09-25T06:27:45.000Z" itemprop="datePublished">2020-09-25</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>C++标准库提供了一个非常优秀的字符串处理类<code>std::string</code>，我们可以通过该类完成各种字符串操作。但是<code>std::string</code>有一个缺点，它的很多操作都是针对字符串实体，存在不必要的内存拷贝的代码，导致字符串的处理性能不尽如人意。针对这种情况C++17标准引入了<code>std::string_view</code>这个类，该类不会直接作用在字符串实体上，而是记录字符串处理的位置，这样就可以保证用最小的代价对字符串进行处理。</p>
<p>为了验证这个结论，下面的代码实现了一个断词器，然后针对64MB的数据做断词处理并且分别记录使用<code>std::string</code>和<code>std::string_view</code>作为基础类型时断词器运行的时间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tokenizer</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> string_type = T;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> T::value_type;</span><br><span class="line">    <span class="built_in">tokenizer</span>(<span class="type">const</span> string_type&amp; str, </span><br><span class="line">        std::<span class="type">enable_if_t</span>&lt;std::disjunction_v&lt;</span><br><span class="line">        std::is_same&lt;string_type, std::basic_string&lt;value_type&gt;&gt;,</span><br><span class="line">        std::is_same&lt;string_type, std::basic_string_view&lt;value_type&gt;&gt;&gt;&gt;* = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">data_</span>(str), <span class="built_in">begin_</span>(<span class="number">0</span>), <span class="built_in">end_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function">string_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> value_type sep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; end_ &lt; data_.<span class="built_in">size</span>(); ++end_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data_[end_] == sep) &#123;</span><br><span class="line">                <span class="keyword">auto</span> res = data_.<span class="built_in">substr</span>(begin_, end_ - begin_);</span><br><span class="line">                begin_ = ++end_;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end_ &lt;= data_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data_.<span class="built_in">substr</span>(begin_, end_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">more</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> end_ &lt; data_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> string_type data_;</span><br><span class="line">    <span class="type">size_t</span> begin_, end_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">make_string_data</span><span class="params">(<span class="type">size_t</span> count, <span class="type">char</span> sep)</span> </span>&#123;</span><br><span class="line">    std::string data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + i % <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> != count)</span><br><span class="line">            data.<span class="built_in">push_back</span>(sep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string data = <span class="built_in">make_string_data</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">32</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">tokenizer&lt;std::string&gt; <span class="title">tk</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">while</span> (tk.<span class="built_in">more</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">tk</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; diff = end - start;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;elapsed time = &quot;</span> &lt;&lt; diff.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中<code>tokenizer</code>是一个断词器的类模板，接受<code>std::string</code>、<code>std::wstring</code>等<code>std::basic_string</code>模板实例化的类型，同时也能接受<code>std::string_view</code>、<code>std::wstring_view</code>等<code>std::basic_string_view</code>模板实例化的类型。这里采用了SFINAE的方法来约束<code>tokenizer</code>的模板实参必须为以上类型。如果编译环境是C++20标准，可以采用概念来约束模板实参类型。</p>
<p>这份代码<code>tokenizer&lt;std::string&gt;</code>运行结果是0.45秒，如果将<code>tokenizer&lt;std::string&gt;</code>替换为<code>tokenizer&lt;std::string_view&gt;</code>运行时间缩短为0.08秒，性能提升是非常明显的 。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/09/25/use-string_view-to-improve-string-processing-performance/" data-id="cl4babrbr009zm8uedde1a7c6" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-something-about-enable_shared_from_this" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/05/something-about-enable_shared_from_this/">std::enable_shared_from_this原理浅析</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/08/05/something-about-enable_shared_from_this/" class="article-date"><time datetime="2020-08-05T09:54:11.000Z" itemprop="datePublished">2020-08-05</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在解释<code>std::enable_shared_from_this</code>之前，先看一个<code>std::shared_ptr</code>典型用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; pt1&#123; <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">10</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> pt2&#123; pt1 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时<code>pt1</code>和<code>pt2</code>共用了引用计数，当<code>pt1</code>和<code>pt2</code>的生命周期都结束时，<code>new int&#123;10&#125;</code>分配的内存会被释放。下面的做法会导致内存多次释放，因为它们没有使用共同的引用计数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pt&#123; <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">10</span> &#125; &#125;;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; pt1&#123; pt &#125;;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; pt2&#123; pt &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我想应该也没有人这么使用<code>std::shared_ptr</code>。不过下面这个错误倒是比较常见：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要用this调用SomeAPI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这段代码需要在<code>NeedCallSomeAPI</code>函数中调用<code>SomeAPI</code>，而<code>SomeAPI</code>需要的是一个<code>std::shared_ptr&lt;SomeData&gt;</code>的实参。这个时候应该怎么做？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(std::shared_ptr&lt;SomeData&gt;&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的做法是错误的，因为<code>SomeAPI</code>调用结束后<code>std::shared_ptr&lt;SomeData&gt;</code>对象的引用计数会降为0，导致<code>this</code>被意外释放。</p>
<p>这种情况下，我们需要使用<code>std::enable_shared_from_this </code>，使用方法很简单，只需要让<code>SomeData</code>继承<code>std::enable_shared_from_this&lt;SomeData&gt;</code>，然后调用<code>shared_from_this</code>吗，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span>:std::enable_shared_from_this&lt;SomeData&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SomeData&gt; <span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;SomeData&gt;(<span class="keyword">new</span> SomeData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SomeData</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> d&#123; SomeData::<span class="built_in">Create</span>() &#125;;</span><br><span class="line">    d-&gt;<span class="built_in">NeedCallSomeAPI</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::enable_shared_from_this </code>的实现比较复杂，但是实现原理则比较简单。它内部使用了<code>std::weak_ptr</code>来帮助完成指针相关控制数据的同步，而这份数据是在创建<code>std::shared_ptr</code>的时候完成的。我们来重点解析这一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">enable_shared_from_this</span> &#123;</span><br><span class="line"> <span class="keyword">mutable</span> weak_ptr&lt;T&gt; weak_this;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">shared_ptr&lt;T&gt; <span class="title">shared_from_this</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(weak_this); </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function">shared_ptr&lt;<span class="type">const</span> T&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> T&gt;(weak_this); </span><br><span class="line"> &#125;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">shared_ptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上是摘要的<code>enable_shared_from_this</code>的代码，这份代码中有两个关键要素。首先<code>weak_this</code>被声明为<code>mutable</code>，这让<code>weak_this</code>可以在<code>const</code>的限定下修改，其次也是最关键的地方，该类声明了<code>shared_ptr</code>为友元。这意味着<code>std::shared_ptr</code>可以修改<code>weak_this</code>，并且<code>weak_this</code>被初始化的地方在<code>std::shared_ptr</code>中。进一步说，没有<code>std::shared_ptr</code>的<code>enable_shared_from_this</code>是没有灵魂的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span>:std::enable_shared_from_this&lt;SomeData&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> d&#123; <span class="keyword">new</span> SomeData &#125;;</span><br><span class="line">    d-&gt;<span class="built_in">NeedCallSomeAPI</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这份代码中调用<code>shared_from_this</code>会出错。</p>
<p>再深入一步，<code>std::shared_ptr</code>是如何判断实例化对象类型是否继承<code>std::enable_shared_from_this</code>，并且通过判断结果决定是否初始化<code>weak_this</code>的呢？答案是SFINAE(“<em>Substitution Failure Is Not An Error</em>“)。</p>
<p>让我们查看VS2019的STL代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">enable_shared_from_this</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> _Esft_type = enable_shared_from_this;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yty</span>, <span class="keyword">class</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> _Can_enable_shared : false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Can_enable_shared</span>&lt;_Yty, <span class="type">void_t</span>&lt;<span class="keyword">typename</span> _Yty::_Esft_type&gt;&gt;</span><br><span class="line">    : is_convertible&lt;<span class="type">remove_cv_t</span>&lt;_Yty&gt;*, <span class="keyword">typename</span> _Yty::_Esft_type*&gt;::type &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的重点是<code>_Can_enable_shared</code>，如果目标类型有内嵌类型<code>_Esft_type</code>，并且目标类型和内嵌类型的指针是可转换的，也就是有继承关系，那么类型结果为<code>true_type</code>，反之为<code>false_type</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>&gt;</span><br><span class="line">   <span class="type">void</span> _Set_ptr_rep_and_enable_shared(_Ux* <span class="type">const</span> _Px, _Ref_count_base* <span class="type">const</span> _Rx) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>-&gt;_Ptr = _Px;</span><br><span class="line">       <span class="keyword">this</span>-&gt;_Rep = _Rx;</span><br><span class="line">       <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(conjunction_v&lt;negation&lt;is_array&lt;_Ty&gt;&gt;, negation&lt;is_volatile&lt;_Ux&gt;&gt;, _Can_enable_shared&lt;_Ux&gt;&gt;)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (_Px &amp;&amp; _Px-&gt;_Wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">               _Px-&gt;_Wptr = shared_ptr&lt;<span class="type">remove_cv_t</span>&lt;_Ux&gt;&gt;(*<span class="keyword">this</span>, <span class="keyword">const_cast</span>&lt;<span class="type">remove_cv_t</span>&lt;_Ux&gt;*&gt;(_Px));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>接下来，如果对象不是数组、不是<code>volatile</code>声明的并且<code>_Can_enable_shared</code>返回<code>true_type</code>，那么<code>_Wptr</code>才会被初始化。<code>std::shared_ptr</code>的构造函数以及<code>std::make_shared</code>函数都会调用该函数。</p>
<p>以上就是<code>std::enable_shared_from_this</code>实现原理中比较关键的一个部分。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/08/05/something-about-enable_shared_from_this/" data-id="cl4babrbq009xm8ue0ip76tx5" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-use-fmtlib-format-string" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/07/use-fmtlib-format-string/">使用fmtlib格式化字符串</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/07/07/use-fmtlib-format-string/" class="article-date"><time datetime="2020-07-07T04:21:13.000Z" itemprop="datePublished">2020-07-07</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在C++中格式化字符串的方法一直是一个备受争议的话题，无论是<code>printf</code>系列函数还是Stream IO都有各自的优缺点。本篇文章直接略过这两种方法，将目光放到fmtlib这个第三方库中，虽然是第三方库，但是C++20标准会引入该库的一部分特性。</p>
<p>fmtlib格式化字符串的语法和python十分相似，熟悉python的朋友掌握起来会非常迅速，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>以上是python格式化字符串的方法，对比到fmtlib为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在python中，格式化字符串的{}是可以设定索引并且指定顺序的，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在fmtlib中也能够实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外在python中还可以使用命名的{}来格式化字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;first&#125; &#123;second&#125;&quot;</span>.<span class="built_in">format</span>(first = <span class="string">&quot;hello&quot;</span>, second = <span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>不过C++中不支持指定参数名来传参，fmtlib采用了一个很巧妙的方法，它使用了自定义字面量的方法生成了一个named_arg对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/format.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> fmt::literals;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(</span><br><span class="line">        <span class="string">&quot;&#123;first&#125; &#123;second&#125;&quot;</span>, </span><br><span class="line">        <span class="string">&quot;first&quot;</span>_a = <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;second&quot;</span>_a = <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>格式化说明符的语法也是基本相同的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>)</span><br></pre></td></tr></table></figure>

<p>对应到fmtlib：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>, <span class="number">3.1415926</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细的格式化说明符的文档见：<a target="_blank" rel="noopener" href="https://fmt.dev/latest/syntax.html">链接</a></p>
<p>最后fmtlib还支持自定义格式化类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> telephone[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">fmt</span>::formatter&lt;PersonInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> fmt::<span class="function">format_parse_context::iterator </span></span><br><span class="line"><span class="function">    <span class="title">parse</span><span class="params">(fmt::format_parse_context&amp; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = ctx.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> ++iter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt::<span class="function">format_context::iterator </span></span><br><span class="line"><span class="function">    <span class="title">format</span><span class="params">(PersonInfo info, fmt::format_context&amp; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fmt::format_to(ctx.<span class="built_in">out</span>(), </span><br><span class="line">        <span class="string">&quot;name : &#123;&#125; | age : &#123;&#125; | tel. : &#123;&#125;&quot;</span>, </span><br><span class="line">        info.name, info.age, info.telephone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PersonInfo info&#123; <span class="string">&quot;xiaoming&quot;</span>, <span class="number">18</span>, <span class="string">&quot;1234567890&quot;</span> &#125;;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;&#125;&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/07/07/use-fmtlib-format-string/" data-id="cl4babrbo009tm8ue23h8cs7n" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-yampl-seq-and-iterator-part3" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/15/yampl-seq-and-iterator-part3/">序列和迭代器(3)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/06/15/yampl-seq-and-iterator-part3/" class="article-date"><time datetime="2020-06-15T10:15:30.000Z" itemprop="datePublished">2020-06-15</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="list序列的更多元函数"><a href="#list序列的更多元函数" class="headerlink" title="list序列的更多元函数"></a><code>list</code>序列的更多元函数</h2><p>那么目前为止，我们完成了<code>list</code>序列7组基本元函数的调用和验证。不过我们不会就此满足，因为以上元函数能完成的工作有限，为了让序列能完成更多实用的功能，我们还需要进一步的对基础元函进行组合。有一个特别的好消息是，由于后续介绍的元函数都是由以上7组基本元函数组合而成，所以它们可以在任何正向迭代器的序列中使用。不仅如此，如果不是特别在意编译期的效率问题的话，将他们应用于双向迭代器或者随机访问迭代器的序列也是可以的。当然我并不推荐这么做，因为对于双向迭代器或者随机访问迭代器的序列，它们可以使用更灵活的方法操作和访问内部元素。</p>
<h3 id="push-front元函数"><a href="#push-front元函数" class="headerlink" title="push_front元函数"></a><code>push_front</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">push_front_impl</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span>&lt;R, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> push_back&lt;<span class="keyword">typename</span> clear&lt;T&gt;::type, U&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">push_front</span></span><br><span class="line">    : push_front_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出<code>push_front</code>是一个极为典型的组合元函数，它使用<code>begin</code>、<code>end</code>、<code>deref</code>、<code>clear</code>和<code>push_back</code>两个元函数的组合，所以它可以用于任何正向迭代器的序列。不过达到这个目的的代价可以不小，因为这个操作从效率上来说是很低的。观察<code>push_front_impl</code>的实现可知，该元函数首先调用<code>clear</code>元函数获取一个空的序列，接着将目标元素<code>push_back</code>到新的空序列中，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> init = <span class="keyword">typename</span> push_back&lt;<span class="keyword">typename</span> clear&lt;T&gt;::type, U&gt;::type;</span><br></pre></td></tr></table></figure>

<p>并且使用<code>begin</code>、<code>end</code>和<code>deref</code>遍历了原始序列并且按照顺序逐个插入新序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br></pre></td></tr></table></figure>

<h3 id="pop-back和pop-front元函数"><a href="#pop-back和pop-front元函数" class="headerlink" title="pop_back和pop_front元函数"></a><code>pop_back</code>和<code>pop_front</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pop_back_impl</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">N</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> next&lt;N&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span>&lt;R, I, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> clear&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> next&lt;<span class="keyword">typename</span> begin&lt;T&gt;::type&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pop_back</span></span><br><span class="line">    : pop_back_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pop_front_impl</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span>&lt;R, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> clear&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> next&lt;<span class="keyword">typename</span> begin&lt;T&gt;::type&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pop_front</span></span><br><span class="line">    : pop_front_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>事实上，<code>pop_back</code>和<code>pop_front</code>元函数与<code>push_front</code>元函数的实现思路基本上是一样的。它们都使用<code>clear</code>元函数创建了一个空序列，然后再往空序列中填充各自的元素。唯一的区别就在于，<code>pop_back</code>元函数会检查下一个迭代器是否为结束迭代器。如果确定是结束迭代器，那么元函数就会忽略当前迭代器，直接返回当前新序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> next&lt;N&gt;::type, E&gt;::type;</span><br></pre></td></tr></table></figure>

<p>而<code>pop_front</code>则是从一开始遍历原始序列迭代器的时候就用<code>next</code>元函数忽略首个迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> next&lt;<span class="keyword">typename</span> begin&lt;T&gt;::type&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br></pre></td></tr></table></figure>

<h3 id="insert元函数"><a href="#insert元函数" class="headerlink" title="insert元函数"></a><code>insert</code>元函数</h3><p>上面已经介绍了三个组合而成的元函数，它们的实现虽说比较简单，但是却阐明了这类元函数的基本思路，即创建新的序列，然后遍历原始序列将需要的元素逐个插入到新序列中。现在让我们看一个较为复杂的<code>insert</code>元函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">insert_impl</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">B</span>, <span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner, U, B, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span>&lt;R, U, I, I, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> inner2 = <span class="keyword">typename</span> push_back&lt;inner, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner2, I, U, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">B</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span>&lt;R, U, B, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span>&lt;R, U, E, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">B</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> clear&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;init, U, B, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">B</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">insert</span></span><br><span class="line">    : insert_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, B, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码总体思路没有变化，先通过<code>clear</code>创建了新序列，难点是如何遍历原始序列并且找到目标位置插入新元素。这里让我们把注意力放在4个版本的<code>apply_impl</code>上，首先来看通常版本的元函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">B</span>, <span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner, U, B, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>该元函数非常简单，通过<code>push_back</code>将原序列的元素插入到新序列中，其中<code>I</code>是迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span>&lt;R, U, I, I, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> inner2 = <span class="keyword">typename</span> push_back&lt;inner, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner2, I, U, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>第二个的<code>apply_impl</code>是一个特化版本，它限定了当当前迭代器<code>I</code>与目标迭代器相同的时候，将新元素<code>U</code>插入到新序列中，然后再插入迭代器<code>I</code>的元素，这样就能完成插入目标元素<code>U</code>到指定迭代器之前的任务。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">B</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span>&lt;R, U, B, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply_impl</span>&lt;R, U, E, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>最后两个特化版本的<code>apply_impl</code>限定了元函数的结束条件。一方面<code>apply_impl&lt;R, U, B, E, E&gt;</code>，当原序列遍历到结束迭代器时，如果插入目标位置不是结束迭代器，则插入操作直接结束，返回新序列。另一方面<code>apply_impl&lt;R, U, E, E, E&gt;</code>，当原序列遍历到结束迭代器时，如果插入目标位置正好是结束迭代器，那么就将目标元素<code>U</code>插入到新序列的末尾。</p>
<p>以下是一个调用<code>insert</code>元函数的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> insert_list = list&lt;<span class="type">int</span>, <span class="type">bool</span>, <span class="type">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> result_list = insert&lt;insert_list, <span class="type">short</span>, begin&lt;insert_list&gt;::type&gt;::type;</span><br></pre></td></tr></table></figure>

<p>示例代码中，<code>insert</code>元函数将<code>short</code>类型插入了<code>insert_list</code>序列的<code>begin</code>迭代器之前，于是<code>result_list</code>的结果应该是<code>list&lt;short, int, bool, char&gt;</code>。</p>
<h3 id="其他组合元函数"><a href="#其他组合元函数" class="headerlink" title="其他组合元函数"></a>其他组合元函数</h3><p>除了我们上面介绍的<code>push_front</code>、<code>pop_back</code>、<code>pop_front</code>和<code>insert</code>元函数以外，我们还能根据自己的需要实现其他的元函数。比如，用于删除元素的<code>erase</code>元函数，用于排重的<code>unique</code>元函数，用于逆向排序的<code>reverse</code>元函数以及用于查找元素的<code>find</code>元函数等等。它们虽然有各自不同的功能，但是实现思路上确实万变不离其宗的。有兴趣的读者不妨自己尝试动手实现一两个。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/06/15/yampl-seq-and-iterator-part3/" data-id="cl4babrbp009vm8ue51ez95ij" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-yampl-seq-and-iterator-part2" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/20/yampl-seq-and-iterator-part2/">序列和迭代器(2)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/05/20/yampl-seq-and-iterator-part2/" class="article-date"><time datetime="2020-05-20T09:20:11.000Z" itemprop="datePublished">2020-05-20</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="list序列"><a href="#list序列" class="headerlink" title="list序列"></a>list序列</h2><p><code>list</code>序列实际上就是曾经介绍的<code>seq</code>序列的加强版，它的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">list_tag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> iterator_category_tag = forward_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> tag = list_tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>list</code>序列是一个有可变模板形参的类模板，它有两个内嵌类型分别是<code>iterator_category_tag</code>和<code>tag</code>。其中<code>tag</code>指示该序列的类型是<code>list_tag</code>，<code>iterator_category_tag</code>指示<code>list</code>序列的迭代器类型是正向迭代器<code>forward_iterator_tag</code>。除了正向迭代器的<code>tag</code>，YAMPL还定义了双向和随机访问迭代器。</p>
<table>
<thead>
<tr>
<th>迭代器名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>正向迭代器</td>
<td><code>forward_iterator_tag</code></td>
</tr>
<tr>
<td>双向迭代器</td>
<td><code>bidirectional_iterator_tag</code></td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td><code>random_access_iterator_tag</code></td>
</tr>
</tbody></table>
<p>正如上一节所说，要完成一个正向迭代器的序列需要实现至少7组基础元函数。接下来我们会逐一的实现这些元函数。</p>
<h3 id="begin-impl元函数"><a href="#begin-impl元函数" class="headerlink" title="begin_impl元函数"></a><code>begin_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">begin_impl</span>&lt;list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>&lt;T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = iterator&lt;T&lt;Args...&gt;, integral_const&lt;<span class="type">int</span>, <span class="number">0</span>&gt;, T&lt;Args...&gt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据上面的代码，让我们来详细的观察<code>begin_impl</code>的实现。首先可以看到<code>template &lt;&gt; struct begin_impl&lt;list_tag&gt;</code>是一个<code>template &lt;class Tag&gt; struct begin_impl &#123;&#125;;</code>针对<code>list_tag</code>的特化版本。它的作用就是让告知编译器在处理<code>tag</code>为<code>list_tag</code>的序列时，选用<code>template &lt;&gt; struct begin_impl&lt;list_tag&gt;</code>这个元函数。回过头来看<code>begin</code>元函数的实现，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">begin</span> : begin_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>begin_impl</code>元函数调用了<code>sequence_tag</code>来获取序列的<code>tag</code>，从而让编译器能够正确选择<code>begin_impl</code>的版本。<code>sequence_tag</code>的实现很简单，就是获取类型的<code>tag</code>并返回。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sequence_tag</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> T::tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接着观察<code>begin_impl&lt;typename sequence_tag&lt;T&gt;::type&gt;::template apply&lt;T&gt;</code>的<code>apply&lt;T&gt;</code>，我们发现在编译器选择了正确的<code>begin_impl</code>后，真正发挥作用的是内嵌元函数<code>template &lt;class T&gt; struct apply</code>，它的任务是处理<code>begin</code>传入的模板参数<code>T</code>，并且返回第1个迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">apply</span>&lt;T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = iterator&lt;T&lt;Args...&gt;, integral_const&lt;<span class="type">int</span>, <span class="number">0</span>&gt;, T&lt;Args...&gt;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>apply</code>的实现并不复杂，需要注意的是返回迭代器中模板实参的含义。第一个实参<code>T&lt;Args...&gt;</code>是记录当前迭代器所代表的元素以及该元素之后所有元素的序列，比方说现在有一个迭代器的第一个实参为<code>list&lt;int, char, double&gt;</code>，那么它的下一个迭代器的第一个实参应该是<code>list&lt;char, double&gt;</code>。第二个实参<code>integral_const&lt;int, 0&gt;</code>是用来记录当前迭代器在序列中的位置，因为<code>begin</code>返回的是序列的第一个迭代器，所有其位置应该是0。最后的实参<code>T&lt;Args...&gt;</code>对整个序列的记录，由于是首个迭代器所以这个实参看起来和第一个实参相同。另外需要注意的是在正向迭代器中，第三个实参并没有什么作用，之所以给出了这个定义是因为YAMPL还为<code>list</code>实现了一个双向迭代器的版本。</p>
<h3 id="end-impl元函数"><a href="#end-impl元函数" class="headerlink" title="end_impl元函数"></a><code>end_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">end_impl</span>&lt;list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>&lt;T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        iterator&lt;T&lt;&gt;, integral_const&lt;<span class="type">int</span>, <span class="keyword">sizeof</span>...(Args)&gt;, T&lt;Args...&gt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>end_impl</code>的实现和<code>begin_impl</code>基本相同，唯一的区别是内嵌元函数<code>apply</code>返回的迭代器的定义不同，它将返回序列最后一个元素之后的迭代器。该迭代器的第一个实参为<code>T&lt;&gt;</code>，这说明该迭代器已经没有代表的元素了。第二个实参<code>integral_const&lt;int, sizeof...(Args)&gt;</code>同样表示当前迭代器在序列的位置。最后的实参<code>T&lt;Args...&gt;</code>还是对整个序列的记录。</p>
<h3 id="size-impl元函数"><a href="#size-impl元函数" class="headerlink" title="size_impl元函数"></a><code>size_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">size_impl</span>&lt;list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>&lt;T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;<span class="type">int</span>, <span class="keyword">sizeof</span>...(Args)&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>size_impl</code>的内嵌元函数<code>apply</code>返回的是序列中元素的数量<code>integral_const&lt;int, sizeof...(Args)&gt;</code>。</p>
<h3 id="clear-impl元函数"><a href="#clear-impl元函数" class="headerlink" title="clear_impl元函数"></a><code>clear_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">clear_impl</span>&lt;list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>&lt;T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T&lt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>clear_impl</code>的内嵌元函数<code>apply</code>返回的是空序列<code>T&lt;&gt;</code>。</p>
<h3 id="push-back-impl元函数"><a href="#push-back-impl元函数" class="headerlink" title="push_back_impl元函数"></a><code>push_back_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">push_back_impl</span>&lt;list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>&lt;T&lt;Args...&gt;, U&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T&lt;Args..., U&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>push_back_impl</code>的内嵌元函数<code>apply</code>和之前我们看到的<code>apply</code>元函数有一些区别，它需要两个模板参数，这也正是<code>push_back</code>元函数所需的模板参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">push_back</span></span><br><span class="line">    : push_back_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>其中实参<code>T</code>是序列本身，实参U是需要插入序列的元素。最终<code>apply</code>返回的是插入新元素之后的序列<code>T&lt;Args..., U&gt;</code>。</p>
<h3 id="next-impl元函数"><a href="#next-impl元函数" class="headerlink" title="next_impl元函数"></a><code>next_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">next_impl</span>&lt;list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">N</span>, <span class="keyword">class</span> <span class="title class_">B</span>,</span><br><span class="line">            <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>&lt;iterator&lt;T&lt;U, Args...&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = iterator&lt;T&lt;Args...&gt;, <span class="keyword">typename</span> N::next, B&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">N</span>, <span class="keyword">class</span> <span class="title class_">B</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>&lt;iterator&lt;T&lt;U&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = iterator&lt;T&lt;&gt;, <span class="keyword">typename</span> N::next, B&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>next_impl</code>的内嵌元函数<code>apply</code>是一个针对迭代器的元函数，之前我们看到的无论是<code>begin_impl</code>还是<code>push_back_impl</code>的<code>apply</code>元函数都是针对序列本身的。这一点从<code>next</code>的定义中也能看出点端倪。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">next</span></span><br><span class="line">    : next_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发现，<code>next_impl</code>并没有调用<code>sequence_tag</code>获取序列<code>tag</code>，而是采用<code>iterator_sequence_tag</code>元函数获取迭代器所属序列的<code>tag</code>，所以这里<code>next</code>元函数操作的主体对象是迭代器而不是序列。</p>
<p>回头来看<code>next_impl</code>中<code>apply</code>的代码，可以看到<code>apply</code>有两个特化版本，首先当模板实参为<code>iterator&lt;T&lt;U, Args...&gt;, N, B&gt;</code>时，说明该迭代器不是倒数第二个迭代器，那么<code>apply</code>的返回结果应该是下个迭代器<code>iterator&lt;T&lt;Args...&gt;, typename N::next, B&gt;</code>。请注意，因为我们知道模板形参<code>N</code>是一个<code>integral_const</code>类型，所以可以直接使用<code>N::next</code>获取它的下一个整型包装类。</p>
<p>接下来当模板实参为<code>iterator&lt;T&lt;U&gt;, N, B&gt;</code>时，说明它是序列中倒数第二个迭代器。这时<code>apply</code>应该与<code>end</code>元函数返回一个相同的迭代器<code>iterator&lt;T&lt;&gt;, typename N::next, B&gt;</code>。</p>
<h3 id="deref-impl元函数"><a href="#deref-impl元函数" class="headerlink" title="deref_impl元函数"></a><code>deref_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">deref_impl</span>&lt;list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">B</span>,</span><br><span class="line">            <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>&lt;iterator&lt;T&lt;U, Args...&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = U;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>, <span class="keyword">class</span> <span class="title class_">B</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">apply</span>&lt;iterator&lt;T&lt;&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = none;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>deref_impl</code>和<code>next_impl</code>一样也是针对迭代器的元函数，它对迭代器进行解引用操作，随后可以获得元素本身。观察<code>deref_impl</code>的内嵌<code>apply</code>元函数，它也有两个特化版本。当其实参的迭代器为<code>iterator&lt;T&lt;U, Args...&gt;, N, B&gt;</code>时，说明它不是最后一个迭代器，于是返回当前元素<code>U</code>。当实参的迭代器为<code>iterator&lt;T&lt;&gt;, N, B&gt;</code>时，说明这是最后一个迭代器，它不包含任何元素，所以返回<code>none</code>。这里的<code>none</code>是YAMPL专门为类似这种情况定义的类型，用来表示没有意义的结果，具体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">none_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">none</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> tag = none_tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="list序列和迭代器的基本用法"><a href="#list序列和迭代器的基本用法" class="headerlink" title="list序列和迭代器的基本用法"></a><code>list</code>序列和迭代器的基本用法</h2><p>熟悉STL的读者一定对迭代器的使用了如指掌，因为STL中关于容器的大部分函数都依赖迭代器。比如从<code>std::list</code>的容器中删除一个元素就需要使用迭代器指明元素的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; mylist&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">mylist.<span class="built_in">erase</span>(mylist.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>

<p>模板元编程中序列和迭代器的使用方法和STL的迭代器比较类似，只是代码的写法上有些不同，总的来说还算比较容易掌握。以下是一段调用并验证<code>yampl::list</code>基本元函数的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::boolalpha;</span><br><span class="line"><span class="keyword">using</span> my_list = list&lt;int_&lt;<span class="number">0</span>&gt;, int_&lt;<span class="number">1</span>&gt;, int_&lt;<span class="number">2</span>&gt;, int_&lt;<span class="number">3</span>&gt;, int_&lt;<span class="number">4</span>&gt;&gt;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;my_list size = &quot;</span> &lt;&lt; size&lt;my_list&gt;::type::value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> it0 = <span class="keyword">typename</span> begin&lt;my_list&gt;::type;</span><br><span class="line"><span class="keyword">using</span> elem0 = <span class="keyword">typename</span> deref&lt;it0&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;elem0 == int_&lt;0&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;elem0, int_&lt;<span class="number">0</span>&gt;&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> it1 = <span class="keyword">typename</span> next&lt;it0&gt;::type;</span><br><span class="line"><span class="keyword">using</span> elem1 = <span class="keyword">typename</span> deref&lt;it1&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;elem1 == int_&lt;1&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;elem1, int_&lt;<span class="number">1</span>&gt;&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> it2 = <span class="keyword">typename</span> next&lt;it1&gt;::type;</span><br><span class="line"><span class="keyword">using</span> it3 = <span class="keyword">typename</span> next&lt;it2&gt;::type;</span><br><span class="line"><span class="keyword">using</span> it4 = <span class="keyword">typename</span> next&lt;it3&gt;::type;</span><br><span class="line"><span class="keyword">using</span> elem4 = <span class="keyword">typename</span> deref&lt;it4&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;elem4 == int_&lt;4&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;elem4, int_&lt;<span class="number">4</span>&gt;&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;next&lt;it4&gt;::type == end&lt;my_list&gt;::type : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;<span class="keyword">typename</span> next&lt;it4&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;my_list&gt;::type&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> empty_list = <span class="keyword">typename</span> clear&lt;my_list&gt;::type;</span><br><span class="line"><span class="keyword">using</span> my_list2 = <span class="keyword">typename</span> push_back&lt;empty_list, int_&lt;<span class="number">5</span>&gt;&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;my_list2 == list&lt;int_&lt;5&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;my_list2, list&lt;int_&lt;5&gt;&gt;&gt; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，首先定义了一个<code>list</code>序列<code>my_list</code>，序列共有5个元素，它们从<code>int_&lt;0&gt;</code>递增至<code>int&lt;4&gt;</code>。使用<code>size</code>元函数可以获取<code>my_list</code>中元素个数，这里返回的是<code>int_&lt;5&gt;</code>，通过<code>::value</code>可以获取整型数字5，所以第一句<code>std::cout</code>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list size = 5</span><br></pre></td></tr></table></figure>

<p>接着，代码调用<code>begin</code>元函数返回了序列<code>my_list</code>的第一个迭代器<code>it0</code>，可以预见到这个迭代器解引用后的元素就是<code>int_&lt;0&gt;</code>。为了证明这一点，使用元函数<code>deref</code>可以对<code>it0</code>解引用并获得结果<code>elem0</code>，再使用<code>std::is_same_v&lt;elem0, int_&lt;0&gt;&gt;</code>验证类型是否相同，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elem0 == int_&lt;0&gt; : true</span><br></pre></td></tr></table></figure>

<p>为了获取下一个迭代器，可以使用元函数<code>next</code>，这样可以获取迭代器<code>it1</code>。通过同样的方式我们可以获取<code>it2</code>到<code>it4</code>，并且对它们的类型进行判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elem1 == int_&lt;1&gt; : true</span><br><span class="line">elem4 == int_&lt;4&gt; : true</span><br></pre></td></tr></table></figure>

<p><code>it4</code>的下一个迭代器是<code>my_list</code>中最后一个迭代器，应该与<code>end</code>元函数返回的结果相同。我们同样可以通过<code>std::is_same_v&lt;typename next&lt;it4&gt;::type, typename end&lt;my_list&gt;::type&gt;</code>来验证这个结论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next&lt;it4&gt;::type == end&lt;mylist&gt;::type : true</span><br></pre></td></tr></table></figure>

<p>最后，代码中使用<code>clear</code>元函数返回一个空<code>list</code>序列，并且调用<code>push_back</code>将<code>int_&lt;5&gt;</code>插入到序列之中并获得序列<code>my_list2</code>。用同样的方法再次验证<code>push_back</code>和<code>clear</code>元函数的正确性，得到输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list2 == list&lt;int_&lt;5&gt; : true</span><br></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/05/20/yampl-seq-and-iterator-part2/" data-id="cl4babrbn009rm8uebeq39gty" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-yampl-seq-and-iterator-part1" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/yampl-seq-and-iterator-part1/">序列和迭代器(1)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/04/01/yampl-seq-and-iterator-part1/" class="article-date"><time datetime="2020-03-31T23:36:51.000Z" itemprop="datePublished">2020-04-01</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在前面的篇幅中我们已经看到了序列在模板元编程中的一部分作用。在本篇中我们将更加深入的探讨序列以及与之相关的算法，同时我们会使用建立迭代器的方法将这些算法抽象出来以方便它们运用到不同类型的序列中。在YAMPL中实现了两种类型的序列<code>list</code>和<code>vector</code>，本章中我将着重介绍<code>list</code>序列，这是因为该序列更好的使用了C++11的特性。另外本篇中介绍的算法基本上都是使用迭代器实现，所以它们可以顺利的移植到<code>vector</code>上。读者也可以将这些算法移植到自己实现的序列上，而这个移植过程也只需要实现少量代码。</p>
<h2 id="定义迭代器"><a href="#定义迭代器" class="headerlink" title="定义迭代器"></a>定义迭代器</h2><p>为了保证序列相关算法的通用性，我们需要将算法的实现建立在迭代器的基础之上，于是设计一个通用的迭代器就变得十分重要了。以下代码是YAMPL中通用迭代器类模板的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_tag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>, <span class="keyword">class</span> <span class="title class_">B</span> = <span class="type">void</span>, <span class="keyword">class</span> B2 = <span class="type">void</span>, <span class="keyword">class</span> B3 = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator &#123;</span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">  <span class="keyword">using</span> index = N;</span><br><span class="line">  <span class="keyword">using</span> backup = B;</span><br><span class="line">  <span class="keyword">using</span> backup2 = B2;</span><br><span class="line">  <span class="keyword">using</span> backup3 = B3;</span><br><span class="line">  <span class="keyword">using</span> tag = iterator_tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，迭代器<code>iterator</code>定义了5个模板形参。其中第一个形参<code>T</code>通常用于记录当前迭代器代表的元素本身或者是记录与该元素相关的序列；第二个形参<code>N</code>通常用于记录当前迭代器在序列中的位置；而剩下的3个形参可以用来记录一些额外的序列信息。</p>
<p>值得注意的是，以上描述是这5个形参在YAMPL序列中的惯用用法，它们并不是绝对的，所以序列的设计者可以根据序列本身的实际情况安排这5个形参的用途。比如YAMPL中的<code>list</code>使用了前3个形参，而<code>vector</code>只使用了前2个形参。</p>
<p>最后来说明一下内嵌类型<code>tag</code>的用途。在YAMPL中，和序列相关的类模板都有一个<code>tag</code>，比如迭代器的<code>tag</code>就是<code>iterator_tag</code>。这些<code>tag</code>的主要功能是对序列相关的类模板进行分类以方便通用算法在不同的序列上正常工作。例如YAMPL的<code>list</code>序列的<code>tag</code>为<code>list_tag</code>，那么为<code>list_tag</code>设计的基础元函数就能使用在<code>list</code>序列之上。同样的道理，若序列的设计者为了某特殊情况定义了一个<code>special_list</code>序列，并且将其<code>tag</code>定义为<code>list_tag</code>，那么为<code>list_tag</code>设计的算法就可以用于该序列了。</p>
<h2 id="序列和迭代器的基础元函数"><a href="#序列和迭代器的基础元函数" class="headerlink" title="序列和迭代器的基础元函数"></a>序列和迭代器的基础元函数</h2><p>为了让迭代器能顺利的移植到不同的序列上，我们需要定义几个抽象的元函数。这些元函数有些类似C++纯虚函数的概念，它们只提供一个元函数的轮廓，而具体是定义还是要由序列的设计者来实现。这些基础元函数包括：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">begin_impl</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">begin</span> : begin_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">end_impl</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">end</span> : end_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">next_impl</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">next</span></span><br><span class="line">    : next_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">deref_impl</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">deref</span></span><br><span class="line">    : deref_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">size_impl</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">size</span> : size_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">clear_impl</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">clear</span> : clear_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">push_back_impl</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">push_back</span></span><br><span class="line">    : push_back_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示了7组基础元函数，它们分别是<code>begin</code>、<code>end</code>、<code>next</code>、 <code>deref</code>、<code>size</code>、<code>clear</code>和<code>push_back</code>。之所以把它们列为基础元函数，是因为要让一个序列和与之相关的迭代器能正常工作这7组元函数是必不可少的。如果一个序列能实现这7组元函数，那么它的迭代器至少能完成一个正向迭代器的全部工作。</p>
<p>这7组元函数的功能具体为：</p>
<table>
<thead>
<tr>
<th align="left">元函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>begin</code></td>
<td align="left">返回序列中代表第一个元素的迭代器；</td>
</tr>
<tr>
<td align="left"><code>end</code></td>
<td align="left">返回序列中代表最后一个元素之后的迭代器；</td>
</tr>
<tr>
<td align="left"><code>next</code></td>
<td align="left">返回当前迭代器代表元素的下一个元素的迭代器；</td>
</tr>
<tr>
<td align="left"><code>deref</code></td>
<td align="left">解引用，返回当前迭代器代表的元素本身；</td>
</tr>
<tr>
<td align="left"><code>size</code></td>
<td align="left">返回序列中元素个数；</td>
</tr>
<tr>
<td align="left"><code>clear</code></td>
<td align="left">删除序列中的所有元素；</td>
</tr>
<tr>
<td align="left"><code>push_back</code></td>
<td align="left">在序列的最后新增一个元素。</td>
</tr>
</tbody></table>
<p>如果序列的设计者并不满足于正向迭代器的功能，那么还可以实现一个<code>prior</code>元函数的<code>_impl</code>版本来完成一个双向迭代器，<code>prior</code>元函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">prior_impl</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">prior</span></span><br><span class="line">    : prior_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>prior</code>函数的功能具体为：</p>
<table>
<thead>
<tr>
<th>元函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>prior</code></td>
<td>返回当前迭代器代表元素的上一个元素的迭代器。</td>
</tr>
</tbody></table>
<p>进一步的，如果序列的设计者希望该序列能支持一个随机访问迭代器，那么还需要实现以下2组基础元函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">advance_impl</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">advance</span></span><br><span class="line">    : advance_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T,</span><br><span class="line">                                                                            N&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">distance_impl</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">distance</span></span><br><span class="line">    : distance_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;</span><br><span class="line">          T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这2组元函数的功能具体为：</p>
<table>
<thead>
<tr>
<th>元函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>advance</code></td>
<td>返回当前迭代器代表元素的第N个递进元素的迭代器</td>
</tr>
<tr>
<td><code>distance</code></td>
<td>计算同序列中两个迭代器的间隔元素</td>
</tr>
</tbody></table>
<p>需要注意的是，序列需要实现的并不是<code>begin</code>、<code>end</code>、<code>next</code>这些元函数本身，而是它们间接调用的<code>_impl</code>版本的内嵌<code>apply</code>元函数。具体来说，想实现序列的<code>push_back</code>功能，那么应该对应的实现<code>push_back_impl</code>和<code>push_back_impl::apply</code>的元函数，具体的实现方法会在后面<code>list</code>序列的小节中介绍。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/04/01/yampl-seq-and-iterator-part1/" data-id="cl4babrbl009om8uedu5w1kff" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-yampl-base-components-part3" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/08/yampl-base-components-part3/">YAMPL的基础组件(3)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/03/08/yampl-base-components-part3/" class="article-date"><time datetime="2020-03-08T14:23:33.000Z" itemprop="datePublished">2020-03-08</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="逻辑运算符元函数"><a href="#逻辑运算符元函数" class="headerlink" title="逻辑运算符元函数"></a>逻辑运算符元函数</h2><p>在C++中逻辑运算符可以将两个或多个关系表达式连接成一个，例如<code>&amp;&amp;</code>和<code>||</code>，也能够使表达式的逻辑反转，例如<code>!</code>。在这个小节中，我们将根据C++的逻辑运算符实现一套YAMPL可以使用的逻辑运算符元函数，除此之外我们还将结合上面的内容来完成一个元编程例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>, <span class="keyword">class</span>... Nargs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">and_</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> inner = and_&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="type">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value &amp;&amp; inner::value&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">and_</span>&lt;N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="type">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value &amp;&amp; N2::value)&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>观察上面的代码会发现，<code>and_</code>元函数的实现和<code>plus</code>元函数几乎相同，除了使用了不同的运算符以外，唯一的区别就是返回类型。<code>and_</code>元函数的返回类型<code>using type = integral_const&lt;value_type, N1::value &amp;&amp; inner::value&gt;;</code>固定为<code>integral_const&lt;bool, true&gt;</code>或者<code>integral_const&lt;bool, false&gt;</code>之一，也就是<code>true_type</code>或者<code>false_type</code>。这个设计正好是对应<code>&amp;&amp;</code>运算符的返回值必须是<code>true</code>或者<code>false</code>之一。说明了这个区别之后，读者可以回味一下<code>plus</code>的实现应该就能理解<code>and_</code>元函数的实现细节了，这里也不再赘述。</p>
<p>如<code>and_</code>元函数一样，<code>or_</code>也可以通过这样的方式实现，而且只需要修改一个运算符而已。所以这里还是用宏简化代码的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MULTI_OP_BOOL(name, op)                                  \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;class N1, class N2, class... Nargs&gt;</span>                         \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                                         \</span></span><br><span class="line"><span class="meta">    using inner = name<span class="string">&lt;N2, Nargs...&gt;</span>;                                   \</span></span><br><span class="line"><span class="meta">    using value_type = bool;                                            \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="string">&lt;value_type, N1::value op inner::value&gt;</span>; \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                    \</span></span><br><span class="line"><span class="meta">  &#125;;                                                                    \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;class N1, class N2&gt;</span>                                         \</span></span><br><span class="line"><span class="meta">  struct name<span class="string">&lt;N1, N2&gt;</span> &#123;                                                 \</span></span><br><span class="line"><span class="meta">    using value_type = bool;                                            \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="string">&lt;value_type, (N1::value op N2::value)&gt;</span>;  \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                    \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_MULTI_OP_BOOL</span>(and_, &amp;&amp;);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP_BOOL</span>(or_, ||);</span><br></pre></td></tr></table></figure>

<p>以上代码实现了逻辑与和逻辑或的运算符元函数，接下来我们需要实现一个逻辑非运算符元函数，也就是在C++中常用的<code>!</code>。逻辑非运算符元函数的实现相对于前两个就单纯多了，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">not_</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="type">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, !T::value&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里只需要注意<code>not_</code>元函数的返回类型也是固定为<code>integral_const&lt;bool, true&gt;</code>或者<code>integral_const&lt;bool, false&gt;</code>之一，剩下的代码和取负运算符元函数的代码几乎相同很容易理解。</p>
<p>现在，我们要利用上面介绍的内容实现一个特殊的函数模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">special_func</span><span class="params">(T)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该函数模板需要完成这样一个任务：当模板实参<code>T</code>是一个标量或者引用时，函数参数的<code>T</code>为实参本身；否则<code>T</code>为实参的引用。也就是说当<code>T</code>为<code>int</code>时，函数为<code>void special_func(int) &#123;&#125;</code>；当<code>T</code>为<code>int&amp;</code>时，函数为<code>void special_func(int&amp;) &#123;&#125;</code>；当T为<code>std::string</code>时，函数为<code>void special_func(std::string&amp;) &#123;&#125;</code>。</p>
<p>以下是我的一种实现方案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func_helper</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> cond = or_&lt;<span class="keyword">typename</span> std::is_scalar&lt;T&gt;::type,</span><br><span class="line">                   <span class="keyword">typename</span> std::is_reference&lt;T&gt;::type&gt;;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> if_&lt;<span class="keyword">typename</span> cond::type, T,</span><br><span class="line">                            <span class="keyword">typename</span> std::add_lvalue_reference&lt;T&gt;::type&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">special_func</span><span class="params">(<span class="keyword">typename</span> func_helper&lt;T&gt;::type)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中实现了一个<code>func_helper</code>元函数，该元函数会针对<code>special_func</code>的模板实参进行处理以满足函数需求。在<code>func_helper</code>的实现代码中，首先调用了逻辑或元函数<code>or_</code>，用于判断<code>T</code>是否为标量或者引用类型。然后根据返回结果调用<code>if_</code>元函数。当<code>cond::type</code>的结果为<code>true_type</code>时返回<code>T</code>本身，否则调用<code>std::add_lvalue_reference</code>返回<code>T</code>的引用类型，最终<code>type</code>为要求的返回类型。</p>
<p>来测试一下刚刚编写的函数模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">special_func</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line"><span class="built_in">special_func</span>&lt;<span class="type">int</span>&amp;&gt;(n);</span><br><span class="line">std::string s&#123; <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">special_func</span>&lt;std::string&gt;(s);</span><br></pre></td></tr></table></figure>

<p>使用<code>-fdump-tree-gimple</code>命令让GCC生成gimple的中间代码，观察代码发现这样三份中间代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">special_func&lt;int&gt; (type v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br><span class="line">special_func&lt;int&amp;&gt; (int &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br><span class="line">special_func&lt;std::__cxx11::basic_string&lt;char&gt; &gt; (struct basic_string &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到当模板实参为<code>int</code>和<code>int&amp;</code>时，函数形参类型为模板实参本身，而当模板实参为<code>std::__cxx11::basic_string&lt;char&gt;</code>时，函数形参类型为<code>struct basic_string &amp;</code>，满足函数的设计要求。</p>
<h2 id="类型打印元函数"><a href="#类型打印元函数" class="headerlink" title="类型打印元函数"></a>类型打印元函数</h2><p>模板元程序之所以比普通C++程序更难编写主要是因为它很难调试。我们常用的调试方法在模板元程序上都没法正常使用，比如调试器只能调试动态运行的程序，但是却无法调试编译期执行的元程序。</p>
<p>另外打印日志的方法也许能帮上一点忙，因为C++为我们提供了<code>typeid</code>这个操作符，它返回的<code>std::type_info</code>结构中存在一个<code>const char* name()</code>的成员函数可以返回类型名称。于是我们想到可以使用以下方法打印类型信息帮助调试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure>

<p>不过遗憾的是，这种方法也并不完美。首先来说，成员函数<code>name()</code>返回的类型名称在不同编译器中有不同的展现方法，比如MSVC编译出来的程序返回的是一个可读的名称，而GCC编译出来的程序返回的类型名称则需要使用特定API（例如<code>abi::__cxa_demangle</code>）将其转换为可读的名称。其次，<code>typeid</code>也无法真实的反应类型的状态，因为C++标准中说明了<code>typeid</code>会忽略类型的<code>cv</code>属性，也就是说<code>typeid(const T) == typeid(T)</code>。所以<code>typeid</code>打印日志的方法也不满足需求。</p>
<p>为了准确是输出类型信息，我们需要将目光从程序本身移动到编译期上，因为只有编译期才是掌握类型信息最全面的程序。于是我们可以想到使用编译期的错误信息来打印类型信息。由于错误信息往往是帮助程序员排查错误，所以类型信息会非常的全面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">err_print_type</span>;</span><br><span class="line"></span><br><span class="line">err_print_type&lt;<span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type&gt;();</span><br></pre></td></tr></table></figure>

<p>在上面的代码中<code>err_print_type</code>是一个缺少实现的类模板，所以当编译器将其进行实例化的时候必然会报错，而错误信息正是我们想要的结果。<code>err_print_type&lt;typename minus&lt;int_&lt;10&gt;, int_&lt;2&gt;&gt;::type&gt;();</code>在MSVC中会显示错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error C2027: use of undefined type &#x27;err_print_type&lt;yampl::integral_const&lt;T,8&gt;&gt;&#x27;</span><br><span class="line">with</span><br><span class="line">[</span><br><span class="line">    T=int</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在GCC中显示错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: invalid use of incomplete type &#x27;struct err_print_type&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>可以看到，无论是哪种编译器都非常详细的显示了类型信息。</p>
<p>现在类型信息是完整了，但这种方法还是不太好，因为错误会阻止程序的编译导致无法生成可执行程序。我们需要一种方法既能在编译期产生可用的日志，与此同时也不能阻碍程序的正常编译。于是我们想到，如果能将错误信息转换为警告信息不久好了么！在YAMPL中，打印类型信息的方法就是用这种思路实现的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__clang__)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dbg_print_type</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> tmp = <span class="number">1</span> / (<span class="built_in">sizeof</span>(T) - <span class="built_in">sizeof</span>(T));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__GNUC__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic <span class="keyword">warning</span> <span class="string">&quot;-Wsign-compare&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dbg_print_type</span> &#123;</span><br><span class="line">  <span class="keyword">enum</span> &#123; n = <span class="built_in">sizeof</span>(T) &gt; <span class="number">-1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(push, 3)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dbg_print_type</span> &#123;</span><br><span class="line">  <span class="type">char</span> tmp[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dbg_print_type</span> &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>以上代码实现了一个类模板<code>dbg_print_type</code>，并且分别对MSVC、GCC和CLang做了支持。当编译期时MSVC时，使用了数组大小为0的技巧促使编译期发出警告；当编译器是CLang时，使用除数为0的方式让编译器发出警告；当编译器是GCC时，使用不同符号类型比较让编译器发出警告，值得注意的是这个警告需要手动开启。</p>
<p>将上面示例中的<code>err_print_type</code>修改为<code>dbg_print_type</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dbg_print_type&lt;<span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type&gt;();</span><br></pre></td></tr></table></figure>

<p>GCC会发出这样的警告：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In instantiation of &#x27;struct yampl::DbgPrintType&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#x27;:</span><br><span class="line">required from here</span><br><span class="line">warning: comparison of integer expressions of different signedness: &#x27;long long unsigned int&#x27; and &#x27;int&#x27; [-Wsign-compare]</span><br><span class="line">   15 |   enum &#123; n = sizeof(T) &gt; -1 &#125;;</span><br></pre></td></tr></table></figure>

<p>MSVC显示的警告为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">warning C4200: nonstandard extension used: zero-sized array in struct/union</span><br><span class="line">message : This member will be ignored by a defaulted constructor or copy/move assignment operator</span><br><span class="line">message : see reference to class template instantiation &#x27;yampl::DbgPrintType&lt;yampl::integral_const&lt;T,8&gt;&gt;&#x27; being compiled</span><br><span class="line">with</span><br><span class="line">[</span><br><span class="line">    T=int</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>请注意警告的信息确实比较多，但是仔细观察还是能看到<code>&#39;struct yampl::DbgPrintType&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#39;</code>这样类似的信息。另外值得高兴的是，这些警告信息也确实没有阻止程序的编译。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/03/08/yampl-base-components-part3/" data-id="cl4babrbk009mm8uefhte8m67" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-yampl-base-components-part2" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/21/yampl-base-components-part2/">YAMPL的基础组件(2)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/02/21/yampl-base-components-part2/" class="article-date"><time datetime="2020-02-21T12:48:33.000Z" itemprop="datePublished">2020-02-21</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="整型转换等级"><a href="#整型转换等级" class="headerlink" title="整型转换等级"></a>整型转换等级</h2><p>考虑一个简单的问题，在C++中将两个不同类型的整型操作数相加的结果会是怎么样的？比如用<code>short</code>类型的变量和<code>long</code>类型的变量相加。答案很简单，相加的结果应该是一个<code>long</code>类型，因为<code>short</code>类型隐式转换为<code>long</code>，于是就需要我们使用一个<code>long</code>类型的变量来存储计算结果。在C++11以后，我们可以通过类型说明符<code>auto</code>把这件事情交给编译器来完成。但是在模板元编程中，这件事是需要我们亲力亲为的。因此需要一个有效的工具来选择合适的类型，那就是类型转换等级。所谓转换等级实际上是类型根据C++隐式类型转换规则的一种排序，简单来说整型转换等级的排序符合下面两条规则：</p>
<ol>
<li>若两操作数的类型所需的存储空间大小不同，则存储空间较小的操作数类型隐式转换到存储空间较大的操作数类型。</li>
<li>若两操作数的类型所需的存储空间大小相同但符号性不同，则有符号类型操作数会隐式转换成无符号类型。</li>
</ol>
<p>下面是YAMPL对整型转换等级的排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_rank</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">bool</span>&gt; : int_&lt;<span class="number">1</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">signed</span> <span class="type">char</span>&gt; : int_&lt;<span class="number">2</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">char</span>&gt; : int_&lt;<span class="number">3</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; : int_&lt;<span class="number">4</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">wchar_t</span>&gt; : int_&lt;<span class="number">5</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">char16_t</span>&gt; : int_&lt;<span class="number">6</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">short</span>&gt; : int_&lt;<span class="number">7</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt; : int_&lt;<span class="number">8</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">char32_t</span>&gt; : int_&lt;<span class="number">9</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">int</span>&gt; : int_&lt;<span class="number">10</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; : int_&lt;<span class="number">11</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">long</span>&gt; : int_&lt;<span class="number">12</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; : int_&lt;<span class="number">13</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt; : int_&lt;<span class="number">14</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">integral_rank</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; : int_&lt;<span class="number">15</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>integral_rank</code>是一个用于描述整型转换等级的类模板，它的实现非常简单，只是继承了类模板<code>int_</code>的实例，如此一来我们可以通过<code>::value</code>的方法访问类型等级的值，这个技巧在C++模板元编程中被称为元函数转发。</p>
<p>整体的来看这段代码，可以看出等级的排序顺序由小到大，在规则上转换也总是从小到大进行的。比如，<code>char</code>类型的等级为3，<code>int</code>类型的等级为10，于是这两个类型的操作数互相作用后的结果是一个等级数值更大的<code>int</code>类型。为了方便的选择转换等级，YAMPL还提供了一个元函数来完成这件事，该函数依赖元函数<code>if_c</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">using</span> largest_int =</span><br><span class="line">    if_c&lt;integral_rank&lt;T1&gt;::value &gt;= integral_rank&lt;T2&gt;::value, T1, T2&gt;;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">largest_int</span></span><br><span class="line">    : if_c&lt;integral_rank&lt;T1&gt;::value &gt;= integral_rank&lt;T2&gt;::value, T1,</span><br><span class="line">                       T2&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这里无论是使用别名模板还是元函数转发都会调用元函数<code>if_c</code>比较对应类型的转换等级，最终给出拥有较大等级的类型。它们的结果是相同的，读者可以根据自己的喜好来选择<code>largest_int</code>的实现方案。</p>
<p>在下面这段代码中<code>largest_int</code>和<code>auto</code>具有相同的效果，<code>val1</code>和<code>val2</code>都会被编译器推导为<code>int</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a1 = <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> a2 = <span class="number">7</span>;</span><br><span class="line">largest_int&lt;<span class="type">int</span>, <span class="type">char</span>&gt;::type val1 = a1 + a2;</span><br><span class="line"><span class="keyword">auto</span> val2 = a1 + a2;</span><br></pre></td></tr></table></figure>

<h2 id="算术运算符元函数"><a href="#算术运算符元函数" class="headerlink" title="算术运算符元函数"></a>算术运算符元函数</h2><p>我们知道在YAMPL中，整型常量都被包装类模板包装成了特殊的类型。这种处理方式为类型序列和元函数提供了操作数值途径，但随之而来的后果是无法对包装类进行加减乘除等算术运算，同样的也无法对包装类进行逻辑运算。为了解决这类计算问题，我们需要为YAMPL提供一套打通数值计算和类型计算的元函数，让它们来完成算术和逻辑的运算工作。</p>
<p>事实上，上一篇中的<code>plus</code>元函数就可以被列出其中，不过我并不打算直接这么做，因为它还有进一步完善的空间，请看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>, <span class="keyword">class</span>... Nargs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> inner = plus&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> inner::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value + inner::value&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus</span>&lt;N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value + N2::value)&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>观察以上的代码可以发现它和以前的版本有两个显著的升级。首先，现在的元函数<code>plus</code>支持两个或两个以上的操作数参与到加法运算中，比如<code>plus&lt;int_&lt;3&gt;, int_&lt;2&gt;, int_&lt;5&gt;, int_&lt;6&gt;&gt;</code>。显然，为了完成这个目标我们需要实现一个递归，在代码中这个递归的发起点就是<code>using inner = plus&lt;N2, Nargs...&gt;;</code>，它使用<code>plus</code>计算除<code>N1</code>外剩余形参的结果。直到参数个数减少为2时触发结束条件，<code>struct plus&lt;N1, N2&gt;</code>计算两个形参之和并返回结果，递归结束。</p>
<p>另外还可以注意到，该版本的<code>plus</code>支持不同整型的包装类，这是因为在元函数中调用了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">largest_int&lt;<span class="keyword">typename</span> N1::value_type, <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br></pre></td></tr></table></figure>

<p>来获取计算结果的最终类型。因此<code>plus&lt;int_&lt;3&gt;, uint_&lt;2&gt;&gt;::type</code>这段代码可以顺利的编译，它的计算结果是<code>uint_&lt;5&gt;</code>。</p>
<p>当然，除了加法以外还有一些计算也可以支持多个操作数同时进行，例如乘法、位的与计算以及位的或计算等。而这些计算本质上与<code>plus</code>元函数只有运算符上的差别，以乘法为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>, <span class="keyword">class</span>... Nargs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">times</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> inner = times&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> inner::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value * inner::value&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">times</span>&lt;N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value * N2::value)&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比元函数<code>plus</code>，只是<code>N1::value + N2::value</code>被修改为了<code>N1::value * N2::value</code>。根据这样的规则，我们可以用宏来简化这类代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MULTI_OP(name, op)                                              \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;class N1, class N2, class... Nargs&gt;</span>                                \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                                                \</span></span><br><span class="line"><span class="meta">    using inner = name<span class="string">&lt;N2, Nargs...&gt;</span>;                                          \</span></span><br><span class="line"><span class="meta">    using value_type = typename largest_int&lt;typename N1::value_type,           \</span></span><br><span class="line"><span class="meta">                                            typename inner::value_type&gt;::type; \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="string">&lt;value_type, N1::value op inner::value&gt;</span>;        \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                           \</span></span><br><span class="line"><span class="meta">  &#125;;                                                                           \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;class N1, class N2&gt;</span>                                                \</span></span><br><span class="line"><span class="meta">  struct name<span class="string">&lt;N1, N2&gt;</span> &#123;                                                        \</span></span><br><span class="line"><span class="meta">    using value_type = typename largest_int&lt;typename N1::value_type,           \</span></span><br><span class="line"><span class="meta">                                            typename N2::value_type&gt;::type;    \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="string">&lt;value_type, (N1::value op N2::value)&gt;</span>;         \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                           \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(plus, +);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(times, *);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(bitand_, &amp;);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(bitor_, |);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(bitxor_, ^);</span><br></pre></td></tr></table></figure>

<p>可以看到我将<code>+</code>、<code>*</code>、<code>&amp;</code>、<code>|</code>和<code>^</code>归为了一类，并称它们为支持多运算符同时计算的二元运算符元函数。</p>
<p>与支持多操作数的二元运算符不同，减法、除法等运算对于操作数顺序有着严格的要求，所以对于这类运算而言，他们无法支持像加法这种多操作数的运算。也正因如此，减法、除法、移位等这些运算的模板元函数的实现更加的简单了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">minus</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value - N2::value)&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divides</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value / N2::value)&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>观察以上代码可知，减法和除法元函数的实现基本上就是加法元函数的一个特化的实现。另外它们也只有一个运算符的区别，同样可以通过宏将其简化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_SINGLE_OP(name, op)                                          \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;class N1, class N2&gt;</span>                                             \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                                             \</span></span><br><span class="line"><span class="meta">    using value_type = typename largest_int&lt;typename N1::value_type,        \</span></span><br><span class="line"><span class="meta">                                            typename N2::value_type&gt;::type; \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="string">&lt;value_type, (N1::value op N2::value)&gt;</span>;      \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                        \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(minus, -);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(divides, /);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(modulus, %);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(left_shift, &lt;&lt;);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(right_shift, &gt;&gt;);</span><br></pre></td></tr></table></figure>

<p>这里<code>-</code>、<code>/</code>、<code>%</code>、<code>&lt;&lt;</code>和<code>&gt;&gt;</code>被归为一类，也就是普通的二元运算符元函数。</p>
<p>除了以上算数运算符之外，还有一个容易被忽略的运算符——取负运算符。当然，相对于前两种运算符，它的实现就更加简单了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">negate</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> T::value_type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, -T::value&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>综合上述运算符元函数，我们来做一道计算题<code>-((5+(10-2)*3*5/2) &lt;&lt; 2)</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> step1 = minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;;                       <span class="comment">// step1 = 10-2</span></span><br><span class="line"><span class="keyword">using</span> step2 = times&lt;<span class="keyword">typename</span> step1::type, int_&lt;<span class="number">3</span>&gt;, int_&lt;<span class="number">5</span>&gt;&gt;;  <span class="comment">// step2 = step1*3*5</span></span><br><span class="line"><span class="keyword">using</span> step3 = divides&lt;<span class="keyword">typename</span> step2::type, int_&lt;<span class="number">2</span>&gt;&gt;;         <span class="comment">// step3 = step2/2</span></span><br><span class="line"><span class="keyword">using</span> step4 = plus&lt;int_&lt;<span class="number">5</span>&gt;, <span class="keyword">typename</span> step3::type&gt;;            <span class="comment">// step4 = 5+step3</span></span><br><span class="line"><span class="keyword">using</span> step5 = left_shift&lt;<span class="keyword">typename</span> step4::type, int_&lt;<span class="number">2</span>&gt;&gt;;      <span class="comment">// step5 = step4 &lt;&lt; 2</span></span><br><span class="line"><span class="keyword">using</span> result_step = negate&lt;<span class="keyword">typename</span> step5::type&gt;;             <span class="comment">// result_step = -step5</span></span><br><span class="line"><span class="keyword">auto</span> result_value = result_step::value;</span><br></pre></td></tr></table></figure>

<p>编译以上代码，编译器计算<code>result_step</code>的类型为<code>int_&lt;-260&gt;</code>，所以<code>result_value</code>为-260。</p>
<h2 id="关系运算符元函数"><a href="#关系运算符元函数" class="headerlink" title="关系运算符元函数"></a>关系运算符元函数</h2><p>在C++中，想获得两个整数之间的关系是很容易的一件事。比如比较3和7的大小，只需要使用关系运算符<code>&lt;</code>或者<code>&gt;</code>。但使用C++模板元编程事情就变得不那么容易了，我们需要比较的是整型常量包装类之间关系，比如比较<code>int_&lt;3&gt;</code>和<code>int_&lt;7&gt;</code>的大小。所以除了算数运算符元函数，YAMPL还应该提供一套描述整型常量包装类之间关系的元函数，这也是C++模板元编程中必不可少的一环。</p>
<p>好在我们已经有了实现算术运算符元函数的基础，再实现一套关系运算符元函数也并不会觉得很难，下面是<code>==</code>运算符元函数的实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="type">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value == N2::value)&gt;;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码十分简洁，甚至是在算术运算符元函数中一直发挥重要作用的<code>largest_int</code>也被省去了。在<code>equal_to</code>元函数中，<code>value_type</code>被直接定义为<code>bool</code>，这很容易理解，因为关系运算符的计算结果本就是布尔类型。因此，元函数返回的结果<code>type</code>就是<code>integral_const&lt;value_type, true&gt;</code>或者<code>integral_const&lt;value_type, false&gt;</code>。是不是看上去非常熟悉？没错，它们正是<code>true_type</code>和<code>false_type</code>的定义。</p>
<p>基于和算术类型的元函数同样的原因，关系运算符的元函数也能用宏来做统一的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_SINGLE_OP_BOOL(name, op)                                \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;class N1, class N2&gt;</span>                                        \</span></span><br><span class="line"><span class="meta">  struct name &#123;                                                        \</span></span><br><span class="line"><span class="meta">    using value_type = bool;                                           \</span></span><br><span class="line"><span class="meta">    using type = integral_const<span class="string">&lt;value_type, (N1::value op N2::value)&gt;</span>; \</span></span><br><span class="line"><span class="meta">    static constexpr value_type value = type::value;                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(equal_to, ==);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(not_equal_to, !=);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(greater, &gt;);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(greater_equal, &gt;=);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(less, &lt;);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(less_equal, &lt;=);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>和<code>&lt;=</code>被归为一类，可以称它们为返回布尔包装类的二元运算符元函数。调用它们将返回<code>true_type</code>或者<code>false_type</code>，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> step1 = <span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type;</span><br><span class="line"><span class="keyword">using</span> result_type1 = <span class="keyword">typename</span> equal_to&lt;step1, int_&lt;<span class="number">8</span>&gt;&gt;::type;<span class="comment">// true_type</span></span><br><span class="line"><span class="keyword">using</span> result_type2 = <span class="keyword">typename</span> greater&lt;step1, int_&lt;<span class="number">8</span>&gt;&gt;::type; <span class="comment">// false_type</span></span><br><span class="line"><span class="keyword">using</span> result_type3 = <span class="keyword">typename</span> less&lt;step1, int_&lt;<span class="number">8</span>&gt;&gt;::type;    <span class="comment">// false_type</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/02/21/yampl-base-components-part2/" data-id="cl4babrbj009jm8uedhl85cbg" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-yampl-base-components-part1" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/09/yampl-base-components-part1/">YAMPL的基础组件(1)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/01/09/yampl-base-components-part1/" class="article-date"><time datetime="2020-01-09T04:15:47.000Z" itemprop="datePublished">2020-01-09</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>从本篇开始，我们将开始进入轻量级C++模板元编程库YAMPL(Yet Another MPL)的编写环节。不过，在深入探索元编程的序列和算法之前，有一些基础工作必须完成，比如定义命名空间、定义整型常量包装类模板，编写包装类的算数和逻辑运算元函数、编写用于调试的类型打印元函数等等。在完成了这些基础组件后，序列和算法的编写工作将会变得非常高效和有趣。</p>
<h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><p>在前面的文章中，我们定义了两个特殊的类型<code>true_type</code>和<code>false_type</code>。不巧的是，在STL中也有两个一模一样的类型名，而且这两个类型在STL的type_traits中被广泛的使用，例如：<code>std::is_same</code>、<code>std::is_class</code>、<code>std::is_const</code>等等，它们的返回类型就是上述两种类型的其中之一。无独有偶，在Boost中也有这样的两个类型。其实，有一点很容易想到，作为Boost.MPL的模仿者，YAMPL中一定会存在大量与Boost.MPL中相同的命名。所以为了解决以上这类问题，必须为YAMPL安排一个命名空间。为了直观，我就直接定义YAMPL的命名空间名为<code>yampl</code>。</p>
<p>那么现在对于<code>true_type</code>这样的类型有三种实现，包括：<code>yampl::true_type</code>、<code>stl::true_type</code>以及<code>boost::true_type</code>。面对这样的情况，我们有时候会需要一个类型的转换元函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_convert_to</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_convert_to</span>&lt;T, T, V&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = V;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> stl_to_yampl_true_type = type_convert_to&lt;T, std::true_type, yampl::true_type&gt;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，元函数<code>stl_to_yampl_true_type</code>可以将<code>std::true_type</code>转换为<code>yampl::true_type</code>，如果该元函数的实参不是<code>std::true_type</code>则编译出错。如果有需要在库与库之间频繁切换的情况，实现一个这样的转换元函数是很有用的一种方法。</p>
<p>有一点需要指出的是，在后面的文章中会涉及到一些对YAMPL中元函数调用的示例，这些示例一般都默认认为已经使用<code>using namespace yampl;</code>打开过<code>yampl</code>的命名空间，所以没有使用前缀写法<code>yampl::xxx</code>。只有涉及到不同命名空间类型互相转换的情况才会用前缀的方式指明命名空间。</p>
<h2 id="整型常量包装类模板"><a href="#整型常量包装类模板" class="headerlink" title="整型常量包装类模板"></a>整型常量包装类模板</h2><p>在YAMPL中的元函数都是关于类型的计算，但有时候数值计算却又是不可避免的。为了让类型计算的元函数能兼容数值计算，我们需要一个特殊的类模板，它能够将数值转换为类型。这里我们称这个特殊的类模板为整型常量包装类模板。其实在上一篇中我们已经见到过它的简化版本，以下是它的完整版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, T N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_const</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = N;</span><br><span class="line">  <span class="keyword">using</span> next = integral_const&lt;T, N + <span class="number">1</span>&gt;;</span><br><span class="line">  <span class="keyword">using</span> prior = integral_const&lt;T, N - <span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>integral_const</code>是整型常量包装类模板，其模板形参<code>T</code>是包装常量的类型，形参<code>N</code>是包装的具体数值，例如：<code>integral_const&lt;int, 5&gt;</code>是一个包装了数值为1的<code>int</code>类型常量的类型。<code>integral_const</code>定义了静态数据成员<code>value</code>来返回包装类型代表的具体数值，定义<code>value_type</code>来指示返回数值的准确类型。另外为了元函数调用形式上的统一，<code>integral_const</code>还定义内嵌类型<code>type</code>为自身。最后我们还可以发现，<code>integral_const</code>为了方便完成数值的自增和自减操作，分别定义了<code>next</code>和<code>prior</code>来表示<code>integral_const&lt;T, N + 1&gt;</code>和<code>integral_const&lt;T, N - 1&gt;</code>，于是我们可以完成这样的操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::is_same_v&lt;integral_const&lt;<span class="type">int</span>, <span class="number">5</span>&gt;::next, integral_const&lt;<span class="type">int</span>, <span class="number">6</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p><code>std::is_same_v</code>返回的结果为<code>true</code>。</p>
<p>到目前为止<code>integral_const</code>似乎已经满足要求了，这很好，但还有一点却令人厌烦。考虑一下如果我们需要在序列中声明一连串的<code>integral_const</code>会发生什么？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">seq&lt;integral_const&lt;<span class="type">int</span>, <span class="number">1</span>&gt;, integral_const&lt;<span class="type">int</span>, <span class="number">2</span>&gt;, integral_const&lt;<span class="type">int</span>, <span class="number">3</span>&gt;, ...&gt;</span><br></pre></td></tr></table></figure>

<p>显然这种写法过于冗长，这里需要一种更简洁的表达方法，我选择使用别名模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> int_ = integral_const&lt;<span class="type">int</span>, N&gt;;</span><br></pre></td></tr></table></figure>

<p>这样一来定义上面的序列会简洁不少：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">seq&lt;int_&lt;<span class="number">1</span>&gt;, int_&lt;<span class="number">2</span>&gt;, int_&lt;<span class="number">3</span>&gt;, ...&gt;</span><br></pre></td></tr></table></figure>

<p>另外，读者还可以定义其他别名模板以满足自己的需求，比如定义一个无符号整型常量的包装类模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> uint_ = integral_const&lt;<span class="type">unsigned</span> <span class="type">int</span>, N&gt;;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，布尔类型也可以使用<code>integral_const</code>来表示，因为它能和整型发生隐式转换，但会有一些不同之处，请看下面这个针对<code>bool</code>的特化版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_const</span>&lt;<span class="type">bool</span>, N&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="type">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> value_type value = N;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> bool_ = integral_const&lt;<span class="type">bool</span>, N&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> true_type = bool_&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = bool_&lt;<span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>观察上面的代码可以发现，特化版本的<code>integral_const</code>删除了<code>next</code>和<code>prior</code>，这是因为布尔类型只有<code>true</code>和<code>false</code>之分，自增和自减对于它是没有意义的。另外还定义了<code>true_type</code>和<code>false_type</code>以方便后续使用，它们在YAMPL中使用的是比较频繁的。</p>
<h2 id="if元函数"><a href="#if元函数" class="headerlink" title="if元函数"></a>if元函数</h2><p><code>if</code>元函数是YAMPL中最常用的元函数之一，又因为它不依赖其他元函数，所以应该优先介绍它。不过实际上，我们在上一篇已经对<code>if</code>元函数做过了比较详细的介绍了，为了本篇知识体系的完整性这里将它拿出来总结一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> B, <span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">if_c</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = N1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">if_c</span>&lt;<span class="literal">false</span>, N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = N2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">N1</span>, <span class="keyword">class</span> <span class="title class_">N2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">if_</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> if_c&lt;!!T::value, N1, N2&gt;::type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码有两个元函数<code>if</code>和<code>if_c</code>，其中<code>if_c</code>是真正实现选择逻辑的元函数，它接受的条件参数是布尔值。而元函数<code>if</code>对<code>if_c</code>进行了一次包装，这使得它接受的条件参数从一个布尔值转换为了类型，而且这种类型还有相当不错的兼容性，它只要求类型具有静态数据成员<code>value</code>即可，所以上一节提到的<code>true_type</code>、<code>false_type</code>、<code>int_&lt;7&gt;</code>甚至其他库的<code>std::true_type</code>、<code>boost::mpl::false_</code>等等都可以兼容<code>if</code>元函数。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/01/09/yampl-base-components-part1/" data-id="cl4babrbh009hm8ue1ozm2vvs" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li class="active"><span class="page-number">3</span></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/18/">18</a></li><li><a class="page-next" rel="next" href="/page/4/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>https://github.com/0cch</p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CPP/">CPP</a><span class="sidebar-module-list-count">30</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/">Debugging</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">5</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/Tips/">Tips</a><span class="sidebar-module-list-count">7</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/DeepLearner/">DeepLearner</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MiniKernel/">MiniKernel</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">4</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Tips/">Tips</a><span class="sidebar-module-list-count">70</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/debugging/">debugging</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/machinelearning/">machinelearning</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/File-System/" rel="tag">File System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/IDE/" rel="tag">IDE</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Kernel/" rel="tag">Kernel</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/MiniKernel/" rel="tag">MiniKernel</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTFS/" rel="tag">NTFS</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTInternals/" rel="tag">NTInternals</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTSTATUS/" rel="tag">NTSTATUS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/OS/" rel="tag">OS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/PIO/" rel="tag">PIO</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/System/" rel="tag">System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Test/" rel="tag">Test</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Volume/" rel="tag">Volume</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Windows/" rel="tag">Windows</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/grub/" rel="tag">grub</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/snapshot/" rel="tag">snapshot</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/File-System/" style="font-size: 10px;">File System</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Kernel/" style="font-size: 20px;">Kernel</a> <a href="/tags/MiniKernel/" style="font-size: 10px;">MiniKernel</a> <a href="/tags/NTFS/" style="font-size: 15px;">NTFS</a> <a href="/tags/NTInternals/" style="font-size: 10px;">NTInternals</a> <a href="/tags/NTSTATUS/" style="font-size: 10px;">NTSTATUS</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/PIO/" style="font-size: 10px;">PIO</a> <a href="/tags/System/" style="font-size: 10px;">System</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Volume/" style="font-size: 10px;">Volume</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/snapshot/" style="font-size: 10px;">snapshot</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/06/">June 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/05/">May 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/04/">April 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/03/">March 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/02/">February 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/01/">January 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/12/">December 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/11/">November 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/10/">October 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/09/">September 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/08/">August 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/06/">June 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/05/">May 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/04/">April 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/03/">March 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/02/">February 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/01/">January 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/12/">December 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/11/">November 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/10/">October 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/09/">September 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/08/">August 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/07/">July 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">June 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/05/">May 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/04/">April 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/03/">March 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/01/">January 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/12/">December 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/11/">November 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/07/">July 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/06/">June 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/05/">May 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">April 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">March 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">February 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">January 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">December 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">November 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">October 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">September 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">August 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">March 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">February 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">January 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">December 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/11/">November 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">October 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/09/">September 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">August 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">July 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">June 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/05/">May 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">April 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/03/">March 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/01/">January 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/12/">December 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/11/">November 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">October 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">September 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/08/">August 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/07/">July 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/06/">June 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/05/">May 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/04/">April 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/03/">March 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/02/">February 2016</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/01/">January 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/12/">December 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/11/">November 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/10/">October 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/09/">September 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/08/">August 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/07/">July 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/06/">June 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/05/">May 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/04/">April 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/03/">March 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/02/">February 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/01/">January 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/12/">December 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/11/">November 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/10/">October 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/09/">September 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/08/">August 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/07/">July 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/06/">June 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/05/">May 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/04/">April 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/03/">March 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/02/">February 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/01/">January 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/12/">December 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/11/">November 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/10/">October 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/09/">September 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/08/">August 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/07/">July 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/06/">June 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/05/">May 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/04/">April 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/03/">March 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/02/">February 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/01/">January 2013</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/12/">December 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/11/">November 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/08/">August 2012</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/02/">February 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/12/">December 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/10/">October 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/09/">September 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/08/">August 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/06/">June 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/05/">May 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/04/">April 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/02/">February 2011</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2022/06/01/addition-to-rvo-and-copy-elimination/">返回值优化和拷贝消除的一点补充</a>
        </li>
      
        <li>
          <a href="/2022/05/02/use-async-with-caution/">谨慎使用std::async</a>
        </li>
      
        <li>
          <a href="/2022/04/12/pass-params/">值传参</a>
        </li>
      
        <li>
          <a href="/2022/03/08/oneapi-summary/">oneAPI 组件简介</a>
        </li>
      
        <li>
          <a href="/2022/02/12/k+2021/">2021K+软件峰会PPT</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 0CCh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
