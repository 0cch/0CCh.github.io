<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>0CCh Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="0CCh Blog">
<meta property="og:url" content="http://0cch.com/page/2/index.html">
<meta property="og:site_name" content="0CCh Blog">
<meta property="og:locale">
<meta property="article:author" content="0CCh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="0CCh Blog" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">0CCh Blog</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-parallel-algorithm-in-stl" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/05/parallel-algorithm-in-stl/">STL中并行算法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/04/05/parallel-algorithm-in-stl/" class="article-date"><time datetime="2021-04-05T03:04:49.000Z" itemprop="datePublished">2021-04-05</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>C++17标准的一个重大突破是让标准库中的部分算法支持了并行计算，这对于无处不在的多线程环境来说无疑是一个非常不错的消息。具体支持并行计算的算法可以参考提案文档<a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html#algorithms.parallel.overloads">p0024r2</a>。</p>
<p>接下来将会选取两个典型算法函数对STL的并行算法进行介绍：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::for_each(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">            val *= val;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是一个最简单的并行计算例子，例子中使用了<code>for_each</code>函数，该函数并不是新加入到标准库的。只不过现在多了一个并行计算的版本，其中第一个参数是并行计算的策略。实际上，大部分并行计算的算法都是在原有算法的基础做了新增，它们的共同特点是第一个参数改为了并行计算策略，当然老的算法也依然存在。在这个例子中，策略<code>std::execution::par</code>是并行计算其中的一种策略。在这个策略中函数会使用多线程执行算法，并且线程在执行算法的单个步骤是不会被打断的。为了看清线程的执行情况，我们可以将线程id输出到控制台：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::for_each(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            val *= val;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这份代码就会发现线程id交替输出到控制台上，可见确实是多线程执行<code>for_each</code>函数。让我们再看看排序函数<code>std::sort</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; val2) &#123;</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这份代码同样的会发现多个线程交替输出线程id到控制台上，实际上它们正在并行计算排续该容器。并行计算的优势在数据量足够大的时候是非常明显的，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::<span class="built_in">sort</span>(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; val2) &#123;</span><br><span class="line">            <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; diff = end - start;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;elapsed time = &quot;</span> &lt;&lt; diff.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逆向排序100000个数，使用并行算法在我的机器上消耗了0.48秒。如果删除第一个参数使用传统单线程排续，在我的机器上消耗0.89秒，并行计算性能提升近1倍。</p>
<p>最后来介绍一下C++17中的3种并行计算策略：</p>
<ul>
<li><p><code>std::execution::seq</code> 该策略与非并行算法一样，当前执行线程逐个元素依次执行必要的操作。 使用该策略的行为类似于使用完全不接受任何执行策略的非并行调用算法的方式。</p>
</li>
<li><p><code>std::execution::par</code> 该策略会让多个线程执行元素的必要操作。 当算法开始执行必要的操作时，它会一直执行到操作结束，不会被打断。</p>
</li>
<li><p><code>std::execution::par_unseq</code> 该策略会让多个线程执行元素的必要操作，但是与<code>std::execution::par</code>不同的是，该策略不能保证一个线程执行完该元素的所有步骤而不被打断。在提案文档中也指出了错误示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">std::for_each(std::execution::par_unseq, </span><br><span class="line">              std::<span class="built_in">begin</span>(a), std::<span class="built_in">end</span>(a), [&amp;](<span class="keyword">int</span>) &#123;</span><br><span class="line">  std::lock_guard&lt;mutex&gt; <span class="built_in">guard</span>(m); <span class="comment">// Error: lock_guard constructor calls m.lock()</span></span><br><span class="line">  ++x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里由于<code>std::execution::par_unseq</code> 无法保证执行lambda表达式的时候不被打断，可能会造成同一个线程两次次进入lambda表达式，并且调用<code>m.lock()</code>导致死锁。</p>
</li>
</ul>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/04/05/parallel-algorithm-in-stl/" data-id="cktihnvqi00aonoup2ysn63dg" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-intro-3-cpp-online-tools" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/20/intro-3-cpp-online-tools/">C++在线工具</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/03/20/intro-3-cpp-online-tools/" class="article-date"><time datetime="2021-03-20T08:15:53.000Z" itemprop="datePublished">2021-03-20</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇博客打算介绍4个C++在线工具，当手头没有设备或者没有开发环境的时候可以用它们做一些研究性质的工作。</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://wandbox.org/">https://wandbox.org/</a></p>
<p>该网站可以在线编辑以及编译C++源代码并且运行编译后的程序。在C++类别它支持GCC和CLANG，另外除了C++，C、C#、Java、GO等等都有支持。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://quick-bench.com/">https://quick-bench.com/</a></p>
<p>这也是一个可以在线编辑以及编译C++源代码并且运行编译后的程序的网站，但是与上面网站不同的是它运行程序并非用来输出结果，而是对函数做基准检测，采用的是Google Benchmark。同样它支持GCC和CLANG。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://godbolt.org/">https://godbolt.org/</a></p>
<p>这是我很喜欢的一个网站，它可以在线编辑和编译C++源代码，但是不可以运行程序。但是这并不能掩盖其优秀的地方，它支持C++各种编译器的各种版本，跨度非常大也非常全面。同时还可以自由设置编译器的编译参数并且查看输出的中间文件，对于研究C++编译过程十分有用。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cppinsights.io/">https://cppinsights.io/</a></p>
<p>这是一个非常有趣的网站，它能够将源代码展开，使用一种容易理解的方式展示编译器做了哪些自动化工作。用它自己的话来说，就是从编译器的视角看到的源代码。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> arr[<span class="number">10</span>]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>&amp; c : arr)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被网站展开为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">const</span> <span class="params">(&amp;__range1)</span>[10] </span>= arr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * __begin1 = __range1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * __end1 = __range1 + <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">for</span>(; __begin1 != __end1; ++__begin1) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> &amp; c = *__begin1;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/03/20/intro-3-cpp-online-tools/" data-id="cktihnvqh00amnoup75fw5osi" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-msvc-build-qt5.15.2-error" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/03/msvc-build-qt5.15.2-error/">解决vs2019编译qt5.15.2的错误</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/02/03/msvc-build-qt5.15.2-error/" class="article-date"><time datetime="2021-02-03T03:37:28.000Z" itemprop="datePublished">2021-02-03</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>记录一下编译qt-everywhere-src-5.15.2中qtwebengine遇到的问题。</p>
<p>第一、在windows上用vs2019编译qtwebengine的时候需要patch其中的3个文件，否则会报错。错误看起来好像是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ninja: build stopped: subcommand failed. </span><br><span class="line">NMAKE : fatal error U1077: &#x27;call&#x27; : return code &#x27;0x1&#x27;</span><br><span class="line">NMAKE : fatal error U1077: &#x27;&quot;...\nmake.exe&quot;&#x27; : return code &#x27;0x2&#x27; Stop.</span><br><span class="line">NMAKE : fatal error U1077: &#x27;(&#x27; : return code &#x27;0x2&#x27; Stop.</span><br><span class="line">NMAKE : fatal error U1077: &#x27;cd&#x27; : return code &#x27;0x2&#x27; Stop.</span><br><span class="line">NMAKE : fatal error U1077: &#x27;cd&#x27; : return code &#x27;0x2&#x27; Stop</span><br></pre></td></tr></table></figure>

<p>但实际问题是代码在vs2019的cl里编译出错了，C4244警告被当成错误报出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FAILED: obj/third_party/angle/angle_common/mathutil.obj</span><br><span class="line">...</span><br><span class="line">../../3rdparty/chromium/third_party/angle/src/common/mathutil.cpp(75): error C4244: &#x27;=&#x27;: conversion from &#x27;double&#x27; to &#x27;float&#x27;, possible loss of data</span><br><span class="line">../../3rdparty/chromium/third_party/angle/src/common/mathutil.cpp(77): error C4244: &#x27;=&#x27;: conversion from &#x27;double&#x27; to &#x27;float&#x27;, possible loss of data</span><br><span class="line">../../3rdparty/chromium/third_party/angle/src/common/mathutil.cpp(79): error C4244: &#x27;=&#x27;: conversion from &#x27;double&#x27; to &#x27;float&#x27;, possible loss of data</span><br></pre></td></tr></table></figure>

<p>所以需要打个补丁，手动修改也行吧，代码量很少：<br><a target="_blank" rel="noopener" href="https://codereview.qt-project.org/c/qt/qtwebengine-chromium/+/321741">https://codereview.qt-project.org/c/qt/qtwebengine-chromium/+/321741</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From 138a7203f16cf356e9d4dac697920a22437014b0 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: Peter Varga &lt;pvarga@inf.u-szeged.hu&gt;</span><br><span class="line">Date: Fri, 13 Nov 2020 11:09:23 +0100</span><br><span class="line">Subject: [PATCH] Fix build with msvc2019 16.8.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Fixes: QTBUG-88708</span><br><span class="line">Change-Id: I3554ceec0437801b4861f68edd504d01fc01cf93</span><br><span class="line">Reviewed-by: Allan Sandfeld Jensen &lt;allan.jensen@qt.io&gt;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">diff --git a/chromium/third_party/angle/src/common/mathutil.cpp b/chromium/third_party/angle/src/common/mathutil.cpp</span><br><span class="line">index 306cde1..d4f1034 100644</span><br><span class="line">--- a/chromium/third_party/angle/src/common/mathutil.cpp</span><br><span class="line">+++ b/chromium/third_party/angle/src/common/mathutil.cpp</span><br><span class="line">@@ -72,11 +72,11 @@</span><br><span class="line">     const RGB9E5Data *inputData = reinterpret_cast&lt;const RGB9E5Data *&gt;(&amp;input);</span><br><span class="line">     *red =</span><br><span class="line">-        inputData-&gt;R * pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">+        inputData-&gt;R * (float)pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">     *green =</span><br><span class="line">-        inputData-&gt;G * pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">+        inputData-&gt;G * (float)pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">     *blue =</span><br><span class="line">-        inputData-&gt;B * pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">+        inputData-&gt;B * (float)pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  // namespace gl</span><br><span class="line">diff --git a/chromium/third_party/blink/renderer/platform/graphics/lab_color_space.h b/chromium/third_party/blink/renderer/platform/graphics/lab_color_space.h</span><br><span class="line">index 78c316e..136c796 100644</span><br><span class="line">--- a/chromium/third_party/blink/renderer/platform/graphics/lab_color_space.h</span><br><span class="line">+++ b/chromium/third_party/blink/renderer/platform/graphics/lab_color_space.h</span><br><span class="line">@@ -130,7 +130,7 @@</span><br><span class="line">   // https://en.wikipedia.org/wiki/CIELAB_color_space#Forward_transformation.</span><br><span class="line">   FloatPoint3D toXYZ(const FloatPoint3D&amp; lab) const &#123;</span><br><span class="line">     auto invf = [](float x) &#123;</span><br><span class="line">-      return x &gt; kSigma ? pow(x, 3) : 3 * kSigma2 * (x - 4.0f / 29.0f);</span><br><span class="line">+      return x &gt; kSigma ? (float)pow(x, 3) : 3 * kSigma2 * (x - 4.0f / 29.0f);</span><br><span class="line">     &#125;;</span><br><span class="line">     FloatPoint3D v = &#123;clamp(lab.X(), 0.0f, 100.0f),</span><br><span class="line">diff --git a/chromium/third_party/perfetto/src/trace_processor/timestamped_trace_piece.h b/chromium/third_party/perfetto/src/trace_processor/timestamped_trace_piece.h</span><br><span class="line">index 02363d0..8860287 100644</span><br><span class="line">--- a/chromium/third_party/perfetto/src/trace_processor/timestamped_trace_piece.h</span><br><span class="line">+++ b/chromium/third_party/perfetto/src/trace_processor/timestamped_trace_piece.h</span><br><span class="line">@@ -198,6 +198,20 @@</span><br><span class="line">     return *this;</span><br><span class="line">   &#125;</span><br><span class="line">+#if PERFETTO_BUILDFLAG(PERFETTO_COMPILER_MSVC)</span><br><span class="line">+  TimestampedTracePiece&amp; operator=(TimestampedTracePiece&amp;&amp; ttp) const</span><br><span class="line">+  &#123;</span><br><span class="line">+    if (this != &amp;ttp) &#123;</span><br><span class="line">+      // First invoke the destructor and then invoke the move constructor</span><br><span class="line">+      // inline via placement-new to implement move-assignment.</span><br><span class="line">+      this-&gt;~TimestampedTracePiece();</span><br><span class="line">+      new (const_cast&lt;TimestampedTracePiece*&gt;(this)) TimestampedTracePiece(std::move(ttp));</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    return const_cast&lt;TimestampedTracePiece&amp;&gt;(*this);</span><br><span class="line">+  &#125;</span><br><span class="line">+#endif  // PERFETTO_BUILDFLAG(PERFETTO_COMPILER_MSVC)</span><br><span class="line">+</span><br><span class="line">   ~TimestampedTracePiece() &#123;</span><br><span class="line">     switch (type) &#123;</span><br><span class="line">       case Type::kInvalid:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二、在Windows上编译blink的pch也会有些问题，报错找不到头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qt5/qtwebengine/src/3rdparty/chromium/third_party/WebKit/Source/core/win/Precompile-core.cpp: fatal error C1083: Cannot open include file: </span><br><span class="line">&#x27;../../../../../qt5srcgit/qt5/qtwebengine/src/3rdparty/chromium/third_party/WebKit/Source/core/Precompile-core.h&#x27;: No such file or directory</span><br></pre></td></tr></table></figure>

<p>需要patch两个文件blink/renderer/platform/BUILD.gn 和 blink/renderer/core/BUILD.gn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/BUILD.gn</span><br><span class="line">+++ qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/BUILD.gn</span><br><span class="line">@@ -204,7 +204,7 @@</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config(&quot;blink_platform_pch&quot;) &#123;</span><br><span class="line">   if (enable_precompiled_headers) &#123;</span><br><span class="line">-    if (is_win) &#123;</span><br><span class="line">+    if (false) &#123;</span><br><span class="line">       # This is a string rather than a file GN knows about. It has to match</span><br><span class="line">       # exactly what&#x27;s in the /FI flag below, and what might appear in the</span><br><span class="line">       # source code in quotes for an #include directive.</span><br></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/02/03/msvc-build-qt5.15.2-error/" data-id="cktihnvqg00aknoup7nqcdzy1" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-use-any-instead-of-shared_ptr-and-void" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/03/use-any-instead-of-shared_ptr-and-void/">使用std::any代替std::shared_ptr&lt;void&gt;和void *</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/01/03/use-any-instead-of-shared_ptr-and-void/" class="article-date"><time datetime="2021-01-03T04:30:07.000Z" itemprop="datePublished">2021-01-03</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>大家在编写程序的时候应该遇到过这样一个场景，该场景需要传递某种数据，但是数据类型和数据大小并不确定，这种时候我们常用<code>void *</code>类型的变量来保存对象指针。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span> </span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="keyword">void</span>* user_data; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的结构体只是一个示例，代表有的数据是用户产生的。当用户数据是一个字符串时，可能的代码是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SomeData sd&#123;&#125;;</span><br><span class="line">sd.user_data = <span class="keyword">new</span> std::string&#123; <span class="string">&quot;hello world&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>另外，使用<code>void*</code>存储数据需要了解数据类型，并且需要自己维护数据的生命周期：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string *str = <span class="keyword">static_cast</span>&lt;std::string *&gt;(sd.user_data);</span><br><span class="line"><span class="keyword">delete</span> str;</span><br><span class="line">str = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>std::shared_ptr&lt;void&gt;</code>可以解决生命周期的问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">void</span>&gt; user_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeData sd&#123;&#125;;</span><br><span class="line">sd.user_data = std::make_shared&lt;std::string&gt;(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ud = std::static_pointer_cast&lt;std::string&gt;(sd.user_data);</span><br></pre></td></tr></table></figure>

<p>虽然<code>std::shared_ptr&lt;void&gt;</code>可以用于管理生命周期，但是类型安全的问题却无法解决。比如当<code>user_data</code>销毁时，由于缺乏类型信息会导致对象无法正确析构。</p>
<p>为了解决以上这些问题，C++17标准库引入<code>std::any</code>。顾名思义就是可以存储任意类型，我们可以将其理解为带有类型信息的<code>void*</code>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">any</span> &#123;</span></span><br><span class="line"> <span class="keyword">void</span>* object;</span><br><span class="line"> type_info tinfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，<code>std::any</code>的实现比这个要复杂的多，我们后面再讨论类型是如何被记录下来的。先来看看<code>std::any</code>的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;any&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::any a;</span><br><span class="line">    a = std::string&#123; <span class="string">&quot;hello world&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> str = std::any_cast&lt;std::string&gt;(a);</span><br><span class="line">    std::cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了转换为对象本身，还可以转换为引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; str1 = std::any_cast&lt;std::string&amp;&gt;(a);</span><br><span class="line"><span class="keyword">auto</span>&amp; str2 = std::any_cast&lt;<span class="keyword">const</span> std::string&amp;&gt;(a);</span><br></pre></td></tr></table></figure>

<p>当转换类型不正确时，<code>std::any_cast</code>会抛出异常<code>std::bad_any_cast</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; std::any_cast&lt;<span class="keyword">double</span>&gt;(a) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::bad_any_cast&amp;) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Wrong Type!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果转换的不是对象而是对象指针，那么<code>std::any_cast</code>不会抛出异常，而是返回空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>* ptr = std::any_cast&lt;std::string&gt;(&amp;a);</span><br><span class="line"><span class="keyword">if</span>(ptr) &#123;</span><br><span class="line"> std::cout &lt;&lt; *ptr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Wrong Type!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，使用<code>std::any_cast</code>转换类型必须和<code>std::any</code>对象的存储类型完全一致，否则同样会抛出异常，即使两者是继承关系。原因很简单，<code>std::any_cast</code>是直接使用<code>type_info</code>作比较：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> type_info* <span class="keyword">const</span> _Info = _TypeInfo();</span><br><span class="line"><span class="keyword">if</span> (!_Info || *_Info != <span class="built_in"><span class="keyword">typeid</span></span>(_Decayed)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后简单描述一下<code>std::any</code>保证类型安全的原理：</p>
<p>首先是类型转换，刚刚已经提到了，<code>std::any</code>会记录对象的<code>type_info</code>，<code>std::any_cast</code>使用<code>type_info</code>作比较，只有完全一致才能进行转换。</p>
<p>其次为了保证类型正确的拷贝，移动以及生命周期结束时能够正确析构，在创建<code>std::any</code>对象时生成一些函数模板实例，这些函数模板调用了类型的拷贝，移动以及析构函数。<code>std::any</code>只需要记录这些函数模板实例的指针即可。拿析构简单举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_impl</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;T*&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> destory_ptr = <span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">void</span>* <span class="keyword">const</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnyMetadata</span> &#123;</span></span><br><span class="line">    destory_ptr func;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_anymeta</span><span class="params">(AnyMetadata &amp;meta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    meta.func = destroy_impl&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// any构造时知道目标对象类型，此时可以保存函数指针</span></span><br><span class="line">AnyMetadata metadata;</span><br><span class="line">create_anymeta&lt;std::string&gt;(metadata);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any销毁时调用</span></span><br><span class="line">metadata.<span class="built_in">func</span>(obj);</span><br></pre></td></tr></table></figure>




      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2021/01/03/use-any-instead-of-shared_ptr-and-void/" data-id="cktihnvqg00ainoupek1ygyot" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-use-sample-to-get-random-samples" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/26/use-sample-to-get-random-samples/">使用std::sample获取随机样本</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/12/26/use-sample-to-get-random-samples/" class="article-date"><time datetime="2020-12-26T02:16:36.000Z" itemprop="datePublished">2020-12-26</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>C++17标准库提供了一个<code>std::sample</code>函数模板用于获取随机样本，该样本是输入全体样本的一个子集。具体例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sample</span>(data.<span class="built_in">begin</span>(), </span><br><span class="line">        data.<span class="built_in">end</span>(),</span><br><span class="line">        std::ostream_iterator&lt;<span class="keyword">int</span>&gt;&#123;std::cout, <span class="string">&quot;\n&quot;</span>&#125;,</span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line">        std::default_random_engine&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>std::sample</code>需要5个参数，其中前2个参数是全体样本的合计的<code>begin</code>和<code>end</code>迭代器，它定义了全体样本的范围。第3个参数则是输出迭代器，第4个参数是需要样本的数量，最后是随机数引擎。注意这里<code>std::default_random_engine</code>没有设置<code>seed</code>，这必然导致每次运行获取的样本相同。</p>
<p>以上代码的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">488</span><br><span class="line">963</span><br><span class="line">1994</span><br><span class="line">2540</span><br><span class="line">2709</span><br><span class="line">2835</span><br><span class="line">3518</span><br><span class="line">5172</span><br><span class="line">7996</span><br></pre></td></tr></table></figure>

<p>我们可以为随机数引擎设置<code>seed</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::random_device rd;</span><br><span class="line">std::default_random_engine eng&#123; <span class="built_in">rd</span>() &#125;;</span><br><span class="line">std::<span class="built_in">sample</span>(data.<span class="built_in">begin</span>(), </span><br><span class="line">    data.<span class="built_in">end</span>(),</span><br><span class="line">    std::ostream_iterator&lt;<span class="keyword">int</span>&gt;&#123;std::cout, <span class="string">&quot;\n&quot;</span>&#125;,</span><br><span class="line">    <span class="number">10</span>,</span><br><span class="line">    eng);</span><br></pre></td></tr></table></figure>

<p>这样每次样本就会发生变化。另外<code>std::sample</code>是有返回值的，返回的是最后一个随机样本之后的迭代器。它的作用是确定随机样本在输出容器中的范围，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; out_data;</span><br><span class="line">    out_data.<span class="built_in">resize</span>(<span class="number">100</span>);</span><br><span class="line">    std::random_device rd;</span><br><span class="line">    std::default_random_engine eng&#123; <span class="built_in">rd</span>() &#125;;</span><br><span class="line">    <span class="keyword">auto</span> end = std::<span class="built_in">sample</span>(data.<span class="built_in">begin</span>(), </span><br><span class="line">        data.<span class="built_in">end</span>(),</span><br><span class="line">        out_data.<span class="built_in">begin</span>(),</span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line">        eng);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;coll size: &quot;</span> </span><br><span class="line">        &lt;&lt; out_data.<span class="built_in">size</span>() </span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = out_data.<span class="built_in">begin</span>(); it != end; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的输出结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">coll size: <span class="number">100</span></span><br><span class="line"><span class="number">1708</span></span><br><span class="line"><span class="number">1830</span></span><br><span class="line"><span class="number">2803</span></span><br><span class="line"><span class="number">3708</span></span><br><span class="line"><span class="number">5146</span></span><br><span class="line"><span class="number">7376</span></span><br><span class="line"><span class="number">7867</span></span><br><span class="line"><span class="number">8059</span></span><br><span class="line"><span class="number">8271</span></span><br><span class="line"><span class="number">9448</span></span><br></pre></td></tr></table></figure>

<p>可以看到，虽然容器的大小是100，但是我们只填充10个随机样本。最后需要说明一下<code>std::sample</code>对于两个迭代器参数的要求，首先源迭代器至少是一个输入迭代器的时候，目标迭代器至少可以是一个输出迭代器。但是当源迭代器不是一个向前迭代器，那么目标迭代器必须是一个随机迭代器。这一点很好理解，当源迭代器不能确保随机的情况下，只能将目的迭代器随机以确保样本的随机性。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/12/26/use-sample-to-get-random-samples/" data-id="cktihnvqf00agnoup69r4fwdm" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-mybind" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/18/mybind/">实现一个类似std::bind的功能</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/11/18/mybind/" class="article-date"><time datetime="2020-11-18T09:38:46.000Z" itemprop="datePublished">2020-11-18</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>前两天有朋友问我<code>std::bind</code>是如何实现的，对照STL讲述原理后朋友表示还是很难理解，这可以理解，因为STL涉及到的东西太多，很难清晰的将核心部分显式出来。为了解释清楚这个问题，我自己实现了一个bind功能。当然了，比<code>std::bind</code>要简单非常非常多，缺少很多有用的特性，但是也能展示bind的核心原理了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> _Nx&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyPh</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">0</span>&gt; _0;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">1</span>&gt; _1;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">2</span>&gt; _2;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">3</span>&gt; _3;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">4</span>&gt; _4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span> ... Arg&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">MyBind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _MyBind(F f, Arg ... arg) : _MyList(arg...), _f(f) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... CallArg&gt;</span></span><br><span class="line"><span class="function">	R <span class="title">operator</span><span class="params">()</span><span class="params">(CallArg... arg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="function">_MyBind&lt;R, F, CallArg...&gt; <span class="title">c</span><span class="params">(<span class="number">0</span>, arg...)</span></span>;</span><br><span class="line">        std::<span class="keyword">size_t</span> <span class="keyword">constexpr</span> tSize </span><br><span class="line">            = std::tuple_size&lt;std::tuple&lt;Arg...&gt;&gt;::value;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">call_tuple</span>(_f, _MyList, </span><br><span class="line">            c, std::make_index_sequence&lt;tSize&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Tuple, <span class="keyword">typename</span> C, <span class="keyword">size_t</span> ...S&gt;</span></span><br><span class="line"><span class="function">	R <span class="title">call_tuple</span><span class="params">(F f, Tuple t, C c, std::index_sequence&lt;S...&gt;)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(c[std::get&lt;S&gt;(_MyList)]...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="keyword">operator</span>[] (T &amp;t) &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt; <span class="keyword">typename</span> std::tuple_element&lt;N, </span><br><span class="line">        std::tuple&lt;Arg...&gt;&gt;::type <span class="keyword">operator</span>[] (_MyPh&lt;N&gt;) </span><br><span class="line">    &#123; </span><br><span class="line">            <span class="keyword">return</span> std::get&lt;N&gt;(_MyList);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tuple&lt;Arg...&gt; _MyList;</span><br><span class="line">    F _f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span> ... Arg&gt; </span></span><br><span class="line"><span class="function">	_MyBind&lt;R, F, Arg...&gt; <span class="title">mybind</span><span class="params">(F f, Arg ... arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _MyBind&lt;R, F, Arg...&gt;(f, arg...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> myfunc = mybind&lt;<span class="keyword">int</span>&gt;(sum, _0, <span class="number">2</span>, _1)(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先占位符其实就是一个空类型，我们不需要类型里有什么，只是想要一个类型标识符。</p>
<p>然后看到最关键的<code>_MyBind</code>类模板，该类模板有数据成员<code>_MyList</code>和<code>_f</code>，用于存放绑定的函数和参数。在构造对象的时候数据成员会被填充，并且在调用<code>template&lt;typename ... CallArg&gt; R operator()(CallArg... arg)</code>的时候使用这两个数据成员。这里比较难理解的是<code>call_tuple</code>函数模板，该函数需要将绑定的参数列表和后续调用的参数列表传入函数，</p>
<p>最后使用SFINAE的技巧有选择的通过<code>operator[]</code>获取对应的值。如果<code>std::get&lt;S&gt;(_MyList)</code>返回的是绑定的具体值，那么通过<code>template&lt;typename T&gt; T operator[] (T &amp;t) &#123; return t; &#125;</code>返回值本身，注意这里的<code>t</code>是最外层<code>_MyList</code>中的元素；如果<code>std::get&lt;S&gt;(_MyList)</code>返回的是占位符，那么将通过<code>template&lt;int N&gt; typename std::tuple_element&lt;N, std::tuple&lt;Arg...&gt;&gt;::type operator[] (_MyPh&lt;N&gt;) &#123; return std::get&lt;N&gt;(_MyList); &#125;</code>返回<code>c</code>中<code>_MyList</code>的元素，请注意这里的<code>this</code>对象是<code>c</code>。</p>
<p>当然为了使用方便需要一个函数模板<code>mybind</code>，它只需要指定一个返回类型就可以使用了。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/11/18/mybind/" data-id="cktihnvqf00aenouphtdidm87" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-use-span-instead-of-array-pointer-to-pass-parameters" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/">使用std::span代替数组指针传参</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/" class="article-date"><time datetime="2020-10-02T07:52:31.000Z" itemprop="datePublished">2020-10-02</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道<code>std::string_view</code>可以创建<code>std::string</code>的一个视图，视图本身并不拥有实例，它只是保持视图映射的状态。在不修改实例的情况下，使用<code>std::string_view</code>会让字符串处理的性能大幅提升。实际上，对于那些连续的序列对象我们都可以创建这样一份视图，对于<code>std::vector</code>这样的对象可以提高某些操作中的性能，另外对原生数组可以提高其访问的安全性。</p>
<p>过去如果一个函数想接受无法确定数组长度的数组作为参数，那么一定需要声明两个参数：数组指针和长度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_data</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">set_data</span>(buf, <span class="number">128</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种人工输入增加了编码的风险，数组长度的错误输入会引发程序的未定义行为，甚至是成为可被利用的漏洞。C++20标准库为我们提供了一个很好解决方案<code>std::span</code>，通过它可以定义一个基于连续序列对象的视图，包括原生数组，并且保留连续序列对象的大小。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;span&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_data</span><span class="params">(std::span&lt;<span class="keyword">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arr.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">set_data</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了原生数组，<code>std::vector</code>和<code>std::array</code>也在<code>std::span</code>的处理之列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; buf1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 3&gt; buf2&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">set_data</span>(buf1);</span><br><span class="line"><span class="built_in">set_data</span>(buf2);</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>std::span</code>还可以通过构造函数设置连续序列对象的长度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">set_data</span>(&#123; buf, <span class="number">16</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>从<code>std::string_view</code>到<code>std::span</code>，我们可以看出C++标准库很乐于这种视图设计，因为这种设计和抽象的实现可以提高C ++程序的可靠性而又不牺牲性能和可移植性。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/" data-id="cktihnvqe00acnoupcah4dt19" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-use-string_view-to-improve-string-processing-performance" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/25/use-string_view-to-improve-string-processing-performance/">使用std::string_view提升字符串处理性能</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/09/25/use-string_view-to-improve-string-processing-performance/" class="article-date"><time datetime="2020-09-25T06:27:45.000Z" itemprop="datePublished">2020-09-25</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>C++标准库提供了一个非常优秀的字符串处理类<code>std::string</code>，我们可以通过该类完成各种字符串操作。但是<code>std::string</code>有一个缺点，它的很多操作都是针对字符串实体，存在不必要的内存拷贝的代码，导致字符串的处理性能不尽如人意。针对这种情况C++17标准引入了<code>std::string_view</code>这个类，该类不会直接作用在字符串实体上，而是记录字符串处理的位置，这样就可以保证用最小的代价对字符串进行处理。</p>
<p>为了验证这个结论，下面的代码实现了一个断词器，然后针对64MB的数据做断词处理并且分别记录使用<code>std::string</code>和<code>std::string_view</code>作为基础类型时断词器运行的时间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tokenizer</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> string_type = T;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> T::value_type;</span><br><span class="line">    <span class="built_in">tokenizer</span>(<span class="keyword">const</span> string_type&amp; str, </span><br><span class="line">        std::<span class="keyword">enable_if_t</span>&lt;std::disjunction_v&lt;</span><br><span class="line">        std::is_same&lt;string_type, std::basic_string&lt;value_type&gt;&gt;,</span><br><span class="line">        std::is_same&lt;string_type, std::basic_string_view&lt;value_type&gt;&gt;&gt;&gt;* = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">data_</span>(str), <span class="built_in">begin_</span>(<span class="number">0</span>), <span class="built_in">end_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function">string_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> value_type sep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; end_ &lt; data_.<span class="built_in">size</span>(); ++end_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data_[end_] == sep) &#123;</span><br><span class="line">                <span class="keyword">auto</span> res = data_.<span class="built_in">substr</span>(begin_, end_ - begin_);</span><br><span class="line">                begin_ = ++end_;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end_ &lt;= data_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data_.<span class="built_in">substr</span>(begin_, end_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">more</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> end_ &lt; data_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> string_type data_;</span><br><span class="line">    <span class="keyword">size_t</span> begin_, end_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">make_string_data</span><span class="params">(<span class="keyword">size_t</span> count, <span class="keyword">char</span> sep)</span> </span>&#123;</span><br><span class="line">    std::string data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + i % <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> != count)</span><br><span class="line">            data.<span class="built_in">push_back</span>(sep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string data = <span class="built_in">make_string_data</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">32</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">tokenizer&lt;std::string&gt; <span class="title">tk</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">while</span> (tk.<span class="built_in">more</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">tk</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; diff = end - start;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;elapsed time = &quot;</span> &lt;&lt; diff.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中<code>tokenizer</code>是一个断词器的类模板，接受<code>std::string</code>、<code>std::wstring</code>等<code>std::basic_string</code>模板实例化的类型，同时也能接受<code>std::string_view</code>、<code>std::wstring_view</code>等<code>std::basic_string_view</code>模板实例化的类型。这里采用了SFINAE的方法来约束<code>tokenizer</code>的模板实参必须为以上类型。如果编译环境是C++20标准，可以采用概念来约束模板实参类型。</p>
<p>这份代码<code>tokenizer&lt;std::string&gt;</code>运行结果是0.45秒，如果将<code>tokenizer&lt;std::string&gt;</code>替换为<code>tokenizer&lt;std::string_view&gt;</code>运行时间缩短为0.08秒，性能提升是非常明显的 。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/09/25/use-string_view-to-improve-string-processing-performance/" data-id="cktihnvqd00aanoup3gigaywn" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-something-about-enable_shared_from_this" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/05/something-about-enable_shared_from_this/">std::enable_shared_from_this原理浅析</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/08/05/something-about-enable_shared_from_this/" class="article-date"><time datetime="2020-08-05T09:54:11.000Z" itemprop="datePublished">2020-08-05</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在解释<code>std::enable_shared_from_this</code>之前，先看一个<code>std::shared_ptr</code>典型用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; pt1&#123; <span class="keyword">new</span> <span class="keyword">int</span>&#123; <span class="number">10</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> pt2&#123; pt1 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时<code>pt1</code>和<code>pt2</code>共用了引用计数，当<code>pt1</code>和<code>pt2</code>的生命周期都结束时，<code>new int&#123;10&#125;</code>分配的内存会被释放。下面的做法会导致内存多次释放，因为它们没有使用共同的引用计数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pt&#123; <span class="keyword">new</span> <span class="keyword">int</span>&#123; <span class="number">10</span> &#125; &#125;;</span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; pt1&#123; pt &#125;;</span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; pt2&#123; pt &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我想应该也没有人这么使用<code>std::shared_ptr</code>。不过下面这个错误倒是比较常见：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要用this调用SomeAPI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这段代码需要在<code>NeedCallSomeAPI</code>函数中调用<code>SomeAPI</code>，而<code>SomeAPI</code>需要的是一个<code>std::shared_ptr&lt;SomeData&gt;</code>的实参。这个时候应该怎么做？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(std::shared_ptr&lt;SomeData&gt;&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的做法是错误的，因为<code>SomeAPI</code>调用结束后<code>std::shared_ptr&lt;SomeData&gt;</code>对象的引用计数会降为0，导致<code>this</code>被意外释放。</p>
<p>这种情况下，我们需要使用<code>std::enable_shared_from_this </code>，使用方法很简单，只需要让<code>SomeData</code>继承<code>std::enable_shared_from_this&lt;SomeData&gt;</code>，然后调用<code>shared_from_this</code>吗，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>:</span>std::enable_shared_from_this&lt;SomeData&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::shared_ptr&lt;SomeData&gt; <span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::shared_ptr&lt;SomeData&gt;(<span class="keyword">new</span> SomeData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SomeData</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> d&#123; SomeData::<span class="built_in">Create</span>() &#125;;</span><br><span class="line">    d-&gt;<span class="built_in">NeedCallSomeAPI</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::enable_shared_from_this </code>的实现比较复杂，但是实现原理则比较简单。它内部使用了<code>std::weak_ptr</code>来帮助完成指针相关控制数据的同步，而这份数据是在创建<code>std::shared_ptr</code>的时候完成的。我们来重点解析这一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span> &#123;</span></span><br><span class="line"> <span class="keyword">mutable</span> weak_ptr&lt;T&gt; weak_this;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">shared_ptr&lt;T&gt; <span class="title">shared_from_this</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> shared_ptr&lt;T&gt;(weak_this); </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function">shared_ptr&lt;<span class="keyword">const</span> T&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> shared_ptr&lt;<span class="keyword">const</span> T&gt;(weak_this); </span><br><span class="line"> &#125;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上是摘要的<code>enable_shared_from_this</code>的代码，这份代码中有两个关键要素。首先<code>weak_this</code>被声明为<code>mutable</code>，这让<code>weak_this</code>可以在<code>const</code>的限定下修改，其次也是最关键的地方，该类声明了<code>shared_ptr</code>为友元。这意味着<code>std::shared_ptr</code>可以修改<code>weak_this</code>，并且<code>weak_this</code>被初始化的地方在<code>std::shared_ptr</code>中。进一步说，没有<code>std::shared_ptr</code>的<code>enable_shared_from_this</code>是没有灵魂的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>:</span>std::enable_shared_from_this&lt;SomeData&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> d&#123; <span class="keyword">new</span> SomeData &#125;;</span><br><span class="line">    d-&gt;<span class="built_in">NeedCallSomeAPI</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这份代码中调用<code>shared_from_this</code>会出错。</p>
<p>再深入一步，<code>std::shared_ptr</code>是如何判断实例化对象类型是否继承<code>std::enable_shared_from_this</code>，并且通过判断结果决定是否初始化<code>weak_this</code>的呢？答案是SFINAE(“<em>Substitution Failure Is Not An Error</em>“)。</p>
<p>让我们查看VS2019的STL代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> _Esft_type = enable_shared_from_this;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yty</span>, <span class="keyword">class</span> =</span> <span class="keyword">void</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Can_enable_shared</span> :</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Can_enable_shared</span>&lt;</span>_Yty, <span class="keyword">void_t</span>&lt;<span class="keyword">typename</span> _Yty::_Esft_type&gt;&gt;</span><br><span class="line">    : is_convertible&lt;<span class="keyword">remove_cv_t</span>&lt;_Yty&gt;*, <span class="keyword">typename</span> _Yty::_Esft_type*&gt;::type &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的重点是<code>_Can_enable_shared</code>，如果目标类型有内嵌类型<code>_Esft_type</code>，并且目标类型和内嵌类型的指针是可转换的，也就是有继承关系，那么类型结果为<code>true_type</code>，反之为<code>false_type</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ux</span>&gt;</span></span><br><span class="line">   <span class="keyword">void</span> _Set_ptr_rep_and_enable_shared(_Ux* <span class="keyword">const</span> _Px, _Ref_count_base* <span class="keyword">const</span> _Rx) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>-&gt;_Ptr = _Px;</span><br><span class="line">       <span class="keyword">this</span>-&gt;_Rep = _Rx;</span><br><span class="line">       <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(conjunction_v&lt;negation&lt;is_array&lt;_Ty&gt;&gt;, negation&lt;is_volatile&lt;_Ux&gt;&gt;, _Can_enable_shared&lt;_Ux&gt;&gt;)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (_Px &amp;&amp; _Px-&gt;_Wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">               _Px-&gt;_Wptr = shared_ptr&lt;<span class="keyword">remove_cv_t</span>&lt;_Ux&gt;&gt;(*<span class="keyword">this</span>, <span class="keyword">const_cast</span>&lt;<span class="keyword">remove_cv_t</span>&lt;_Ux&gt;*&gt;(_Px));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>接下来，如果对象不是数组、不是<code>volatile</code>声明的并且<code>_Can_enable_shared</code>返回<code>true_type</code>，那么<code>_Wptr</code>才会被初始化。<code>std::shared_ptr</code>的构造函数以及<code>std::make_shared</code>函数都会调用该函数。</p>
<p>以上就是<code>std::enable_shared_from_this</code>实现原理中比较关键的一个部分。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/08/05/something-about-enable_shared_from_this/" data-id="cktihnvqd00a8noupfbe042w9" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-use-fmtlib-format-string" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/07/use-fmtlib-format-string/">使用fmtlib格式化字符串</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/07/07/use-fmtlib-format-string/" class="article-date"><time datetime="2020-07-07T04:21:13.000Z" itemprop="datePublished">2020-07-07</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在C++中格式化字符串的方法一直是一个备受争议的话题，无论是<code>printf</code>系列函数还是Stream IO都有各自的优缺点。本篇文章直接略过这两种方法，将目光放到fmtlib这个第三方库中，虽然是第三方库，但是C++20标准会引入该库的一部分特性。</p>
<p>fmtlib格式化字符串的语法和python十分相似，熟悉python的朋友掌握起来会非常迅速，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>以上是python格式化字符串的方法，对比到fmtlib为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在python中，格式化字符串的{}是可以设定索引并且指定顺序的，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在fmtlib中也能够实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外在python中还可以使用命名的{}来格式化字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;first&#125; &#123;second&#125;&quot;</span>.<span class="built_in">format</span>(first = <span class="string">&quot;hello&quot;</span>, second = <span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>不过C++中不支持指定参数名来传参，fmtlib采用了一个很巧妙的方法，它使用了自定义字面量的方法生成了一个named_arg对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/format.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> fmt::literals;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(</span><br><span class="line">        <span class="string">&quot;&#123;first&#125; &#123;second&#125;&quot;</span>, </span><br><span class="line">        <span class="string">&quot;first&quot;</span>_a = <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;second&quot;</span>_a = <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>格式化说明符的语法也是基本相同的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>)</span><br></pre></td></tr></table></figure>

<p>对应到fmtlib：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>, <span class="number">3.1415926</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细的格式化说明符的文档见：<a target="_blank" rel="noopener" href="https://fmt.dev/latest/syntax.html">链接</a></p>
<p>最后fmtlib还支持自定义格式化类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> telephone[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">fmt</span>:</span>:formatter&lt;PersonInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> fmt::<span class="function">format_parse_context::iterator </span></span><br><span class="line"><span class="function">	<span class="title">parse</span><span class="params">(fmt::format_parse_context&amp; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = ctx.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> ++iter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt::<span class="function">format_context::iterator </span></span><br><span class="line"><span class="function">	<span class="title">format</span><span class="params">(PersonInfo info, fmt::format_context&amp; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fmt::format_to(ctx.<span class="built_in">out</span>(), </span><br><span class="line">        <span class="string">&quot;name : &#123;&#125; | age : &#123;&#125; | tel. : &#123;&#125;&quot;</span>, </span><br><span class="line">        info.name, info.age, info.telephone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PersonInfo info&#123; <span class="string">&quot;xiaoming&quot;</span>, <span class="number">18</span>, <span class="string">&quot;1234567890&quot;</span> &#125;;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;&#125;&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2020/07/07/use-fmtlib-format-string/" data-id="cktihnvqc00a6nouphf4i0a77" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="active"><span class="page-number">2</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/18/">18</a></li><li><a class="page-next" rel="next" href="/page/3/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>https://github.com/0cch</p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CPP/">CPP</a><span class="sidebar-module-list-count">27</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/">Debugging</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">5</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/Tips/">Tips</a><span class="sidebar-module-list-count">7</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/DeepLearner/">DeepLearner</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MiniKernel/">MiniKernel</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">4</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Tips/">Tips</a><span class="sidebar-module-list-count">69</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/debugging/">debugging</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/machinelearning/">machinelearning</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/File-System/" rel="tag">File System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/IDE/" rel="tag">IDE</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Kernel/" rel="tag">Kernel</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/MiniKernel/" rel="tag">MiniKernel</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTFS/" rel="tag">NTFS</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTInternals/" rel="tag">NTInternals</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTSTATUS/" rel="tag">NTSTATUS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/OS/" rel="tag">OS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/PIO/" rel="tag">PIO</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/System/" rel="tag">System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Test/" rel="tag">Test</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Volume/" rel="tag">Volume</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Windows/" rel="tag">Windows</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/grub/" rel="tag">grub</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/snapshot/" rel="tag">snapshot</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/File-System/" style="font-size: 10px;">File System</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Kernel/" style="font-size: 20px;">Kernel</a> <a href="/tags/MiniKernel/" style="font-size: 10px;">MiniKernel</a> <a href="/tags/NTFS/" style="font-size: 15px;">NTFS</a> <a href="/tags/NTInternals/" style="font-size: 10px;">NTInternals</a> <a href="/tags/NTSTATUS/" style="font-size: 10px;">NTSTATUS</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/PIO/" style="font-size: 10px;">PIO</a> <a href="/tags/System/" style="font-size: 10px;">System</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Volume/" style="font-size: 10px;">Volume</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/snapshot/" style="font-size: 10px;">snapshot</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/02/">February 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/01/">January 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/12/">December 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/11/">November 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/10/">October 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/09/">September 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/08/">August 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/06/">June 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/05/">May 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/04/">April 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/03/">March 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/02/">February 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/01/">January 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/12/">December 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/11/">November 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/10/">October 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/09/">September 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/08/">August 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/07/">July 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">June 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/05/">May 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/04/">April 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/03/">March 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/01/">January 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/12/">December 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/11/">November 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/07/">July 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/06/">June 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/05/">May 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">April 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">March 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">February 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">January 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">December 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">November 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">October 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">September 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">August 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">March 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">February 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">January 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">December 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/11/">November 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">October 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/09/">September 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">August 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">July 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">June 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/05/">May 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">April 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/03/">March 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/01/">January 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/12/">December 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/11/">November 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">October 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">September 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/08/">August 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/07/">July 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/06/">June 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/05/">May 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/04/">April 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/03/">March 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/02/">February 2016</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/01/">January 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/12/">December 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/11/">November 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/10/">October 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/09/">September 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/08/">August 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/07/">July 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/06/">June 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/05/">May 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/04/">April 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/03/">March 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/02/">February 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/01/">January 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/12/">December 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/11/">November 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/10/">October 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/09/">September 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/08/">August 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/07/">July 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/06/">June 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/05/">May 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/04/">April 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/03/">March 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/02/">February 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/01/">January 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/12/">December 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/11/">November 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/10/">October 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/09/">September 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/08/">August 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/07/">July 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/06/">June 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/05/">May 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/04/">April 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/03/">March 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/02/">February 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/01/">January 2013</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/12/">December 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/11/">November 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/08/">August 2012</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/02/">February 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/12/">December 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/10/">October 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/09/">September 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/08/">August 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/06/">June 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/05/">May 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/04/">April 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/02/">February 2011</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2022/02/12/k+2021/">2021K+软件峰会PPT</a>
        </li>
      
        <li>
          <a href="/2022/01/01/2021-summary/">2021小结</a>
        </li>
      
        <li>
          <a href="/2021/12/01/dpcpp/">DPC++中的现代C++语言特性</a>
        </li>
      
        <li>
          <a href="/2021/11/02/module-ext/">补编-模块(C++20)</a>
        </li>
      
        <li>
          <a href="/2021/10/07/moderncpp42/">《现代C++语言核心特性解析》上架感言</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 0CCh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
