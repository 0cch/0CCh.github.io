<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>0CCh Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="0CCh Blog">
<meta property="og:url" content="http://0cch.com/page/18/index.html">
<meta property="og:site_name" content="0CCh Blog">
<meta property="og:locale">
<meta property="article:author" content="0CCh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="0CCh Blog" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">0CCh Blog</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/08/28/e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081/">一份简陋的NTFS Parse代码</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/08/28/e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081/" class="article-date"><time datetime="2011-08-28T01:20:09.000Z" itemprop="datePublished">2011-08-28</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/NTInternals/">NTInternals</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>研究了近两周的NTFS文件格式，初步了解了一些NTFS基本属性的解析方法。<br>为了自己研究方便，写了点简单的解析代码。发出来以方便需要的人。<br>话说这份代码的解析类只是属于demo阶段，而且没有注释。不过代码写的还算清晰。  </p>
<p>参考资料方面，我是转了一份NTFS 3G的文档，这份文档把NTFS的基本特点写的比较清晰了。值得一看</p>
<p><a target="_blank" rel="noopener" href="http://0cch.net/ntfsdoc/">http://0cch.net/ntfsdoc/</a></p>
<p>代码：<a href="/uploads/2011/08/NtfsParse.zip">NtfsParse</a></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/08/28/e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081/" data-id="cl4babr65000am8uecb17fv2x" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTFS/" rel="tag">NTFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/" rel="tag">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/06/10/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862/">ReactOS-Freeldr磁盘及文件管理2</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/06/10/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862/" class="article-date"><time datetime="2011-06-09T18:17:00.000Z" itemprop="datePublished">2011-06-10</time></a>
</div>

    <div class="article-author">cradiator</div>
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>ArcOpen的大体流程我们看过了。大致分为这几步</p>
<ol>
<li><p>函数会尝试找到文件所在分区的设备句柄，如果还没有对应的句柄。那么使用DEVICE.FuncTable中的Open函数打开设备，并为这个设备分配句柄。</p>
</li>
<li><p>打开设备后条用XxxMount识别分区格式，识别成功返回另外的FuncTable，存储到设备的FileData.FileFuncTable域。</p>
</li>
<li><p>为文件分配一个句柄，在对应的FileData.DeviceId为上面创建设备句柄，FileData.FuncTable为设备的FileData.FileFuncTable。</p>
</li>
<li><p>最后调用文件的FileData.FuncTable.Open函数打开文件。</p>
</li>
</ol>
<p><strong>挂载分区时做了什么</strong></p>
<p>之前我们忽略了XxxMount函数。现在来读读比较简单的FatMount (freeldr\freeldr\fs\fat.c)。</p>
<ol>
<li><p><em>const</em> DEVVTBL***** FatMount**(<strong>ULONG DeviceId</strong>)**</p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p><strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.****.</strong></p>
</li>
<li><p>&#x2F;&#x2F; 生成一个FAT_VOLUME_INFO结构</p>
</li>
<li><p>Volume <strong>&#x3D;</strong> MmHeapAlloc**(<strong><em>sizeof</em></strong>(<strong>FAT_VOLUME_INFO</strong>)<strong><strong>)</strong></strong>;**</p>
</li>
<li><p><em>if</em> <strong>(****!<strong>Volume</strong>)</strong></p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><em>RtlZeroMemory</em><strong>(<strong>Volume, <em>sizeof</em></strong>(<strong>FAT_VOLUME_INFO</strong>)<strong><strong>)</strong></strong>;</strong></p>
</li>
<li><p>&#x2F;&#x2F; 读第一个扇区</p>
</li>
<li><p>Position**.<strong>HighPart <strong>&#x3D;</strong> 0</strong>;**</p>
</li>
<li><p>Position**.<strong>LowPart <strong>&#x3D;</strong> 0</strong>;**</p>
</li>
<li><p>ret <strong>&#x3D;</strong> ArcSeek**(*<em>DeviceId, <strong>&amp;<strong>Position, SeekAbsolute</strong>)</strong></em><em>;</em>*</p>
</li>
<li><p><em>if</em> <strong>(<strong>ret <strong>!****&#x3D;</strong> ESUCCESS</strong>)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree**(<strong>Volume</strong>)****;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>ret <strong>&#x3D;</strong> ArcRead**(<strong>DeviceId, Buffer, <em>sizeof</em></strong>(<strong>Buffer</strong>)**, <strong>&amp;<strong>Count</strong>)****;</strong></p>
</li>
<li><p><em>if</em> <strong>(<strong>ret <strong>!****&#x3D;</strong> ESUCCESS <strong>|****|</strong> Count <strong>!****&#x3D;</strong> <em>sizeof</em></strong>(<strong>Buffer</strong>)****)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree**(<strong>Volume</strong>)****;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>&#x2F;&#x2F; 判断是否有fat分区标志</p>
</li>
<li><p><em>if</em> <strong>(<strong><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector</strong>-</strong></strong>&gt;<strong>FileSystemType, “FAT12 “, 8</strong>)</strong> <strong>&amp;****&amp;</strong></p>
</li>
<li><p><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector</strong>-****&gt;<strong>FileSystemType, “FAT16 “, 8</strong>)</strong> <strong>&amp;****&amp;</strong></p>
</li>
<li><p><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector32</strong>-****&gt;<strong>FileSystemType, “FAT32 “, 8</strong>)</strong> <strong>&amp;****&amp;</strong></p>
</li>
<li><p><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSectorX</strong>-<strong><strong>&gt;<strong>FileSystemType, “FATX”, 4</strong>)</strong></strong>)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree**(<strong>Volume</strong>)****;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>&#x2F;&#x2F; 获得分区大小等信息</p>
</li>
<li><p>ret <strong>&#x3D;</strong> ArcGetFileInformation**(*<em>DeviceId, <strong>&amp;<strong>FileInformation</strong>)</strong></em><em>;</em>*</p>
</li>
<li><p><em>if</em> <strong>(<strong>ret <strong>!****&#x3D;</strong> ESUCCESS</strong>)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree**(<strong>Volume</strong>)****;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>SectorCount**.<strong>HighPart <strong>&#x3D;</strong> FileInformation</strong>.<strong>EndingAddress</strong>.<strong>HighPart</strong>;**</p>
</li>
<li><p>SectorCount**.<strong>LowPart <strong>&#x3D;</strong> FileInformation</strong>.<strong>EndingAddress</strong>.<strong>LowPart</strong>;**</p>
</li>
<li><p>SectorCount**.<strong>QuadPart <strong>&#x2F;****&#x3D;</strong> SECTOR_SIZE</strong>;**</p>
</li>
<li><p>Volume**-****&gt;<strong>DeviceId <strong>&#x3D;</strong> DeviceId</strong>;**</p>
</li>
<li><p>&#x2F;&#x2F; 打开分区</p>
</li>
<li><p><em>if</em> <strong>(<strong><strong>!<strong>FatOpenVolume</strong>(<strong>Volume, BootSector, SectorCount</strong>.<strong>QuadPart</strong>)</strong></strong>)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree**(<strong>Volume</strong>)****;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>&#x2F;&#x2F; 存储FAT_VOLUME_INFO结构</p>
</li>
<li><p>FatVolumes**[<strong>DeviceId</strong>]** <strong>&#x3D;</strong> Volume**;**</p>
</li>
<li><p>&#x2F;&#x2F; 返回fat文件读写的FuncTable</p>
</li>
<li><p><em>return</em> <strong>&amp;<strong>FatFuncTable</strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>**</p>
</li>
</ol>
<p>**</p>
<p>函数中的DeviceId是设备的句柄。</p>
<p>生成FAT_VOLUME_INFO结构。这个结构里面存储了FAT分区的基本信息。包括扇区大小，每个簇的扇区数等等。</p>
<ol>
<li><p><em>typedef</em> <em>struct</em> _FAT_VOLUME_INFO </p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>ULONG BytesPerSector**;** &#x2F;* Number of bytes per sector *&#x2F;</p>
</li>
<li><p>ULONG SectorsPerCluster**;** &#x2F;* Number of sectors per cluster *&#x2F;</p>
</li>
<li><p>ULONG FatSectorStart**;** &#x2F;* Starting sector of 1st FAT table *&#x2F;</p>
</li>
<li><p>ULONG ActiveFatSectorStart**;** &#x2F;* Starting sector of active FAT table *&#x2F;</p>
</li>
<li><p>ULONG NumberOfFats**;** &#x2F;* Number of FAT tables *&#x2F;</p>
</li>
<li><p>ULONG SectorsPerFat**;** &#x2F;* Sectors per FAT table *&#x2F;</p>
</li>
<li><p>ULONG RootDirSectorStart**;** &#x2F;* Starting sector of the root directory (non-fat32) *&#x2F;</p>
</li>
<li><p>ULONG RootDirSectors**;** &#x2F;* Number of sectors of the root directory (non-fat32) *&#x2F;</p>
</li>
<li><p>ULONG RootDirStartCluster**;** &#x2F;* Starting cluster number of the root directory (fat32 only) *&#x2F;</p>
</li>
<li><p>ULONG DataSectorStart**;** &#x2F;* Starting sector of the data area *&#x2F;</p>
</li>
<li><p>ULONG FatType**;** &#x2F;* FAT12, FAT16, FAT32, FATX16 or FATX32 *&#x2F;</p>
</li>
<li><p>ULONG DeviceId**;**</p>
</li>
<li><p><strong>}</strong> FAT_VOLUME_INFO**;**</p>
</li>
<li><p>**</p>
</li>
</ol>
<p>**</p>
<p>  读取第一个山区，判断是否有fat标志。如果没有直接返回，挂载失败。之后使用ArcGetFileInformation获得分区大小。ArcGetFileInformation里面调用了FileData.FuncTable.GetFileInformation。因为当前DeviceId是设备句柄，所以他实际调用的是DiskGetFileInformation(freeldr\freeldr\arch\i386\hardware.c)。这个函数很简单，通过FileInformation返回分区开始和结束的地址，这里就不列出了。     </p>
<p>这里的代码用FileInformation**.**EndingAddress &#x2F; SECTOR_SIZE计算出了该分区的扇区数SectorCount。这里应该BUG。因为EndingAddress是分区结束地址，真的扇区数应该是 (分区开始地址 - EndingAddress ) &#x2F; SECTOR_SIZE。好在SectorCount只是判断fat分区的一个依据，而且一般C盘计算出的SectorCount误差不会很大，影响不大。</p>
<p>最后执行FatOpenVolume真正执行分区的挂载、初始化。初始化结束后将生成的Volume放到fat.c维护的全局数组FatVolumes里，之后对fat分区进行操作（读写）时，通过设备的DeviceId就可以找到对应的FAT_VOLUME_INFO结构。</p>
<p>最后函数返回FatFuncTable函数数组</p>
<ol>
<li><p><em>const</em> DEVVTBL FatFuncTable <strong>&#x3D;</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>FatClose, </p>
</li>
<li><p>FatGetFileInformation, </p>
</li>
<li><p>FatOpen, </p>
</li>
<li><p>FatRead, </p>
</li>
<li><p>FatSeek, </p>
</li>
<li><p>L”fastfat”, </p>
</li>
<li><p><strong>}****;</strong></p>
</li>
<li></li>
</ol>
<p>用户可以通过这些函数就读写改fat分区啦。</p>
<p>那么FatOpenVolume都干了什么呢。</p>
<p>这个函数简单来说就是根据分区内容填写了Volume结构，已经算是一个分区的具体实现细节了，和整体架构无关，不多说了。这个函数在freeldr\freeldr\fs\fat.c中。</p>
<p><strong><strong>打开文件时做了什么</strong></strong></p>
<p>上一篇文章中还有一个地方没说，就是打开设备并创建完文件的句柄后，ArcOpen调用了文件对应的FileData.FuncTable.Open。对于fat分区而言这个函数是FatOpen(freeldr\freeldr\fs\fat.c). 这个函数也是和分区结构有关的了，有一点比较重要就是函数最后调用了FsSetDeviceSpecific把一个和文件相关的内部结构与文件句柄相关联。以后使用FatRead对文件句柄进行读操作时直接就可以获得这个结构啦。</p>
<ol>
<li><p>LONG FatOpen**(<strong>CHAR</strong>*** Path, OPENMODE OpenMode, ULONG***** FileId**)**</p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p><strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.****.</strong></p>
</li>
<li></li>
<li><p>&#x2F;&#x2F; 根据文件的FileId获得文件所在的设备句柄FileData.DeviceId, 从而获得FatMount时生成的Volume结构。</p>
</li>
<li><p>DeviceId <strong>&#x3D;</strong> FsGetDeviceId**(<em><strong><strong><strong>FileId</strong>)</strong></strong>;</em>*</p>
</li>
<li><p>FatVolume <strong>&#x3D;</strong> FatVolumes**[<strong>DeviceId</strong>]****;**</p>
</li>
<li><p>&#x2F;&#x2F; 从DeviceId设备中读取并查询fat表，判断path表示的文件是否存在</p>
</li>
<li><p><em>RtlZeroMemory</em><strong>(<strong><strong>&amp;<strong>TempFileInfo, <em>sizeof</em></strong>(<strong>TempFileInfo</strong>)****)</strong></strong>;</strong></p>
</li>
<li><p>ret <strong>&#x3D;</strong> FatLookupFile**(*<em>FatVolume, Path, DeviceId, <strong>&amp;<strong>TempFileInfo</strong>)</strong></em><em>;</em>*</p>
</li>
<li><p><em>if</em> <strong>(<strong>ret <strong>!****&#x3D;</strong> ESUCCESS</strong>)</strong></p>
</li>
<li><p><em>return</em> ENOENT**;**</p>
</li>
<li><p>&#x2F;&#x2F; 判断是否是目录</p>
</li>
<li><p>IsDirectory <strong>&#x3D;</strong> <strong>(<strong>TempFileInfo</strong>.<strong>Attributes <strong>&amp;</strong> ATTR_DIRECTORY</strong>)</strong> <strong>!****&#x3D;</strong> 0**;**</p>
</li>
<li><p><em>if</em> <strong>(<strong>IsDirectory <strong>&amp;****&amp;</strong> OpenMode <strong>!****&#x3D;</strong> OpenDirectory</strong>)</strong></p>
</li>
<li><p><em>return</em> EISDIR**;**</p>
</li>
<li><p><em>else</em> <em>if</em> <strong>(<strong>**!*<em>IsDirectory <strong>&amp;</strong></em><em>&amp;</em>* OpenMode <strong>!</strong></strong>&#x3D;** OpenReadOnly**)</strong></p>
</li>
<li><p><em>return</em> ENOTDIR**;**</p>
</li>
<li><p>&#x2F;&#x2F; 生成FAT_FILE_INFO结构，里面存放了文件的信息(开始的扇区等)</p>
</li>
<li><p>FileHandle <strong>&#x3D;</strong> MmHeapAlloc**(<strong><em>sizeof</em></strong>(<strong>FAT_FILE_INFO</strong>)<strong><strong>)</strong></strong>;**</p>
</li>
<li><p><em>if</em> <strong>(****!<strong>FileHandle</strong>)</strong></p>
</li>
<li><p><em>return</em> ENOMEM**;**</p>
</li>
<li><p>RtlCopyMemory**(*<em>FileHandle, <strong>&amp;<strong>TempFileInfo, <em>sizeof</em></strong>(<strong>FAT_FILE_INFO</strong>)****)</strong></em><em>;</em>*</p>
</li>
<li><p>FileHandle**-****&gt;<strong>Volume <strong>&#x3D;</strong> FatVolume</strong>;**</p>
</li>
<li><p>&#x2F;&#x2F; 把这个结构和文件对应的FileData.Specific关联。之后进行FatRead等操作时可以直接获得这个结构了</p>
</li>
<li><p>FsSetDeviceSpecific**(<em><strong><strong><strong>FileId, FileHandle</strong>)</strong></strong>;</em>*</p>
</li>
<li><p><em>return</em> ESUCCESS**;**</p>
</li>
<li><p><strong>}</strong></p>
</li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/06/10/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862/" data-id="cl4babr630008m8ue1u673109" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086/">ReactOS-Freeldr磁盘及文件管理</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086/" class="article-date"><time datetime="2011-06-02T06:33:19.000Z" itemprop="datePublished">2011-06-02</time></a>
</div>

    <div class="article-author">cradiator</div>
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Freeldr提供了对fat12、fat32、fatx、ntfs等文件系统的只读功能。这部分代码主要集中在boot\freeldr\freeldr\fs\fs.c文件中。<br>首先计算机加电后会把mbr读取到物理内存的0x7c00位置，mbr搜索活动分区并加载活动分区根目录下的Freeldr.sys文件。加载后跳入Freeldr入口start。Freeldr进行32为初始化后跳入主初始化函数BootMain(boot\freeldr\freeldr\Freeldr.c)中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">BootMain</span><span class="params">(LPSTR CmdLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">MachInit</span>(CmdLine);</span><br><span class="line"><span class="built_in">FsInit</span>();</span><br><span class="line">......</span><br><span class="line"><span class="built_in">RunLoader</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>BootMain会对硬件(MachInit)和文件系统(FsInit)进行检测和初始化。所有准备工作进行完毕后就会调用RunLoader进行系统的加载工作。<br>Fs初始化和DEVICE、FILEDATA结构<br>下面看一下文件系统的初始化 FsInit(boot\freeldr\freeldr\fs\fs.c)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FsInit</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ULONG i;</span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(FileData, <span class="built_in">sizeof</span>(FileData));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FDS; i++)</span><br><span class="line">FileData[i].DeviceId = (ULONG)<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">InitializeListHead</span>(&amp;DeviceListHead);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>FsInit初始化FileData数组。和一个和磁盘分区相关的链表DeviceListHead。<br>首先fs.c维护了一个MAX_FDS(60)大小的数组 static FILEDATA FileData[MAX_FDS];  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagDEVVTBL</span></span><br><span class="line">&#123;</span><br><span class="line">ARC_CLOSE Close;</span><br><span class="line">ARC_GET_FILE_INFORMATION GetFileInformation;</span><br><span class="line">ARC_OPEN Open;</span><br><span class="line">ARC_READ Read;</span><br><span class="line">ARC_SEEK Seek;</span><br><span class="line">LPCWSTR ServiceName;</span><br><span class="line">&#125; DEVVTBL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagFILEDATA</span></span><br><span class="line">&#123;</span><br><span class="line">ULONG DeviceId;            <span class="comment">// 文件所在磁盘的磁盘文件句柄, 同样也是FileData的索引</span></span><br><span class="line">ULONG ReferenceCount;       <span class="comment">// 引用计数</span></span><br><span class="line"><span class="type">const</span> DEVVTBL* FuncTable;    <span class="comment">// 对文件进行读写的指针</span></span><br><span class="line"><span class="type">const</span> DEVVTBL* FileFuncTable; <span class="comment">// 对文件进行读写的函数数组</span></span><br><span class="line">VOID* Specific;             <span class="comment">// 文件系统自定义指针</span></span><br><span class="line">&#125; FILEDATA;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>每一个成功打开的文件会返回一个文件句柄，这个句柄实际上就是FileData数组的索引。所以每个打开的文件都有一个对应的FileData。这个结构就类似windows中的FILE_OBJECT<br>FileData中DeviceId是文件所在磁盘的句柄。这个句柄同样也是FileData数组的索引，通过这个句柄可以找到”磁盘文件”，对”磁盘文件”的读写就是直接对相应的磁盘或磁盘分区的读写。类似Windows中直接对磁盘分区进行CreateFile返回的句柄。”磁盘文件”的DeviceId没有意义。<br>ReferenceCount是该文件的引用计数。<br>FuncTable这是一个函数数组指针，里面存放了对文件进行读写、SEEK等操作的函数指针。<br>FileFuncTable只对”磁盘文件”有意义。当Freeldr确定了磁盘文件对应的分区的分区格式后，会把与分区格式相关的函数指针数组放到这个字段里面。如Fat12分区”磁盘文件”的FileFuncTable字段存放的就是FatFuncTable指针。<br>Specific存放于文件有关的结构。磁盘文件就是DISKCONTEXT指针，fat12下的文件就是FAT_FILE_INFO指针 等等。<br>之后是DeviceListHead，这是DEVICE结构的链表头  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagDEVICE</span></span><br><span class="line">&#123;</span><br><span class="line">LIST_ENTRY ListEntry;        <span class="comment">// 链表节点</span></span><br><span class="line"><span class="type">const</span> DEVVTBL* FuncTable;    <span class="comment">// 操作该分区的函数表</span></span><br><span class="line">CHAR* Prefix;              <span class="comment">// 分区对应的ArcName</span></span><br><span class="line">ULONG DeviceId;            <span class="comment">// FILEDATA中该分区对应的句柄</span></span><br><span class="line">ULONG ReferenceCount;      <span class="comment">// 引用计数</span></span><br><span class="line">&#125; DEVICE;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>用户电脑中的每一个硬盘和硬盘中的每一分区都对应了一个DEVICE结构。<br>FuncTable里面存放了对该分区进行读写等操作的指针，对于硬盘而言这个数组就是DiskVtbl。<br>Prefix是该分区或硬盘的ArcName。(如multi(0)disk(0)rdisk(0)partition(0))。Freeldr中的文件路径都是Arc形式的路径。而且0号分区代表整个硬盘，真正的分区从1号开始。如multi(0)disk(0)rdisk(0)partition(0)便代表第0块硬盘本身。multi(0)disk(0)rdisk(0)partition(1)代表第0块硬盘的第0个分区。<br>通过DeviceId字段可以找到该DEVICE的文件句柄。这个字段和FILEDATA相互配合，使系统可以遍历DEVICE结构快速找到某个分区的文件句柄。<br>DEVICE(磁盘及分区)的检测<br>上面说到Freeldr操作的路径都是存储在DEVICE结构中的ArcPath。那么这些DEVICE是怎么来的呢？<br>首先我们看一下DEVICE的注册函数，FsRegisterDevice(boot\freeldr\freeldr\fs\fs.c)  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FsRegisterDevice</span><span class="params">(CHAR* Prefix, <span class="type">const</span> DEVVTBL* FuncTable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DEVICE* pNewEntry;</span><br><span class="line">ULONG dwLength;</span><br><span class="line">dwLength = <span class="built_in">strlen</span>(Prefix) + <span class="number">1</span>;</span><br><span class="line">pNewEntry = <span class="built_in">MmHeapAlloc</span>(<span class="built_in">sizeof</span>(DEVICE) + dwLength);</span><br><span class="line"><span class="keyword">if</span> (!pNewEntry)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">pNewEntry-&gt;FuncTable = FuncTable;</span><br><span class="line">pNewEntry-&gt;ReferenceCount = <span class="number">0</span>;</span><br><span class="line">pNewEntry-&gt;Prefix = (CHAR*)(pNewEntry + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(pNewEntry-&gt;Prefix, Prefix, dwLength);</span><br><span class="line"><span class="built_in">InsertHeadList</span>(&amp;DeviceListHead, &amp;pNewEntry-&gt;ListEntry);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这么函数非常简单。Prefix就是Arc路径，FuncTable是操作这个分区（磁盘）对应的函数数组。FsRegisterDevice生成了一个DEVICE结构，把ArcName和FuncTable复制进去。之后连入了DeviceListHead链表。<br>那么又是谁调用的FsRegisterDevice呢？是DetectBiosDisks(boot\freeldr\freeldr\arch\i386\hardware.c)函数。虽然这一部分已经不属于FS的范畴，还是在这里简单讲一下便于理解。这里我略去了不必要的代码。<br>DetectBiosDisks的调用顺序是 RunLoader -&gt; MachHwDetect (PcHwDetect)-&gt; DetectISABios -&gt; DetectBiosDisks</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> VOID</span></span><br><span class="line"><span class="function"><span class="title">DetectBiosDisks</span><span class="params">(PCONFIGURATION_COMPONENT_DATA BusKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOLEAN BootDriveReported = FALSE;</span><br><span class="line">ULONG i;</span><br><span class="line">ULONG DiskCount = <span class="built_in">GetDiskCount</span>(BusKey);</span><br><span class="line">CHAR BootPath[<span class="number">512</span>];</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DiskCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">ULONG Size;</span><br><span class="line">CHAR Identifier[<span class="number">20</span>];</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (BootDrive == <span class="number">0x80</span> + i)</span><br><span class="line">BootDriveReported = TRUE;</span><br><span class="line"><span class="comment">/* Get disk values */</span></span><br><span class="line"><span class="built_in">GetHarddiskIdentifier</span>(Identifier, <span class="number">0x80</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>首先使用GetDiskCount从Freeldr注册表的System键中读取硬盘总数。System键的初始化在DetectSystem(freeldr\freeldr\arch\i386\hardware.c)中，一会儿再看。<br>于是进入一个for循环，为每个硬盘调用GetHarddiskIdentifier函数。在BIOS中硬盘号是从0x80开始的，所以GetHarddiskIdentifier的硬盘号加了0x80。<br>GetHarddiskIdentifier的作用是为制定硬盘生成一个唯一的ID，并通过Identifier参数返回。但这个函数名起得并不好，因为生成ID其实只是这个函数的功能之一。另外的一大功能是检测硬盘，并且为硬盘本身和硬盘分区调用FsRegisterDevice函数进行注册。通过这个注册后硬盘才能真正被文件系统识别。<br>freeldr\freeldr\arch\i386\hardware.c中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> VOID</span></span><br><span class="line"><span class="function"><span class="title">GetHarddiskIdentifier</span><span class="params">(PCHAR Identifier,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG DriveNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PMASTER_BOOT_RECORD Mbr;</span><br><span class="line">ULONG *Buffer;</span><br><span class="line">ULONG i;</span><br><span class="line">ULONG Checksum;</span><br><span class="line">ULONG Signature;</span><br><span class="line">CHAR ArcName[<span class="number">256</span>];</span><br><span class="line">PARTITION_TABLE_ENTRY PartitionTableEntry;</span><br><span class="line"><span class="comment">/* Read the MBR */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">MachDiskReadLogicalSectors</span>(DriveNumber, <span class="number">0ULL</span>, <span class="number">1</span>, (PVOID)DISKREADBUFFER))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DPRINTM</span>(DPRINT_HWDETECT, <span class="string">&quot;Reading MBR failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Buffer = (ULONG*)DISKREADBUFFER;</span><br><span class="line">Mbr = (PMASTER_BOOT_RECORD)DISKREADBUFFER;</span><br><span class="line">Signature = Mbr-&gt;Signature;</span><br><span class="line"><span class="built_in">DPRINTM</span>(DPRINT_HWDETECT, <span class="string">&quot;Signature: %x\n&quot;</span>, Signature);</span><br><span class="line"><span class="comment">/* Calculate the MBR checksum */</span></span><br><span class="line">Checksum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Checksum += Buffer[i];</span><br><span class="line">&#125;</span><br><span class="line">Checksum = ~Checksum + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">DPRINTM</span>(DPRINT_HWDETECT, <span class="string">&quot;Checksum: %x\n&quot;</span>, Checksum);</span><br><span class="line"><span class="comment">/* Fill out the ARC disk block */</span></span><br><span class="line">reactos_arc_disk_info[reactos_disk_count].Signature = Signature;</span><br><span class="line">reactos_arc_disk_info[reactos_disk_count].CheckSum = Checksum;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)&quot;</span>, reactos_disk_count);</span><br><span class="line"><span class="built_in">strcpy</span>(reactos_arc_strings[reactos_disk_count], ArcName);</span><br><span class="line">reactos_arc_disk_info[reactos_disk_count].ArcName =</span><br><span class="line">reactos_arc_strings[reactos_disk_count];</span><br><span class="line">reactos_disk_count++;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)partition(0)&quot;</span>, DriveNumber - <span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">FsRegisterDevice</span>(ArcName, &amp;DiskVtbl);</span><br><span class="line"><span class="comment">/* Add partitions */</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">DiskReportError</span>(FALSE);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">DiskGetPartitionEntry</span>(DriveNumber, i, &amp;PartitionTableEntry))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (PartitionTableEntry.SystemIndicator != PARTITION_ENTRY_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)partition(%lu)&quot;</span>, DriveNumber - <span class="number">0x80</span>, i);</span><br><span class="line"><span class="built_in">FsRegisterDevice</span>(ArcName, &amp;DiskVtbl);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DiskReportError</span>(TRUE);</span><br><span class="line"><span class="comment">/* Convert checksum and signature to identifier string */</span></span><br><span class="line">Identifier[<span class="number">0</span>] = Hex[(Checksum &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">1</span>] = Hex[(Checksum &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">2</span>] = Hex[(Checksum &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">3</span>] = Hex[(Checksum &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">4</span>] = Hex[(Checksum &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">5</span>] = Hex[(Checksum &gt;&gt; <span class="number">8</span> ) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">6</span>] = Hex[(Checksum &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">7</span>] = Hex[Checksum &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">8</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">Identifier[<span class="number">9</span>] = Hex[(Signature &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">10</span>] = Hex[(Signature &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">11</span>] = Hex[(Signature &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">12</span>] = Hex[(Signature &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">13</span>] = Hex[(Signature &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">14</span>] = Hex[(Signature &gt;&gt; <span class="number">8</span> ) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">15</span>] = Hex[(Signature &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">16</span>] = Hex[Signature &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">17</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">Identifier[<span class="number">18</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">Identifier[<span class="number">19</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>函数首先使用MachDiskReadLogicalSectors读取指定硬盘的MBR。对于PC机而言MachDiskReadLogicalSectors使用int 13h中断实现对硬盘的读操作。里面包括了16、32位代码的互转，和本节内容无关，以后再做说明。<br>MBR结构为。详细信息可以参考(<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Master_boot_record">http://en.wikipedia.org/wiki/Master_boot_record</a>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MASTER_BOOT_RECORD</span></span><br><span class="line">&#123;</span><br><span class="line">UCHAR        MasterBootRecordCodeAndData[<span class="number">0x1b8</span>];   <span class="comment">/* 0x000 */</span></span><br><span class="line">ULONG        Signature;          <span class="comment">/* 0x1B8 */</span></span><br><span class="line">USHORT        Reserved;          <span class="comment">/* 0x1BC */</span></span><br><span class="line">PARTITION_TABLE_ENTRY   PartitionTable[<span class="number">4</span>];        <span class="comment">/* 0x1BE */</span></span><br><span class="line">USHORT        MasterBootRecordMagic;        <span class="comment">/* 0x1FE */</span></span><br><span class="line">&#125; MASTER_BOOT_RECORD, *PMASTER_BOOT_RECORD;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>GetHarddiskIdentifier在获取了Signature、计算了Checksum后 。<br>sprintf(ArcName, “multi(0)disk(0)rdisk(%lu)partition(0)”, DriveNumber - 0x80);<br>FsRegisterDevice(ArcName, &amp;DiskVtbl);<br>生成对应硬盘的ArcName，使用FsRegisterDevice注册这块硬盘，这个函数我们已经看过。注意这里Partition为0，所以0号分区实际表示硬盘本身。<br>之后</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">DiskGetPartitionEntry</span>(DriveNumber, i, &amp;PartitionTableEntry))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (PartitionTableEntry.SystemIndicator != PARTITION_ENTRY_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)partition(%lu)&quot;</span>, DriveNumber - <span class="number">0x80</span>, i);</span><br><span class="line"><span class="built_in">FsRegisterDevice</span>(ArcName, &amp;DiskVtbl);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>DiskGetParititionEntry将会解析DriveNumber对应磁盘的分区表，填充第i个分区的信息到PartitionTableEntry结构。如果分区存在则使用FsRegisterDevice注册分区。<br>使用刚才计算的CheckSum和Signature组合一个ID返回给调用者。其实这个ID没有被使用过。。。<br>最后看一下调用FsRegisterDevice时的第二个参数DiskVtbl  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> DEVVTBL DiskVtbl = &#123;</span><br><span class="line">DiskClose,</span><br><span class="line">DiskGetFileInformation,</span><br><span class="line">DiskOpen,</span><br><span class="line">DiskRead,</span><br><span class="line">DiskSeek,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这里面包含了对磁盘扇区读写的全部函数。我们之后再介绍。<br>至此硬盘的及硬盘分区的注册完成。<br>执行完DetectBiosDisks后，DeviceListHead里面就存放了当前计算机所有的磁盘和分区对应的DEVICE结构。<br>文件系统的识别和文件的打开<br>这时Fs模块已经知道的硬盘数量，分区信息。下面来看看一个文件的打开流程。<br>首先，Freeldr使用的是Arc路径，IDE硬盘以multi(0)disk(0)rdisk(n)开头，文件也是以Arc路径表示的。打开文件的函数在Freeldr\Freeldr\fs\fs.c中。这函数比较长，我们分段阅读。<br>Freeldr\Freeldr\fs\fs.c</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">ArcOpen</span><span class="params">(CHAR* Path, OPENMODE OpenMode, ULONG* FileId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">*FileId = MAX_FDS;</span><br><span class="line"><span class="comment">/* Search last &#x27;)&#x27;, which delimits device and path */</span></span><br><span class="line">FileName = <span class="built_in">strrchr</span>(Path, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!FileName)</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line">FileName++;</span><br><span class="line"><span class="comment">/* Count number of &quot;()&quot;, which needs to be replaced by &quot;(0)&quot; */</span></span><br><span class="line">dwCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (p = Path; p != FileName; p++)</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">&#x27;(&#x27;</span> &amp;&amp; *(p + <span class="number">1</span>) == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">dwCount++;</span><br><span class="line"><span class="comment">/* Duplicate device name, and replace &quot;()&quot; by &quot;(0)&quot; (if required) */</span></span><br><span class="line">dwLength = FileName - Path + dwCount;</span><br><span class="line"><span class="keyword">if</span> (dwCount != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">DeviceName = <span class="built_in">MmHeapAlloc</span>(FileName - Path + dwCount);</span><br><span class="line"><span class="keyword">if</span> (!DeviceName)</span><br><span class="line"><span class="keyword">return</span> ENOMEM;</span><br><span class="line"><span class="keyword">for</span> (p = Path, q = DeviceName; p != FileName; p++)</span><br><span class="line">&#123;</span><br><span class="line">*q++ = *p;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">&#x27;(&#x27;</span> &amp;&amp; *(p + <span class="number">1</span>) == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">*q++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">DeviceName = Path;</span><br><span class="line">......</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这个函数有三个参数Path是文件名的Arc路径，如multi(0)disk(0)rdisk(0)partition(1)Freeldr.sys就表示C盘中的Freeldr.sys文件。<br>OpenMode是打开模式(OpenReadOnly、OpenReadWrite等)。<br>如果打开成功，文件句柄将通过FileId参数返回。<br>首先这一部分代码分理出Arc磁盘路径中的”()”替换成”(0)”并存入DeviceName中，如multi()disk()rdisk()partition(1)Freeldr.sys处理后，DeviceName将指向multi(0)disk(0)rdisk(0)partition(1)。注意这个DeviceName是不以NULL结尾的。。。这是个很蛋疼的设计。<br>FileName会指向Arc路径中的文件名部分，上面的例子将是Freeldr.sys。<br>文件打开分为两步，第一步是开个文件所在的设备、创建设备的句柄。第二部才是打开文件本身。<br>这里是第一步打开设备的代码。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">pEntry = DeviceListHead.Flink;</span><br><span class="line"><span class="keyword">while</span> (pEntry != &amp;DeviceListHead)</span><br><span class="line">&#123;</span><br><span class="line">pDevice = <span class="built_in">CONTAINING_RECORD</span>(pEntry, DEVICE, ListEntry);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(pDevice-&gt;Prefix, DeviceName, dwLength) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* OK, device found. It is already opened? */</span></span><br><span class="line"><span class="keyword">if</span> (pDevice-&gt;ReferenceCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Search some room for the device */</span></span><br><span class="line"><span class="keyword">for</span> (DeviceId = <span class="number">0</span>; DeviceId &lt; MAX_FDS; DeviceId++)</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FuncTable)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (DeviceId == MAX_FDS)</span><br><span class="line"><span class="keyword">return</span> EMFILE;</span><br><span class="line"><span class="comment">/* Try to open the device */</span></span><br><span class="line">FileData[DeviceId].FuncTable = pDevice-&gt;FuncTable;</span><br><span class="line">ret = pDevice-&gt;FuncTable-&gt;<span class="built_in">Open</span>(pDevice-&gt;Prefix, DeviceOpenMode, &amp;DeviceId);</span><br><span class="line"><span class="keyword">if</span> (ret != ESUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!*FileName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Done, caller wanted to open the raw device */</span></span><br><span class="line">*FileId = DeviceId;</span><br><span class="line">pDevice-&gt;ReferenceCount++;</span><br><span class="line"><span class="keyword">return</span> ESUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Try to detect the file system */</span></span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">FatMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">NtfsMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">Ext2Mount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Error, unable to detect file system */</span></span><br><span class="line">pDevice-&gt;FuncTable-&gt;<span class="built_in">Close</span>(DeviceId);</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">pDevice-&gt;DeviceId = DeviceId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">DeviceId = pDevice-&gt;DeviceId;</span><br><span class="line">&#125;</span><br><span class="line">pDevice-&gt;ReferenceCount++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pEntry = pEntry-&gt;Flink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pEntry == &amp;DeviceListHead)</span><br><span class="line"><span class="keyword">return</span> ENODEV;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>一个循环，遍历DEVICE链表，找到DEVICE-&gt;Prefix (磁盘、分区的Arc路径，上一节说过)和刚刚分解出来的DeviceName相等的节点。如果没有则函数直接失败。<br>找到DEVICE节点后判断DEVICE-&gt;ReferenceCount是否为0。这个代表该DEVICE被打开的次数，如果ReferenceCount不为0，说明DEVICE已经被打开。那个直接从Device-&gt;DeviceId中获得设备的文件句柄。可以看出无论打开一个设备多少次，只会有ReferenceCount的变化，而句柄都是相同的。所以如果设备打开两次，SEEK时会相互影响。读写之前最好重新调用SEEK函数。<br>当DEVICE-&gt;ReferenceCount为0时是Freeldr需要调用进行打开和文件系统的识别。我们仔细读读。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Search some room for the device */</span></span><br><span class="line"><span class="keyword">for</span> (DeviceId = <span class="number">0</span>; DeviceId &lt; MAX_FDS; DeviceId++)</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FuncTable)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (DeviceId == MAX_FDS)</span><br><span class="line"><span class="keyword">return</span> EMFILE;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>首先在FileData数组中找到空闲项，数组的索引即将成为设备句柄。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Try to open the device */</span></span><br><span class="line">FileData[DeviceId].FuncTable = pDevice-&gt;FuncTable;</span><br><span class="line">ret = pDevice-&gt;FuncTable-&gt;<span class="built_in">Open</span>(pDevice-&gt;Prefix, DeviceOpenMode, &amp;DeviceId);</span><br><span class="line"><span class="keyword">if</span> (ret != ESUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!*FileName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Done, caller wanted to open the raw device */</span></span><br><span class="line">*FileId = DeviceId;</span><br><span class="line">pDevice-&gt;ReferenceCount++;</span><br><span class="line"><span class="keyword">return</span> ESUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>之后把DEVICE中存储的设别操作函数数组FuncTable赋值给对应FileData中的FuncTable。之后对该句柄的读写操作将直接传递给FileData.FuncTable中的函数。<br>调用FuncTable-&gt;Open打开设备。上面我们看过这个函数实际是freeldr\freeldr\arch\i386\hardware.c中的DiskOpen。<br>打开成功后，如果FileName（需要打开的文件名）为空，说明这次请求只打开设备，于是直接返回设备的句柄。<br>如果不为空，则下面开始识别分区格式，打开文件的操作。<br>在继续读ArcOpen函数前我们先看看DiskOpen在打开设备时都做了什么。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ArcOpen -&gt; <span class="built_in">DiskOpen</span> (freeldr\freeldr\arch\i386\hardware.c)</span><br><span class="line"><span class="function"><span class="type">static</span> LONG <span class="title">DiskOpen</span><span class="params">(CHAR* Path, OPENMODE OpenMode, ULONG* FileId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DissectArcPath</span>(Path, FileName, &amp;DriveNumber, &amp;DrivePartition))</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line"><span class="keyword">if</span> (DrivePartition == <span class="number">0xff</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* This is a CD-ROM device */</span></span><br><span class="line">SectorSize = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SectorSize = <span class="number">512</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DrivePartition != <span class="number">0xff</span> &amp;&amp; DrivePartition != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DiskGetPartitionEntry</span>(DriveNumber, DrivePartition, &amp;PartitionTableEntry))</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line">SectorOffset = PartitionTableEntry.SectorCountBeforePartition;</span><br><span class="line">SectorCount = PartitionTableEntry.PartitionSectorCount;</span><br><span class="line">&#125;</span><br><span class="line">Context = <span class="built_in">MmHeapAlloc</span>(<span class="built_in">sizeof</span>(DISKCONTEXT));</span><br><span class="line"><span class="keyword">if</span> (!Context)</span><br><span class="line"><span class="keyword">return</span> ENOMEM;</span><br><span class="line">Context-&gt;DriveNumber = DriveNumber;</span><br><span class="line">Context-&gt;SectorSize = SectorSize;</span><br><span class="line">Context-&gt;SectorOffset = SectorOffset;</span><br><span class="line">Context-&gt;SectorCount = SectorCount;</span><br><span class="line">Context-&gt;SectorNumber = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">FsSetDeviceSpecific</span>(*FileId, Context);</span><br><span class="line"><span class="keyword">return</span> ESUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这个函数非常简单，使用DissectArcPath根据设备的Arc路径分解出文件名FileName、BIOS驱动器号DriveNumber、和分区号DrivePartition（第0个分区的编号是1，0代表整个硬盘）<br>之后确定扇区大小，分区开始的扇区号、分区扇区数等信息，存入DISKCONTEXT结构。使用FsSetDeviceSpecific和FildId相关联。<br>还记得FILEDATA的结构么？FsSetDeviceSpecific就是填充里面的Specific指针 ：）  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FsSetDeviceSpecific</span><span class="params">(ULONG FileId, VOID* Specific)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (FileId &gt;= MAX_FDS || !FileData[FileId].FuncTable)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">FileData[FileId].Specific = Specific;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>实际上DiskOpen的作用就是获得该设备（分区）的基本信息——BIOS驱动器号、扇区大小、开始扇区号、扇区数量和当前读写指针（SectorNumber）。生成DISKCONTENT结构使用FsSetDeviceSpecific和FileID绑定。<br>现在我们回到ArcOpen函数，希望你还记得 ：）  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Try to detect the file system */</span></span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">FatMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">NtfsMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">Ext2Mount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Error, unable to detect file system */</span></span><br><span class="line">pDevice-&gt;FuncTable-&gt;<span class="built_in">Close</span>(DeviceId);</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">pDevice-&gt;DeviceId = DeviceId;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>现在FileData[DeviceId]已经代表刚刚打开的设备了，开始挂载分区。啥叫挂载分区，就是让文件系统提供个接口，能让我们操作分区里面的文件。而这个接口就是个DEVVTBL指针，和直接操作硬盘的接口一样，只不过这次这个可以操作文件了。如果分区识别成功，XxxMount函数将会返回另外一个DEVVTBL指针数组，这个指针赋值给设备对象的FileFuncTable成员。使用这个指针数组就可以在文件级别操作了。比如打开freeldr.sys文件就可以调用FileData[DeviceId].FileFuncTable-&gt;open函数。FileFuncTable和FuncTable是不同的哦！ ：）<br>注意FileFuncTable其实是不直接使用的，这个指针的作用是为之后打开的文件对应的FileData.FileTable赋值。于是操作文件和操作磁盘都是用对应的FileData.FileTable，实现形式上的统一。而且这种架构还可以轻易的实现将一个文件虚拟成为一个分区，只要为文件对象调用XxxMount并且给FileFuncTable域赋值就可以了，非常易于扩展。Freeldr并没有实现这种功能，文件的FileData.FileFuncTable没有使用～<br>下面我们就来看看第二步，打开文件<br>首先为文件找一个空闲的FileData  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FDS; i++)</span><br><span class="line"><span class="keyword">if</span> (!FileData[i].FuncTable)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i == MAX_FDS)</span><br><span class="line"><span class="keyword">return</span> EMFILE;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>跳过文件名开始的 “&quot; 字符  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*FileName == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">FileName++;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>我们前面说的，为FileData.FuncTable赋值。FileData.DeviceId是文件所在分区的句柄。FuncTable内部函数将通过这个句柄调用读写分区内容，为用户提供文件的读写接口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FileData[i].FuncTable = FileData[DeviceId].FileFuncTable;</span><br><span class="line">FileData[i].DeviceId = DeviceId;</span><br><span class="line">*FileId = i;</span><br><span class="line">ret = FileData[i].FuncTable-&gt;<span class="built_in">Open</span>(FileName, OpenMode, FileId);</span><br><span class="line"><span class="keyword">if</span> (ret != ESUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">FileData[i].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line">*FileId = MAX_FDS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>至此打开文件的操作结束。这里略去了XxxMount和文件的Open函数。以后再说。 ：）  </p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086/" data-id="cl4babr5x0005m8uehmj48fd8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-e585b3e4ba8ee69687e4bbb6shareaccess" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/">关于文件ShareAccess</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/" class="article-date"><time datetime="2011-05-22T10:26:22.000Z" itemprop="datePublished">2011-05-22</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/NTInternals/">NTInternals</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>我是真心太懒了，虽然平时也在研究一些东西，但是总是理解了就算了，没有把他们记录下来的想法。虽然不记录下来也不至于会忘记，但是人的记忆总是有限的我也不敢保证记忆完全不错。好不容易说服自己写点东西，就从今天看的那点东西写起吧。</p>
<p>（吐槽：我尽量把以后的文章写得详细以至于啰嗦，免得以后自己又看不懂了。）</p>
<p>什么是ShareAccess。我们做一个简单的实验，进入系统目录(一般就是C:\Windows)。在C:\Windows\system32\config中，复制一个SYSTEM文件，然后把文件粘贴到另一个地方。如果我们的系统正常，那么我们看到肯定是一个错误框。（图1）“无法复制 system: 文件正在被另一个人或程序使用。关闭任何可能使用这个文件的程序，重新试一次。”无论懂不懂编程，这样一个令人蛋疼的错误框应该会看过无数次吧。这里我就不解释Windows为什么要这么做，假设所有读者都是了解其中的原因了。这篇文章想介绍的是，Windows怎么做到“访问拒绝”的。简单的来说就是当一个进程打开该文件的时候ShareAccess中没有ShareRead属性，所以其他的进程无法访问他。</p>
<p><a href="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-51-31.png"><img src="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-51-31-300x225.png"></a></p>
<p>（图1）</p>
<p>在我们平时打开文件中（CreateFile）总是需要我们传入一个dwShareMode的参数。它有三个值分别是FILE_SHARE_DELETE，FILE_SHARE_READ，FILE_SHARE_WRITE。如果一个打开一个文件的时候，没有传入了FILE_SHARE_READ，那么如果有另一段代码对文件用FILE_READ_DATA权限打开的时候一定返回的是一个失败。其他两个SHARE也是一样。那么是不是设置了FILE_SHARE_READ，其他代码用FILE_READ_DATA权限打开该文件都会成功呢？答案是不一定，主要要看在这段代码CreateFile的dwShareMode。如果也设置的FILE_SHARE_READ，那么打开文件就会成功，否则返回一个SHARE错误。</p>
<p>（吐槽：上面说了一堆，还是没进入正题，貌似有点太详细了。接下来才是重头戏。）</p>
<p>来看看NTFS文件系统是怎么来Check权限的。<br>每个文件打开的时候系统会为文件分配一个FILE_OBJECT（文件对象）。在这里我们主要关注的是以下几个域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nt!_FILE_OBJECT</span><br><span class="line">...</span><br><span class="line">+0x00c FsContext        : Ptr32 Void</span><br><span class="line">...</span><br><span class="line">+0x026 ReadAccess       : UChar</span><br><span class="line">+0x027 WriteAccess      : UChar</span><br><span class="line">+0x028 DeleteAccess     : UChar</span><br><span class="line">+0x029 SharedRead       : UChar</span><br><span class="line">+0x02a SharedWrite      : UChar</span><br><span class="line">+0x02b SharedDelete     : UChar</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>熟悉NTFS文件系统的同学都知道FsContext实际上是对应着一个SCB。SCB的数据结构是未公开的，所以只有逆向或者通过其他途径获得。而这篇文章只需要关注的是SCB的SHARE_ACCESS。SHARE_ACCESS在SCB的0x60的偏移处，这个和NT的SCB有些不同。SHARE_ACCESS的数据结构是这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SHARE_ACCESS</span> &#123;</span><br><span class="line">ULONG OpenCount;</span><br><span class="line">ULONG Readers;</span><br><span class="line">ULONG Writers;</span><br><span class="line">ULONG Deleters;</span><br><span class="line">ULONG SharedRead;</span><br><span class="line">ULONG SharedWrite;</span><br><span class="line">ULONG SharedDelete;</span><br><span class="line">&#125; SHARE_ACCESS, *PSHARE_ACCESS;</span><br></pre></td></tr></table></figure>
<p>这个就是这篇文章的关键。</p>
<p>当一个文件被打开的时候，系统会初始化这个数据结构。根据CreateFile的权限设置来填充这个结构。<br>比如DesiredAccess中设置了FILE_READ_DATA，那么Readers，OpenCount就会增加1，如果在此同时设置了ShareMode为FILE_SHARE_READ，那么SharedRead也会加1。同时FILE_OBJECT的ReadAccess和SharedRead会被设置为TRUE。那么在文件被关闭的时候，如果FILE_OBJECT的ReadAccess和SharedRead为TRUE，那么SHARE_ACCESS的Readers，OpenCount，SharedRead就会减1。</p>
<p>在进程准备去打开一个已经打开的文件时，文件系统会做一系列的检查，包括文件权限（比如如果是只读文件，你却想要写权限，这样就会失败），安全描述符，以及共享权限（ShareAccess）。假设前面两个都符合要求，那么就到了共享权限的检查了。</p>
<p>还是以刚才那个SYSTEM文件为例，他打开的权限是FILE_READ_DATA，FILE_WRITE_DATA，DELETE。那么SHARE_ACCESS的OpenCount，Readers，Writers，Deleters都为1，而完全没有Share的意图，所以其他的域都是0。</p>
<p>当有另外一段代码去试图用FILE_READ_DATA权限打开这个文件的时候，那么文件系统就会去检查第一个打开这个文件的操作共享权限。这时的OpenCount是1，SharedRead是0，他会发现SharedRead小于OpenCount，那么他认为这个文件并没有SHARE_READ，所以参数检查返回失败，你会得到一个共享错误。这就是为什么我们复制粘贴SYSTEM文件的时候会失败。</p>
<p>原因分析到这里就结束了。但是我就这样满足了么？显然我没那么容易满足滴~</p>
<p>我想做的就是复制出这个SYSTEM文件，实际上网上已经有很多做法，什么底层磁盘解析读取数据，句柄复制大法。而我这次是修改底层SCB的ShareAccess来达到复制的目的。如果读懂了上面的原理，看下面这段代码就很轻松了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kfile File;</span><br><span class="line">ns = File.<span class="built_in">Create</span>(FILENAME, FILE_OPEN, FILE_READ_ATTRIBUTES, <span class="number">0</span>);</span><br><span class="line">FileObj = File.<span class="built_in">GetObject</span>();</span><br><span class="line">ShareAccess = (SHARE_ACCESS *)((ULONG)FileObj-&gt;FsContext + Offset);</span><br><span class="line">ShareAccess-&gt;SharedRead = ShareAccess-&gt;Readers;</span><br><span class="line">File.<span class="built_in">Release</span>();</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>OK，编写好测试代码，生成一个驱动。运行即可。接下来就是见证奇迹的时刻了。还是用同样的方法复制看看，完全没有问题了。（图2）</p>
<p><a href="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-53-40.png"><img src="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-53-40-300x225.png"></a></p>
<p>（图2）</p>
<p>（吐槽：好久没写这么长的文章，写的我都崩溃了。说到写文章，我发现现在我如果拿起笔去写字，经常会发生提笔忘字的情况！！！天啊！！！）</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/" data-id="cl4babr610007m8ue21qshanv" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/File-System/" rel="tag">File System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTFS/" rel="tag">NTFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTInternals/" rel="tag">NTInternals</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-e8aea9e7a88be5ba8fe7ad89e5be85e8b083e8af95e599a8e99984e58aa0" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/04/01/e8aea9e7a88be5ba8fe7ad89e5be85e8b083e8af95e599a8e99984e58aa0/">让程序等待调试器附加</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/04/01/e8aea9e7a88be5ba8fe7ad89e5be85e8b083e8af95e599a8e99984e58aa0/" class="article-date"><time datetime="2011-04-01T08:05:21.000Z" itemprop="datePublished">2011-04-01</time></a>
</div>

    <div class="article-author">admin</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Debugging/">Debugging</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>有的时候出于一些目的，我们会希望程序等待调试器Attach上去以后才开始继续往前跑。例如，我们写了一堆console程序，同时又有个shell去调用这些console，而这个时候我们却想去调试shell运行起来的这个console。当然Windbg本身就有调试debugee子进程的功能，但是身为懒人，这种方式太麻烦。我还是更愿意加入几行代码解决这个问题。</p>
<p>要解决这个问题，原理上很简单。无非是程序运行初期不断的去检测本进程是否被调试，如果是就把自己断下来，如果不是继续等待。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WaitDebuggerAttach</span><span class="params">(DWORD Second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD CurSec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((!<span class="built_in">IsDebuggerPresent</span>()) &amp;&amp; (CurSec &lt; Second)) &#123;</span><br><span class="line">        </span><br><span class="line">        CurSec++;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsDebuggerPresent</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        __asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>这个函数可以指定等待时间，如果Debugger Attach上去了，那么就断下来方便调试，否则会超时，正常执行。<br>这里我是用的IsDebuggerPresent这个API来获得进程的调试状态。实际上检测自己调试状态的方法很多，只不过这个用起来最方便而已。比如可以用测试断点异常的方法来检测自己的调试状态。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckForDebugger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __try </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugBreak</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    __except(<span class="built_in">GetExceptionCode</span>() == EXCEPTION_BREAKPOINT ? </span><br><span class="line">             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No debugger is attached, so return FALSE </span></span><br><span class="line">        <span class="comment">// and continue.</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>本Blog的第一篇文章总算是出炉了~~~我太懒了哇~</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/04/01/e8aea9e7a88be5ba8fe7ad89e5be85e8b083e8af95e599a8e99984e58aa0/" data-id="cl4babr5t0003m8uee59t460z" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/02/28/hello-world/">Hello world!</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2011/02/28/hello-world/" class="article-date"><time datetime="2011-02-27T23:51:00.000Z" itemprop="datePublished">2011-02-28</time></a>
</div>

    <div class="article-author">admin</div>
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>); </span><br></pre></td></tr></table></figure>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://0cch.com/2011/02/28/hello-world/" data-id="cl4babr5m0001m8uehsqahh4l" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/17/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/16/">16</a></li><li><a class="page-number" href="/page/17/">17</a></li><li class="active"><span class="page-number">18</span></li><li class="disabled"><span class="page-next">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>https://github.com/0cch</p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CPP/">CPP</a><span class="sidebar-module-list-count">30</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/">Debugging</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">5</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Debugging/Tips/">Tips</a><span class="sidebar-module-list-count">7</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/DeepLearner/">DeepLearner</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MiniKernel/">MiniKernel</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/">NTInternals</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/NTInternals/Tips/">Tips</a><span class="sidebar-module-list-count">4</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Tips/">Tips</a><span class="sidebar-module-list-count">70</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/debugging/">debugging</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/machinelearning/">machinelearning</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/File-System/" rel="tag">File System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/IDE/" rel="tag">IDE</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Kernel/" rel="tag">Kernel</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/MiniKernel/" rel="tag">MiniKernel</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTFS/" rel="tag">NTFS</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTInternals/" rel="tag">NTInternals</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/NTSTATUS/" rel="tag">NTSTATUS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/OS/" rel="tag">OS</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/PIO/" rel="tag">PIO</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/System/" rel="tag">System</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Test/" rel="tag">Test</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Volume/" rel="tag">Volume</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Windows/" rel="tag">Windows</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/grub/" rel="tag">grub</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/snapshot/" rel="tag">snapshot</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/File-System/" style="font-size: 10px;">File System</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Kernel/" style="font-size: 20px;">Kernel</a> <a href="/tags/MiniKernel/" style="font-size: 10px;">MiniKernel</a> <a href="/tags/NTFS/" style="font-size: 15px;">NTFS</a> <a href="/tags/NTInternals/" style="font-size: 10px;">NTInternals</a> <a href="/tags/NTSTATUS/" style="font-size: 10px;">NTSTATUS</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/PIO/" style="font-size: 10px;">PIO</a> <a href="/tags/System/" style="font-size: 10px;">System</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Volume/" style="font-size: 10px;">Volume</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/snapshot/" style="font-size: 10px;">snapshot</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/06/">June 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/05/">May 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/04/">April 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/03/">March 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/02/">February 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/01/">January 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/12/">December 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/11/">November 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/10/">October 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/09/">September 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/08/">August 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/06/">June 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/05/">May 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/04/">April 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/03/">March 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/02/">February 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/01/">January 2021</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/12/">December 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/11/">November 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/10/">October 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/09/">September 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/08/">August 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/07/">July 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">June 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/05/">May 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/04/">April 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/03/">March 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/01/">January 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/12/">December 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/11/">November 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/07/">July 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/06/">June 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/05/">May 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">April 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">March 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">February 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">January 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">December 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">November 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">October 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">September 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">August 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">March 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">February 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">January 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">December 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/11/">November 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">October 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/09/">September 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">August 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">July 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">June 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/05/">May 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">April 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/03/">March 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/01/">January 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/12/">December 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/11/">November 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">October 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">September 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/08/">August 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/07/">July 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/06/">June 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/05/">May 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/04/">April 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/03/">March 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/02/">February 2016</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/01/">January 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/12/">December 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/11/">November 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/10/">October 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/09/">September 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/08/">August 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/07/">July 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/06/">June 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/05/">May 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/04/">April 2015</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/03/">March 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/02/">February 2015</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/01/">January 2015</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/12/">December 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/11/">November 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/10/">October 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/09/">September 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/08/">August 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/07/">July 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/06/">June 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/05/">May 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/04/">April 2014</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/03/">March 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/02/">February 2014</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2014/01/">January 2014</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/12/">December 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/11/">November 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/10/">October 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/09/">September 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/08/">August 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/07/">July 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/06/">June 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/05/">May 2013</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/04/">April 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/03/">March 2013</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/02/">February 2013</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2013/01/">January 2013</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/12/">December 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/11/">November 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/08/">August 2012</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2012/02/">February 2012</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/12/">December 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/10/">October 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/09/">September 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/08/">August 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/06/">June 2011</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/05/">May 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/04/">April 2011</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2011/02/">February 2011</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2022/06/01/addition-to-rvo-and-copy-elimination/">返回值优化和拷贝消除的一点补充</a>
        </li>
      
        <li>
          <a href="/2022/05/02/use-async-with-caution/">谨慎使用std::async</a>
        </li>
      
        <li>
          <a href="/2022/04/12/pass-params/">值传参</a>
        </li>
      
        <li>
          <a href="/2022/03/08/oneapi-summary/">oneAPI 组件简介</a>
        </li>
      
        <li>
          <a href="/2022/02/12/k+2021/">2021K+软件峰会PPT</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 0CCh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
