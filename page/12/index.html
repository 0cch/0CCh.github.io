<!DOCTYPE html>
<html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <link rel="icon" href="/favicon.ico">
  
  <title>0CCh Blog</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox-1.3.4.css">
  <!--在这里倒入jquery 方便处理部分页面的jquery-->
  <script src="https://cdn.staticfile.org/jquery/1.7/jquery.min.js" type="text/javascript" ></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body class="home">
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="site-header navfixed-false">
  <div class="container">
      <h1><a href="/" title="0CCh Blog"><span class="octicon octicon-mark-github"></span> 0CCh Blog</a></h1>
      <nav class="site-header-nav" role="navigation">
        
              
              <a href="/"  class=" site-header-nav-item hvr-underline-from-center" title="Home">Home</a>
        
              
              <a href="/categories/"  class=" site-header-nav-item hvr-underline-from-center" title="Category">Category</a>
        
              
              <a href="/open-source/"  class=" site-header-nav-item hvr-underline-from-center" title="Open-Source">Open-Source</a>
        
      </nav>
  </div>
</header>

	<section class="banner-false">
    <div class="collection-head">
        <div class="container">
            <div class="collection-title">
                <h1 class="collection-header" id="site-description">
                    
                </h1>
                <div class="collection-info">
                    
                    
                        <span class="meta-info">
                            
                                <span class="octicon octicon-location">
                                   
                                        China
                                    
                                </span>
                                
                            
                        </span>
                    
                        <span class="meta-info">
                            
                                <span class="octicon octicon-mark-github">
                                   
                                </span>
                                
                                    <a href="http://github.com/0cch" target="_blank">0cch</a>
                                
                            
                        </span>
                    
                </div>
            </div>
        </div>
    </div>
</section>
	   <section class="container">
    <div class="columns">
        <div class="column two-thirds">
            
                  <article id="post-e68891e69cace69da5e4b88de683b3e58699kernelefbc8ce79bb4e588b0e68891e79a84e8869de79b96e4b8ade4ba86e4b880e7aead" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/12/11/e68891e69cace69da5e4b88de683b3e58699kernelefbc8ce79bb4e588b0e68891e79a84e8869de79b96e4b8ade4ba86e4b880e7aead/">我本来不想写kernel，直到我的膝盖中了一箭</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近中箭体很火，我也凑个热闹。话说自从delete那篇文章过后，又有一个多月没写了。其实不是不想写，是不知道些什么才好。简单的东西不想写，难的东西写不出来。</p>
<p>正像标题写的，恩，我开始写kernel玩了。其实写一个简单，功能单一的kernel并不难。麻烦的只是搭建环境等等。kernel的编写资料也很多，但是可惜的是，绝大部分都是应用在linux环境。我是那种看到linux就头晕的人。所以还是坚持用windows和vc来开发kernel。令人惊喜的是grub能够帮助我们map kernel到内存中，所以boot loader这一步可以想放下。等kernel写了个大概再来写boot loader也不迟。</p>
<p>环境和工具：<br>环境正如我上面提到了windows xp 和 vs 2008。其他工具包括winimage，virtual pc，bochsdbg（+ IDA）。当然还有grub4dos。</p>
<p>要高效的起步，先要了解mulitBoot的一些知识。还有就是写一套能够在text mode下打印信息的函数，例如printf。这样在不用调试的情况下，就能了解一些信息。说实在的bochsdbg的调试功能真心不好用，但是加上IDA可能是一个比较好的做法。具备以上条件后，就可以开始kernel之旅了。</p>
<p><a href="/uploads/2011/12/20111211174748.png"><img src="/uploads/2011/12/20111211174748.png" alt=""></a></p>
<p>可以看出内存的基本状况已经可以从boot_info中获取了。接下来要做的事情也很明了。就是需要一个物理内存管理器，实现最基本的物理内存管理器也不算难，不过那就是下篇文章的事情了。现在的kernel大小为7168字节，慢慢玩，看我能坚持多久。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-12-11T02:32:55.000Z" itemprop="datePublished">2011-12-11</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/MiniKernel/' title=''>MiniKernel</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/">Windows</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/grub/">grub</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-e4b8bae4bb80e4b988e5bf85e9a1bbe794a8deletee9878ae694bee695b0e7bb84" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/10/31/e4b8bae4bb80e4b988e5bf85e9a1bbe794a8deletee9878ae694bee695b0e7bb84/">为什么必须用delete[]释放数组</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近不知哪来的好奇心，对C++产生了一些兴趣，要知道我通常情况下都是cpp文件中写c代码，c代码中嵌汇编。不过，在做了一些大点的项目之后，确确实实发现了，这种编码方式麻烦的一面。有时候甚至自己都难得维护以前写的东西。所以选择性看了google的c++编程规范，而且对scoped_ptr和auto_ptr的区别参数兴趣。然后我得出的结论是这两种实际上是其实差不多，只不过scoped_ptr拷贝构造函数和赋值构造函数都是私有的。这样就避免粗心大意的程序员调用他。其他的区别还真没看出来。</p>
<p>OK，这些都不是记录这篇tip的重点。重点在于boost，或者说是google的scoped_ptr代码里面实现了scoped_array。而要用在数组上使用智能指针，就必须用数组的智能指针类。而auto_ptr刚好没有数组部分，所以对于数组，就不能用auto_ptr了。（为什么不用vector？这也不是重点）</p>
<p>作为一个蹩脚的C++程序员，我这时候开始犯晕了。我们知道只能指针都是帮助程序员去释放资源，让程序员把精力放到更重要的地方。那么在我看来那么所需要做的就是析构的时候 delete 或者 delete[] 就行了。要知道，delete[] 就是调用的delete，他们只是单纯的释放内存。那么数组和非数组又有什么区别？</p>
<p>光想肯定不行，写两个例子。</p>
<p>首先是new 一个char数组，分别用delete和delete[]释放。结果表明，没有任何问题，而且不会产生内存泄露。坑爹么？NO，还没完，其实咱们最怀疑的一直都是数组对象，因为他们都有构造和析构函数。而char这样的系统内建类型，想象得出不会出什么问题。new一个对象数组，分别用delete和delete[] 释放。果然问题暴露了，delete的时候出了问题。</p>
<p>知其然，不足以满足好奇心。下面才是拿手的，精彩的要放在后面嘛。</p>
<p>先看测试代码</p>
<pre><code>#include

using namespace std;

class A {

public:
A() {cout &lt;&lt; &quot;start 1&quot; &lt;&lt; endl;}
~A() {cout &lt;&lt; &quot;End 1&quot; &lt;&lt; endl;}
};

int main()
{
A *a = new A[10]();

delete[] a;
return 0;
}
 </code></pre>
<p>编译后看到代码如下<br><pre><code>0040103D push 0Eh
0040103F call operator new[] (403ED0h)</code></pre><br>注意到这里传入的大小时0Eh，也就是说申请分配14个字节大小的内存。但是我们知道C++标准中空类的大小应该是1字节。那么多出的dword我们就很容易想到他的用处，应该是记录数组大小的。事实也确实如此。</p>
<pre><code>mov dword ptr [eax],0Ah</code></pre>  
<p>这里明确交代，给分配内存的第一个dword传入10。</p>
<pre><code>00401069 push offset A::~A (4011D0h)
0040106E push offset A::A (401120h)
00401073 push 0Ah
00401075 push 1
00401077 mov ecx,dword ptr [ebp-0F8h]
0040107D add ecx,4
00401080 push ecx
00401081 call `eh vector constructor iterator&#39; (40A010h)</code></pre>  
<p>这里是调用构造函数，注意是vector版本的构造函数。参数分别是数组的this指针，sizeof(A)，数组数量，构造和析构函数。这样，在这个函数内部循环10次调用构造函数，构造完毕。</p>
<pre><code>004010BD mov eax,dword ptr [ebp-14h]
004010C0 mov dword ptr [ebp-0E0h],eax
004010C6 mov ecx,dword ptr [ebp-0E0h]
004010CC mov dword ptr [ebp-0ECh],ecx
004010D2 cmp dword ptr [ebp-0ECh],0
004010D9 je main+0F0h (4010F0h)
004010DB push 3
004010DD mov ecx,dword ptr [ebp-0ECh]
004010E3 call A::`vector deleting destructor&#39; (401230h)</code></pre>  
<p>这里是析构部分传入数组的this指针，传入flag(3)，调用析构函数。</p>
<p>继续看call之后的代码<br><pre><code>00401253 mov eax,dword ptr [ebp+8]
00401256 and eax,2
00401259 je A::`vector deleting destructor&#39;+61h (401291h)
0040125B push offset A::~A (4011D0h)
00401260 mov eax,dword ptr [this]
00401263 mov ecx,dword ptr [eax-4]
00401266 push ecx
00401267 push 1
00401269 mov edx,dword ptr [this]
0040126C push edx
0040126D call `eh vector destructor iterator&#39; (40A920h)
00401272 mov eax,dword ptr [ebp+8]</code></pre><br>如果flag中位1是set，那么调用eh_vector_destructor_iterator调用每个析构函数。参数分别是this，sizeof(A)，数组个数（这里很明显是从eax-4中拿出来的）以及析构函数地址。</p>
<p>OK，明白了delete[]的做法，我们看看delete为什么失败。<br><pre><code>004010BD mov eax,dword ptr [ebp-14h]
004010C0 mov dword ptr [ebp-0E0h],eax
004010C6 mov ecx,dword ptr [ebp-0E0h]
004010CC mov dword ptr [ebp-0ECh],ecx
004010D2 cmp dword ptr [ebp-0ECh],0
004010D9 je main+0F0h (4010F0h)
004010DB push 1
004010DD mov ecx,dword ptr [ebp-0ECh]
004010E3 call A::`scalar deleting destructor&#39; (4012D0h)</code></pre><br>这里调用的析构函数都不一样是一个scalar版本的函数。</p>
<p>继续看这个函数的关键部分<br><pre><code>004012F3 mov ecx,dword ptr [this]
004012F6 call A::~A (4011D0h)
004012FB mov eax,dword ptr [ebp+8]
004012FE and eax,1
00401301 je A::`scalar deleting destructor&#39;+3Fh (40130Fh)
00401303 mov eax,dword ptr [this]
00401306 push eax
00401307 call operator delete (40A890h)</code></pre><br>这里很清楚的看到，只进行一次析构，然后就释放内存。所以我们看到的现象是只调用一次析构函数。那么为什么会崩溃呢？因为delete错了地址。看上面的对比的值，eax-4才是new返回的地址，所以delete的不应该是eax，而是eax-4。</p>
<p>真相大白？NO，还有一个问题，delete[] 和delete 内建类型真的成功了么？<br>看看我贴出的代码吧，这里不解释了。</p>
<pre><code>;delete[] version
0040101E push 0Ah
00401020 call operator new[] (4014C0h)
00401025 add esp,4
00401028 mov dword ptr [ebp-0E0h],eax
0040102E mov eax,dword ptr [ebp-0E0h]
00401034 mov dword ptr [a],eax
00401037 mov eax,dword ptr [a]
0040103A mov dword ptr [ebp-0D4h],eax
00401040 mov ecx,dword ptr [ebp-0D4h]
00401046 push ecx
00401047 call operator delete[] (401600h) `

;delete version
0040101E push 0Ah
00401020 call operator new[] (4014C0h)
00401025 add esp,4
00401028 mov dword ptr [ebp-0E0h],eax
0040102E mov eax,dword ptr [ebp-0E0h]
00401034 mov dword ptr [a],eax
00401037 mov eax,dword ptr [a]
0040103A mov dword ptr [ebp-0D4h],eax
00401040 mov ecx,dword ptr [ebp-0D4h]
00401046 push ecx
00401047 call operator delete (401600h)</code></pre>
<p>就像我刚刚所说的delete[]会调用delete。所以不会出任何问题。</p>
<p>如果汇编看的头疼的话，这里我写了两个函数的逆向代码（说了精彩的应该放在后面的）：</p>
<pre><code>void A::&#39;scalar deleting destructor&#39;(unsigned int flags)
{
	this-&gt;~A();
	if (flags &amp; 1) {
	A::operator delete(this);
}

void A::&#39;vector deleting destructor&#39;(unsigned int flags)
{
	if (flags &amp; 2) {
		count = *(int *)((int)this - 4);
		&#39;eh vector destructor iterator&#39;(this, sizeof(A), count, A::~A);
		if (flags&amp;1) {
			A::operator delete((void *)((int)this - 4));
		}
	}
	else {
		this-&gt;~A();
		if (flags &amp; 1) {
			A::operator delete(this);
		}
	}
};
 </code></pre>
<p>分析到这，终于明白。数组一定要用delete[]释放才安全。所以千万不要用auto_ptr作为数组的智能指针，不然会死的很惨。这里还要提一点，auto_ptr也不要用到容器里面去了，也是不允许的。非要这么做就用shared_ptr吧， C++0x已经在stl中加入的这部分。从vs2008 sp1开始支持。低版本的vs的话就去boost里面找吧。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-10-31T08:54:55.000Z" itemprop="datePublished">2011-10-31</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Tips/' title=''>Tips</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-volume-snapshot" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/10/30/volume-snapshot/">Volume snapshot</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上个月说了，准备放一份基于卷磁盘快照代码。拖到现在也没有更新了，就把它放出来，留着也没啥用。本来就是为了做一个演示demo，没考虑效率和稳定性，只是提供一种思路，其实思路也很简单，有人已经把他完善的很好了。感觉博客更新确实慢，但是也没什么想写的，其实也写不出来什么。悲剧啊！</p>
<p>和我其他代码一样，这么代码同样没有注释。需要的讲究读读吧。那啥，最近昨天把google的代码规范看了看，确实有很多值得学习的地方。不过呢，有些地方可能个性使然，不太认同。不过风格的问题，其实也没什么。</p>
<p>最近还写了hive文件读解析的代码，还没完善，然后又转去看系统缓存那部分的东西了。有时间完善完善。还要完善了是自己写的一个ini文件解析的类。哎，都是一些自己造轮子的活。不过还挺有意思。</p>
<p>下载：<a href="/uploads/2011/10/SectorMon.zip">SectorMon</a></p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-10-30T01:03:12.000Z" itemprop="datePublished">2011-10-30</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/NTInternals/' title=''>NTInternals</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volume/">Volume</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/snapshot/">snapshot</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-ntstatus-lookup" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/09/17/ntstatus-lookup/">NTSTATUS Lookup</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>磁盘快照写好了后，闲着无聊写了个nslookup，用来看驱动返回值解释的。写这个程序还先写了个nsstatus.h的解析工具。生成了一个超大的switch case。没啥技术含量。至于那个磁盘快照的代码，过段时间如果合适也可以共享出来。</p>
<p><a href="/uploads/2011/09/ntstatus.jpg"><img src="/uploads/2011/09/ntstatus.jpg" alt=""></a></p>
<p>1.0.0.2 更新：</p>
<p>1.增加程序初始化时，直接读取剪切板中的数据功能。<br>2.增加对输入的判断，支持“0x”前缀。</p>
<p>下载：<a href="/uploads/2011/09/nslookup1002.zip">nslookup</a></p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-09-17T06:39:26.000Z" itemprop="datePublished">2011-09-17</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Debugging/' title=''>Debugging</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTSTATUS/">NTSTATUS</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/08/28/e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081/">一份简陋的NTFS Parse代码</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>研究了近两周的NTFS文件格式，初步了解了一些NTFS基本属性的解析方法。<br>为了自己研究方便，写了点简单的解析代码。发出来以方便需要的人。<br>话说这份代码的解析类只是属于demo阶段，而且没有注释。不过代码写的还算清晰。  </p>
<p>参考资料方面，我是转了一份NTFS 3G的文档，这份文档把NTFS的基本特点写的比较清晰了。值得一看</p>
<p><a href="http://0cch.net/ntfsdoc/" target="_blank" rel="external">http://0cch.net/ntfsdoc/</a></p>
<p>代码：<a href="/uploads/2011/08/NtfsParse.zip">NtfsParse</a></p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-08-28T01:20:09.000Z" itemprop="datePublished">2011-08-28</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/NTInternals/' title=''>NTInternals</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTFS/">NTFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/">Windows</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/06/10/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862/">ReactOS-Freeldr磁盘及文件管理2</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ArcOpen的大体流程我们看过了。大致分为这几步</p>
<ol>
<li>函数会尝试找到文件所在分区的设备句柄，如果还没有对应的句柄。那么使用DEVICE.FuncTable中的Open函数打开设备，并为这个设备分配句柄。</li>
</ol>
<ol>
<li>打开设备后条用XxxMount识别分区格式，识别成功返回另外的FuncTable，存储到设备的FileData.FileFuncTable域。</li>
</ol>
<ol>
<li>为文件分配一个句柄，在对应的FileData.DeviceId为上面创建设备句柄，FileData.FuncTable为设备的FileData.FileFuncTable。</li>
</ol>
<ol>
<li>最后调用文件的FileData.FuncTable.Open函数打开文件。</li>
</ol>
<p><strong>挂载分区时做了什么</strong></p>
<p>之前我们忽略了XxxMount函数。现在来读读比较简单的FatMount (freeldr\freeldr\fs\fat.c)。</p>
<ol>
<li><p><em>const</em> DEVVTBL<strong>*</strong> FatMount<strong>(</strong>ULONG DeviceId<strong>)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p><strong>.**</strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.**</p>
</li>
<li><p>// 生成一个FAT_VOLUME_INFO结构</p>
</li>
<li><p>Volume <strong>=</strong> MmHeapAlloc<strong>(</strong><em>sizeof</em><strong>(</strong>FAT_VOLUME_INFO<strong>)**</strong>)<strong>**;</strong></p>
</li>
<li><p><em>if</em> <strong>(**</strong>!<strong>Volume</strong>)**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><em>RtlZeroMemory</em><strong>(</strong>Volume, <em>sizeof</em><strong>(</strong>FAT_VOLUME_INFO<strong>)**</strong>)<strong>**;</strong></p>
</li>
<li><p>// 读第一个扇区</p>
</li>
<li><p>Position<strong>.</strong>HighPart <strong>=</strong> 0<strong>;</strong></p>
</li>
<li><p>Position<strong>.</strong>LowPart <strong>=</strong> 0<strong>;</strong></p>
</li>
<li><p>ret <strong>=</strong> ArcSeek<strong>(</strong>DeviceId, <strong>&amp;</strong>Position, SeekAbsolute<strong>)**</strong>;**</p>
</li>
<li><p><em>if</em> <strong>(</strong>ret <strong>!**</strong>=<strong> ESUCCESS</strong>)**</p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree<strong>(</strong>Volume<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>ret <strong>=</strong> ArcRead<strong>(</strong>DeviceId, Buffer, <em>sizeof</em><strong>(</strong>Buffer<strong>)</strong>, <strong>&amp;</strong>Count<strong>)**</strong>;**</p>
</li>
<li><p><em>if</em> <strong>(</strong>ret <strong>!**</strong>=<strong> ESUCCESS </strong>|<strong>**|</strong> Count <strong>!**</strong>=<strong> <em>sizeof</em></strong>(<strong>Buffer</strong>)<strong>**)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree<strong>(</strong>Volume<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>// 判断是否有fat分区标志</p>
</li>
<li><p><em>if</em> <strong>(**</strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector</strong>-<strong>**&gt;</strong>FileSystemType, “FAT12 “, 8<strong>)</strong> <strong>&amp;**</strong>&amp;**</p>
</li>
<li><p><strong>!</strong>RtlEqualMemory<strong>(</strong>BootSector<strong>-**</strong>&gt;<strong>FileSystemType, “FAT16 “, 8</strong>)<strong> </strong>&amp;<strong>**&amp;</strong></p>
</li>
<li><p><strong>!</strong>RtlEqualMemory<strong>(</strong>BootSector32<strong>-**</strong>&gt;<strong>FileSystemType, “FAT32 “, 8</strong>)<strong> </strong>&amp;<strong>**&amp;</strong></p>
</li>
<li><p><strong>!</strong>RtlEqualMemory<strong>(</strong>BootSectorX<strong>-**</strong>&gt;<strong>FileSystemType, “FATX”, 4</strong>)<strong>**)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree<strong>(</strong>Volume<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>// 获得分区大小等信息</p>
</li>
<li><p>ret <strong>=</strong> ArcGetFileInformation<strong>(</strong>DeviceId, <strong>&amp;</strong>FileInformation<strong>)**</strong>;**</p>
</li>
<li><p><em>if</em> <strong>(</strong>ret <strong>!**</strong>=<strong> ESUCCESS</strong>)**</p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree<strong>(</strong>Volume<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>SectorCount<strong>.</strong>HighPart <strong>=</strong> FileInformation<strong>.</strong>EndingAddress<strong>.</strong>HighPart<strong>;</strong></p>
</li>
<li><p>SectorCount<strong>.</strong>LowPart <strong>=</strong> FileInformation<strong>.</strong>EndingAddress<strong>.</strong>LowPart<strong>;</strong></p>
</li>
<li><p>SectorCount<strong>.</strong>QuadPart <strong>/**</strong>=<strong> SECTOR_SIZE</strong>;**</p>
</li>
<li><p>Volume<strong>-**</strong>&gt;<strong>DeviceId </strong>=<strong> DeviceId</strong>;**</p>
</li>
<li><p>// 打开分区</p>
</li>
<li><p><em>if</em> <strong>(**</strong>!<strong>FatOpenVolume</strong>(<strong>Volume, BootSector, SectorCount</strong>.<strong>QuadPart</strong>)<strong>**)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>MmHeapFree<strong>(</strong>Volume<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> <em>NULL</em><strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p>// 存储FAT_VOLUME_INFO结构</p>
</li>
<li><p>FatVolumes<strong>[</strong>DeviceId<strong>]</strong> <strong>=</strong> Volume<strong>;</strong></p>
</li>
<li><p>// 返回fat文件读写的FuncTable</p>
</li>
<li><p><em>return</em> <strong>&amp;</strong>FatFuncTable<strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
<li><p><strong>           
</strong></p>
</li>
</ol>
<p>函数中的DeviceId是设备的句柄。</p>
<p>生成FAT_VOLUME_INFO结构。这个结构里面存储了FAT分区的基本信息。包括扇区大小，每个簇的扇区数等等。</p>
<ol>
<li><p><em>typedef</em> <em>struct</em> _FAT_VOLUME_INFO </p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>ULONG BytesPerSector<strong>;</strong> /<em> Number of bytes per sector </em>/</p>
</li>
<li><p>ULONG SectorsPerCluster<strong>;</strong> /<em> Number of sectors per cluster </em>/</p>
</li>
<li><p>ULONG FatSectorStart<strong>;</strong> /<em> Starting sector of 1st FAT table </em>/</p>
</li>
<li><p>ULONG ActiveFatSectorStart<strong>;</strong> /<em> Starting sector of active FAT table </em>/</p>
</li>
<li><p>ULONG NumberOfFats<strong>;</strong> /<em> Number of FAT tables </em>/</p>
</li>
<li><p>ULONG SectorsPerFat<strong>;</strong> /<em> Sectors per FAT table </em>/</p>
</li>
<li><p>ULONG RootDirSectorStart<strong>;</strong> /<em> Starting sector of the root directory (non-fat32) </em>/</p>
</li>
<li><p>ULONG RootDirSectors<strong>;</strong> /<em> Number of sectors of the root directory (non-fat32) </em>/</p>
</li>
<li><p>ULONG RootDirStartCluster<strong>;</strong> /<em> Starting cluster number of the root directory (fat32 only) </em>/</p>
</li>
<li><p>ULONG DataSectorStart<strong>;</strong> /<em> Starting sector of the data area </em>/</p>
</li>
<li><p>ULONG FatType<strong>;</strong> /<em> FAT12, FAT16, FAT32, FATX16 or FATX32 </em>/</p>
</li>
<li><p>ULONG DeviceId<strong>;</strong></p>
</li>
<li><p><strong>}</strong> FAT_VOLUME_INFO<strong>;</strong></p>
</li>
<li><p><strong>             
</strong></p>
</li>
</ol>
<p>  读取第一个山区，判断是否有fat标志。如果没有直接返回，挂载失败。之后使用ArcGetFileInformation获得分区大小。ArcGetFileInformation里面调用了FileData.FuncTable.GetFileInformation。因为当前DeviceId是设备句柄，所以他实际调用的是DiskGetFileInformation(freeldr\freeldr\arch\i386\hardware.c)。这个函数很简单，通过FileInformation返回分区开始和结束的地址，这里就不列出了。     </p>
<p>这里的代码用FileInformation<strong>.</strong>EndingAddress / SECTOR_SIZE计算出了该分区的扇区数SectorCount。这里应该BUG。因为EndingAddress是分区结束地址，真的扇区数应该是 (分区开始地址 - EndingAddress ) / SECTOR_SIZE。好在SectorCount只是判断fat分区的一个依据，而且一般C盘计算出的SectorCount误差不会很大，影响不大。</p>
<p>最后执行FatOpenVolume真正执行分区的挂载、初始化。初始化结束后将生成的Volume放到fat.c维护的全局数组FatVolumes里，之后对fat分区进行操作（读写）时，通过设备的DeviceId就可以找到对应的FAT_VOLUME_INFO结构。</p>
<p>最后函数返回FatFuncTable函数数组</p>
<ol>
<li><p><em>const</em> DEVVTBL FatFuncTable <strong>=</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p>FatClose, </p>
</li>
<li><p>FatGetFileInformation, </p>
</li>
<li><p>FatOpen, </p>
</li>
<li><p>FatRead, </p>
</li>
<li><p>FatSeek, </p>
</li>
<li><p>L”fastfat”, </p>
</li>
<li><p><strong>}**</strong>;**</p>
</li>
<li></li>
</ol>
<p>用户可以通过这些函数就读写改fat分区啦。</p>
<p>那么FatOpenVolume都干了什么呢。</p>
<p>这个函数简单来说就是根据分区内容填写了Volume结构，已经算是一个分区的具体实现细节了，和整体架构无关，不多说了。这个函数在freeldr\freeldr\fs\fat.c中。</p>
<p><strong><strong>打开文件时做了什么</strong></strong></p>
<p>上一篇文章中还有一个地方没说，就是打开设备并创建完文件的句柄后，ArcOpen调用了文件对应的FileData.FuncTable.Open。对于fat分区而言这个函数是FatOpen(freeldr\freeldr\fs\fat.c). 这个函数也是和分区结构有关的了，有一点比较重要就是函数最后调用了FsSetDeviceSpecific把一个和文件相关的内部结构与文件句柄相关联。以后使用FatRead对文件句柄进行读操作时直接就可以获得这个结构啦。</p>
<ol>
<li><p>LONG FatOpen<strong>(</strong>CHAR<strong>*</strong> Path, OPENMODE OpenMode, ULONG<strong>*</strong> FileId<strong>)</strong></p>
</li>
<li><p><strong>{</strong></p>
</li>
<li><p><strong>.**</strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.**</p>
</li>
<li></li>
<li><p>// 根据文件的FileId获得文件所在的设备句柄FileData.DeviceId, 从而获得FatMount时生成的Volume结构。</p>
</li>
<li><p>DeviceId <strong>=</strong> FsGetDeviceId<strong>(<strong>*</strong></strong>FileId<strong>)**</strong>;**</p>
</li>
<li><p>FatVolume <strong>=</strong> FatVolumes<strong>[</strong>DeviceId<strong>]**</strong>;**</p>
</li>
<li><p>// 从DeviceId设备中读取并查询fat表，判断path表示的文件是否存在</p>
</li>
<li><p><em>RtlZeroMemory</em><strong>(**</strong>&amp;<strong>TempFileInfo, <em>sizeof</em></strong>(<strong>TempFileInfo</strong>)<strong><strong>)</strong></strong>;**</p>
</li>
<li><p>ret <strong>=</strong> FatLookupFile<strong>(</strong>FatVolume, Path, DeviceId, <strong>&amp;</strong>TempFileInfo<strong>)**</strong>;**</p>
</li>
<li><p><em>if</em> <strong>(</strong>ret <strong>!**</strong>=<strong> ESUCCESS</strong>)**</p>
</li>
<li><p><em>return</em> ENOENT<strong>;</strong></p>
</li>
<li><p>// 判断是否是目录</p>
</li>
<li><p>IsDirectory <strong>=</strong> <strong>(</strong>TempFileInfo<strong>.</strong>Attributes <strong>&amp;</strong> ATTR_DIRECTORY<strong>)</strong> <strong>!**</strong>=<strong> 0</strong>;**</p>
</li>
<li><p><em>if</em> <strong>(</strong>IsDirectory <strong>&amp;**</strong>&amp;<strong> OpenMode </strong>!<strong>**=</strong> OpenDirectory<strong>)</strong></p>
</li>
<li><p><em>return</em> EISDIR<strong>;</strong></p>
</li>
<li><p><em>else</em> <em>if</em> <strong>(**</strong>!<strong>IsDirectory </strong>&amp;<strong>**&amp;</strong> OpenMode <strong>!**</strong>=<strong> OpenReadOnly</strong>)**</p>
</li>
<li><p><em>return</em> ENOTDIR<strong>;</strong></p>
</li>
<li><p>// 生成FAT_FILE_INFO结构，里面存放了文件的信息(开始的扇区等)</p>
</li>
<li><p>FileHandle <strong>=</strong> MmHeapAlloc<strong>(</strong><em>sizeof</em><strong>(</strong>FAT_FILE_INFO<strong>)**</strong>)<strong>**;</strong></p>
</li>
<li><p><em>if</em> <strong>(**</strong>!<strong>FileHandle</strong>)**</p>
</li>
<li><p><em>return</em> ENOMEM<strong>;</strong></p>
</li>
<li><p>RtlCopyMemory<strong>(</strong>FileHandle, <strong>&amp;</strong>TempFileInfo, <em>sizeof</em><strong>(</strong>FAT_FILE_INFO<strong>)**</strong>)<strong>**;</strong></p>
</li>
<li><p>FileHandle<strong>-**</strong>&gt;<strong>Volume </strong>=<strong> FatVolume</strong>;**</p>
</li>
<li><p>// 把这个结构和文件对应的FileData.Specific关联。之后进行FatRead等操作时可以直接获得这个结构了</p>
</li>
<li><p>FsSetDeviceSpecific<strong>(<strong>*</strong></strong>FileId, FileHandle<strong>)**</strong>;**</p>
</li>
<li><p><em>return</em> ESUCCESS<strong>;</strong></p>
</li>
<li><p><strong>}</strong></p>
</li>
</ol>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-06-09T18:17:00.000Z" itemprop="datePublished">2011-06-10</time>
        </span>

        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086/">ReactOS-Freeldr磁盘及文件管理</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Freeldr提供了对fat12、fat32、fatx、ntfs等文件系统的只读功能。这部分代码主要集中在boot\freeldr\freeldr\fs\fs.c文件中。<br>首先计算机加电后会把mbr读取到物理内存的0x7c00位置，mbr搜索活动分区并加载活动分区根目录下的Freeldr.sys文件。加载后跳入Freeldr入口start。Freeldr进行32为初始化后跳入主初始化函数BootMain(boot\freeldr\freeldr\Freeldr.c)中。</p>
<pre><code>VOID BootMain(LPSTR CmdLine)
{
......
MachInit(CmdLine);
FsInit();
......
RunLoader();
}
 </code></pre>
<p>BootMain会对硬件(MachInit)和文件系统(FsInit)进行检测和初始化。所有准备工作进行完毕后就会调用RunLoader进行系统的加载工作。<br>Fs初始化和DEVICE、FILEDATA结构<br>下面看一下文件系统的初始化 FsInit(boot\freeldr\freeldr\fs\fs.c)</p>
<pre><code>VOID FsInit(VOID)
{
ULONG i;
RtlZeroMemory(FileData, sizeof(FileData));
for (i = 0; i &lt; MAX_FDS; i++)
FileData[i].DeviceId = (ULONG)-1;
InitializeListHead(&amp;DeviceListHead);
}
 </code></pre>
<p>FsInit初始化FileData数组。和一个和磁盘分区相关的链表DeviceListHead。<br>首先fs.c维护了一个MAX_FDS(60)大小的数组 static FILEDATA FileData[MAX_FDS];  </p>
<pre><code>typedef struct tagDEVVTBL
{
ARC_CLOSE Close;
ARC_GET_FILE_INFORMATION GetFileInformation;
ARC_OPEN Open;
ARC_READ Read;
ARC_SEEK Seek;
LPCWSTR ServiceName;
} DEVVTBL;
typedef struct tagFILEDATA
{
ULONG DeviceId;            &#x2F;&#x2F; 文件所在磁盘的磁盘文件句柄, 同样也是FileData的索引
ULONG ReferenceCount;       &#x2F;&#x2F; 引用计数
const DEVVTBL* FuncTable;    &#x2F;&#x2F; 对文件进行读写的指针
const DEVVTBL* FileFuncTable; &#x2F;&#x2F; 对文件进行读写的函数数组
VOID* Specific;             &#x2F;&#x2F; 文件系统自定义指针
} FILEDATA;
 </code></pre>
<p>每一个成功打开的文件会返回一个文件句柄，这个句柄实际上就是FileData数组的索引。所以每个打开的文件都有一个对应的FileData。这个结构就类似windows中的FILE_OBJECT<br>FileData中DeviceId是文件所在磁盘的句柄。这个句柄同样也是FileData数组的索引，通过这个句柄可以找到”磁盘文件”，对”磁盘文件”的读写就是直接对相应的磁盘或磁盘分区的读写。类似Windows中直接对磁盘分区进行CreateFile返回的句柄。”磁盘文件”的DeviceId没有意义。<br>ReferenceCount是该文件的引用计数。<br>FuncTable这是一个函数数组指针，里面存放了对文件进行读写、SEEK等操作的函数指针。<br>FileFuncTable只对”磁盘文件”有意义。当Freeldr确定了磁盘文件对应的分区的分区格式后，会把与分区格式相关的函数指针数组放到这个字段里面。如Fat12分区”磁盘文件”的FileFuncTable字段存放的就是FatFuncTable指针。<br>Specific存放于文件有关的结构。磁盘文件就是DISKCONTEXT指针，fat12下的文件就是FAT_FILE_INFO指针 等等。<br>之后是DeviceListHead，这是DEVICE结构的链表头  </p>
<pre><code>typedef struct tagDEVICE
{
LIST_ENTRY ListEntry;        &#x2F;&#x2F; 链表节点
const DEVVTBL* FuncTable;    &#x2F;&#x2F; 操作该分区的函数表
CHAR* Prefix;              &#x2F;&#x2F; 分区对应的ArcName
ULONG DeviceId;            &#x2F;&#x2F; FILEDATA中该分区对应的句柄
ULONG ReferenceCount;      &#x2F;&#x2F; 引用计数
} DEVICE;
 </code></pre>
<p>用户电脑中的每一个硬盘和硬盘中的每一分区都对应了一个DEVICE结构。<br>FuncTable里面存放了对该分区进行读写等操作的指针，对于硬盘而言这个数组就是DiskVtbl。<br>Prefix是该分区或硬盘的ArcName。(如multi(0)disk(0)rdisk(0)partition(0))。Freeldr中的文件路径都是Arc形式的路径。而且0号分区代表整个硬盘，真正的分区从1号开始。如multi(0)disk(0)rdisk(0)partition(0)便代表第0块硬盘本身。multi(0)disk(0)rdisk(0)partition(1)代表第0块硬盘的第0个分区。<br>通过DeviceId字段可以找到该DEVICE的文件句柄。这个字段和FILEDATA相互配合，使系统可以遍历DEVICE结构快速找到某个分区的文件句柄。<br>DEVICE(磁盘及分区)的检测<br>上面说到Freeldr操作的路径都是存储在DEVICE结构中的ArcPath。那么这些DEVICE是怎么来的呢？<br>首先我们看一下DEVICE的注册函数，FsRegisterDevice(boot\freeldr\freeldr\fs\fs.c)  </p>
<pre><code>VOID FsRegisterDevice(CHAR* Prefix, const DEVVTBL* FuncTable)
{
DEVICE* pNewEntry;
ULONG dwLength;
dwLength = strlen(Prefix) + 1;
pNewEntry = MmHeapAlloc(sizeof(DEVICE) + dwLength);
if (!pNewEntry)
return;
pNewEntry-&gt;FuncTable = FuncTable;
pNewEntry-&gt;ReferenceCount = 0;
pNewEntry-&gt;Prefix = (CHAR*)(pNewEntry + 1);
memcpy(pNewEntry-&gt;Prefix, Prefix, dwLength);
InsertHeadList(&amp;DeviceListHead, &amp;pNewEntry-&gt;ListEntry);
}
 </code></pre>
<p>这么函数非常简单。Prefix就是Arc路径，FuncTable是操作这个分区（磁盘）对应的函数数组。FsRegisterDevice生成了一个DEVICE结构，把ArcName和FuncTable复制进去。之后连入了DeviceListHead链表。<br>那么又是谁调用的FsRegisterDevice呢？是DetectBiosDisks(boot\freeldr\freeldr\arch\i386\hardware.c)函数。虽然这一部分已经不属于FS的范畴，还是在这里简单讲一下便于理解。这里我略去了不必要的代码。<br>DetectBiosDisks的调用顺序是 RunLoader -&gt; MachHwDetect (PcHwDetect)-&gt; DetectISABios -&gt; DetectBiosDisks</p>
<pre><code>static VOID
DetectBiosDisks(PCONFIGURATION_COMPONENT_DATA BusKey)
{
BOOLEAN BootDriveReported = FALSE;
ULONG i;
ULONG DiskCount = GetDiskCount(BusKey);
CHAR BootPath[512];
......
for (i = 0; i &lt; DiskCount; i++)
{
ULONG Size;
CHAR Identifier[20];
......
if (BootDrive == 0x80 + i)
BootDriveReported = TRUE;
&#x2F;* Get disk values *&#x2F;
GetHarddiskIdentifier(Identifier, 0x80 + i);
}
}
 </code></pre>
<p>首先使用GetDiskCount从Freeldr注册表的System键中读取硬盘总数。System键的初始化在DetectSystem(freeldr\freeldr\arch\i386\hardware.c)中，一会儿再看。<br>于是进入一个for循环，为每个硬盘调用GetHarddiskIdentifier函数。在BIOS中硬盘号是从0x80开始的，所以GetHarddiskIdentifier的硬盘号加了0x80。<br>GetHarddiskIdentifier的作用是为制定硬盘生成一个唯一的ID，并通过Identifier参数返回。但这个函数名起得并不好，因为生成ID其实只是这个函数的功能之一。另外的一大功能是检测硬盘，并且为硬盘本身和硬盘分区调用FsRegisterDevice函数进行注册。通过这个注册后硬盘才能真正被文件系统识别。<br>freeldr\freeldr\arch\i386\hardware.c中</p>
<pre><code>static VOID
GetHarddiskIdentifier(PCHAR Identifier,
ULONG DriveNumber)
{
PMASTER_BOOT_RECORD Mbr;
ULONG *Buffer;
ULONG i;
ULONG Checksum;
ULONG Signature;
CHAR ArcName[256];
PARTITION_TABLE_ENTRY PartitionTableEntry;
&#x2F;* Read the MBR *&#x2F;
if (!MachDiskReadLogicalSectors(DriveNumber, 0ULL, 1, (PVOID)DISKREADBUFFER))
{
DPRINTM(DPRINT_HWDETECT, &quot;Reading MBR failed\n&quot;);
return;
}
Buffer = (ULONG*)DISKREADBUFFER;
Mbr = (PMASTER_BOOT_RECORD)DISKREADBUFFER;
Signature = Mbr-&gt;Signature;
DPRINTM(DPRINT_HWDETECT, &quot;Signature: %x\n&quot;, Signature);
&#x2F;* Calculate the MBR checksum *&#x2F;
Checksum = 0;
for (i = 0; i &lt; 128; i++)
{
Checksum += Buffer[i];
}
Checksum = ~Checksum + 1;
DPRINTM(DPRINT_HWDETECT, &quot;Checksum: %x\n&quot;, Checksum);
&#x2F;* Fill out the ARC disk block *&#x2F;
reactos_arc_disk_info[reactos_disk_count].Signature = Signature;
reactos_arc_disk_info[reactos_disk_count].CheckSum = Checksum;
sprintf(ArcName, &quot;multi(0)disk(0)rdisk(%lu)&quot;, reactos_disk_count);
strcpy(reactos_arc_strings[reactos_disk_count], ArcName);
reactos_arc_disk_info[reactos_disk_count].ArcName =
reactos_arc_strings[reactos_disk_count];
reactos_disk_count++;
sprintf(ArcName, &quot;multi(0)disk(0)rdisk(%lu)partition(0)&quot;, DriveNumber - 0x80);
FsRegisterDevice(ArcName, &amp;DiskVtbl);
&#x2F;* Add partitions *&#x2F;
i = 1;
DiskReportError(FALSE);
while (DiskGetPartitionEntry(DriveNumber, i, &amp;PartitionTableEntry))
{
if (PartitionTableEntry.SystemIndicator != PARTITION_ENTRY_UNUSED)
{
sprintf(ArcName, &quot;multi(0)disk(0)rdisk(%lu)partition(%lu)&quot;, DriveNumber - 0x80, i);
FsRegisterDevice(ArcName, &amp;DiskVtbl);
}
i++;
}
DiskReportError(TRUE);
&#x2F;* Convert checksum and signature to identifier string *&#x2F;
Identifier[0] = Hex[(Checksum &gt;&gt; 28) &amp; 0x0F];
Identifier[1] = Hex[(Checksum &gt;&gt; 24) &amp; 0x0F];
Identifier[2] = Hex[(Checksum &gt;&gt; 20) &amp; 0x0F];
Identifier[3] = Hex[(Checksum &gt;&gt; 16) &amp; 0x0F];
Identifier[4] = Hex[(Checksum &gt;&gt; 12) &amp; 0x0F];
Identifier[5] = Hex[(Checksum &gt;&gt; 8 ) &amp; 0x0F];
Identifier[6] = Hex[(Checksum &gt;&gt; 4) &amp; 0x0F];
Identifier[7] = Hex[Checksum &amp; 0x0F];
Identifier[8] = &#39;-&#39;;
Identifier[9] = Hex[(Signature &gt;&gt; 28) &amp; 0x0F];
Identifier[10] = Hex[(Signature &gt;&gt; 24) &amp; 0x0F];
Identifier[11] = Hex[(Signature &gt;&gt; 20) &amp; 0x0F];
Identifier[12] = Hex[(Signature &gt;&gt; 16) &amp; 0x0F];
Identifier[13] = Hex[(Signature &gt;&gt; 12) &amp; 0x0F];
Identifier[14] = Hex[(Signature &gt;&gt; 8 ) &amp; 0x0F];
Identifier[15] = Hex[(Signature &gt;&gt; 4) &amp; 0x0F];
Identifier[16] = Hex[Signature &amp; 0x0F];
Identifier[17] = &#39;-&#39;;
Identifier[18] = &#39;A&#39;;
Identifier[19] = 0;
}
 </code></pre>
<p>函数首先使用MachDiskReadLogicalSectors读取指定硬盘的MBR。对于PC机而言MachDiskReadLogicalSectors使用int 13h中断实现对硬盘的读操作。里面包括了16、32位代码的互转，和本节内容无关，以后再做说明。<br>MBR结构为。详细信息可以参考(<a href="http://en.wikipedia.org/wiki/Master_boot_record" target="_blank" rel="external">http://en.wikipedia.org/wiki/Master_boot_record</a>)</p>
<pre><code>typedef struct _MASTER_BOOT_RECORD
{
UCHAR        MasterBootRecordCodeAndData[0x1b8];   &#x2F;* 0x000 *&#x2F;
ULONG        Signature;          &#x2F;* 0x1B8 *&#x2F;
USHORT        Reserved;          &#x2F;* 0x1BC *&#x2F;
PARTITION_TABLE_ENTRY   PartitionTable[4];        &#x2F;* 0x1BE *&#x2F;
USHORT        MasterBootRecordMagic;        &#x2F;* 0x1FE *&#x2F;
} MASTER_BOOT_RECORD, *PMASTER_BOOT_RECORD;
 </code></pre>
<p>GetHarddiskIdentifier在获取了Signature、计算了Checksum后 。<br>sprintf(ArcName, “multi(0)disk(0)rdisk(%lu)partition(0)”, DriveNumber - 0x80);<br>FsRegisterDevice(ArcName, &amp;DiskVtbl);<br>生成对应硬盘的ArcName，使用FsRegisterDevice注册这块硬盘，这个函数我们已经看过。注意这里Partition为0，所以0号分区实际表示硬盘本身。<br>之后</p>
<pre><code>i = 1;
while (DiskGetPartitionEntry(DriveNumber, i, &amp;PartitionTableEntry))
{
if (PartitionTableEntry.SystemIndicator != PARTITION_ENTRY_UNUSED)
{
sprintf(ArcName, &quot;multi(0)disk(0)rdisk(%lu)partition(%lu)&quot;, DriveNumber - 0x80, i);
FsRegisterDevice(ArcName, &amp;DiskVtbl);
}
i++;
}
 </code></pre>
<p>DiskGetParititionEntry将会解析DriveNumber对应磁盘的分区表，填充第i个分区的信息到PartitionTableEntry结构。如果分区存在则使用FsRegisterDevice注册分区。<br>使用刚才计算的CheckSum和Signature组合一个ID返回给调用者。其实这个ID没有被使用过。。。<br>最后看一下调用FsRegisterDevice时的第二个参数DiskVtbl  </p>
<pre><code>static const DEVVTBL DiskVtbl = {
DiskClose,
DiskGetFileInformation,
DiskOpen,
DiskRead,
DiskSeek,
};
 </code></pre>
<p>这里面包含了对磁盘扇区读写的全部函数。我们之后再介绍。<br>至此硬盘的及硬盘分区的注册完成。<br>执行完DetectBiosDisks后，DeviceListHead里面就存放了当前计算机所有的磁盘和分区对应的DEVICE结构。<br>文件系统的识别和文件的打开<br>这时Fs模块已经知道的硬盘数量，分区信息。下面来看看一个文件的打开流程。<br>首先，Freeldr使用的是Arc路径，IDE硬盘以multi(0)disk(0)rdisk(n)开头，文件也是以Arc路径表示的。打开文件的函数在Freeldr\Freeldr\fs\fs.c中。这函数比较长，我们分段阅读。<br>Freeldr\Freeldr\fs\fs.c</p>
<pre><code>LONG ArcOpen(CHAR* Path, OPENMODE OpenMode, ULONG* FileId)
{
......
*FileId = MAX_FDS;
&#x2F;* Search last &#39;)&#39;, which delimits device and path *&#x2F;
FileName = strrchr(Path, &#39;)&#39;);
if (!FileName)
return EINVAL;
FileName++;
&#x2F;* Count number of &quot;()&quot;, which needs to be replaced by &quot;(0)&quot; *&#x2F;
dwCount = 0;
for (p = Path; p != FileName; p++)
if (*p == &#39;(&#39; &amp;&amp; *(p + 1) == &#39;)&#39;)
dwCount++;
&#x2F;* Duplicate device name, and replace &quot;()&quot; by &quot;(0)&quot; (if required) *&#x2F;
dwLength = FileName - Path + dwCount;
if (dwCount != 0)
{
DeviceName = MmHeapAlloc(FileName - Path + dwCount);
if (!DeviceName)
return ENOMEM;
for (p = Path, q = DeviceName; p != FileName; p++)
{
*q++ = *p;
if (*p == &#39;(&#39; &amp;&amp; *(p + 1) == &#39;)&#39;)
*q++ = &#39;0&#39;;
}
}
else
DeviceName = Path;
......
 </code></pre>
<p>这个函数有三个参数Path是文件名的Arc路径，如multi(0)disk(0)rdisk(0)partition(1)Freeldr.sys就表示C盘中的Freeldr.sys文件。<br>OpenMode是打开模式(OpenReadOnly、OpenReadWrite等)。<br>如果打开成功，文件句柄将通过FileId参数返回。<br>首先这一部分代码分理出Arc磁盘路径中的”()”替换成”(0)”并存入DeviceName中，如multi()disk()rdisk()partition(1)Freeldr.sys处理后，DeviceName将指向multi(0)disk(0)rdisk(0)partition(1)。注意这个DeviceName是不以NULL结尾的。。。这是个很蛋疼的设计。<br>FileName会指向Arc路径中的文件名部分，上面的例子将是Freeldr.sys。<br>文件打开分为两步，第一步是开个文件所在的设备、创建设备的句柄。第二部才是打开文件本身。<br>这里是第一步打开设备的代码。  </p>
<pre><code>......
pEntry = DeviceListHead.Flink;
while (pEntry != &amp;DeviceListHead)
{
pDevice = CONTAINING_RECORD(pEntry, DEVICE, ListEntry);
if (strncmp(pDevice-&gt;Prefix, DeviceName, dwLength) == 0)
{
&#x2F;* OK, device found. It is already opened? *&#x2F;
if (pDevice-&gt;ReferenceCount == 0)
{
&#x2F;* Search some room for the device *&#x2F;
for (DeviceId = 0; DeviceId &lt; MAX_FDS; DeviceId++)
if (!FileData[DeviceId].FuncTable)
break;
if (DeviceId == MAX_FDS)
return EMFILE;
&#x2F;* Try to open the device *&#x2F;
FileData[DeviceId].FuncTable = pDevice-&gt;FuncTable;
ret = pDevice-&gt;FuncTable-&gt;Open(pDevice-&gt;Prefix, DeviceOpenMode, &amp;DeviceId);
if (ret != ESUCCESS)
{
FileData[DeviceId].FuncTable = NULL;
return ret;
}
else if (!*FileName)
{
&#x2F;* Done, caller wanted to open the raw device *&#x2F;
*FileId = DeviceId;
pDevice-&gt;ReferenceCount++;
return ESUCCESS;
}
&#x2F;* Try to detect the file system *&#x2F;
FileData[DeviceId].FileFuncTable = FatMount(DeviceId);
if (!FileData[DeviceId].FileFuncTable)
FileData[DeviceId].FileFuncTable = NtfsMount(DeviceId);
if (!FileData[DeviceId].FileFuncTable)
FileData[DeviceId].FileFuncTable = Ext2Mount(DeviceId);
if (!FileData[DeviceId].FileFuncTable)
{
&#x2F;* Error, unable to detect file system *&#x2F;
pDevice-&gt;FuncTable-&gt;Close(DeviceId);
FileData[DeviceId].FuncTable = NULL;
return ENODEV;
}
pDevice-&gt;DeviceId = DeviceId;
}
else
{
DeviceId = pDevice-&gt;DeviceId;
}
pDevice-&gt;ReferenceCount++;
break;
}
pEntry = pEntry-&gt;Flink;
}
if (pEntry == &amp;DeviceListHead)
return ENODEV;
 </code></pre>
<p>一个循环，遍历DEVICE链表，找到DEVICE-&gt;Prefix (磁盘、分区的Arc路径，上一节说过)和刚刚分解出来的DeviceName相等的节点。如果没有则函数直接失败。<br>找到DEVICE节点后判断DEVICE-&gt;ReferenceCount是否为0。这个代表该DEVICE被打开的次数，如果ReferenceCount不为0，说明DEVICE已经被打开。那个直接从Device-&gt;DeviceId中获得设备的文件句柄。可以看出无论打开一个设备多少次，只会有ReferenceCount的变化，而句柄都是相同的。所以如果设备打开两次，SEEK时会相互影响。读写之前最好重新调用SEEK函数。<br>当DEVICE-&gt;ReferenceCount为0时是Freeldr需要调用进行打开和文件系统的识别。我们仔细读读。  </p>
<pre><code>&#x2F;* Search some room for the device *&#x2F;
for (DeviceId = 0; DeviceId &lt; MAX_FDS; DeviceId++)
if (!FileData[DeviceId].FuncTable)
break;
if (DeviceId == MAX_FDS)
return EMFILE;
 </code></pre>
<p>首先在FileData数组中找到空闲项，数组的索引即将成为设备句柄。  </p>
<pre><code>&#x2F;* Try to open the device *&#x2F;
FileData[DeviceId].FuncTable = pDevice-&gt;FuncTable;
ret = pDevice-&gt;FuncTable-&gt;Open(pDevice-&gt;Prefix, DeviceOpenMode, &amp;DeviceId);
if (ret != ESUCCESS)
{
FileData[DeviceId].FuncTable = NULL;
return ret;
}
else if (!*FileName)
{
&#x2F;* Done, caller wanted to open the raw device *&#x2F;
*FileId = DeviceId;
pDevice-&gt;ReferenceCount++;
return ESUCCESS;
}
 </code></pre>
<p>之后把DEVICE中存储的设别操作函数数组FuncTable赋值给对应FileData中的FuncTable。之后对该句柄的读写操作将直接传递给FileData.FuncTable中的函数。<br>调用FuncTable-&gt;Open打开设备。上面我们看过这个函数实际是freeldr\freeldr\arch\i386\hardware.c中的DiskOpen。<br>打开成功后，如果FileName（需要打开的文件名）为空，说明这次请求只打开设备，于是直接返回设备的句柄。<br>如果不为空，则下面开始识别分区格式，打开文件的操作。<br>在继续读ArcOpen函数前我们先看看DiskOpen在打开设备时都做了什么。  </p>
<pre><code>ArcOpen -&gt; DiskOpen (freeldr\freeldr\arch\i386\hardware.c)
static LONG DiskOpen(CHAR* Path, OPENMODE OpenMode, ULONG* FileId)
{
......
if (!DissectArcPath(Path, FileName, &amp;DriveNumber, &amp;DrivePartition))
return EINVAL;
if (DrivePartition == 0xff)
{
&#x2F;* This is a CD-ROM device *&#x2F;
SectorSize = 2048;
}
else
{
SectorSize = 512;
}
if (DrivePartition != 0xff &amp;&amp; DrivePartition != 0)
{
if (!DiskGetPartitionEntry(DriveNumber, DrivePartition, &amp;PartitionTableEntry))
return EINVAL;
SectorOffset = PartitionTableEntry.SectorCountBeforePartition;
SectorCount = PartitionTableEntry.PartitionSectorCount;
}
Context = MmHeapAlloc(sizeof(DISKCONTEXT));
if (!Context)
return ENOMEM;
Context-&gt;DriveNumber = DriveNumber;
Context-&gt;SectorSize = SectorSize;
Context-&gt;SectorOffset = SectorOffset;
Context-&gt;SectorCount = SectorCount;
Context-&gt;SectorNumber = 0;
FsSetDeviceSpecific(*FileId, Context);
return ESUCCESS;
}
 </code></pre>
<p>这个函数非常简单，使用DissectArcPath根据设备的Arc路径分解出文件名FileName、BIOS驱动器号DriveNumber、和分区号DrivePartition（第0个分区的编号是1，0代表整个硬盘）<br>之后确定扇区大小，分区开始的扇区号、分区扇区数等信息，存入DISKCONTEXT结构。使用FsSetDeviceSpecific和FildId相关联。<br>还记得FILEDATA的结构么？FsSetDeviceSpecific就是填充里面的Specific指针 ：）  </p>
<pre><code>VOID FsSetDeviceSpecific(ULONG FileId, VOID* Specific)
{
if (FileId &gt;= MAX_FDS || !FileData[FileId].FuncTable)
return;
FileData[FileId].Specific = Specific;
}
 </code></pre>
<p>实际上DiskOpen的作用就是获得该设备（分区）的基本信息——BIOS驱动器号、扇区大小、开始扇区号、扇区数量和当前读写指针（SectorNumber）。生成DISKCONTENT结构使用FsSetDeviceSpecific和FileID绑定。<br>现在我们回到ArcOpen函数，希望你还记得 ：）  </p>
<pre><code>&#x2F;* Try to detect the file system *&#x2F;
FileData[DeviceId].FileFuncTable = FatMount(DeviceId);
if (!FileData[DeviceId].FileFuncTable)
FileData[DeviceId].FileFuncTable = NtfsMount(DeviceId);
if (!FileData[DeviceId].FileFuncTable)
FileData[DeviceId].FileFuncTable = Ext2Mount(DeviceId);
if (!FileData[DeviceId].FileFuncTable)
{
&#x2F;* Error, unable to detect file system *&#x2F;
pDevice-&gt;FuncTable-&gt;Close(DeviceId);
FileData[DeviceId].FuncTable = NULL;
return ENODEV;
}
pDevice-&gt;DeviceId = DeviceId;
 </code></pre>
<p>现在FileData[DeviceId]已经代表刚刚打开的设备了，开始挂载分区。啥叫挂载分区，就是让文件系统提供个接口，能让我们操作分区里面的文件。而这个接口就是个DEVVTBL指针，和直接操作硬盘的接口一样，只不过这次这个可以操作文件了。如果分区识别成功，XxxMount函数将会返回另外一个DEVVTBL指针数组，这个指针赋值给设备对象的FileFuncTable成员。使用这个指针数组就可以在文件级别操作了。比如打开freeldr.sys文件就可以调用FileData[DeviceId].FileFuncTable-&gt;open函数。FileFuncTable和FuncTable是不同的哦！ ：）<br>注意FileFuncTable其实是不直接使用的，这个指针的作用是为之后打开的文件对应的FileData.FileTable赋值。于是操作文件和操作磁盘都是用对应的FileData.FileTable，实现形式上的统一。而且这种架构还可以轻易的实现将一个文件虚拟成为一个分区，只要为文件对象调用XxxMount并且给FileFuncTable域赋值就可以了，非常易于扩展。Freeldr并没有实现这种功能，文件的FileData.FileFuncTable没有使用～<br>下面我们就来看看第二步，打开文件<br>首先为文件找一个空闲的FileData  </p>
<pre><code>for (i = 0; i &lt; MAX_FDS; i++)
if (!FileData[i].FuncTable)
break;
if (i == MAX_FDS)
return EMFILE;
 </code></pre>
<p>跳过文件名开始的 “\” 字符  </p>
<pre><code>if (*FileName == &#39;\\&#39;)
FileName++;
 </code></pre>
<p>我们前面说的，为FileData.FuncTable赋值。FileData.DeviceId是文件所在分区的句柄。FuncTable内部函数将通过这个句柄调用读写分区内容，为用户提供文件的读写接口。</p>
<pre><code>FileData[i].FuncTable = FileData[DeviceId].FileFuncTable;
FileData[i].DeviceId = DeviceId;
*FileId = i;
ret = FileData[i].FuncTable-&gt;Open(FileName, OpenMode, FileId);
if (ret != ESUCCESS)
{
FileData[i].FuncTable = NULL;
*FileId = MAX_FDS;
}
 </code></pre>
<p>至此打开文件的操作结束。这里略去了XxxMount和文件的Open函数。以后再说。 ：）  </p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-06-02T06:33:19.000Z" itemprop="datePublished">2011-06-02</time>
        </span>

        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-e585b3e4ba8ee69687e4bbb6shareaccess" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/">关于文件ShareAccess</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我是真心太懒了，虽然平时也在研究一些东西，但是总是理解了就算了，没有把他们记录下来的想法。虽然不记录下来也不至于会忘记，但是人的记忆总是有限的我也不敢保证记忆完全不错。好不容易说服自己写点东西，就从今天看的那点东西写起吧。</p>
<p>（吐槽：我尽量把以后的文章写得详细以至于啰嗦，免得以后自己又看不懂了。）</p>
<p>什么是ShareAccess。我们做一个简单的实验，进入系统目录(一般就是C:\Windows)。在C:\Windows\system32\config中，复制一个SYSTEM文件，然后把文件粘贴到另一个地方。如果我们的系统正常，那么我们看到肯定是一个错误框。（图1）“无法复制 system: 文件正在被另一个人或程序使用。关闭任何可能使用这个文件的程序，重新试一次。”无论懂不懂编程，这样一个令人蛋疼的错误框应该会看过无数次吧。这里我就不解释Windows为什么要这么做，假设所有读者都是了解其中的原因了。这篇文章想介绍的是，Windows怎么做到“访问拒绝”的。简单的来说就是当一个进程打开该文件的时候ShareAccess中没有ShareRead属性，所以其他的进程无法访问他。</p>
<p><a href="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-51-31.png"><img src="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-51-31-300x225.png" alt=""></a></p>
<p>（图1）</p>
<p>在我们平时打开文件中（CreateFile）总是需要我们传入一个dwShareMode的参数。它有三个值分别是FILE_SHARE_DELETE，FILE_SHARE_READ，FILE_SHARE_WRITE。如果一个打开一个文件的时候，没有传入了FILE_SHARE_READ，那么如果有另一段代码对文件用FILE_READ_DATA权限打开的时候一定返回的是一个失败。其他两个SHARE也是一样。那么是不是设置了FILE_SHARE_READ，其他代码用FILE_READ_DATA权限打开该文件都会成功呢？答案是不一定，主要要看在这段代码CreateFile的dwShareMode。如果也设置的FILE_SHARE_READ，那么打开文件就会成功，否则返回一个SHARE错误。</p>
<p>（吐槽：上面说了一堆，还是没进入正题，貌似有点太详细了。接下来才是重头戏。）</p>
<p>来看看NTFS文件系统是怎么来Check权限的。<br>每个文件打开的时候系统会为文件分配一个FILE_OBJECT（文件对象）。在这里我们主要关注的是以下几个域。<br><pre><code>nt!_FILE_OBJECT
...
+0x00c FsContext        : Ptr32 Void
...
+0x026 ReadAccess       : UChar
+0x027 WriteAccess      : UChar
+0x028 DeleteAccess     : UChar
+0x029 SharedRead       : UChar
+0x02a SharedWrite      : UChar
+0x02b SharedDelete     : UChar
...</code></pre><br>熟悉NTFS文件系统的同学都知道FsContext实际上是对应着一个SCB。SCB的数据结构是未公开的，所以只有逆向或者通过其他途径获得。而这篇文章只需要关注的是SCB的SHARE_ACCESS。SHARE_ACCESS在SCB的0x60的偏移处，这个和NT的SCB有些不同。SHARE_ACCESS的数据结构是这样</p>
<pre><code>typedef struct _SHARE_ACCESS {
ULONG OpenCount;
ULONG Readers;
ULONG Writers;
ULONG Deleters;
ULONG SharedRead;
ULONG SharedWrite;
ULONG SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;</code></pre>
<p>这个就是这篇文章的关键。</p>
<p>当一个文件被打开的时候，系统会初始化这个数据结构。根据CreateFile的权限设置来填充这个结构。<br>比如DesiredAccess中设置了FILE_READ_DATA，那么Readers，OpenCount就会增加1，如果在此同时设置了ShareMode为FILE_SHARE_READ，那么SharedRead也会加1。同时FILE_OBJECT的ReadAccess和SharedRead会被设置为TRUE。那么在文件被关闭的时候，如果FILE_OBJECT的ReadAccess和SharedRead为TRUE，那么SHARE_ACCESS的Readers，OpenCount，SharedRead就会减1。</p>
<p>在进程准备去打开一个已经打开的文件时，文件系统会做一系列的检查，包括文件权限（比如如果是只读文件，你却想要写权限，这样就会失败），安全描述符，以及共享权限（ShareAccess）。假设前面两个都符合要求，那么就到了共享权限的检查了。</p>
<p>还是以刚才那个SYSTEM文件为例，他打开的权限是FILE_READ_DATA，FILE_WRITE_DATA，DELETE。那么SHARE_ACCESS的OpenCount，Readers，Writers，Deleters都为1，而完全没有Share的意图，所以其他的域都是0。</p>
<p>当有另外一段代码去试图用FILE_READ_DATA权限打开这个文件的时候，那么文件系统就会去检查第一个打开这个文件的操作共享权限。这时的OpenCount是1，SharedRead是0，他会发现SharedRead小于OpenCount，那么他认为这个文件并没有SHARE_READ，所以参数检查返回失败，你会得到一个共享错误。这就是为什么我们复制粘贴SYSTEM文件的时候会失败。</p>
<p>原因分析到这里就结束了。但是我就这样满足了么？显然我没那么容易满足滴~</p>
<p>我想做的就是复制出这个SYSTEM文件，实际上网上已经有很多做法，什么底层磁盘解析读取数据，句柄复制大法。而我这次是修改底层SCB的ShareAccess来达到复制的目的。如果读懂了上面的原理，看下面这段代码就很轻松了。</p>
<pre><code>kfile File;
ns = File.Create(FILENAME, FILE_OPEN, FILE_READ_ATTRIBUTES, 0);
FileObj = File.GetObject();
ShareAccess = (SHARE_ACCESS *)((ULONG)FileObj-&gt;FsContext + Offset);
ShareAccess-&gt;SharedRead = ShareAccess-&gt;Readers;
File.Release();
 </code></pre>
<p>OK，编写好测试代码，生成一个驱动。运行即可。接下来就是见证奇迹的时刻了。还是用同样的方法复制看看，完全没有问题了。（图2）</p>
<p><a href="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-53-40.png"><img src="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-53-40-300x225.png" alt=""></a></p>
<p>（图2）</p>
<p>（吐槽：好久没写这么长的文章，写的我都崩溃了。说到写文章，我发现现在我如果拿起笔去写字，经常会发生提笔忘字的情况！！！天啊！！！）</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-05-22T10:26:22.000Z" itemprop="datePublished">2011-05-22</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/NTInternals/' title=''>NTInternals</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/File-System/">File System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTFS/">NTFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NTInternals/">NTInternals</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-e8aea9e7a88be5ba8fe7ad89e5be85e8b083e8af95e599a8e99984e58aa0" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/04/01/e8aea9e7a88be5ba8fe7ad89e5be85e8b083e8af95e599a8e99984e58aa0/">让程序等待调试器附加</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>有的时候出于一些目的，我们会希望程序等待调试器Attach上去以后才开始继续往前跑。例如，我们写了一堆console程序，同时又有个shell去调用这些console，而这个时候我们却想去调试shell运行起来的这个console。当然Windbg本身就有调试debugee子进程的功能，但是身为懒人，这种方式太麻烦。我还是更愿意加入几行代码解决这个问题。</p>
<p>要解决这个问题，原理上很简单。无非是程序运行初期不断的去检测本进程是否被调试，如果是就把自己断下来，如果不是继续等待。</p>
<pre><code>void WaitDebuggerAttach(DWORD Second)
{
	DWORD CurSec = 0;
	while((!IsDebuggerPresent()) &amp;&amp; (CurSec &lt; Second)) {
		
		CurSec++;
		Sleep(1000);
	}

	if (IsDebuggerPresent()) {

		__asm int 3
	}
}
 </code></pre>
<p>这个函数可以指定等待时间，如果Debugger Attach上去了，那么就断下来方便调试，否则会超时，正常执行。<br>这里我是用的IsDebuggerPresent这个API来获得进程的调试状态。实际上检测自己调试状态的方法很多，只不过这个用起来最方便而已。比如可以用测试断点异常的方法来检测自己的调试状态。  </p>
<pre><code>BOOL CheckForDebugger()
{
    __try 
    {
        DebugBreak();
    }
    __except(GetExceptionCode() == EXCEPTION_BREAKPOINT ? 
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) 
    {
        &#x2F;&#x2F; No debugger is attached, so return FALSE 
        &#x2F;&#x2F; and continue.
        return FALSE;
    }
    return TRUE;
}
 </code></pre>
<p>本Blog的第一篇文章总算是出炉了~~~我太懒了哇~</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-04-01T08:05:21.000Z" itemprop="datePublished">2011-04-01</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Debugging/' title=''>Debugging</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-hello-world" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2011/02/28/hello-world/">Hello world!</a>
  

      </h3>
      <div class="repo-list-description">
        
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><pre><code>printf(&quot;hello world!&quot;); </code></pre>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2011-02-27T23:51:00.000Z" itemprop="datePublished">2011-02-28</time>
        </span>

        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
        </div>
        <div class="column one-third">
          <!--处理未安装 search 插件 默认 Google 搜索-->
 

<h3>Search</h3>

<div id="site_search">

	<!-- Google -->
	
		<form action="http://www.google.com/search?" data-site="http://0cch.com">
	    	<input type="text" id="search_box" name="q" placeholder="Search">
	    	<button type="button" class="btn btn-default" id="site_search_do"><span class="octicon octicon-search"></span></button>
	    </form>
	

	<!-- 本地搜索 -->
	

</div>

<h3>Popular Repositories</h3>
    <div class="popular-container"></div>
    
    <script type="text/template" id="popular-list-template">
        <a href="{%=clone_url%}" class="card text-center" target="_blank">
            <div class="thumbnail">
                <div class="card-image geopattern" data-pattern-id="{%=name%}">
                    <div class="card-image-cell">
                        <h3 class="card-title">
                            {%=name%}
                        </h3>
                    </div>
                </div>
                <div class="caption">
                    <div class="card-description">
                        <p class="card-text">
                            {%=description%}
                        </p>
                    </div>
                    <div class="card-text">
                        <span class="meta-info tooltipped tooltipped-n" aria-label="{%=stargazers_count%} stars">
                            <span class="octicon octicon-star"></span> {%=stargazers_count%}
                        </span>
                        <span class="meta-info tooltipped tooltipped-n" aria-label="{%=forks_count%} forks">
                            <span class="octicon octicon-git-branch"></span> {%=forks_count%}
                        </span>
                        <span class="meta-info tooltipped tooltipped-n" aria-label="最后更新时间：{%=updated_at%}">
                            <span class="octicon octicon-clock"></span>
                            <time datetime="{%=updated_at%}">{%=updated_at%}</time>
                        </span>
                    </div>
                </div>
            </div>
        </a>
    </script>

    <script src="/js/baiduTemplate.js"></script>
    <script type="text/javascript">
        var popular_repos = function(){

            var baiduTpl = new Object();

            var handleTpl = function(){
                baiduTpl.popular_list = baidu.template("popular-list-template");
            };

            var handleGithub = function(){
                var popularContainer = $(".popular-container");

                var repos = "0cchext,luadbg".split(",");
                for(var i in repos){
                    var name = repos[i];
                    $.get("https://api.github.com/repos/0cch/"+name,handle);
                }

                function handle(result){
                    result.updated_at = result.updated_at.split("T")[0];
                    if(result){
                        var html = baiduTpl.popular_list(result);
                        popularContainer.append(html);
                        $(".geopattern").each(function(){           
                            $(this).geopattern($(this).data('pattern-id'));
                        });
                    }
                }
            };

            return {
                init:function(){
                    handleTpl();
                    handleGithub();
                }
            }
        }; 
        $(popular_repos().init);
    </script>


  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">February 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">February 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">December 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">October 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">September 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/08/">August 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/06/">June 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/05/">May 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/04/">April 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/02/">February 2011</a></li></ul>
    </div>
  </div>


        </div>
    </div>

    
      <div class="pagination text-align">
          <div class="btn-group">
              <a class="extend prev" rel="prev" href="/page/11/">&laquo;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span>
          </div>
      </div>
    
</section>

<footer class="container">
    <div class="site-footer" role="contentinfo">
        
        <ul class="site-footer-links right mobile-hidden">
            <li>
                <a href="javascript:window.scrollTo(0,0)" >TOP</a>
            </li>
        </ul>

        <ul class="site-footer-links mobile-hidden">
            
                  
                  <li>
                    <a href="/"  title="Home">Home</a>
                  </li>
            
                  
                  <li>
                    <a href="/categories/"  title="Category">Category</a>
                  </li>
            
                  
                  <li>
                    <a href="/open-source/"  title="Open-Source">Open-Source</a>
                  </li>
            
            <li>
                <a href="/atom.xml">
                    <span class="octicon octicon-rss" style="color:orange;"></span>
                </a>
            </li>
        </ul>
    </div>
</footer>

		<script src="/js/geopattern.js"></script>
		<script src="/js/highlight.pack.js"></script>
		<script src="/lib/fancybox/jquery.fancybox-1.3.4.pack.js"></script>

		

		<script src="/js/index.js"></script>

		 <script src="/js/popular_repo.js"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --> 

	</body>
</html>