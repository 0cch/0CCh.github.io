<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qt的隐式共享和写时拷贝</title>
      <link href="/2021/07/11/qt-implicit-sharing-copy-on-write/"/>
      <url>/2021/07/11/qt-implicit-sharing-copy-on-write/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>不得不说Qt为了提高代码的运行效率做了很多伟大的工作，引入隐式共享和写时拷贝技术就是其中之一。该技术十分值得我们学习，一方面是因为它也可以运用到我们的代码中提高代码的运行效率，另一方面我们在理解其原理之后才能够更加高效的使用Qt。</p><p>Qt中的隐式共享是指类中存在一个共享数据块指针，改数据块由数据和引用技术组成。</p><ul><li>当类型对象被创建时，共享数据块也被创建，并且设置引用技术为1。</li><li>当类型对象发生拷贝时，共享数据块共享其指针，并且递增引用计数（+1）。</li><li>当类型对象销毁时，共享数据块引用技术递减（-1），当引用计数归零时销毁数据块。</li><li>当类型对象调用方法有可能被修改时，采用写时拷贝机制，创建真正对象副本。</li></ul><p>使用隐式共享和写时拷贝的好处非常明显，在只读的情况下，拷贝对象的内存和CPU计算成本非常低。只有在真正修改对象的时候，才会发生对象拷贝。除了Qt中的普通类型以外，Qt的容器类型也大量采用了这种技术，这也是Qt容器和STL容器的一个显著的区别。</p><p>来看一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class QPenPrivate *d</span></span><br><span class="line"></span><br><span class="line">QPen::<span class="built_in">QPen</span>(<span class="keyword">const</span> QPen &amp;p) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    d = p.d;</span><br><span class="line">    <span class="keyword">if</span> (d)</span><br><span class="line">        d-&gt;ref.<span class="built_in">ref</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QPen::~<span class="built_in">QPen</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &amp;&amp; !d-&gt;ref.<span class="built_in">deref</span>())</span><br><span class="line">        <span class="keyword">delete</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QPen::detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ref.<span class="built_in">loadRelaxed</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    QPenData *x = <span class="keyword">new</span> <span class="built_in">QPenData</span>(*<span class="keyword">static_cast</span>&lt;QPenData *&gt;(d));</span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;ref.<span class="built_in">deref</span>())</span><br><span class="line">        <span class="keyword">delete</span> d;</span><br><span class="line">    x-&gt;ref.<span class="built_in">storeRelaxed</span>(<span class="number">1</span>);</span><br><span class="line">    d = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QPen::setStyle</span><span class="params">(Qt::PenStyle s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;style == s)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">detach</span>();</span><br><span class="line">    d-&gt;style = s;</span><br><span class="line">    QPenData *dd = <span class="keyword">static_cast</span>&lt;QPenData *&gt;(d);</span><br><span class="line">    dd-&gt;dashPattern.<span class="built_in">clear</span>();</span><br><span class="line">    dd-&gt;dashOffset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>Pen</code>的拷贝构造函数只是将共享数据块指针从<code>p</code>赋值到当前对象，然后增加其引用计数。当对象析构时，首先减少引用计数，然后判断引用计数是否归零，如果条件成立则释放对象。当调用<code>setStyle</code>函数修改对象的时候，函数调用了一个<code>detach</code>函数，这个<code>detach</code>函数检查当前的引用计数，若引用计数为1，证明没有共享数据块，可以直接修改数据。反之引用计数不为1，则证明存在共享改数据块的类，无法直接修改数据，需要拷贝一份新的数据。</p><p>现在看来，Qt似乎已经为我们考虑的十分周到了，不调用修改对象的函数是不会发生真正的拷贝的。那么需要我们做什么呢？答案是，Qt的使用者应该尽可能的避免误操作导致的数据拷贝。前面提到过，Qt认为可能发生写对象的操作都会真实的拷贝对象，其中要给典型的情况是：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line"><span class="keyword">int</span>* p = test2.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure><p>这里看起来并没有发生对象的写操作，但是数据拷贝还是发生了，因为Qt认为这是一个可能发生写数据的操作，所以在调用<code>data()</code>的时候就调用了<code>detach()</code>函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> T *<span class="title">data</span><span class="params">()</span> </span>&#123; <span class="built_in">detach</span>(); <span class="keyword">return</span> d-&gt;<span class="built_in">begin</span>(); &#125;</span><br></pre></td></tr></table></figure><p>如果确定不会修改对象的数据应该明确告知编译器：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test3 = test1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = test2.<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* q = test3.<span class="built_in">constData</span>();</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T *<span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d-&gt;<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T *<span class="title">constData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d-&gt;<span class="built_in">begin</span>(); &#125;</span><br></pre></td></tr></table></figure><p>它们都不会调用<code>detach</code>函数拷贝对象。还是C++编程老生常谈那句话：在确定不修改对象的时候总是使用<code>const</code>来声明它，以便编译器对其做优化处理。</p><p>有时候我们并不是完全弄清楚编程环境中具体发生了什么，比如你可能不知道Qt的隐式共享和写时拷贝，但是保持良好的编程习惯，比如对于不修改的对象声明为<code>const</code>，有时候可以在不经意间优化了编写的代码，何乐而不为呢。</p><p>值得注意的是，我们应该尽量避免直接引用并通过引用修改Qt容器中的对象。千万不要这么做，因为可能会得到你不想看到的结果，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line"><span class="keyword">int</span>&amp; v = test1[<span class="number">1</span>];</span><br><span class="line">v = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>这份代码不会出现问题，因为当表达式<code>test2 = test1</code>运行时，共享数据的引用计数递增为2，当调用<code>operator []</code>的时候由于<code>test1</code>不是<code>const</code>，所以会为<code>test1</code>拷贝一份副本。最后结果是：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">test1[<span class="number">1</span>] == <span class="number">20</span>;</span><br><span class="line">test2[<span class="number">1</span>] == <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这样看来没有问题，但不幸的是我们有时候也会这样写：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>&amp; v = test1[<span class="number">1</span>];</span><br><span class="line">QVector&lt;<span class="keyword">int</span>&gt; test2 = test1;</span><br><span class="line">v = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>上面这份代码会带来一个意想不到的结果：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">test1[<span class="number">1</span>] == <span class="number">20</span>;</span><br><span class="line">test2[<span class="number">1</span>] == <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>因为在运行<code>int&amp; v = test1[1];</code>这句代码的时候，数据块的引用计数为1，<code>detach</code>函数认为数据块没有共享，所以无需拷贝数据。当执行<code>test2 = test1</code>的时候，Qt并不知道之前发生了什么，所以仅仅增加了引用计数，所以修改<code>v</code>同时修改了<code>test1</code>和<code>test2</code>。这不是我们想看到的结果，所以我们应该怎么做？注意代码执行的顺序么？得了吧，即使能保证自己会注意到代码的执行顺序问题，也不能保证其他人修改你的代码时会怎么做，最好的做法是告诉大家，我们的项目有一条规则——禁止直接引用并通过引用修改Qt容器中的对象！或者干脆，使用STL的容器吧。</p><p>最后，如果觉得Qt的隐式共享和写时拷贝技术很不错，碰巧你的项目的编写环境中也有Qt，那么使用<code>QSharedData</code>和<code>QSharedDataPointer</code>会让你的工作轻松很多。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Q_DECLARE_TYPEINFO让Qt优化容器算法</title>
      <link href="/2021/06/15/use-Q_DECLARE_TYPEINFO-to-optimize-the-container/"/>
      <url>/2021/06/15/use-Q_DECLARE_TYPEINFO-to-optimize-the-container/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如果需要使用Qt容器，那么使用<code>Q_DECLARE_TYPEINFO</code>让Qt了解容器内元素的类型特征是一个不错的做法。因为Qt可以通过识别<code>Q_DECLARE_TYPEINFO</code>给定的类型特征，在容器中采用不同的算法和内存模型以达到计算速度和内存使用上的优化。</p><p><code>Q_DECLARE_TYPEINFO(Type, Flags)</code>的使用非常简单，在定义了数据结构之后，通过指定类型名和枚举标识来指定这个类型特征，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(Point2D, Q_PRIMITIVE_TYPE);</span><br></pre></td></tr></table></figure><ul><li><code>Q_PRIMITIVE_TYPE</code>指定Type是没有构造函数或析构函数的POD(plain old data) 类型，并且<code>memcpy()</code>可以这种类型创建有效的独立副本的对象。</li><li><code>Q_MOVABLE_TYPE</code>指定Type具有构造函数或析构函数，但可以使用<code>memcpy()</code>在内存中移动。注意：尽管有叫做move，但是这个和移动构造函数或移动语义无关。</li><li><code>Q_COMPLEX_TYPE</code>（默认值）指定Type具有构造函数和析构函数，并且可能不会在内存中移动。</li></ul><p>再来看看<code>Q_DECLARE_TYPEINFO</code>的具体实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QTypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        isSpecialized = std::is_enum&lt;T&gt;::value, <span class="comment">// don&#x27;t require every enum to be marked manually</span></span><br><span class="line">        isPointer = <span class="literal">false</span>,</span><br><span class="line">        isIntegral = std::is_integral&lt;T&gt;::value,</span><br><span class="line">        isComplex = !qIsTrivial&lt;T&gt;(),</span><br><span class="line">        isStatic = <span class="literal">true</span>,</span><br><span class="line">        isRelocatable = qIsRelocatable&lt;T&gt;(),</span><br><span class="line">        isLarge = (<span class="built_in"><span class="keyword">sizeof</span></span>(T)&gt;<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*)),</span><br><span class="line">        isDummy = <span class="literal">false</span>, </span><br><span class="line">        sizeOf = <span class="built_in"><span class="keyword">sizeof</span></span>(T)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_TYPEINFO_BODY(TYPE, FLAGS) \</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QTypeInfo</span>&lt;</span>TYPE &gt; \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">public</span>: \</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> \</span><br><span class="line">        isSpecialized = <span class="literal">true</span>, \</span><br><span class="line">        isComplex = (((FLAGS) &amp; Q_PRIMITIVE_TYPE) == <span class="number">0</span>) &amp;&amp; !qIsTrivial&lt;TYPE&gt;(), \</span><br><span class="line">        isStatic = (((FLAGS) &amp; (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == <span class="number">0</span>), \</span><br><span class="line">        isRelocatable = !isStatic || ((FLAGS) &amp; Q_RELOCATABLE_TYPE) || qIsRelocatable&lt;TYPE&gt;(), \</span><br><span class="line">        isLarge = (<span class="built_in"><span class="keyword">sizeof</span></span>(TYPE)&gt;<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*)), \</span><br><span class="line">        isPointer = <span class="literal">false</span>, \</span><br><span class="line">        isIntegral = std::is_integral&lt; TYPE &gt;::value, \</span><br><span class="line">        isDummy = (((FLAGS) &amp; Q_DUMMY_TYPE) != <span class="number">0</span>), \</span><br><span class="line">        sizeOf = <span class="built_in"><span class="keyword">sizeof</span></span>(TYPE) \</span><br><span class="line">    &#125;; \</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> #TYPE; &#125; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_TYPEINFO(TYPE, FLAGS) \</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; \</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO_BODY</span>(TYPE, FLAGS)</span><br></pre></td></tr></table></figure><p>可以看出<code>Q_DECLARE_TYPEINFO</code>是一个典型的模板特化和模板enum hack结合的例子，代码使用宏<code>Q_DECLARE_TYPEINFO_BODY</code>定义了一个<code>QTypeInfo</code>的特化版本<code>class QTypeInfo&lt;TYPE &gt;</code>，并且使用定义给定的标志，计算出了一系列枚举值，例如<code>isComplex</code>、<code>isStatic</code>等。</p><p>Qt预定义了自己类型的<code>QTypeInfo</code>以便让它们在容器中获得更高的处理效率，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">bool</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">char</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">signed</span> <span class="keyword">char</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(uchar, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">short</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(ushort, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">int</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(uint, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">long</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(ulong, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(qint64, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(quint64, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">float</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">double</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">long</span> <span class="keyword">double</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">char16_t</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">char32_t</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">wchar_t</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(<span class="keyword">long</span> <span class="keyword">double</span>, Q_PRIMITIVE_TYPE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QFileSystemWatcherPathKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QLoggingRule, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QProcEnvKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QProcEnvValue, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QResourceRoot, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QConfFileCustomFormat, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsIniKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsIniSection, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsKey, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSettingsGroup, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QModelIndex, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QItemSelectionRange, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QBasicTimer, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(pollfd, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QSocketNotifierSetUNIX, Q_PRIMITIVE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(Variable, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QMetaMethod, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QMetaEnum, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QMetaClassInfo, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QArgumentType, Q_MOVABLE_TYPE);</span><br><span class="line"><span class="built_in">Q_DECLARE_TYPEINFO</span>(QCustomTypeInfo, Q_MOVABLE_TYPE);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Qt容器类型</span></span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QList);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QVector);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QQueue);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QStack);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QSet);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QMap);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QMultiMap);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QHash);</span><br><span class="line"><span class="built_in">Q_DECLARE_MOVABLE_CONTAINER</span>(QMultiHash);</span><br></pre></td></tr></table></figure><p>最后让我们来看看Qt容器如何利用<code>QTypeInfo</code>来优化容器算法的。以我们之前介绍过的<code>QList</code>为例，<code>QList</code>会因为类型大小的不同采用不同的内存布局和构造方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Q_INLINE_TEMPLATE <span class="keyword">void</span> QList&lt;T&gt;::<span class="built_in">node_construct</span>(Node *n, <span class="keyword">const</span> T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) n-&gt;v = <span class="keyword">new</span> <span class="built_in">T</span>(t);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isComplex) <span class="built_in"><span class="keyword">new</span></span> (n) <span class="built_in">T</span>(t);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__IBMCPP__)) &amp;&amp; !defined(__OPTIMIZE__)</span></span><br><span class="line">    <span class="keyword">else</span> *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(n) = t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">else</span> ::<span class="built_in">memcpy</span>(n, <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;(&amp;t), <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Q_INLINE_TEMPLATE <span class="keyword">void</span> QList&lt;T&gt;::<span class="built_in">node_destruct</span>(Node *n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) <span class="keyword">delete</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(n-&gt;v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isComplex) <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(n)-&gt;~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Q_INLINE_TEMPLATE <span class="keyword">void</span> QList&lt;T&gt;::<span class="built_in">node_copy</span>(Node *from, Node *to, Node *src)</span><br><span class="line">&#123;</span><br><span class="line">    Node *current = from;</span><br><span class="line">    <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) &#123;</span><br><span class="line">        QT_TRY &#123;</span><br><span class="line">            <span class="keyword">while</span>(current != to) &#123;</span><br><span class="line">                current-&gt;v = <span class="keyword">new</span> <span class="built_in">T</span>(*<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(src-&gt;v));</span><br><span class="line">                ++current;</span><br><span class="line">                ++src;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">QT_CATCH</span>(...) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current-- != from)</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(current-&gt;v);</span><br><span class="line">            QT_RETHROW;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (QTypeInfo&lt;T&gt;::isComplex) &#123;</span><br><span class="line">        QT_TRY &#123;</span><br><span class="line">            <span class="keyword">while</span>(current != to) &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">new</span></span> (current) <span class="built_in">T</span>(*<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(src));</span><br><span class="line">                ++current;</span><br><span class="line">                ++src;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">QT_CATCH</span>(...) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current-- != from)</span><br><span class="line">                (<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(current))-&gt;~<span class="built_in">T</span>();</span><br><span class="line">            QT_RETHROW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (src != from &amp;&amp; to - from &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(from, src, (to - from) * <span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上代码可以看出，<code>QList</code>根据<code>QTypeInfo</code>中<code>isLarge</code>、<code>isStatic</code>和<code>isComplex</code>的不同采用不同的构造析构和拷贝方法。以构造为例，当表达式<code>QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic</code>计算结果为<code>true</code>时，<code>QList</code>从堆里分配新内存并且构造对象存储在<code>node</code>中。当<code>QTypeInfo&lt;T&gt;::isComplex</code>的计算结果为<code>true</code>时，<code>QList</code>采用Placement new的方式直接使用<code>node</code>内存构造对象。除此之外则简单粗暴的拷贝内存到<code>node</code>内存上。析构和拷贝也有相似处理，阅读代码很容易理解其中的含义。</p><p>我们应该怎么做？Qt默认情况下会认为类型特征<code>isStatic</code>为<code>true</code>，这会导致一些不必要的性能下降，例如<code>QList</code>会无视类型大小，采用从堆重新分配内存构造对象。所以我们应该做的是充分理解我们的对象类型是否可以安全的移动，如果可以移动请使用<code>Q_DECLARE_TYPEINFO(TYPE, Q_MOVABLE_TYPE);</code>告知Qt，这样当对象长度小于指针长度的时候，Qt可以避免访问堆来分配内存，并且直接利用已有内存，对于频繁发生的小尺寸对象的操作这种优化是非常巨大的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Run on (8 X 3600 MHz CPU s)</span><br><span class="line">CPU Caches:</span><br><span class="line">  L1 Data 32 KiB (x4)</span><br><span class="line">  L1 Instruction 32 KiB (x4)</span><br><span class="line">  L2 Unified 256 KiB (x4)</span><br><span class="line">  L3 Unified 8192 KiB (x1)</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Benchmark                                         Time             CPU   Iterations</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">BM_QListPushString&#x2F;iterations:10000000          152 ns          150 ns     10000000</span><br><span class="line">BM_QVectorPushString&#x2F;iterations:10000000        102 ns          102 ns     10000000</span><br><span class="line">BM_QListPushChar&#x2F;iterations:10000000           12.2 ns         12.5 ns     10000000</span><br><span class="line">BM_QVectorPushChar&#x2F;iterations:10000000         4.92 ns         4.69 ns     10000000</span><br></pre></td></tr></table></figure><p>详细可以阅读前面的文章《<code>QList</code> 的工作原理和运行效率浅析》。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QList 的工作原理和运行效率浅析</title>
      <link href="/2021/05/29/the-working-principle-of-qlist/"/>
      <url>/2021/05/29/the-working-principle-of-qlist/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们知道Qt为了在一些没有STL的环境中运作，开发了一套相对完整的容器。大部分Qt的容器我们都能够招到对应STL容器，例如<code>QVector</code>对应<code>std::vector</code>, <code>QMap</code>对应<code>std::map</code>，不过这其中也有一些特例，例如<code>QList</code>在STL中就没有应该的容器，<code>std::list</code>对应的Qt容器实际上是<code>QLinkedList</code>。所以在使用<code>QList</code>的时候请务必弄清楚这一点，否则可能会导致程序的运行效率的低下，让我们先看一份代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;benchmark/benchmark.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qlist&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qvector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> std::string test_buffer&#123; <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ITER_COUNTS = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QListPushString</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QList&lt;std::string&gt; test_qlist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qlist.<span class="built_in">push_back</span>(test_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QListPushString)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QVectorPushString</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QVector&lt;std::string&gt; test_qvector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qvector.<span class="built_in">push_back</span>(test_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QVectorPushString)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QListPushChar</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QList&lt;<span class="keyword">char</span>&gt; test_qlist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qlist.<span class="built_in">push_back</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QListPushChar)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_QVectorPushChar</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    QVector&lt;<span class="keyword">char</span>&gt; test_qvector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        test_qvector.<span class="built_in">push_back</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_QVectorPushChar)-&gt;<span class="built_in">Iterations</span>(ITER_COUNTS);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK_MAIN</span>();</span><br></pre></td></tr></table></figure><p>以上代码使用google benchmark统计<code>QList</code>和<code>QVector</code>的运行效率，代码采用的最简单的<code>push_back</code>函数测试两种容器对于小数据和相对较大数据的处理性能。结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Run on (8 X 3600 MHz CPU s)</span><br><span class="line">CPU Caches:</span><br><span class="line">  L1 Data 32 KiB (x4)</span><br><span class="line">  L1 Instruction 32 KiB (x4)</span><br><span class="line">  L2 Unified 256 KiB (x4)</span><br><span class="line">  L3 Unified 8192 KiB (x1)</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Benchmark                                         Time             CPU   Iterations</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">BM_QListPushString&#x2F;iterations:10000000          152 ns          150 ns     10000000</span><br><span class="line">BM_QVectorPushString&#x2F;iterations:10000000        102 ns          102 ns     10000000</span><br><span class="line">BM_QListPushChar&#x2F;iterations:10000000           12.2 ns         12.5 ns     10000000</span><br><span class="line">BM_QVectorPushChar&#x2F;iterations:10000000         4.92 ns         4.69 ns     10000000</span><br></pre></td></tr></table></figure><p>可以发现<code>QVector</code>在两种情况下的性能都占优，尤其是<code>PushChar</code>的情况优势更加明显。原因就要从<code>QList</code>的原理说起了。前面说过<code>QList</code>并不是一个链表链接的结构，它的实际结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       QListData                                 +--------------------+</span><br><span class="line">                                                 |                    |</span><br><span class="line">+------------------------+                       |      obj buffer 1  |</span><br><span class="line">|                        |                       |                    |</span><br><span class="line">|      ptr to buffer 1   +-----------------------&gt;                    |</span><br><span class="line">|                        |                       +--------------------+</span><br><span class="line">+------------------------+</span><br><span class="line">|                        |                       +--------------------+</span><br><span class="line">|      ptr to buffer 2   |                       |                    |</span><br><span class="line">|                        +-----------------------&gt;      obj buffer 2  |</span><br><span class="line">+------------------------+                       |                    |</span><br><span class="line">|                        |                       |                    |</span><br><span class="line">|           .            |                       +--------------------+</span><br><span class="line">|           .            |</span><br><span class="line">|           .            |</span><br><span class="line">|                        |</span><br><span class="line">+------------------------+</span><br><span class="line">|                        |                       +--------------------+</span><br><span class="line">|                        |                       |                    |</span><br><span class="line">|      ptr to buffer N   +-----------------------&gt;                    |</span><br><span class="line">|                        |                       |      obj buffer N  |</span><br><span class="line">+------------------------+                       |                    |</span><br><span class="line">                                                 +--------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它的内部维护了一个指针（void*）的数组，该数组指向了真正的对象，它就像是一个<code>vector</code>和<code>list</code>的结合体一样。在对象占用内存大的时候（大于<code>sizeof(void*)</code>），它每次会从堆中分配内存。然后将内存的起始地址放入数组中。相对于<code>QVector</code>慢的原因是它每次都要经过堆分配内存，而<code>QVector</code>可以预分配内存从而提高<code>push_back</code>的运行效率。而对于小内存对象，他直接将其存储到数组中，这样不需要经过堆分配内存，所以相对于大内存<code>QList</code>本身也有很大的性能提升，但是由于它每次需要用到<code>sizeof(void*)</code>的内存，也会导致更多的内存分配，所以运行效率还是不如<code>QVector</code>。</p><p>当然，<code>QList</code>也有自己的优势，例如当对占用大内存对象进行重新排续的时候，<code>QVector</code>只能进行大量内存移动，而<code>QList</code>则只需要移动对象指针即可。相对于<code>std::list</code>，<code>QList</code>在单纯的<code>push_back</code>和枚举的时候也有不错的表现。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL中并行算法</title>
      <link href="/2021/04/05/parallel-algorithm-in-stl/"/>
      <url>/2021/04/05/parallel-algorithm-in-stl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>C++17标准的一个重大突破是让标准库中的部分算法支持了并行计算，这对于无处不在的多线程环境来说无疑是一个非常不错的消息。具体支持并行计算的算法可以参考提案文档<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html#algorithms.parallel.overloads">p0024r2</a>。</p><p>接下来将会选取两个典型算法函数对STL的并行算法进行介绍：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::for_each(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">            val *= val;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是一个最简单的并行计算例子，例子中使用了<code>for_each</code>函数，该函数并不是新加入到标准库的。只不过现在多了一个并行计算的版本，其中第一个参数是并行计算的策略。实际上，大部分并行计算的算法都是在原有算法的基础做了新增，它们的共同特点是第一个参数改为了并行计算策略，当然老的算法也依然存在。在这个例子中，策略<code>std::execution::par</code>是并行计算其中的一种策略。在这个策略中函数会使用多线程执行算法，并且线程在执行算法的单个步骤是不会被打断的。为了看清线程的执行情况，我们可以将线程id输出到控制台：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::for_each(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            val *= val;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这份代码就会发现线程id交替输出到控制台上，可见确实是多线程执行<code>for_each</code>函数。让我们再看看排序函数<code>std::sort</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; val2) &#123;</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这份代码同样的会发现多个线程交替输出线程id到控制台上，实际上它们正在并行计算排续该容器。并行计算的优势在数据量足够大的时候是非常明显的，比如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    coll.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        coll.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::<span class="built_in">sort</span>(std::execution::par,</span><br><span class="line">        coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; val2) &#123;</span><br><span class="line">            <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; diff = end - start;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;elapsed time = &quot;</span> &lt;&lt; diff.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向排序100000个数，使用并行算法在我的机器上消耗了0.48秒。如果删除第一个参数使用传统单线程排续，在我的机器上消耗0.89秒，并行计算性能提升近1倍。</p><p>最后来介绍一下C++17中的3种并行计算策略：</p><ul><li><p><code>std::execution::seq</code> 该策略与非并行算法一样，当前执行线程逐个元素依次执行必要的操作。 使用该策略的行为类似于使用完全不接受任何执行策略的非并行调用算法的方式。</p></li><li><p><code>std::execution::par</code> 该策略会让多个线程执行元素的必要操作。 当算法开始执行必要的操作时，它会一直执行到操作结束，不会被打断。</p></li><li><p><code>std::execution::par_unseq</code> 该策略会让多个线程执行元素的必要操作，但是与<code>std::execution::par</code>不同的是，该策略不能保证一个线程执行完该元素的所有步骤而不被打断。在提案文档中也指出了错误示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">std::for_each(std::execution::par_unseq, </span><br><span class="line">              std::<span class="built_in">begin</span>(a), std::<span class="built_in">end</span>(a), [&amp;](<span class="keyword">int</span>) &#123;</span><br><span class="line">  std::lock_guard&lt;mutex&gt; <span class="built_in">guard</span>(m); <span class="comment">// Error: lock_guard constructor calls m.lock()</span></span><br><span class="line">  ++x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里由于<code>std::execution::par_unseq</code> 无法保证执行lambda表达式的时候不被打断，可能会造成同一个线程两次次进入lambda表达式，并且调用<code>m.lock()</code>导致死锁。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++在线工具</title>
      <link href="/2021/03/20/intro-3-cpp-online-tools/"/>
      <url>/2021/03/20/intro-3-cpp-online-tools/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这篇博客打算介绍4个C++在线工具，当手头没有设备或者没有开发环境的时候可以用它们做一些研究性质的工作。</p><ol><li><p><a href="https://wandbox.org/">https://wandbox.org/</a></p><p>该网站可以在线编辑以及编译C++源代码并且运行编译后的程序。在C++类别它支持GCC和CLANG，另外除了C++，C、C#、Java、GO等等都有支持。</p></li><li><p><a href="https://quick-bench.com/">https://quick-bench.com/</a></p><p>这也是一个可以在线编辑以及编译C++源代码并且运行编译后的程序的网站，但是与上面网站不同的是它运行程序并非用来输出结果，而是对函数做基准检测，采用的是Google Benchmark。同样它支持GCC和CLANG。</p></li><li><p><a href="https://godbolt.org/">https://godbolt.org/</a></p><p>这是我很喜欢的一个网站，它可以在线编辑和编译C++源代码，但是不可以运行程序。但是这并不能掩盖其优秀的地方，它支持C++各种编译器的各种版本，跨度非常大也非常全面。同时还可以自由设置编译器的编译参数并且查看输出的中间文件，对于研究C++编译过程十分有用。</p></li><li><p><a href="https://cppinsights.io/">https://cppinsights.io/</a></p><p>这是一个非常有趣的网站，它能够将源代码展开，使用一种容易理解的方式展示编译器做了哪些自动化工作。用它自己的话来说，就是从编译器的视角看到的源代码。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> arr[<span class="number">10</span>]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>&amp; c : arr)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被网站展开为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  &#123;</span><br><span class="line">    char const (&amp;__range1)[10] = arr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * __begin1 = __range1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * __end1 = __range1 + <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">for</span>(; __begin1 != __end1; ++__begin1) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> &amp; c = *__begin1;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决vs2019编译qt5.15.2的错误</title>
      <link href="/2021/02/03/msvc-build-qt5.15.2-error/"/>
      <url>/2021/02/03/msvc-build-qt5.15.2-error/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>记录一下编译qt-everywhere-src-5.15.2中qtwebengine遇到的问题。</p><p>第一、在windows上用vs2019编译qtwebengine的时候需要patch其中的3个文件，否则会报错。错误看起来好像是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ninja: build stopped: subcommand failed. </span><br><span class="line">NMAKE : fatal error U1077: &#39;call&#39; : return code &#39;0x1&#39;</span><br><span class="line">NMAKE : fatal error U1077: &#39;&quot;...\nmake.exe&quot;&#39; : return code &#39;0x2&#39; Stop.</span><br><span class="line">NMAKE : fatal error U1077: &#39;(&#39; : return code &#39;0x2&#39; Stop.</span><br><span class="line">NMAKE : fatal error U1077: &#39;cd&#39; : return code &#39;0x2&#39; Stop.</span><br><span class="line">NMAKE : fatal error U1077: &#39;cd&#39; : return code &#39;0x2&#39; Stop</span><br></pre></td></tr></table></figure><p>但实际问题是代码在vs2019的cl里编译出错了，C4244警告被当成错误报出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FAILED: obj&#x2F;third_party&#x2F;angle&#x2F;angle_common&#x2F;mathutil.obj</span><br><span class="line">...</span><br><span class="line">..&#x2F;..&#x2F;3rdparty&#x2F;chromium&#x2F;third_party&#x2F;angle&#x2F;src&#x2F;common&#x2F;mathutil.cpp(75): error C4244: &#39;&#x3D;&#39;: conversion from &#39;double&#39; to &#39;float&#39;, possible loss of data</span><br><span class="line">..&#x2F;..&#x2F;3rdparty&#x2F;chromium&#x2F;third_party&#x2F;angle&#x2F;src&#x2F;common&#x2F;mathutil.cpp(77): error C4244: &#39;&#x3D;&#39;: conversion from &#39;double&#39; to &#39;float&#39;, possible loss of data</span><br><span class="line">..&#x2F;..&#x2F;3rdparty&#x2F;chromium&#x2F;third_party&#x2F;angle&#x2F;src&#x2F;common&#x2F;mathutil.cpp(79): error C4244: &#39;&#x3D;&#39;: conversion from &#39;double&#39; to &#39;float&#39;, possible loss of data</span><br></pre></td></tr></table></figure><p>所以需要打个补丁，手动修改也行吧，代码量很少：<br><a href="https://codereview.qt-project.org/c/qt/qtwebengine-chromium/+/321741">https://codereview.qt-project.org/c/qt/qtwebengine-chromium/+/321741</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">From 138a7203f16cf356e9d4dac697920a22437014b0 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: Peter Varga &lt;pvarga@inf.u-szeged.hu&gt;</span><br><span class="line">Date: Fri, 13 Nov 2020 11:09:23 +0100</span><br><span class="line">Subject: [PATCH] Fix build with msvc2019 16.8.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Fixes: QTBUG-88708</span><br><span class="line">Change-Id: I3554ceec0437801b4861f68edd504d01fc01cf93</span><br><span class="line">Reviewed-by: Allan Sandfeld Jensen &lt;allan.jensen@qt.io&gt;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;chromium&#x2F;third_party&#x2F;angle&#x2F;src&#x2F;common&#x2F;mathutil.cpp b&#x2F;chromium&#x2F;third_party&#x2F;angle&#x2F;src&#x2F;common&#x2F;mathutil.cpp</span><br><span class="line">index 306cde1..d4f1034 100644</span><br><span class="line">--- a&#x2F;chromium&#x2F;third_party&#x2F;angle&#x2F;src&#x2F;common&#x2F;mathutil.cpp</span><br><span class="line">+++ b&#x2F;chromium&#x2F;third_party&#x2F;angle&#x2F;src&#x2F;common&#x2F;mathutil.cpp</span><br><span class="line">@@ -72,11 +72,11 @@</span><br><span class="line">     const RGB9E5Data *inputData &#x3D; reinterpret_cast&lt;const RGB9E5Data *&gt;(&amp;input);</span><br><span class="line">     *red &#x3D;</span><br><span class="line">-        inputData-&gt;R * pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">+        inputData-&gt;R * (float)pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">     *green &#x3D;</span><br><span class="line">-        inputData-&gt;G * pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">+        inputData-&gt;G * (float)pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">     *blue &#x3D;</span><br><span class="line">-        inputData-&gt;B * pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">+        inputData-&gt;B * (float)pow(2.0f, (int)inputData-&gt;E - g_sharedexp_bias - g_sharedexp_mantissabits);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  &#x2F;&#x2F; namespace gl</span><br><span class="line">diff --git a&#x2F;chromium&#x2F;third_party&#x2F;blink&#x2F;renderer&#x2F;platform&#x2F;graphics&#x2F;lab_color_space.h b&#x2F;chromium&#x2F;third_party&#x2F;blink&#x2F;renderer&#x2F;platform&#x2F;graphics&#x2F;lab_color_space.h</span><br><span class="line">index 78c316e..136c796 100644</span><br><span class="line">--- a&#x2F;chromium&#x2F;third_party&#x2F;blink&#x2F;renderer&#x2F;platform&#x2F;graphics&#x2F;lab_color_space.h</span><br><span class="line">+++ b&#x2F;chromium&#x2F;third_party&#x2F;blink&#x2F;renderer&#x2F;platform&#x2F;graphics&#x2F;lab_color_space.h</span><br><span class="line">@@ -130,7 +130,7 @@</span><br><span class="line">   &#x2F;&#x2F; https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CIELAB_color_space#Forward_transformation.</span><br><span class="line">   FloatPoint3D toXYZ(const FloatPoint3D&amp; lab) const &#123;</span><br><span class="line">     auto invf &#x3D; [](float x) &#123;</span><br><span class="line">-      return x &gt; kSigma ? pow(x, 3) : 3 * kSigma2 * (x - 4.0f &#x2F; 29.0f);</span><br><span class="line">+      return x &gt; kSigma ? (float)pow(x, 3) : 3 * kSigma2 * (x - 4.0f &#x2F; 29.0f);</span><br><span class="line">     &#125;;</span><br><span class="line">     FloatPoint3D v &#x3D; &#123;clamp(lab.X(), 0.0f, 100.0f),</span><br><span class="line">diff --git a&#x2F;chromium&#x2F;third_party&#x2F;perfetto&#x2F;src&#x2F;trace_processor&#x2F;timestamped_trace_piece.h b&#x2F;chromium&#x2F;third_party&#x2F;perfetto&#x2F;src&#x2F;trace_processor&#x2F;timestamped_trace_piece.h</span><br><span class="line">index 02363d0..8860287 100644</span><br><span class="line">--- a&#x2F;chromium&#x2F;third_party&#x2F;perfetto&#x2F;src&#x2F;trace_processor&#x2F;timestamped_trace_piece.h</span><br><span class="line">+++ b&#x2F;chromium&#x2F;third_party&#x2F;perfetto&#x2F;src&#x2F;trace_processor&#x2F;timestamped_trace_piece.h</span><br><span class="line">@@ -198,6 +198,20 @@</span><br><span class="line">     return *this;</span><br><span class="line">   &#125;</span><br><span class="line">+#if PERFETTO_BUILDFLAG(PERFETTO_COMPILER_MSVC)</span><br><span class="line">+  TimestampedTracePiece&amp; operator&#x3D;(TimestampedTracePiece&amp;&amp; ttp) const</span><br><span class="line">+  &#123;</span><br><span class="line">+    if (this !&#x3D; &amp;ttp) &#123;</span><br><span class="line">+      &#x2F;&#x2F; First invoke the destructor and then invoke the move constructor</span><br><span class="line">+      &#x2F;&#x2F; inline via placement-new to implement move-assignment.</span><br><span class="line">+      this-&gt;~TimestampedTracePiece();</span><br><span class="line">+      new (const_cast&lt;TimestampedTracePiece*&gt;(this)) TimestampedTracePiece(std::move(ttp));</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    return const_cast&lt;TimestampedTracePiece&amp;&gt;(*this);</span><br><span class="line">+  &#125;</span><br><span class="line">+#endif  &#x2F;&#x2F; PERFETTO_BUILDFLAG(PERFETTO_COMPILER_MSVC)</span><br><span class="line">+</span><br><span class="line">   ~TimestampedTracePiece() &#123;</span><br><span class="line">     switch (type) &#123;</span><br><span class="line">       case Type::kInvalid:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二、在Windows上编译blink的pch也会有些问题，报错找不到头文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qt5&#x2F;qtwebengine&#x2F;src&#x2F;3rdparty&#x2F;chromium&#x2F;third_party&#x2F;WebKit&#x2F;Source&#x2F;core&#x2F;win&#x2F;Precompile-core.cpp: fatal error C1083: Cannot open include file: </span><br><span class="line">&#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;qt5srcgit&#x2F;qt5&#x2F;qtwebengine&#x2F;src&#x2F;3rdparty&#x2F;chromium&#x2F;third_party&#x2F;WebKit&#x2F;Source&#x2F;core&#x2F;Precompile-core.h&#39;: No such file or directory</span><br></pre></td></tr></table></figure><p>需要patch两个文件blink/renderer/platform/BUILD.gn 和 blink/renderer/core/BUILD.gn</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--- qtwebengine&#x2F;src&#x2F;3rdparty&#x2F;chromium&#x2F;third_party&#x2F;blink&#x2F;renderer&#x2F;platform&#x2F;BUILD.gn</span><br><span class="line">+++ qtwebengine&#x2F;src&#x2F;3rdparty&#x2F;chromium&#x2F;third_party&#x2F;blink&#x2F;renderer&#x2F;platform&#x2F;BUILD.gn</span><br><span class="line">@@ -204,7 +204,7 @@</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config(&quot;blink_platform_pch&quot;) &#123;</span><br><span class="line">   if (enable_precompiled_headers) &#123;</span><br><span class="line">-    if (is_win) &#123;</span><br><span class="line">+    if (false) &#123;</span><br><span class="line">       # This is a string rather than a file GN knows about. It has to match</span><br><span class="line">       # exactly what&#39;s in the &#x2F;FI flag below, and what might appear in the</span><br><span class="line">       # source code in quotes for an #include directive.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用std::any代替std::shared_ptr&lt;void&gt;和void *</title>
      <link href="/2021/01/03/use-any-instead-of-shared_ptr-and-void/"/>
      <url>/2021/01/03/use-any-instead-of-shared_ptr-and-void/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>大家在编写程序的时候应该遇到过这样一个场景，该场景需要传递某种数据，但是数据类型和数据大小并不确定，这种时候我们常用<code>void *</code>类型的变量来保存对象指针。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span> </span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="keyword">void</span>* user_data; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的结构体只是一个示例，代表有的数据是用户产生的。当用户数据是一个字符串时，可能的代码是：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SomeData sd&#123;&#125;;</span><br><span class="line">sd.user_data = <span class="keyword">new</span> std::string&#123; <span class="string">&quot;hello world&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>另外，使用<code>void*</code>存储数据需要了解数据类型，并且需要自己维护数据的生命周期：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string *str = <span class="keyword">static_cast</span>&lt;std::string *&gt;(sd.user_data);</span><br><span class="line"><span class="keyword">delete</span> str;</span><br><span class="line">str = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>使用<code>std::shared_ptr&lt;void&gt;</code>可以解决生命周期的问题：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">void</span>&gt; user_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeData sd&#123;&#125;;</span><br><span class="line">sd.user_data = std::make_shared&lt;std::string&gt;(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ud = std::static_pointer_cast&lt;std::string&gt;(sd.user_data);</span><br></pre></td></tr></table></figure><p>虽然<code>std::shared_ptr&lt;void&gt;</code>可以用于管理生命周期，但是类型安全的问题却无法解决。比如当<code>user_data</code>销毁时，由于缺乏类型信息会导致对象无法正确析构。</p><p>为了解决以上这些问题，C++17标准库引入<code>std::any</code>。顾名思义就是可以存储任意类型，我们可以将其理解为带有类型信息的<code>void*</code>。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">any</span> &#123;</span></span><br><span class="line"> <span class="keyword">void</span>* object;</span><br><span class="line"> type_info tinfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，<code>std::any</code>的实现比这个要复杂的多，我们后面再讨论类型是如何被记录下来的。先来看看<code>std::any</code>的用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;any&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::any a;</span><br><span class="line">    a = std::string&#123; <span class="string">&quot;hello world&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> str = std::any_cast&lt;std::string&gt;(a);</span><br><span class="line">    std::cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了转换为对象本身，还可以转换为引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; str1 = std::any_cast&lt;std::string&amp;&gt;(a);</span><br><span class="line"><span class="keyword">auto</span>&amp; str2 = std::any_cast&lt;<span class="keyword">const</span> std::string&amp;&gt;(a);</span><br></pre></td></tr></table></figure><p>当转换类型不正确时，<code>std::any_cast</code>会抛出异常<code>std::bad_any_cast</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; std::any_cast&lt;<span class="keyword">double</span>&gt;(a) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::bad_any_cast&amp;) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Wrong Type!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果转换的不是对象而是对象指针，那么<code>std::any_cast</code>不会抛出异常，而是返回空指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>* ptr = std::any_cast&lt;std::string&gt;(&amp;a);</span><br><span class="line"><span class="keyword">if</span>(ptr) &#123;</span><br><span class="line"> std::cout &lt;&lt; *ptr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Wrong Type!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，使用<code>std::any_cast</code>转换类型必须和<code>std::any</code>对象的存储类型完全一致，否则同样会抛出异常，即使两者是继承关系。原因很简单，<code>std::any_cast</code>是直接使用<code>type_info</code>作比较：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> type_info* <span class="keyword">const</span> _Info = _TypeInfo();</span><br><span class="line"><span class="keyword">if</span> (!_Info || *_Info != <span class="built_in"><span class="keyword">typeid</span></span>(_Decayed)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后简单描述一下<code>std::any</code>保证类型安全的原理：</p><p>首先是类型转换，刚刚已经提到了，<code>std::any</code>会记录对象的<code>type_info</code>，<code>std::any_cast</code>使用<code>type_info</code>作比较，只有完全一致才能进行转换。</p><p>其次为了保证类型正确的拷贝，移动以及生命周期结束时能够正确析构，在创建<code>std::any</code>对象时生成一些函数模板实例，这些函数模板调用了类型的拷贝，移动以及析构函数。<code>std::any</code>只需要记录这些函数模板实例的指针即可。拿析构简单举例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_impl</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;T*&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> destory_ptr = <span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">void</span>* <span class="keyword">const</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnyMetadata</span> &#123;</span></span><br><span class="line">    destory_ptr func;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_anymeta</span><span class="params">(AnyMetadata &amp;meta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    meta.func = destroy_impl&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// any构造时知道目标对象类型，此时可以保存函数指针</span></span><br><span class="line">AnyMetadata metadata;</span><br><span class="line">create_anymeta&lt;std::string&gt;(metadata);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any销毁时调用</span></span><br><span class="line">metadata.<span class="built_in">func</span>(obj);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用std::sample获取随机样本</title>
      <link href="/2020/12/26/use-sample-to-get-random-samples/"/>
      <url>/2020/12/26/use-sample-to-get-random-samples/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>C++17标准库提供了一个<code>std::sample</code>函数模板用于获取随机样本，该样本是输入全体样本的一个子集。具体例子如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sample</span>(data.<span class="built_in">begin</span>(), </span><br><span class="line">        data.<span class="built_in">end</span>(),</span><br><span class="line">        std::ostream_iterator&lt;<span class="keyword">int</span>&gt;&#123;std::cout, <span class="string">&quot;\n&quot;</span>&#125;,</span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line">        std::default_random_engine&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>std::sample</code>需要5个参数，其中前2个参数是全体样本的合计的<code>begin</code>和<code>end</code>迭代器，它定义了全体样本的范围。第3个参数则是输出迭代器，第4个参数是需要样本的数量，最后是随机数引擎。注意这里<code>std::default_random_engine</code>没有设置<code>seed</code>，这必然导致每次运行获取的样本相同。</p><p>以上代码的输出结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">488</span><br><span class="line">963</span><br><span class="line">1994</span><br><span class="line">2540</span><br><span class="line">2709</span><br><span class="line">2835</span><br><span class="line">3518</span><br><span class="line">5172</span><br><span class="line">7996</span><br></pre></td></tr></table></figure><p>我们可以为随机数引擎设置<code>seed</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::random_device rd;</span><br><span class="line">std::default_random_engine eng&#123; <span class="built_in">rd</span>() &#125;;</span><br><span class="line">std::<span class="built_in">sample</span>(data.<span class="built_in">begin</span>(), </span><br><span class="line">    data.<span class="built_in">end</span>(),</span><br><span class="line">    std::ostream_iterator&lt;<span class="keyword">int</span>&gt;&#123;std::cout, <span class="string">&quot;\n&quot;</span>&#125;,</span><br><span class="line">    <span class="number">10</span>,</span><br><span class="line">    eng);</span><br></pre></td></tr></table></figure><p>这样每次样本就会发生变化。另外<code>std::sample</code>是有返回值的，返回的是最后一个随机样本之后的迭代器。它的作用是确定随机样本在输出容器中的范围，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; out_data;</span><br><span class="line">    out_data.<span class="built_in">resize</span>(<span class="number">100</span>);</span><br><span class="line">    std::random_device rd;</span><br><span class="line">    std::default_random_engine eng&#123; <span class="built_in">rd</span>() &#125;;</span><br><span class="line">    <span class="keyword">auto</span> end = std::<span class="built_in">sample</span>(data.<span class="built_in">begin</span>(), </span><br><span class="line">        data.<span class="built_in">end</span>(),</span><br><span class="line">        out_data.<span class="built_in">begin</span>(),</span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line">        eng);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;coll size: &quot;</span> </span><br><span class="line">        &lt;&lt; out_data.<span class="built_in">size</span>() </span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = out_data.<span class="built_in">begin</span>(); it != end; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出结果为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">coll size: <span class="number">100</span></span><br><span class="line"><span class="number">1708</span></span><br><span class="line"><span class="number">1830</span></span><br><span class="line"><span class="number">2803</span></span><br><span class="line"><span class="number">3708</span></span><br><span class="line"><span class="number">5146</span></span><br><span class="line"><span class="number">7376</span></span><br><span class="line"><span class="number">7867</span></span><br><span class="line"><span class="number">8059</span></span><br><span class="line"><span class="number">8271</span></span><br><span class="line"><span class="number">9448</span></span><br></pre></td></tr></table></figure><p>可以看到，虽然容器的大小是100，但是我们只填充10个随机样本。最后需要说明一下<code>std::sample</code>对于两个迭代器参数的要求，首先源迭代器至少是一个输入迭代器的时候，目标迭代器至少可以是一个输出迭代器。但是当源迭代器不是一个向前迭代器，那么目标迭代器必须是一个随机迭代器。这一点很好理解，当源迭代器不能确保随机的情况下，只能将目的迭代器随机以确保样本的随机性。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现一个类似std::bind的功能</title>
      <link href="/2020/11/18/mybind/"/>
      <url>/2020/11/18/mybind/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前两天有朋友问我<code>std::bind</code>是如何实现的，对照STL讲述原理后朋友表示还是很难理解，这可以理解，因为STL涉及到的东西太多，很难清晰的将核心部分显式出来。为了解释清楚这个问题，我自己实现了一个bind功能。当然了，比<code>std::bind</code>要简单非常非常多，缺少很多有用的特性，但是也能展示bind的核心原理了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> _Nx&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyPh</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">0</span>&gt; _0;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">1</span>&gt; _1;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">2</span>&gt; _2;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">3</span>&gt; _3;</span><br><span class="line"><span class="keyword">constexpr</span> _MyPh&lt;<span class="number">4</span>&gt; _4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span> ... Arg&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">MyBind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _MyBind(F f, Arg ... arg) : _MyList(arg...), _f(f) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... CallArg&gt;</span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(CallArg... arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        _MyBind&lt;R, F, CallArg...&gt; c(0, arg...);</span><br><span class="line">        std::<span class="keyword">size_t</span> <span class="keyword">constexpr</span> tSize </span><br><span class="line">            = std::tuple_size&lt;std::tuple&lt;Arg...&gt;&gt;::value;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">call_tuple</span>(_f, _MyList, </span><br><span class="line">            c, std::make_index_sequence&lt;tSize&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Tuple, <span class="keyword">typename</span> C, <span class="keyword">size_t</span> ...S&gt;</span><br><span class="line">    <span class="function">R <span class="title">call_tuple</span><span class="params">(F f, Tuple t, C c, std::index_sequence&lt;S...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(c[std::get&lt;S&gt;(_MyList)]...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="keyword">operator</span>[] (T &amp;t) &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt; <span class="keyword">typename</span> std::tuple_element&lt;N, </span><br><span class="line">        std::tuple&lt;Arg...&gt;&gt;::type <span class="keyword">operator</span>[] (_MyPh&lt;N&gt;) </span><br><span class="line">    &#123; </span><br><span class="line">            <span class="keyword">return</span> std::get&lt;N&gt;(_MyList);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tuple&lt;Arg...&gt; _MyList;</span><br><span class="line">    F _f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span> ... Arg&gt; </span><br><span class="line">    _MyBind&lt;R, F, Arg...&gt; mybind(F f, Arg ... arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _MyBind&lt;R, F, Arg...&gt;(f, arg...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> myfunc = mybind&lt;<span class="keyword">int</span>&gt;(sum, _0, <span class="number">2</span>, _1)(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先占位符其实就是一个空类型，我们不需要类型里有什么，只是想要一个类型标识符。</p><p>然后看到最关键的<code>_MyBind</code>类模板，该类模板有数据成员<code>_MyList</code>和<code>_f</code>，用于存放绑定的函数和参数。在构造对象的时候数据成员会被填充，并且在调用<code>template&lt;typename ... CallArg&gt; R operator()(CallArg... arg)</code>的时候使用这两个数据成员。这里比较难理解的是<code>call_tuple</code>函数模板，该函数需要将绑定的参数列表和后续调用的参数列表传入函数，</p><p>最后使用SFINAE的技巧有选择的通过<code>operator[]</code>获取对应的值。如果<code>std::get&lt;S&gt;(_MyList)</code>返回的是绑定的具体值，那么通过<code>template&lt;typename T&gt; T operator[] (T &amp;t) &#123; return t; &#125;</code>返回值本身，注意这里的<code>t</code>是最外层<code>_MyList</code>中的元素；如果<code>std::get&lt;S&gt;(_MyList)</code>返回的是占位符，那么将通过<code>template&lt;int N&gt; typename std::tuple_element&lt;N, std::tuple&lt;Arg...&gt;&gt;::type operator[] (_MyPh&lt;N&gt;) &#123; return std::get&lt;N&gt;(_MyList); &#125;</code>返回<code>c</code>中<code>_MyList</code>的元素，请注意这里的<code>this</code>对象是<code>c</code>。</p><p>当然为了使用方便需要一个函数模板<code>mybind</code>，它只需要指定一个返回类型就可以使用了。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用std::span代替数组指针传参</title>
      <link href="/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/"/>
      <url>/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们知道<code>std::string_view</code>可以创建<code>std::string</code>的一个视图，视图本身并不拥有实例，它只是保持视图映射的状态。在不修改实例的情况下，使用<code>std::string_view</code>会让字符串处理的性能大幅提升。实际上，对于那些连续的序列对象我们都可以创建这样一份视图，对于<code>std::vector</code>这样的对象可以提高某些操作中的性能，另外对原生数组可以提高其访问的安全性。</p><p>过去如果一个函数想接受无法确定数组长度的数组作为参数，那么一定需要声明两个参数：数组指针和长度：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_data</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">set_data</span>(buf, <span class="number">128</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种人工输入增加了编码的风险，数组长度的错误输入会引发程序的未定义行为，甚至是成为可被利用的漏洞。C++20标准库为我们提供了一个很好解决方案<code>std::span</code>，通过它可以定义一个基于连续序列对象的视图，包括原生数组，并且保留连续序列对象的大小。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;span&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_data</span><span class="params">(std::span&lt;<span class="keyword">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arr.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">set_data</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了原生数组，<code>std::vector</code>和<code>std::array</code>也在<code>std::span</code>的处理之列：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; buf1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 3&gt; buf2&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">set_data</span>(buf1);</span><br><span class="line"><span class="built_in">set_data</span>(buf2);</span><br></pre></td></tr></table></figure><p>值得注意的是，<code>std::span</code>还可以通过构造函数设置连续序列对象的长度：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buf[<span class="number">128</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">set_data</span>(&#123; buf, <span class="number">16</span> &#125;);</span><br></pre></td></tr></table></figure><p>从<code>std::string_view</code>到<code>std::span</code>，我们可以看出C++标准库很乐于这种视图设计，因为这种设计和抽象的实现可以提高C ++程序的可靠性而又不牺牲性能和可移植性。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用std::string_view提升字符串处理性能</title>
      <link href="/2020/09/25/use-string_view-to-improve-string-processing-performance/"/>
      <url>/2020/09/25/use-string_view-to-improve-string-processing-performance/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>C++标准库提供了一个非常优秀的字符串处理类<code>std::string</code>，我们可以通过该类完成各种字符串操作。但是<code>std::string</code>有一个缺点，它的很多操作都是针对字符串实体，存在不必要的内存拷贝的代码，导致字符串的处理性能不尽如人意。针对这种情况C++17标准引入了<code>std::string_view</code>这个类，该类不会直接作用在字符串实体上，而是记录字符串处理的位置，这样就可以保证用最小的代价对字符串进行处理。</p><p>为了验证这个结论，下面的代码实现了一个断词器，然后针对64MB的数据做断词处理并且分别记录使用<code>std::string</code>和<code>std::string_view</code>作为基础类型时断词器运行的时间：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tokenizer</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> string_type = T;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> T::value_type;</span><br><span class="line">    <span class="built_in">tokenizer</span>(<span class="keyword">const</span> string_type&amp; str, </span><br><span class="line">        std::<span class="keyword">enable_if_t</span>&lt;std::disjunction_v&lt;</span><br><span class="line">        std::is_same&lt;string_type, std::basic_string&lt;value_type&gt;&gt;,</span><br><span class="line">        std::is_same&lt;string_type, std::basic_string_view&lt;value_type&gt;&gt;&gt;&gt;* = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">data_</span>(str), <span class="built_in">begin_</span>(<span class="number">0</span>), <span class="built_in">end_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function">string_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> value_type sep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; end_ &lt; data_.<span class="built_in">size</span>(); ++end_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data_[end_] == sep) &#123;</span><br><span class="line">                <span class="keyword">auto</span> res = data_.<span class="built_in">substr</span>(begin_, end_ - begin_);</span><br><span class="line">                begin_ = ++end_;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end_ &lt;= data_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data_.<span class="built_in">substr</span>(begin_, end_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">more</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> end_ &lt; data_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> string_type data_;</span><br><span class="line">    <span class="keyword">size_t</span> begin_, end_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">make_string_data</span><span class="params">(<span class="keyword">size_t</span> count, <span class="keyword">char</span> sep)</span> </span>&#123;</span><br><span class="line">    std::string data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + i % <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> != count)</span><br><span class="line">            data.<span class="built_in">push_back</span>(sep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string data = <span class="built_in">make_string_data</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">32</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">tokenizer&lt;std::string&gt; <span class="title">tk</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">while</span> (tk.<span class="built_in">more</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">tk</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; diff = end - start;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;elapsed time = &quot;</span> &lt;&lt; diff.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中<code>tokenizer</code>是一个断词器的类模板，接受<code>std::string</code>、<code>std::wstring</code>等<code>std::basic_string</code>模板实例化的类型，同时也能接受<code>std::string_view</code>、<code>std::wstring_view</code>等<code>std::basic_string_view</code>模板实例化的类型。这里采用了SFINAE的方法来约束<code>tokenizer</code>的模板实参必须为以上类型。如果编译环境是C++20标准，可以采用概念来约束模板实参类型。</p><p>这份代码<code>tokenizer&lt;std::string&gt;</code>运行结果是0.45秒，如果将<code>tokenizer&lt;std::string&gt;</code>替换为<code>tokenizer&lt;std::string_view&gt;</code>运行时间缩短为0.08秒，性能提升是非常明显的 。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>std::enable_shared_from_this原理浅析</title>
      <link href="/2020/08/05/something-about-enable_shared_from_this/"/>
      <url>/2020/08/05/something-about-enable_shared_from_this/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在解释<code>std::enable_shared_from_this</code>之前，先看一个<code>std::shared_ptr</code>典型用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; pt1&#123; <span class="keyword">new</span> <span class="keyword">int</span>&#123; <span class="number">10</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> pt2&#123; pt1 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时<code>pt1</code>和<code>pt2</code>共用了引用计数，当<code>pt1</code>和<code>pt2</code>的生命周期都结束时，<code>new int&#123;10&#125;</code>分配的内存会被释放。下面的做法会导致内存多次释放，因为它们没有使用共同的引用计数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pt&#123; <span class="keyword">new</span> <span class="keyword">int</span>&#123; <span class="number">10</span> &#125; &#125;;</span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; pt1&#123; pt &#125;;</span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; pt2&#123; pt &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我想应该也没有人这么使用<code>std::shared_ptr</code>。不过下面这个错误倒是比较常见：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要用this调用SomeAPI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这段代码需要在<code>NeedCallSomeAPI</code>函数中调用<code>SomeAPI</code>，而<code>SomeAPI</code>需要的是一个<code>std::shared_ptr&lt;SomeData&gt;</code>的实参。这个时候应该怎么做？</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(std::shared_ptr&lt;SomeData&gt;&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的做法是错误的，因为<code>SomeAPI</code>调用结束后<code>std::shared_ptr&lt;SomeData&gt;</code>对象的引用计数会降为0，导致<code>this</code>被意外释放。</p><p>这种情况下，我们需要使用<code>std::enable_shared_from_this </code>，使用方法很简单，只需要让<code>SomeData</code>继承<code>std::enable_shared_from_this&lt;SomeData&gt;</code>，然后调用<code>shared_from_this</code>吗，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>:</span>std::enable_shared_from_this&lt;SomeData&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::shared_ptr&lt;SomeData&gt; <span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::shared_ptr&lt;SomeData&gt;(<span class="keyword">new</span> SomeData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SomeData</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> d&#123; SomeData::<span class="built_in">Create</span>() &#125;;</span><br><span class="line">    d-&gt;<span class="built_in">NeedCallSomeAPI</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::enable_shared_from_this </code>的实现比较复杂，但是实现原理则比较简单。它内部使用了<code>std::weak_ptr</code>来帮助完成指针相关控制数据的同步，而这份数据是在创建<code>std::shared_ptr</code>的时候完成的。我们来重点解析这一点。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span> &#123;</span></span><br><span class="line"> <span class="keyword">mutable</span> weak_ptr&lt;T&gt; weak_this;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">shared_ptr&lt;T&gt; <span class="title">shared_from_this</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> shared_ptr&lt;T&gt;(weak_this); </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function">shared_ptr&lt;<span class="keyword">const</span> T&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> shared_ptr&lt;<span class="keyword">const</span> T&gt;(weak_this); </span><br><span class="line"> &#125;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上是摘要的<code>enable_shared_from_this</code>的代码，这份代码中有两个关键要素。首先<code>weak_this</code>被声明为<code>mutable</code>，这让<code>weak_this</code>可以在<code>const</code>的限定下修改，其次也是最关键的地方，该类声明了<code>shared_ptr</code>为友元。这意味着<code>std::shared_ptr</code>可以修改<code>weak_this</code>，并且<code>weak_this</code>被初始化的地方在<code>std::shared_ptr</code>中。进一步说，没有<code>std::shared_ptr</code>的<code>enable_shared_from_this</code>是没有灵魂的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeAPI</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;SomeData&gt;&amp; d)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeData</span>:</span>std::enable_shared_from_this&lt;SomeData&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NeedCallSomeAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SomeAPI</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> d&#123; <span class="keyword">new</span> SomeData &#125;;</span><br><span class="line">    d-&gt;<span class="built_in">NeedCallSomeAPI</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这份代码中调用<code>shared_from_this</code>会出错。</p><p>再深入一步，<code>std::shared_ptr</code>是如何判断实例化对象类型是否继承<code>std::enable_shared_from_this</code>，并且通过判断结果决定是否初始化<code>weak_this</code>的呢？答案是SFINAE(“<em>Substitution Failure Is Not An Error</em>“)。</p><p>让我们查看VS2019的STL代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> _Esft_type = enable_shared_from_this;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yty</span>, <span class="keyword">class</span> =</span> <span class="keyword">void</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Can_enable_shared</span> :</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Can_enable_shared</span>&lt;</span>_Yty, <span class="keyword">void_t</span>&lt;<span class="keyword">typename</span> _Yty::_Esft_type&gt;&gt;</span><br><span class="line">    : is_convertible&lt;<span class="keyword">remove_cv_t</span>&lt;_Yty&gt;*, <span class="keyword">typename</span> _Yty::_Esft_type*&gt;::type &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的重点是<code>_Can_enable_shared</code>，如果目标类型有内嵌类型<code>_Esft_type</code>，并且目标类型和内嵌类型的指针是可转换的，也就是有继承关系，那么类型结果为<code>true_type</code>，反之为<code>false_type</code>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ux</span>&gt;</span></span><br><span class="line">   <span class="keyword">void</span> _Set_ptr_rep_and_enable_shared(_Ux* <span class="keyword">const</span> _Px, _Ref_count_base* <span class="keyword">const</span> _Rx) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>-&gt;_Ptr = _Px;</span><br><span class="line">       <span class="keyword">this</span>-&gt;_Rep = _Rx;</span><br><span class="line">       <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(conjunction_v&lt;negation&lt;is_array&lt;_Ty&gt;&gt;, negation&lt;is_volatile&lt;_Ux&gt;&gt;, _Can_enable_shared&lt;_Ux&gt;&gt;)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (_Px &amp;&amp; _Px-&gt;_Wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">               _Px-&gt;_Wptr = shared_ptr&lt;<span class="keyword">remove_cv_t</span>&lt;_Ux&gt;&gt;(*<span class="keyword">this</span>, <span class="keyword">const_cast</span>&lt;<span class="keyword">remove_cv_t</span>&lt;_Ux&gt;*&gt;(_Px));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接下来，如果对象不是数组、不是<code>volatile</code>声明的并且<code>_Can_enable_shared</code>返回<code>true_type</code>，那么<code>_Wptr</code>才会被初始化。<code>std::shared_ptr</code>的构造函数以及<code>std::make_shared</code>函数都会调用该函数。</p><p>以上就是<code>std::enable_shared_from_this</code>实现原理中比较关键的一个部分。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用fmtlib格式化字符串</title>
      <link href="/2020/07/07/use-fmtlib-format-string/"/>
      <url>/2020/07/07/use-fmtlib-format-string/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在C++中格式化字符串的方法一直是一个备受争议的话题，无论是<code>printf</code>系列函数还是Stream IO都有各自的优缺点。本篇文章直接略过这两种方法，将目光放到fmtlib这个第三方库中，虽然是第三方库，但是C++20标准会引入该库的一部分特性。</p><p>fmtlib格式化字符串的语法和python十分相似，熟悉python的朋友掌握起来会非常迅速，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>) </span><br></pre></td></tr></table></figure><p>以上是python格式化字符串的方法，对比到fmtlib为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在python中，格式化字符串的{}是可以设定索引并且指定顺序的，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure><p>在fmtlib中也能够实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外在python中还可以使用命名的{}来格式化字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;first&#125; &#123;second&#125;&quot;</span>.<span class="built_in">format</span>(first = <span class="string">&quot;hello&quot;</span>, second = <span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure><p>不过C++中不支持指定参数名来传参，fmtlib采用了一个很巧妙的方法，它使用了自定义字面量的方法生成了一个named_arg对象：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/format.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> fmt::literals;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(</span><br><span class="line">        <span class="string">&quot;&#123;first&#125; &#123;second&#125;&quot;</span>, </span><br><span class="line">        <span class="string">&quot;first&quot;</span>_a = <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;second&quot;</span>_a = <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式化说明符的语法也是基本相同的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>)</span><br></pre></td></tr></table></figure><p>对应到fmtlib：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>, <span class="number">3.1415926</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的格式化说明符的文档见：<a href="https://fmt.dev/latest/syntax.html">链接</a></p><p>最后fmtlib还支持自定义格式化类型，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> telephone[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">fmt</span>:</span>:formatter&lt;PersonInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> fmt::format_parse_context::iterator </span><br><span class="line">    <span class="built_in">parse</span>(fmt::format_parse_context&amp; ctx) &#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = ctx.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> ++iter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt::format_context::iterator </span><br><span class="line">    format(PersonInfo info, fmt::format_context&amp; ctx) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt::format_to(ctx.<span class="built_in">out</span>(), </span><br><span class="line">        <span class="string">&quot;name : &#123;&#125; | age : &#123;&#125; | tel. : &#123;&#125;&quot;</span>, </span><br><span class="line">        info.name, info.age, info.telephone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PersonInfo info&#123; <span class="string">&quot;xiaoming&quot;</span>, <span class="number">18</span>, <span class="string">&quot;1234567890&quot;</span> &#125;;</span><br><span class="line">    std::cout &lt;&lt; fmt::format(<span class="string">&quot;&#123;&#125;&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序列和迭代器(3)</title>
      <link href="/2020/06/15/yampl-seq-and-iterator-part3/"/>
      <url>/2020/06/15/yampl-seq-and-iterator-part3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="list序列的更多元函数"><a href="#list序列的更多元函数" class="headerlink" title="list序列的更多元函数"></a><code>list</code>序列的更多元函数</h2><p>那么目前为止，我们完成了<code>list</code>序列7组基本元函数的调用和验证。不过我们不会就此满足，因为以上元函数能完成的工作有限，为了让序列能完成更多实用的功能，我们还需要进一步的对基础元函进行组合。有一个特别的好消息是，由于后续介绍的元函数都是由以上7组基本元函数组合而成，所以它们可以在任何正向迭代器的序列中使用。不仅如此，如果不是特别在意编译期的效率问题的话，将他们应用于双向迭代器或者随机访问迭代器的序列也是可以的。当然我并不推荐这么做，因为对于双向迭代器或者随机访问迭代器的序列，它们可以使用更灵活的方法操作和访问内部元素。</p><h3 id="push-front元函数"><a href="#push-front元函数" class="headerlink" title="push_front元函数"></a><code>push_front</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_front_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> push_back&lt;<span class="keyword">typename</span> clear&lt;T&gt;::type, U&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_front</span></span></span><br><span class="line"><span class="class">    :</span> push_front_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出<code>push_front</code>是一个极为典型的组合元函数，它使用<code>begin</code>、<code>end</code>、<code>deref</code>、<code>clear</code>和<code>push_back</code>两个元函数的组合，所以它可以用于任何正向迭代器的序列。不过达到这个目的的代价可以不小，因为这个操作从效率上来说是很低的。观察<code>push_front_impl</code>的实现可知，该元函数首先调用<code>clear</code>元函数获取一个空的序列，接着将目标元素<code>push_back</code>到新的空序列中，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> init = <span class="keyword">typename</span> push_back&lt;<span class="keyword">typename</span> clear&lt;T&gt;::type, U&gt;::type;</span><br></pre></td></tr></table></figure><p>并且使用<code>begin</code>、<code>end</code>和<code>deref</code>遍历了原始序列并且按照顺序逐个插入新序列。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br></pre></td></tr></table></figure><h3 id="pop-back和pop-front元函数"><a href="#pop-back和pop-front元函数" class="headerlink" title="pop_back和pop_front元函数"></a><code>pop_back</code>和<code>pop_front</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pop_back_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> next&lt;N&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, I, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> clear&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> next&lt;<span class="keyword">typename</span> begin&lt;T&gt;::type&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pop_back</span></span></span><br><span class="line"><span class="class">    :</span> pop_back_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pop_front_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> clear&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> next&lt;<span class="keyword">typename</span> begin&lt;T&gt;::type&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pop_front</span></span></span><br><span class="line"><span class="class">    :</span> pop_front_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>事实上，<code>pop_back</code>和<code>pop_front</code>元函数与<code>push_front</code>元函数的实现思路基本上是一样的。它们都使用<code>clear</code>元函数创建了一个空序列，然后再往空序列中填充各自的元素。唯一的区别就在于，<code>pop_back</code>元函数会检查下一个迭代器是否为结束迭代器。如果确定是结束迭代器，那么元函数就会忽略当前迭代器，直接返回当前新序列。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;inner, <span class="keyword">typename</span> next&lt;I&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> next&lt;N&gt;::type, E&gt;::type;</span><br></pre></td></tr></table></figure><p>而<code>pop_front</code>则是从一开始遍历原始序列迭代器的时候就用<code>next</code>元函数忽略首个迭代器。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;init, <span class="keyword">typename</span> next&lt;<span class="keyword">typename</span> begin&lt;T&gt;::type&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br></pre></td></tr></table></figure><h3 id="insert元函数"><a href="#insert元函数" class="headerlink" title="insert元函数"></a><code>insert</code>元函数</h3><p>上面已经介绍了三个组合而成的元函数，它们的实现虽说比较简单，但是却阐明了这类元函数的基本思路，即创建新的序列，然后遍历原始序列将需要的元素逐个插入到新序列中。现在让我们看一个较为复杂的<code>insert</code>元函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insert_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner, U, B, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, I, I, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> inner2 = <span class="keyword">typename</span> push_back&lt;inner, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner2, I, U, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, B, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, E, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">B</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> init = <span class="keyword">typename</span> clear&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> apply_impl&lt;init, U, B, <span class="keyword">typename</span> begin&lt;T&gt;::type,</span><br><span class="line">                                     <span class="keyword">typename</span> end&lt;T&gt;::type&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insert</span></span></span><br><span class="line"><span class="class">    :</span> insert_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, B, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码总体思路没有变化，先通过<code>clear</code>创建了新序列，难点是如何遍历原始序列并且找到目标位置插入新元素。这里让我们把注意力放在4个版本的<code>apply_impl</code>上，首先来看通常版本的元函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner, U, B, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>该元函数非常简单，通过<code>push_back</code>将原序列的元素插入到新序列中，其中<code>I</code>是迭代器。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, I, I, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> inner = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> inner2 = <span class="keyword">typename</span> push_back&lt;inner, <span class="keyword">typename</span> deref&lt;I&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> apply_impl&lt;inner2, I, U, <span class="keyword">typename</span> next&lt;I&gt;::type, E&gt;::type;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>第二个的<code>apply_impl</code>是一个特化版本，它限定了当当前迭代器<code>I</code>与目标迭代器相同的时候，将新元素<code>U</code>插入到新序列中，然后再插入迭代器<code>I</code>的元素，这样就能完成插入目标元素<code>U</code>到指定迭代器之前的任务。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, B, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = R;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply_impl</span>&lt;</span>R, U, E, E, E&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> push_back&lt;R, U&gt;::type;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>最后两个特化版本的<code>apply_impl</code>限定了元函数的结束条件。一方面<code>apply_impl&lt;R, U, B, E, E&gt;</code>，当原序列遍历到结束迭代器时，如果插入目标位置不是结束迭代器，则插入操作直接结束，返回新序列。另一方面<code>apply_impl&lt;R, U, E, E, E&gt;</code>，当原序列遍历到结束迭代器时，如果插入目标位置正好是结束迭代器，那么就将目标元素<code>U</code>插入到新序列的末尾。</p><p>以下是一个调用<code>insert</code>元函数的示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> insert_list = list&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>, <span class="keyword">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> result_list = insert&lt;insert_list, <span class="keyword">short</span>, begin&lt;insert_list&gt;::type&gt;::type;</span><br></pre></td></tr></table></figure><p>示例代码中，<code>insert</code>元函数将<code>short</code>类型插入了<code>insert_list</code>序列的<code>begin</code>迭代器之前，于是<code>result_list</code>的结果应该是<code>list&lt;short, int, bool, char&gt;</code>。</p><h3 id="其他组合元函数"><a href="#其他组合元函数" class="headerlink" title="其他组合元函数"></a>其他组合元函数</h3><p>除了我们上面介绍的<code>push_front</code>、<code>pop_back</code>、<code>pop_front</code>和<code>insert</code>元函数以外，我们还能根据自己的需要实现其他的元函数。比如，用于删除元素的<code>erase</code>元函数，用于排重的<code>unique</code>元函数，用于逆向排序的<code>reverse</code>元函数以及用于查找元素的<code>find</code>元函数等等。它们虽然有各自不同的功能，但是实现思路上确实万变不离其宗的。有兴趣的读者不妨自己尝试动手实现一两个。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序列和迭代器(2)</title>
      <link href="/2020/05/20/yampl-seq-and-iterator-part2/"/>
      <url>/2020/05/20/yampl-seq-and-iterator-part2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="list序列"><a href="#list序列" class="headerlink" title="list序列"></a>list序列</h2><p><code>list</code>序列实际上就是曾经介绍的<code>seq</code>序列的加强版，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_tag</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category_tag = forward_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> tag = list_tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，<code>list</code>序列是一个有可变模板形参的类模板，它有两个内嵌类型分别是<code>iterator_category_tag</code>和<code>tag</code>。其中<code>tag</code>指示该序列的类型是<code>list_tag</code>，<code>iterator_category_tag</code>指示<code>list</code>序列的迭代器类型是正向迭代器<code>forward_iterator_tag</code>。除了正向迭代器的<code>tag</code>，YAMPL还定义了双向和随机访问迭代器。</p><table><thead><tr><th>迭代器名称</th><th>定义</th></tr></thead><tbody><tr><td>正向迭代器</td><td><code>forward_iterator_tag</code></td></tr><tr><td>双向迭代器</td><td><code>bidirectional_iterator_tag</code></td></tr><tr><td>随机访问迭代器</td><td><code>random_access_iterator_tag</code></td></tr></tbody></table><p>正如上一节所说，要完成一个正向迭代器的序列需要实现至少7组基础元函数。接下来我们会逐一的实现这些元函数。</p><h3 id="begin-impl元函数"><a href="#begin-impl元函数" class="headerlink" title="begin_impl元函数"></a><code>begin_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">begin_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = iterator&lt;T&lt;Args...&gt;, integral_const&lt;<span class="keyword">int</span>, <span class="number">0</span>&gt;, T&lt;Args...&gt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上面的代码，让我们来详细的观察<code>begin_impl</code>的实现。首先可以看到<code>template &lt;&gt; struct begin_impl&lt;list_tag&gt;</code>是一个<code>template &lt;class Tag&gt; struct begin_impl &#123;&#125;;</code>针对<code>list_tag</code>的特化版本。它的作用就是让告知编译器在处理<code>tag</code>为<code>list_tag</code>的序列时，选用<code>template &lt;&gt; struct begin_impl&lt;list_tag&gt;</code>这个元函数。回过头来看<code>begin</code>元函数的实现，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">begin</span> :</span> begin_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>begin_impl</code>元函数调用了<code>sequence_tag</code>来获取序列的<code>tag</code>，从而让编译器能够正确选择<code>begin_impl</code>的版本。<code>sequence_tag</code>的实现很简单，就是获取类型的<code>tag</code>并返回。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sequence_tag</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> T::tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着观察<code>begin_impl&lt;typename sequence_tag&lt;T&gt;::type&gt;::template apply&lt;T&gt;</code>的<code>apply&lt;T&gt;</code>，我们发现在编译器选择了正确的<code>begin_impl</code>后，真正发挥作用的是内嵌元函数<code>template &lt;class T&gt; struct apply</code>，它的任务是处理<code>begin</code>传入的模板参数<code>T</code>，并且返回第1个迭代器。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = iterator&lt;T&lt;Args...&gt;, integral_const&lt;<span class="keyword">int</span>, <span class="number">0</span>&gt;, T&lt;Args...&gt;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>apply</code>的实现并不复杂，需要注意的是返回迭代器中模板实参的含义。第一个实参<code>T&lt;Args...&gt;</code>是记录当前迭代器所代表的元素以及该元素之后所有元素的序列，比方说现在有一个迭代器的第一个实参为<code>list&lt;int, char, double&gt;</code>，那么它的下一个迭代器的第一个实参应该是<code>list&lt;char, double&gt;</code>。第二个实参<code>integral_const&lt;int, 0&gt;</code>是用来记录当前迭代器在序列中的位置，因为<code>begin</code>返回的是序列的第一个迭代器，所有其位置应该是0。最后的实参<code>T&lt;Args...&gt;</code>对整个序列的记录，由于是首个迭代器所以这个实参看起来和第一个实参相同。另外需要注意的是在正向迭代器中，第三个实参并没有什么作用，之所以给出了这个定义是因为YAMPL还为<code>list</code>实现了一个双向迭代器的版本。</p><h3 id="end-impl元函数"><a href="#end-impl元函数" class="headerlink" title="end_impl元函数"></a><code>end_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">end_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        iterator&lt;T&lt;&gt;, integral_const&lt;<span class="keyword">int</span>, <span class="keyword">sizeof</span>...(Args)&gt;, T&lt;Args...&gt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>end_impl</code>的实现和<code>begin_impl</code>基本相同，唯一的区别是内嵌元函数<code>apply</code>返回的迭代器的定义不同，它将返回序列最后一个元素之后的迭代器。该迭代器的第一个实参为<code>T&lt;&gt;</code>，这说明该迭代器已经没有代表的元素了。第二个实参<code>integral_const&lt;int, sizeof...(Args)&gt;</code>同样表示当前迭代器在序列的位置。最后的实参<code>T&lt;Args...&gt;</code>还是对整个序列的记录。</p><h3 id="size-impl元函数"><a href="#size-impl元函数" class="headerlink" title="size_impl元函数"></a><code>size_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">size_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;<span class="keyword">int</span>, <span class="keyword">sizeof</span>...(Args)&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>size_impl</code>的内嵌元函数<code>apply</code>返回的是序列中元素的数量<code>integral_const&lt;int, sizeof...(Args)&gt;</code>。</p><h3 id="clear-impl元函数"><a href="#clear-impl元函数" class="headerlink" title="clear_impl元函数"></a><code>clear_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clear_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T&lt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>clear_impl</code>的内嵌元函数<code>apply</code>返回的是空序列<code>T&lt;&gt;</code>。</p><h3 id="push-back-impl元函数"><a href="#push-back-impl元函数" class="headerlink" title="push_back_impl元函数"></a><code>push_back_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_back_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>T&lt;Args...&gt;, U&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T&lt;Args..., U&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>push_back_impl</code>的内嵌元函数<code>apply</code>和之前我们看到的<code>apply</code>元函数有一些区别，它需要两个模板参数，这也正是<code>push_back</code>元函数所需的模板参数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_back</span></span></span><br><span class="line"><span class="class">    :</span> push_back_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>其中实参<code>T</code>是序列本身，实参U是需要插入序列的元素。最终<code>apply</code>返回的是插入新元素之后的序列<code>T&lt;Args..., U&gt;</code>。</p><h3 id="next-impl元函数"><a href="#next-impl元函数" class="headerlink" title="next_impl元函数"></a><code>next_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">next_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">B</span>,</span></span><br><span class="line"><span class="class">            <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>iterator&lt;T&lt;U, Args...&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = iterator&lt;T&lt;Args...&gt;, <span class="keyword">typename</span> N::next, B&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">B</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>iterator&lt;T&lt;U&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = iterator&lt;T&lt;&gt;, <span class="keyword">typename</span> N::next, B&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>next_impl</code>的内嵌元函数<code>apply</code>是一个针对迭代器的元函数，之前我们看到的无论是<code>begin_impl</code>还是<code>push_back_impl</code>的<code>apply</code>元函数都是针对序列本身的。这一点从<code>next</code>的定义中也能看出点端倪。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">next</span></span></span><br><span class="line"><span class="class">    :</span> next_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>我们发现，<code>next_impl</code>并没有调用<code>sequence_tag</code>获取序列<code>tag</code>，而是采用<code>iterator_sequence_tag</code>元函数获取迭代器所属序列的<code>tag</code>，所以这里<code>next</code>元函数操作的主体对象是迭代器而不是序列。</p><p>回头来看<code>next_impl</code>中<code>apply</code>的代码，可以看到<code>apply</code>有两个特化版本，首先当模板实参为<code>iterator&lt;T&lt;U, Args...&gt;, N, B&gt;</code>时，说明该迭代器不是倒数第二个迭代器，那么<code>apply</code>的返回结果应该是下个迭代器<code>iterator&lt;T&lt;Args...&gt;, typename N::next, B&gt;</code>。请注意，因为我们知道模板形参<code>N</code>是一个<code>integral_const</code>类型，所以可以直接使用<code>N::next</code>获取它的下一个整型包装类。</p><p>接下来当模板实参为<code>iterator&lt;T&lt;U&gt;, N, B&gt;</code>时，说明它是序列中倒数第二个迭代器。这时<code>apply</code>应该与<code>end</code>元函数返回一个相同的迭代器<code>iterator&lt;T&lt;&gt;, typename N::next, B&gt;</code>。</p><h3 id="deref-impl元函数"><a href="#deref-impl元函数" class="headerlink" title="deref_impl元函数"></a><code>deref_impl</code>元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deref_impl</span>&lt;</span>list_tag&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">B</span>,</span></span><br><span class="line"><span class="class">            <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>iterator&lt;T&lt;U, Args...&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = U;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;class...&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">B</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">apply</span>&lt;</span>iterator&lt;T&lt;&gt;, N, B&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = none;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>deref_impl</code>和<code>next_impl</code>一样也是针对迭代器的元函数，它对迭代器进行解引用操作，随后可以获得元素本身。观察<code>deref_impl</code>的内嵌<code>apply</code>元函数，它也有两个特化版本。当其实参的迭代器为<code>iterator&lt;T&lt;U, Args...&gt;, N, B&gt;</code>时，说明它不是最后一个迭代器，于是返回当前元素<code>U</code>。当实参的迭代器为<code>iterator&lt;T&lt;&gt;, N, B&gt;</code>时，说明这是最后一个迭代器，它不包含任何元素，所以返回<code>none</code>。这里的<code>none</code>是YAMPL专门为类似这种情况定义的类型，用来表示没有意义的结果，具体定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">none_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">none</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> tag = none_tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list序列和迭代器的基本用法"><a href="#list序列和迭代器的基本用法" class="headerlink" title="list序列和迭代器的基本用法"></a><code>list</code>序列和迭代器的基本用法</h2><p>熟悉STL的读者一定对迭代器的使用了如指掌，因为STL中关于容器的大部分函数都依赖迭代器。比如从<code>std::list</code>的容器中删除一个元素就需要使用迭代器指明元素的位置。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::list&lt;<span class="keyword">int</span>&gt; mylist&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">mylist.<span class="built_in">erase</span>(mylist.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><p>模板元编程中序列和迭代器的使用方法和STL的迭代器比较类似，只是代码的写法上有些不同，总的来说还算比较容易掌握。以下是一段调用并验证<code>yampl::list</code>基本元函数的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::boolalpha;</span><br><span class="line"><span class="keyword">using</span> my_list = list&lt;int_&lt;<span class="number">0</span>&gt;, int_&lt;<span class="number">1</span>&gt;, int_&lt;<span class="number">2</span>&gt;, int_&lt;<span class="number">3</span>&gt;, int_&lt;<span class="number">4</span>&gt;&gt;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;my_list size = &quot;</span> &lt;&lt; size&lt;my_list&gt;::type::value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> it0 = <span class="keyword">typename</span> begin&lt;my_list&gt;::type;</span><br><span class="line"><span class="keyword">using</span> elem0 = <span class="keyword">typename</span> deref&lt;it0&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;elem0 == int_&lt;0&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;elem0, int_&lt;<span class="number">0</span>&gt;&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> it1 = <span class="keyword">typename</span> next&lt;it0&gt;::type;</span><br><span class="line"><span class="keyword">using</span> elem1 = <span class="keyword">typename</span> deref&lt;it1&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;elem1 == int_&lt;1&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;elem1, int_&lt;<span class="number">1</span>&gt;&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> it2 = <span class="keyword">typename</span> next&lt;it1&gt;::type;</span><br><span class="line"><span class="keyword">using</span> it3 = <span class="keyword">typename</span> next&lt;it2&gt;::type;</span><br><span class="line"><span class="keyword">using</span> it4 = <span class="keyword">typename</span> next&lt;it3&gt;::type;</span><br><span class="line"><span class="keyword">using</span> elem4 = <span class="keyword">typename</span> deref&lt;it4&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;elem4 == int_&lt;4&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;elem4, int_&lt;<span class="number">4</span>&gt;&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;next&lt;it4&gt;::type == end&lt;my_list&gt;::type : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;<span class="keyword">typename</span> next&lt;it4&gt;::type,</span><br><span class="line">                            <span class="keyword">typename</span> end&lt;my_list&gt;::type&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> empty_list = <span class="keyword">typename</span> clear&lt;my_list&gt;::type;</span><br><span class="line"><span class="keyword">using</span> my_list2 = <span class="keyword">typename</span> push_back&lt;empty_list, int_&lt;<span class="number">5</span>&gt;&gt;::type;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;my_list2 == list&lt;int_&lt;5&gt; : &quot;</span></span><br><span class="line">          &lt;&lt; std::is_same_v&lt;my_list2, list&lt;int_&lt;5&gt;&gt;&gt; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>在上面的代码中，首先定义了一个<code>list</code>序列<code>my_list</code>，序列共有5个元素，它们从<code>int_&lt;0&gt;</code>递增至<code>int&lt;4&gt;</code>。使用<code>size</code>元函数可以获取<code>my_list</code>中元素个数，这里返回的是<code>int_&lt;5&gt;</code>，通过<code>::value</code>可以获取整型数字5，所以第一句<code>std::cout</code>输出结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_list size &#x3D; 5</span><br></pre></td></tr></table></figure><p>接着，代码调用<code>begin</code>元函数返回了序列<code>my_list</code>的第一个迭代器<code>it0</code>，可以预见到这个迭代器解引用后的元素就是<code>int_&lt;0&gt;</code>。为了证明这一点，使用元函数<code>deref</code>可以对<code>it0</code>解引用并获得结果<code>elem0</code>，再使用<code>std::is_same_v&lt;elem0, int_&lt;0&gt;&gt;</code>验证类型是否相同，输出结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elem0 &#x3D;&#x3D; int_&lt;0&gt; : true</span><br></pre></td></tr></table></figure><p>为了获取下一个迭代器，可以使用元函数<code>next</code>，这样可以获取迭代器<code>it1</code>。通过同样的方式我们可以获取<code>it2</code>到<code>it4</code>，并且对它们的类型进行判断：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elem1 &#x3D;&#x3D; int_&lt;1&gt; : true</span><br><span class="line">elem4 &#x3D;&#x3D; int_&lt;4&gt; : true</span><br></pre></td></tr></table></figure><p><code>it4</code>的下一个迭代器是<code>my_list</code>中最后一个迭代器，应该与<code>end</code>元函数返回的结果相同。我们同样可以通过<code>std::is_same_v&lt;typename next&lt;it4&gt;::type, typename end&lt;my_list&gt;::type&gt;</code>来验证这个结论：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">next&lt;it4&gt;::type &#x3D;&#x3D; end&lt;mylist&gt;::type : true</span><br></pre></td></tr></table></figure><p>最后，代码中使用<code>clear</code>元函数返回一个空<code>list</code>序列，并且调用<code>push_back</code>将<code>int_&lt;5&gt;</code>插入到序列之中并获得序列<code>my_list2</code>。用同样的方法再次验证<code>push_back</code>和<code>clear</code>元函数的正确性，得到输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_list2 &#x3D;&#x3D; list&lt;int_&lt;5&gt; : true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序列和迭代器(1)</title>
      <link href="/2020/04/01/yampl-seq-and-iterator-part1/"/>
      <url>/2020/04/01/yampl-seq-and-iterator-part1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在前面的篇幅中我们已经看到了序列在模板元编程中的一部分作用。在本篇中我们将更加深入的探讨序列以及与之相关的算法，同时我们会使用建立迭代器的方法将这些算法抽象出来以方便它们运用到不同类型的序列中。在YAMPL中实现了两种类型的序列<code>list</code>和<code>vector</code>，本章中我将着重介绍<code>list</code>序列，这是因为该序列更好的使用了C++11的特性。另外本篇中介绍的算法基本上都是使用迭代器实现，所以它们可以顺利的移植到<code>vector</code>上。读者也可以将这些算法移植到自己实现的序列上，而这个移植过程也只需要实现少量代码。</p><h2 id="定义迭代器"><a href="#定义迭代器" class="headerlink" title="定义迭代器"></a>定义迭代器</h2><p>为了保证序列相关算法的通用性，我们需要将算法的实现建立在迭代器的基础之上，于是设计一个通用的迭代器就变得十分重要了。以下代码是YAMPL中通用迭代器类模板的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N</span>, <span class="keyword">class</span> <span class="title">B</span> =</span> <span class="keyword">void</span>, <span class="class"><span class="keyword">class</span> <span class="title">B2</span> =</span> <span class="keyword">void</span>, <span class="class"><span class="keyword">class</span> <span class="title">B3</span> =</span> <span class="keyword">void</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">  <span class="keyword">using</span> index = N;</span><br><span class="line">  <span class="keyword">using</span> backup = B;</span><br><span class="line">  <span class="keyword">using</span> backup2 = B2;</span><br><span class="line">  <span class="keyword">using</span> backup3 = B3;</span><br><span class="line">  <span class="keyword">using</span> tag = iterator_tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，迭代器<code>iterator</code>定义了5个模板形参。其中第一个形参<code>T</code>通常用于记录当前迭代器代表的元素本身或者是记录与该元素相关的序列；第二个形参<code>N</code>通常用于记录当前迭代器在序列中的位置；而剩下的3个形参可以用来记录一些额外的序列信息。</p><p>值得注意的是，以上描述是这5个形参在YAMPL序列中的惯用用法，它们并不是绝对的，所以序列的设计者可以根据序列本身的实际情况安排这5个形参的用途。比如YAMPL中的<code>list</code>使用了前3个形参，而<code>vector</code>只使用了前2个形参。</p><p>最后来说明一下内嵌类型<code>tag</code>的用途。在YAMPL中，和序列相关的类模板都有一个<code>tag</code>，比如迭代器的<code>tag</code>就是<code>iterator_tag</code>。这些<code>tag</code>的主要功能是对序列相关的类模板进行分类以方便通用算法在不同的序列上正常工作。例如YAMPL的<code>list</code>序列的<code>tag</code>为<code>list_tag</code>，那么为<code>list_tag</code>设计的基础元函数就能使用在<code>list</code>序列之上。同样的道理，若序列的设计者为了某特殊情况定义了一个<code>special_list</code>序列，并且将其<code>tag</code>定义为<code>list_tag</code>，那么为<code>list_tag</code>设计的算法就可以用于该序列了。</p><h2 id="序列和迭代器的基础元函数"><a href="#序列和迭代器的基础元函数" class="headerlink" title="序列和迭代器的基础元函数"></a>序列和迭代器的基础元函数</h2><p>为了让迭代器能顺利的移植到不同的序列上，我们需要定义几个抽象的元函数。这些元函数有些类似C++纯虚函数的概念，它们只提供一个元函数的轮廓，而具体是定义还是要由序列的设计者来实现。这些基础元函数包括：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">begin_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">begin</span> :</span> begin_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">end_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">end</span> :</span> end_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">next_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">next</span></span></span><br><span class="line"><span class="class">    :</span> next_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deref_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deref</span></span></span><br><span class="line"><span class="class">    :</span> deref_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">size_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">size</span> :</span> size_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clear_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clear</span> :</span> clear_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_back_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">push_back</span></span></span><br><span class="line"><span class="class">    :</span> push_back_impl&lt;<span class="keyword">typename</span> sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码展示了7组基础元函数，它们分别是<code>begin</code>、<code>end</code>、<code>next</code>、 <code>deref</code>、<code>size</code>、<code>clear</code>和<code>push_back</code>。之所以把它们列为基础元函数，是因为要让一个序列和与之相关的迭代器能正常工作这7组元函数是必不可少的。如果一个序列能实现这7组元函数，那么它的迭代器至少能完成一个正向迭代器的全部工作。</p><p>这7组元函数的功能具体为：</p><table><thead><tr><th align="left">元函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>begin</code></td><td align="left">返回序列中代表第一个元素的迭代器；</td></tr><tr><td align="left"><code>end</code></td><td align="left">返回序列中代表最后一个元素之后的迭代器；</td></tr><tr><td align="left"><code>next</code></td><td align="left">返回当前迭代器代表元素的下一个元素的迭代器；</td></tr><tr><td align="left"><code>deref</code></td><td align="left">解引用，返回当前迭代器代表的元素本身；</td></tr><tr><td align="left"><code>size</code></td><td align="left">返回序列中元素个数；</td></tr><tr><td align="left"><code>clear</code></td><td align="left">删除序列中的所有元素；</td></tr><tr><td align="left"><code>push_back</code></td><td align="left">在序列的最后新增一个元素。</td></tr></tbody></table><p>如果序列的设计者并不满足于正向迭代器的功能，那么还可以实现一个<code>prior</code>元函数的<code>_impl</code>版本来完成一个双向迭代器，<code>prior</code>元函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prior_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prior</span></span></span><br><span class="line"><span class="class">    :</span> prior_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>prior</code>函数的功能具体为：</p><table><thead><tr><th>元函数</th><th>说明</th></tr></thead><tbody><tr><td><code>prior</code></td><td>返回当前迭代器代表元素的上一个元素的迭代器。</td></tr></tbody></table><p>进一步的，如果序列的设计者希望该序列能支持一个随机访问迭代器，那么还需要实现以下2组基础元函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">advance_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">advance</span></span></span><br><span class="line"><span class="class">    :</span> advance_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;T,</span><br><span class="line">                                                                            N&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">distance_impl</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">distance</span></span></span><br><span class="line"><span class="class">    :</span> distance_impl&lt;<span class="keyword">typename</span> iterator_sequence_tag&lt;T&gt;::type&gt;::<span class="keyword">template</span> apply&lt;</span><br><span class="line">          T, U&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这2组元函数的功能具体为：</p><table><thead><tr><th>元函数</th><th>说明</th></tr></thead><tbody><tr><td><code>advance</code></td><td>返回当前迭代器代表元素的第N个递进元素的迭代器</td></tr><tr><td><code>distance</code></td><td>计算同序列中两个迭代器的间隔元素</td></tr></tbody></table><p>需要注意的是，序列需要实现的并不是<code>begin</code>、<code>end</code>、<code>next</code>这些元函数本身，而是它们间接调用的<code>_impl</code>版本的内嵌<code>apply</code>元函数。具体来说，想实现序列的<code>push_back</code>功能，那么应该对应的实现<code>push_back_impl</code>和<code>push_back_impl::apply</code>的元函数，具体的实现方法会在后面<code>list</code>序列的小节中介绍。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>YAMPL的基础组件(3)</title>
      <link href="/2020/03/08/yampl-base-components-part3/"/>
      <url>/2020/03/08/yampl-base-components-part3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="逻辑运算符元函数"><a href="#逻辑运算符元函数" class="headerlink" title="逻辑运算符元函数"></a>逻辑运算符元函数</h2><p>在C++中逻辑运算符可以将两个或多个关系表达式连接成一个，例如<code>&amp;&amp;</code>和<code>||</code>，也能够使表达式的逻辑反转，例如<code>!</code>。在这个小节中，我们将根据C++的逻辑运算符实现一套YAMPL可以使用的逻辑运算符元函数，除此之外我们还将结合上面的内容来完成一个元编程例子。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">and_</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> inner = and_&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value &amp;&amp; inner::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">and_</span>&lt;</span>N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value &amp;&amp; N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>观察上面的代码会发现，<code>and_</code>元函数的实现和<code>plus</code>元函数几乎相同，除了使用了不同的运算符以外，唯一的区别就是返回类型。<code>and_</code>元函数的返回类型<code>using type = integral_const&lt;value_type, N1::value &amp;&amp; inner::value&gt;;</code>固定为<code>integral_const&lt;bool, true&gt;</code>或者<code>integral_const&lt;bool, false&gt;</code>之一，也就是<code>true_type</code>或者<code>false_type</code>。这个设计正好是对应<code>&amp;&amp;</code>运算符的返回值必须是<code>true</code>或者<code>false</code>之一。说明了这个区别之后，读者可以回味一下<code>plus</code>的实现应该就能理解<code>and_</code>元函数的实现细节了，这里也不再赘述。</p><p>如<code>and_</code>元函数一样，<code>or_</code>也可以通过这样的方式实现，而且只需要修改一个运算符而已。所以这里还是用宏简化代码的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_MULTI_OP_BOOL(name, op)                                  \</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;</span>                         \</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>                                                         \</span><br><span class="line">    <span class="keyword">using</span> inner = name&lt;N2, Nargs...&gt;;                                   \</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;                                            \</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value op inner::value&gt;; \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;                    \</span><br><span class="line">  &#125;;                                                                    \</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span>                                         \</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span>&lt;</span>N1, N2&gt; &#123;                                                 \</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;                                            \</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value op N2::value)&gt;;  \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;                    \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_MULTI_OP_BOOL</span>(and_, &amp;&amp;);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP_BOOL</span>(or_, ||);</span><br></pre></td></tr></table></figure><p>以上代码实现了逻辑与和逻辑或的运算符元函数，接下来我们需要实现一个逻辑非运算符元函数，也就是在C++中常用的<code>!</code>。逻辑非运算符元函数的实现相对于前两个就单纯多了，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">not_</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, !T::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里只需要注意<code>not_</code>元函数的返回类型也是固定为<code>integral_const&lt;bool, true&gt;</code>或者<code>integral_const&lt;bool, false&gt;</code>之一，剩下的代码和取负运算符元函数的代码几乎相同很容易理解。</p><p>现在，我们要利用上面介绍的内容实现一个特殊的函数模板：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">special_func</span><span class="params">(T)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>该函数模板需要完成这样一个任务：当模板实参<code>T</code>是一个标量或者引用时，函数参数的<code>T</code>为实参本身；否则<code>T</code>为实参的引用。也就是说当<code>T</code>为<code>int</code>时，函数为<code>void special_func(int) &#123;&#125;</code>；当<code>T</code>为<code>int&amp;</code>时，函数为<code>void special_func(int&amp;) &#123;&#125;</code>；当T为<code>std::string</code>时，函数为<code>void special_func(std::string&amp;) &#123;&#125;</code>。</p><p>以下是我的一种实现方案：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func_helper</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> cond = or_&lt;<span class="keyword">typename</span> std::is_scalar&lt;T&gt;::type,</span><br><span class="line">                   <span class="keyword">typename</span> std::is_reference&lt;T&gt;::type&gt;;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> if_&lt;<span class="keyword">typename</span> cond::type, T,</span><br><span class="line">                            <span class="keyword">typename</span> std::add_lvalue_reference&lt;T&gt;::type&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">special_func</span><span class="params">(<span class="keyword">typename</span> func_helper&lt;T&gt;::type)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中实现了一个<code>func_helper</code>元函数，该元函数会针对<code>special_func</code>的模板实参进行处理以满足函数需求。在<code>func_helper</code>的实现代码中，首先调用了逻辑或元函数<code>or_</code>，用于判断<code>T</code>是否为标量或者引用类型。然后根据返回结果调用<code>if_</code>元函数。当<code>cond::type</code>的结果为<code>true_type</code>时返回<code>T</code>本身，否则调用<code>std::add_lvalue_reference</code>返回<code>T</code>的引用类型，最终<code>type</code>为要求的返回类型。</p><p>来测试一下刚刚编写的函数模板：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">special_func&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">special_func&lt;<span class="keyword">int</span>&amp;&gt;(n);</span><br><span class="line">std::string s&#123; <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">special_func&lt;std::string&gt;(s);</span><br></pre></td></tr></table></figure><p>使用<code>-fdump-tree-gimple</code>命令让GCC生成gimple的中间代码，观察代码发现这样三份中间代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">special_func&lt;int&gt; (type v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br><span class="line">special_func&lt;int&amp;&gt; (int &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br><span class="line">special_func&lt;std::__cxx11::basic_string&lt;char&gt; &gt; (struct basic_string &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  GIMPLE_NOP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当模板实参为<code>int</code>和<code>int&amp;</code>时，函数形参类型为模板实参本身，而当模板实参为<code>std::__cxx11::basic_string&lt;char&gt;</code>时，函数形参类型为<code>struct basic_string &amp;</code>，满足函数的设计要求。</p><h2 id="类型打印元函数"><a href="#类型打印元函数" class="headerlink" title="类型打印元函数"></a>类型打印元函数</h2><p>模板元程序之所以比普通C++程序更难编写主要是因为它很难调试。我们常用的调试方法在模板元程序上都没法正常使用，比如调试器只能调试动态运行的程序，但是却无法调试编译期执行的元程序。</p><p>另外打印日志的方法也许能帮上一点忙，因为C++为我们提供了<code>typeid</code>这个操作符，它返回的<code>std::type_info</code>结构中存在一个<code>const char* name()</code>的成员函数可以返回类型名称。于是我们想到可以使用以下方法打印类型信息帮助调试：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure><p>不过遗憾的是，这种方法也并不完美。首先来说，成员函数<code>name()</code>返回的类型名称在不同编译器中有不同的展现方法，比如MSVC编译出来的程序返回的是一个可读的名称，而GCC编译出来的程序返回的类型名称则需要使用特定API（例如<code>abi::__cxa_demangle</code>）将其转换为可读的名称。其次，<code>typeid</code>也无法真实的反应类型的状态，因为C++标准中说明了<code>typeid</code>会忽略类型的<code>cv</code>属性，也就是说<code>typeid(const T) == typeid(T)</code>。所以<code>typeid</code>打印日志的方法也不满足需求。</p><p>为了准确是输出类型信息，我们需要将目光从程序本身移动到编译期上，因为只有编译期才是掌握类型信息最全面的程序。于是我们可以想到使用编译期的错误信息来打印类型信息。由于错误信息往往是帮助程序员排查错误，所以类型信息会非常的全面。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">err_print_type</span>;</span></span><br><span class="line"></span><br><span class="line">err_print_type&lt;<span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type&gt;();</span><br></pre></td></tr></table></figure><p>在上面的代码中<code>err_print_type</code>是一个缺少实现的类模板，所以当编译器将其进行实例化的时候必然会报错，而错误信息正是我们想要的结果。<code>err_print_type&lt;typename minus&lt;int_&lt;10&gt;, int_&lt;2&gt;&gt;::type&gt;();</code>在MSVC中会显示错误信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error C2027: use of undefined type &#39;err_print_type&lt;yampl::integral_const&lt;T,8&gt;&gt;&#39;</span><br><span class="line">with</span><br><span class="line">[</span><br><span class="line">    T&#x3D;int</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在GCC中显示错误信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: invalid use of incomplete type &#39;struct err_print_type&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#39;</span><br></pre></td></tr></table></figure><p>可以看到，无论是哪种编译器都非常详细的显示了类型信息。</p><p>现在类型信息是完整了，但这种方法还是不太好，因为错误会阻止程序的编译导致无法生成可执行程序。我们需要一种方法既能在编译期产生可用的日志，与此同时也不能阻碍程序的正常编译。于是我们想到，如果能将错误信息转换为警告信息不久好了么！在YAMPL中，打印类型信息的方法就是用这种思路实现的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__clang__)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> tmp = <span class="number">1</span> / (<span class="built_in"><span class="keyword">sizeof</span></span>(T) - <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__GNUC__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic <span class="meta-keyword">warning</span> <span class="meta-string">&quot;-Wsign-compare&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(T) &gt; <span class="number">-1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push, 3)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbg_print_type</span> &#123;</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>以上代码实现了一个类模板<code>dbg_print_type</code>，并且分别对MSVC、GCC和CLang做了支持。当编译期时MSVC时，使用了数组大小为0的技巧促使编译期发出警告；当编译器是CLang时，使用除数为0的方式让编译器发出警告；当编译器是GCC时，使用不同符号类型比较让编译器发出警告，值得注意的是这个警告需要手动开启。</p><p>将上面示例中的<code>err_print_type</code>修改为<code>dbg_print_type</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dbg_print_type&lt;<span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type&gt;();</span><br></pre></td></tr></table></figure><p>GCC会发出这样的警告：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In instantiation of &#39;struct yampl::DbgPrintType&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#39;:</span><br><span class="line">required from here</span><br><span class="line">warning: comparison of integer expressions of different signedness: &#39;long long unsigned int&#39; and &#39;int&#39; [-Wsign-compare]</span><br><span class="line">   15 |   enum &#123; n &#x3D; sizeof(T) &gt; -1 &#125;;</span><br></pre></td></tr></table></figure><p>MSVC显示的警告为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">warning C4200: nonstandard extension used: zero-sized array in struct&#x2F;union</span><br><span class="line">message : This member will be ignored by a defaulted constructor or copy&#x2F;move assignment operator</span><br><span class="line">message : see reference to class template instantiation &#39;yampl::DbgPrintType&lt;yampl::integral_const&lt;T,8&gt;&gt;&#39; being compiled</span><br><span class="line">with</span><br><span class="line">[</span><br><span class="line">    T&#x3D;int</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>请注意警告的信息确实比较多，但是仔细观察还是能看到<code>&#39;struct yampl::DbgPrintType&lt;yampl::integral_const&lt;int, 8&gt; &gt;&#39;</code>这样类似的信息。另外值得高兴的是，这些警告信息也确实没有阻止程序的编译。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>YAMPL的基础组件(2)</title>
      <link href="/2020/02/21/yampl-base-components-part2/"/>
      <url>/2020/02/21/yampl-base-components-part2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="整型转换等级"><a href="#整型转换等级" class="headerlink" title="整型转换等级"></a>整型转换等级</h2><p>考虑一个简单的问题，在C++中将两个不同类型的整型操作数相加的结果会是怎么样的？比如用<code>short</code>类型的变量和<code>long</code>类型的变量相加。答案很简单，相加的结果应该是一个<code>long</code>类型，因为<code>short</code>类型隐式转换为<code>long</code>，于是就需要我们使用一个<code>long</code>类型的变量来存储计算结果。在C++11以后，我们可以通过类型说明符<code>auto</code>把这件事情交给编译器来完成。但是在模板元编程中，这件事是需要我们亲力亲为的。因此需要一个有效的工具来选择合适的类型，那就是类型转换等级。所谓转换等级实际上是类型根据C++隐式类型转换规则的一种排序，简单来说整型转换等级的排序符合下面两条规则：</p><ol><li>若两操作数的类型所需的存储空间大小不同，则存储空间较小的操作数类型隐式转换到存储空间较大的操作数类型。</li><li>若两操作数的类型所需的存储空间大小相同但符号性不同，则有符号类型操作数会隐式转换成无符号类型。</li></ol><p>下面是YAMPL对整型转换等级的排序：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">bool</span>&gt; : int_&lt;<span class="number">1</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">signed</span> <span class="keyword">char</span>&gt; : int_&lt;<span class="number">2</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">char</span>&gt; : int_&lt;<span class="number">3</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; : int_&lt;<span class="number">4</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">wchar_t</span>&gt; : int_&lt;<span class="number">5</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">char16_t</span>&gt; : int_&lt;<span class="number">6</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">short</span>&gt; : int_&lt;<span class="number">7</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">short</span>&gt; : int_&lt;<span class="number">8</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">char32_t</span>&gt; : int_&lt;<span class="number">9</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">int</span>&gt; : int_&lt;<span class="number">10</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; : int_&lt;<span class="number">11</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">long</span>&gt; : int_&lt;<span class="number">12</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; : int_&lt;<span class="number">13</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">long</span> <span class="keyword">long</span>&gt; : int_&lt;<span class="number">14</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">integral_rank</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt; : int_&lt;<span class="number">15</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>integral_rank</code>是一个用于描述整型转换等级的类模板，它的实现非常简单，只是继承了类模板<code>int_</code>的实例，如此一来我们可以通过<code>::value</code>的方法访问类型等级的值，这个技巧在C++模板元编程中被称为元函数转发。</p><p>整体的来看这段代码，可以看出等级的排序顺序由小到大，在规则上转换也总是从小到大进行的。比如，<code>char</code>类型的等级为3，<code>int</code>类型的等级为10，于是这两个类型的操作数互相作用后的结果是一个等级数值更大的<code>int</code>类型。为了方便的选择转换等级，YAMPL还提供了一个元函数来完成这件事，该函数依赖元函数<code>if_c</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> largest_int =</span><br><span class="line">    if_c&lt;integral_rank&lt;T1&gt;::value &gt;= integral_rank&lt;T2&gt;::value, T1, T2&gt;;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">largest_int</span></span></span><br><span class="line"><span class="class">    :</span> if_c&lt;integral_rank&lt;T1&gt;::value &gt;= integral_rank&lt;T2&gt;::value, T1,</span><br><span class="line">                       T2&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这里无论是使用别名模板还是元函数转发都会调用元函数<code>if_c</code>比较对应类型的转换等级，最终给出拥有较大等级的类型。它们的结果是相同的，读者可以根据自己的喜好来选择<code>largest_int</code>的实现方案。</p><p>在下面这段代码中<code>largest_int</code>和<code>auto</code>具有相同的效果，<code>val1</code>和<code>val2</code>都会被编译器推导为<code>int</code>类型。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> a2 = <span class="number">7</span>;</span><br><span class="line">largest_int&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;::type val1 = a1 + a2;</span><br><span class="line"><span class="keyword">auto</span> val2 = a1 + a2;</span><br></pre></td></tr></table></figure><h2 id="算术运算符元函数"><a href="#算术运算符元函数" class="headerlink" title="算术运算符元函数"></a>算术运算符元函数</h2><p>我们知道在YAMPL中，整型常量都被包装类模板包装成了特殊的类型。这种处理方式为类型序列和元函数提供了操作数值途径，但随之而来的后果是无法对包装类进行加减乘除等算术运算，同样的也无法对包装类进行逻辑运算。为了解决这类计算问题，我们需要为YAMPL提供一套打通数值计算和类型计算的元函数，让它们来完成算术和逻辑的运算工作。</p><p>事实上，上一篇中的<code>plus</code>元函数就可以被列出其中，不过我并不打算直接这么做，因为它还有进一步完善的空间，请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> inner = plus&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> inner::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value + inner::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span>&lt;</span>N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value + N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>观察以上的代码可以发现它和以前的版本有两个显著的升级。首先，现在的元函数<code>plus</code>支持两个或两个以上的操作数参与到加法运算中，比如<code>plus&lt;int_&lt;3&gt;, int_&lt;2&gt;, int_&lt;5&gt;, int_&lt;6&gt;&gt;</code>。显然，为了完成这个目标我们需要实现一个递归，在代码中这个递归的发起点就是<code>using inner = plus&lt;N2, Nargs...&gt;;</code>，它使用<code>plus</code>计算除<code>N1</code>外剩余形参的结果。直到参数个数减少为2时触发结束条件，<code>struct plus&lt;N1, N2&gt;</code>计算两个形参之和并返回结果，递归结束。</p><p>另外还可以注意到，该版本的<code>plus</code>支持不同整型的包装类，这是因为在元函数中调用了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">largest_int&lt;<span class="keyword">typename</span> N1::value_type, <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br></pre></td></tr></table></figure><p>来获取计算结果的最终类型。因此<code>plus&lt;int_&lt;3&gt;, uint_&lt;2&gt;&gt;::type</code>这段代码可以顺利的编译，它的计算结果是<code>uint_&lt;5&gt;</code>。</p><p>当然，除了加法以外还有一些计算也可以支持多个操作数同时进行，例如乘法、位的与计算以及位的或计算等。而这些计算本质上与<code>plus</code>元函数只有运算符上的差别，以乘法为例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">times</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> inner = times&lt;N2, Nargs...&gt;;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> inner::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value * inner::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">times</span>&lt;</span>N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value * N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对比元函数<code>plus</code>，只是<code>N1::value + N2::value</code>被修改为了<code>N1::value * N2::value</code>。根据这样的规则，我们可以用宏来简化这类代码为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_MULTI_OP(name, op)                                              \</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>, <span class="title">class</span>... <span class="title">Nargs</span>&gt;</span>                                \</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>                                                                \</span><br><span class="line">    <span class="keyword">using</span> inner = name&lt;N2, Nargs...&gt;;                                          \</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,           \</span><br><span class="line">                                            <span class="keyword">typename</span> inner::value_type&gt;::type; \</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;value_type, N1::value op inner::value&gt;;        \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;                           \</span><br><span class="line">  &#125;;                                                                           \</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span>                                                \</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span>&lt;</span>N1, N2&gt; &#123;                                                        \</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,           \</span><br><span class="line">                                            <span class="keyword">typename</span> N2::value_type&gt;::type;    \</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value op N2::value)&gt;;         \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;                           \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(plus, +);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(times, *);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(bitand_, &amp;);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(bitor_, |);</span><br><span class="line"><span class="built_in">BINARY_MULTI_OP</span>(bitxor_, ^);</span><br></pre></td></tr></table></figure><p>可以看到我将<code>+</code>、<code>*</code>、<code>&amp;</code>、<code>|</code>和<code>^</code>归为了一类，并称它们为支持多运算符同时计算的二元运算符元函数。</p><p>与支持多操作数的二元运算符不同，减法、除法等运算对于操作数顺序有着严格的要求，所以对于这类运算而言，他们无法支持像加法这种多操作数的运算。也正因如此，减法、除法、移位等这些运算的模板元函数的实现更加的简单了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minus</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value - N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divides</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,</span><br><span class="line">                                          <span class="keyword">typename</span> N2::value_type&gt;::type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value / N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>观察以上代码可知，减法和除法元函数的实现基本上就是加法元函数的一个特化的实现。另外它们也只有一个运算符的区别，同样可以通过宏将其简化为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_SINGLE_OP(name, op)                                          \</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span>                                             \</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>                                                             \</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> largest_int&lt;<span class="keyword">typename</span> N1::value_type,        \</span><br><span class="line">                                            <span class="keyword">typename</span> N2::value_type&gt;::type; \</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value op N2::value)&gt;;      \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;                        \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(minus, -);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(divides, /);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(modulus, %);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(left_shift, &lt;&lt;);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP</span>(right_shift, &gt;&gt;);</span><br></pre></td></tr></table></figure><p>这里<code>-</code>、<code>/</code>、<code>%</code>、<code>&lt;&lt;</code>和<code>&gt;&gt;</code>被归为一类，也就是普通的二元运算符元函数。</p><p>除了以上算数运算符之外，还有一个容易被忽略的运算符——取负运算符。当然，相对于前两种运算符，它的实现就更加简单了：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">negate</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> T::value_type;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, -T::value&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>综合上述运算符元函数，我们来做一道计算题<code>-((5+(10-2)*3*5/2) &lt;&lt; 2)</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> step1 = minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;;                       <span class="comment">// step1 = 10-2</span></span><br><span class="line"><span class="keyword">using</span> step2 = times&lt;<span class="keyword">typename</span> step1::type, int_&lt;<span class="number">3</span>&gt;, int_&lt;<span class="number">5</span>&gt;&gt;;  <span class="comment">// step2 = step1*3*5</span></span><br><span class="line"><span class="keyword">using</span> step3 = divides&lt;<span class="keyword">typename</span> step2::type, int_&lt;<span class="number">2</span>&gt;&gt;;         <span class="comment">// step3 = step2/2</span></span><br><span class="line"><span class="keyword">using</span> step4 = plus&lt;int_&lt;<span class="number">5</span>&gt;, <span class="keyword">typename</span> step3::type&gt;;            <span class="comment">// step4 = 5+step3</span></span><br><span class="line"><span class="keyword">using</span> step5 = left_shift&lt;<span class="keyword">typename</span> step4::type, int_&lt;<span class="number">2</span>&gt;&gt;;      <span class="comment">// step5 = step4 &lt;&lt; 2</span></span><br><span class="line"><span class="keyword">using</span> result_step = negate&lt;<span class="keyword">typename</span> step5::type&gt;;             <span class="comment">// result_step = -step5</span></span><br><span class="line"><span class="keyword">auto</span> result_value = result_step::value;</span><br></pre></td></tr></table></figure><p>编译以上代码，编译器计算<code>result_step</code>的类型为<code>int_&lt;-260&gt;</code>，所以<code>result_value</code>为-260。</p><h2 id="关系运算符元函数"><a href="#关系运算符元函数" class="headerlink" title="关系运算符元函数"></a>关系运算符元函数</h2><p>在C++中，想获得两个整数之间的关系是很容易的一件事。比如比较3和7的大小，只需要使用关系运算符<code>&lt;</code>或者<code>&gt;</code>。但使用C++模板元编程事情就变得不那么容易了，我们需要比较的是整型常量包装类之间关系，比如比较<code>int_&lt;3&gt;</code>和<code>int_&lt;7&gt;</code>的大小。所以除了算数运算符元函数，YAMPL还应该提供一套描述整型常量包装类之间关系的元函数，这也是C++模板元编程中必不可少的一环。</p><p>好在我们已经有了实现算术运算符元函数的基础，再实现一套关系运算符元函数也并不会觉得很难，下面是<code>==</code>运算符元函数的实现代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">equal_to</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value == N2::value)&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码十分简洁，甚至是在算术运算符元函数中一直发挥重要作用的<code>largest_int</code>也被省去了。在<code>equal_to</code>元函数中，<code>value_type</code>被直接定义为<code>bool</code>，这很容易理解，因为关系运算符的计算结果本就是布尔类型。因此，元函数返回的结果<code>type</code>就是<code>integral_const&lt;value_type, true&gt;</code>或者<code>integral_const&lt;value_type, false&gt;</code>。是不是看上去非常熟悉？没错，它们正是<code>true_type</code>和<code>false_type</code>的定义。</p><p>基于和算术类型的元函数同样的原因，关系运算符的元函数也能用宏来做统一的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_SINGLE_OP_BOOL(name, op)                                \</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span>                                        \</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>                                                        \</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;                                           \</span><br><span class="line">    <span class="keyword">using</span> type = integral_const&lt;value_type, (N1::value op N2::value)&gt;; \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = type::value;                   \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(equal_to, ==);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(not_equal_to, !=);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(greater, &gt;);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(greater_equal, &gt;=);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(less, &lt;);</span><br><span class="line"><span class="built_in">BINARY_SINGLE_OP_BOOL</span>(less_equal, &lt;=);</span><br></pre></td></tr></table></figure><p>在上面的代码中<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>和<code>&lt;=</code>被归为一类，可以称它们为返回布尔包装类的二元运算符元函数。调用它们将返回<code>true_type</code>或者<code>false_type</code>，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> step1 = <span class="keyword">typename</span> minus&lt;int_&lt;<span class="number">10</span>&gt;, int_&lt;<span class="number">2</span>&gt;&gt;::type;</span><br><span class="line"><span class="keyword">using</span> result_type1 = <span class="keyword">typename</span> equal_to&lt;step1, int_&lt;<span class="number">8</span>&gt;&gt;::type;<span class="comment">// true_type</span></span><br><span class="line"><span class="keyword">using</span> result_type2 = <span class="keyword">typename</span> greater&lt;step1, int_&lt;<span class="number">8</span>&gt;&gt;::type; <span class="comment">// false_type</span></span><br><span class="line"><span class="keyword">using</span> result_type3 = <span class="keyword">typename</span> less&lt;step1, int_&lt;<span class="number">8</span>&gt;&gt;::type;    <span class="comment">// false_type</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>YAMPL的基础组件(1)</title>
      <link href="/2020/01/09/yampl-base-components-part1/"/>
      <url>/2020/01/09/yampl-base-components-part1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>从本篇开始，我们将开始进入轻量级C++模板元编程库YAMPL(Yet Another MPL)的编写环节。不过，在深入探索元编程的序列和算法之前，有一些基础工作必须完成，比如定义命名空间、定义整型常量包装类模板，编写包装类的算数和逻辑运算元函数、编写用于调试的类型打印元函数等等。在完成了这些基础组件后，序列和算法的编写工作将会变得非常高效和有趣。</p><h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><p>在前面的文章中，我们定义了两个特殊的类型<code>true_type</code>和<code>false_type</code>。不巧的是，在STL中也有两个一模一样的类型名，而且这两个类型在STL的type_traits中被广泛的使用，例如：<code>std::is_same</code>、<code>std::is_class</code>、<code>std::is_const</code>等等，它们的返回类型就是上述两种类型的其中之一。无独有偶，在Boost中也有这样的两个类型。其实，有一点很容易想到，作为Boost.MPL的模仿者，YAMPL中一定会存在大量与Boost.MPL中相同的命名。所以为了解决以上这类问题，必须为YAMPL安排一个命名空间。为了直观，我就直接定义YAMPL的命名空间名为<code>yampl</code>。</p><p>那么现在对于<code>true_type</code>这样的类型有三种实现，包括：<code>yampl::true_type</code>、<code>stl::true_type</code>以及<code>boost::true_type</code>。面对这样的情况，我们有时候会需要一个类型的转换元函数，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_convert_to</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_convert_to</span>&lt;</span>T, T, V&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = V;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> stl_to_yampl_true_type = type_convert_to&lt;T, std::true_type, yampl::true_type&gt;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，元函数<code>stl_to_yampl_true_type</code>可以将<code>std::true_type</code>转换为<code>yampl::true_type</code>，如果该元函数的实参不是<code>std::true_type</code>则编译出错。如果有需要在库与库之间频繁切换的情况，实现一个这样的转换元函数是很有用的一种方法。</p><p>有一点需要指出的是，在后面的文章中会涉及到一些对YAMPL中元函数调用的示例，这些示例一般都默认认为已经使用<code>using namespace yampl;</code>打开过<code>yampl</code>的命名空间，所以没有使用前缀写法<code>yampl::xxx</code>。只有涉及到不同命名空间类型互相转换的情况才会用前缀的方式指明命名空间。</p><h2 id="整型常量包装类模板"><a href="#整型常量包装类模板" class="headerlink" title="整型常量包装类模板"></a>整型常量包装类模板</h2><p>在YAMPL中的元函数都是关于类型的计算，但有时候数值计算却又是不可避免的。为了让类型计算的元函数能兼容数值计算，我们需要一个特殊的类模板，它能够将数值转换为类型。这里我们称这个特殊的类模板为整型常量包装类模板。其实在上一篇中我们已经见到过它的简化版本，以下是它的完整版：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_const</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = N;</span><br><span class="line">  <span class="keyword">using</span> next = integral_const&lt;T, N + <span class="number">1</span>&gt;;</span><br><span class="line">  <span class="keyword">using</span> prior = integral_const&lt;T, N - <span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>integral_const</code>是整型常量包装类模板，其模板形参<code>T</code>是包装常量的类型，形参<code>N</code>是包装的具体数值，例如：<code>integral_const&lt;int, 5&gt;</code>是一个包装了数值为1的<code>int</code>类型常量的类型。<code>integral_const</code>定义了静态数据成员<code>value</code>来返回包装类型代表的具体数值，定义<code>value_type</code>来指示返回数值的准确类型。另外为了元函数调用形式上的统一，<code>integral_const</code>还定义内嵌类型<code>type</code>为自身。最后我们还可以发现，<code>integral_const</code>为了方便完成数值的自增和自减操作，分别定义了<code>next</code>和<code>prior</code>来表示<code>integral_const&lt;T, N + 1&gt;</code>和<code>integral_const&lt;T, N - 1&gt;</code>，于是我们可以完成这样的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::is_same_v&lt;integral_const&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt;::next, integral_const&lt;<span class="keyword">int</span>, <span class="number">6</span>&gt;&gt;;</span><br></pre></td></tr></table></figure><p><code>std::is_same_v</code>返回的结果为<code>true</code>。</p><p>到目前为止<code>integral_const</code>似乎已经满足要求了，这很好，但还有一点却令人厌烦。考虑一下如果我们需要在序列中声明一连串的<code>integral_const</code>会发生什么？</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">seq&lt;integral_const&lt;<span class="keyword">int</span>, <span class="number">1</span>&gt;, integral_const&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt;, integral_const&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;, ...&gt;</span><br></pre></td></tr></table></figure><p>显然这种写法过于冗长，这里需要一种更简洁的表达方法，我选择使用别名模板：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> int_ = integral_const&lt;<span class="keyword">int</span>, N&gt;;</span><br></pre></td></tr></table></figure><p>这样一来定义上面的序列会简洁不少：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">seq&lt;int_&lt;<span class="number">1</span>&gt;, int_&lt;<span class="number">2</span>&gt;, int_&lt;<span class="number">3</span>&gt;, ...&gt;</span><br></pre></td></tr></table></figure><p>另外，读者还可以定义其他别名模板以满足自己的需求，比如定义一个无符号整型常量的包装类模板：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> uint_ = integral_const&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, N&gt;;</span><br></pre></td></tr></table></figure><p>值得注意的是，布尔类型也可以使用<code>integral_const</code>来表示，因为它能和整型发生隐式转换，但会有一些不同之处，请看下面这个针对<code>bool</code>的特化版本：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_const</span>&lt;</span><span class="keyword">bool</span>, N&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">bool</span>;</span><br><span class="line">  <span class="keyword">using</span> type = integral_const;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> value_type value = N;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> bool_ = integral_const&lt;<span class="keyword">bool</span>, N&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> true_type = bool_&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = bool_&lt;<span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure><p>观察上面的代码可以发现，特化版本的<code>integral_const</code>删除了<code>next</code>和<code>prior</code>，这是因为布尔类型只有<code>true</code>和<code>false</code>之分，自增和自减对于它是没有意义的。另外还定义了<code>true_type</code>和<code>false_type</code>以方便后续使用，它们在YAMPL中使用的是比较频繁的。</p><h2 id="if元函数"><a href="#if元函数" class="headerlink" title="if元函数"></a>if元函数</h2><p><code>if</code>元函数是YAMPL中最常用的元函数之一，又因为它不依赖其他元函数，所以应该优先介绍它。不过实际上，我们在上一篇已经对<code>if</code>元函数做过了比较详细的介绍了，为了本篇知识体系的完整性这里将它拿出来总结一下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_c</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = N1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_c</span>&lt;</span><span class="literal">false</span>, N1, N2&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = N2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">N1</span>, <span class="keyword">class</span> <span class="title">N2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> if_c&lt;!!T::value, N1, N2&gt;::type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码有两个元函数<code>if</code>和<code>if_c</code>，其中<code>if_c</code>是真正实现选择逻辑的元函数，它接受的条件参数是布尔值。而元函数<code>if</code>对<code>if_c</code>进行了一次包装，这使得它接受的条件参数从一个布尔值转换为了类型，而且这种类型还有相当不错的兼容性，它只要求类型具有静态数据成员<code>value</code>即可，所以上一节提到的<code>true_type</code>、<code>false_type</code>、<code>int_&lt;7&gt;</code>甚至其他库的<code>std::true_type</code>、<code>boost::mpl::false_</code>等等都可以兼容<code>if</code>元函数。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>元函数和序列(2)</title>
      <link href="/2019/12/12/metaprogramming-metafunction-part2/"/>
      <url>/2019/12/12/metaprogramming-metafunction-part2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>接着上一篇的话题</p><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>一说到序列，我们很容易想到STL中的容器<code>vector</code>。相对于数组，C++程序员显然更喜欢<code>vector</code>，这不仅是因为<code>vector</code>可以动态的扩展容器的空间，更是因为STL为它提供了一系列使用算法，比如插入、查找等等。事实上，关于STL序列的设计思路放在C++模板元编程中也同样适用。要知道，Boost.MPL中的大多数算法都是操作于序列之上的，它能够发挥模板元编程更大潜力，也正因如此序列对于模板元编程才如此的重要。</p><p>当然，相对于STL的<code>vector</code>使用于运行期，模板元编程的序列必须是在编译阶段就能够存储数据的，所以我们能够使用的也只有类模板，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>seq</code>是一个最简单的序列，但千万别小瞧了它，因为它能够容纳任意多个元素。而实现这一能力的关键是C++11标准中引入的可变模板参数的特性，所以这里<code>seq</code>真正存储数据的是模板参数，比如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> integer_list = seq&lt;<span class="keyword">int</span>, <span class="keyword">short</span>, <span class="keyword">char</span>&gt;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类模板实参<code>&lt;int, short, char&gt;</code>为序列<code>seq</code>的保存元素。好了，现在我们已经有了一个最基本的序列，接下来还需要准备一些配合序列的算法。继续对比STL的<code>vector</code>，最常用的<code>vector</code>算法应该是成员函数<code>push_back</code>，那么我们也来给<code>seq</code>实现一个编译阶段的<code>seq_push_back</code>元函数。这听起来似乎有些难度，不过事实上在可变模板形参的基础上实现<code>push_back</code>算法是很容易的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_push_back</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_push_back</span>&lt;</span>seq&lt;Args...&gt;, T&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = seq&lt;Args..., T&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，首先声明了一个元函数<code>seq_push_back</code>，它有两个形参分别为<code>S</code>和<code>T</code>，其中<code>S</code>表示序列，而<code>T</code>代表即将插入的元素。接着代码偏特化了一个<code>seq_push_back</code>，该版本对<code>S</code>为<code>seq</code>的情况定义了元函数的具体实现。请注意这里的实现细节，因为后文中很多算法的实现都基于这个思路。在这个版本中引入了可变形参<code>class... Args</code>，并且将其运用于特化的参数中<code>struct seq_push_back&lt;seq&lt;Args...&gt;, T&gt;</code>，这样就可以利用编译器推导出<code>Args</code>的具体实参。最终通过<code>Args</code>定义新的<code>seq</code>类型以达到<code>push_back</code>算法的目的：<code>using type = seq&lt;Args..., T&gt;;</code>。值得注意的是，元函数<code>seq_push_back</code>并没有提供通用版本的实现，所以当模板实参<code>S</code>不是<code>seq</code>类型的时候编译将无法正确进行。</p><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><p>在C++模板元编程中代码的选择结构是由元函数实现的。这一点比较容易理解，毕竟类模板的特化正好适合来做这件事，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> C, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_</span>&lt;</span><span class="literal">false</span>, T, F&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码实现了两个版本的<code>if_</code>元函数，其中通用版本无条件的返回模板形参<code>T</code>，而针对模板形参<code>C</code>为<code>false</code>的偏特化版本返回的则是模板形参<code>F</code>。这样一来元函数就可以根据模板形参<code>C</code>的具体值返回不同的类型，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">if_&lt;<span class="literal">false</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::type double_value;</span><br><span class="line">if_&lt;<span class="literal">true</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::type int_value;</span><br></pre></td></tr></table></figure><p>作为模板元编程中编写选择结构的常用技巧，STL也实现了一份类似的代码，不过在STL中元函数的函数名为<code>conditional</code>，除此以外基本上没有差异包括调用方式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::conditional&lt;<span class="literal">true</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::type</span><br></pre></td></tr></table></figure><p>请注意，无论是上面的<code>if_</code>还是<code>std::conditional</code>都存在一个问题，那就是将数值和类型计算混合了。我们希望能有一个只有类型计算的<code>if_</code>版本。想达到这个目的需要用到编写<code>plus</code>元函数时的同一个技巧，即创建一个布尔值和类型之前的桥梁：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> C&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bool_</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> true_type = bool_&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = bool_&lt;<span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将数值和类型进行了转换，数值<code>true</code>和<code>false</code>分别转换为了类型<code>true_type</code>和<code>false_type</code>。于此同步的，<code>if_</code>也需要进行一些修改：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> C, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_c</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_c</span>&lt;</span><span class="literal">false</span>, T, F&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">if_</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> if_c&lt;!!C::value, T, F&gt;::type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中存在两个选择元函数<code>if_c</code>和<code>if_</code>，其中<code>if_c</code>的实现和上一个版本的<code>if_</code>一样，通过布尔值<code>C</code>来确定返回的类型。相对的，当前版本的<code>if_</code>元函数的第一个参数<code>C</code>是类型而非是布尔值，进一步来说这个类型<code>C</code>必须是一个带有常量静态数据成员<code>value</code>的类型。元函数<code>if_</code>会通过<code>!!C::value</code>的方法将数值转换成布尔值，最终调用<code>if_c</code>返回目标类型。</p><p>由于元函数<code>if_</code>的形参发生了改变，其调用方法也需要做相应的调整：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">if_&lt;false_type, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::type double_value;</span><br><span class="line">if_&lt;true_type, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::type int_value;</span><br></pre></td></tr></table></figure><p>“<code>if_</code>是改写好了，但是我到目前为止并没有发现这样大动干戈改写的任何好处呀？”相信很多读者会有这样的疑问。这很好，不过现在还不是解释这个问题的最佳时机，请先相信这样的修改一定会带来某种优势吧。</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>与选择结构不同，循环结构没有惯用元函数的具体实现。一般来说，模板元编程中的循环都是根据实际需要来实现的。不过好在它们的实现都有固定的方法和模式，所以总体而言并不算难。让我们先看一个例子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;</span>N, Args...&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = N + sum&lt;Args...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;</span>N&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = N;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，元函数<code>sum</code>有3个版本，其中通用版本的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>;</span></span><br></pre></td></tr></table></figure><p>只有声明却没提供实现，而真正的实现是由它的两个特化版本来完成的。首先<code>struct sum&lt;N, Args...&gt;</code>是一个通过递归完成循环的元函数，它的返回值是第一个形参<code>N</code>与使用剩余形参调用的<code>sum</code>的返回值之和，这样理所当然的形成了一个循环结构。请注意，在普通的C++编程中，我们经常会用到无限循环，但是在模板元编程中无限循环不具有任何意义，毕竟谁也不想自己的程序永远无法通过编译。事实上也真不会发生这样的事情，因为编译器最终会由于递归过多而停止编译并报错。所以在元编程的循环结构中，我们需要为其准备一个有效的结束条件。在本例中，这个结束条件就是<code>struct sum&lt;N&gt;</code>，它定义当<code>sum</code>的形参只剩下一个时递归结束，直接返回形参<code>N</code>，至此整个递归开始折返。</p><p>调用元函数<code>sum</code>:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = sum&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&gt;::value;</span><br></pre></td></tr></table></figure><p>这句代码在编译器中的计算顺序相当于：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = <span class="number">1</span> + (<span class="number">2</span> + (<span class="number">3</span> + (<span class="number">4</span>)));</span><br></pre></td></tr></table></figure><p>也正是递归操作的顺序。</p><p>以上是一个数值计算的求和元函数，按照惯例我们实际期望的是类型计算元函数。接下来我们可以利用之前介绍的<code>plus</code>元函数来实现一个类型计算的求和元函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;</span>N, Args...&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> plus&lt;N, <span class="keyword">typename</span> sum&lt;Args...&gt;::type&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span>&lt;</span>N&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = N;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = sum&lt;int_&lt;<span class="number">1</span>&gt;, int_&lt;<span class="number">2</span>&gt;, int_&lt;<span class="number">3</span>&gt;, int_&lt;<span class="number">4</span>&gt;&gt;::type::value;</span><br></pre></td></tr></table></figure><p>可以看到在上面的代码中关于数值计算的痕迹都被抹去，元函数的调用方式也发生了略微的变化。但是不变的是实现循环结构的方法。在代码中<code>using type = typename plus&lt;N, typename sum&lt;Args...&gt;::type&gt;::type;</code>虽然冗长但还算清晰，很明显<code>type</code>的结果依赖元函数<code>plus</code>计算的结果，而<code>plus</code>的计算结果又依赖于<code>sum</code>的第一个形参与剩余形参调用<code>sum</code>的计算结果，这样就形成了递归，除多了一步<code>plus</code>的调用以外其他过程基本上和上一个版本一致。另外，同样一致的还有递归的结束条件，<code>struct sum&lt;N&gt;</code>与上一个版本唯一的区别是返回类型本身而不是返回数值。</p><p>根据以上两个例子我们可以总结出模板元编程循环结构的两个关键点：更新形参递归并调用元函数本身以及定义有效的结束条件。让我们带上这两个关键点来看下一个例子，这个例子结合了上文提到的序列和选择结构，实际上循环和选择正是序列相关算法的关键，在真实的模板元编程代码中它们是最好的搭档。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">result_wrap</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_is_all_reference</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_is_all_reference</span>&lt;</span>seq&lt;T, Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> cond = <span class="keyword">typename</span> std::is_reference&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> result = <span class="keyword">typename</span> if_&lt;cond, seq_is_all_reference&lt;seq&lt;Args...&gt;&gt;, result_wrap&lt;false_type&gt;&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> result::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_is_all_reference</span>&lt;</span>seq&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> cond = <span class="keyword">typename</span> std::is_reference&lt;T&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> if_&lt;cond, true_type, false_type&gt;::type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，元函数<code>seq_is_all_reference</code>的作用是判断序列<code>seq</code>中的元素是否全都是引用类型，如果都是引用类型就返回<code>true_type</code>，否则返回<code>false_type</code>。在实现上<code>seq_is_all_reference</code>相对复杂一些，因为代码中循环和选择发生了互相嵌套的情况。<code>seq_is_all_reference&lt;seq&lt;T, Args...&gt;&gt;</code>首先判断第一个参数<code>T</code>是否为引用类型，并将结果<code>cond</code>作为实参调用元函数<code>if_</code>。接下来<code>if_</code>判断<code>cond</code>的结果，如果结果为<code>std::true_type</code>则进入递归流程<code>seq_is_all_reference&lt;seq&lt;Args...&gt;</code>，目的是判断后续的参数是否为引用类型。如果<code>cond</code>的结果是<code>std::false_type</code>，那么循环终止并返回<code>false_type</code>。请注意，这里<code>cond</code>是<code>std::is_reference&lt;T&gt;</code>返回的结果，所以结果类型是<code>std::true_type</code>或者<code>std::false_type</code>，而<code>seq_is_all_reference</code>是我们自己的元函数，其返回结果是<code>true_type</code>或者<code>false_type</code>。另外，读者可能也发现了，在<code>seq_is_all_reference</code>的循环结束条件并非只有一个。比较明显的是<code>seq_is_all_reference&lt;seq&lt;T&gt;&gt;</code>，它定义当形参只剩一个的情况下元函数返回<code>cond</code>的结果。除此之外，<code>seq_is_all_reference&lt;seq&lt;Args...&gt;</code>还隐含了一个结束条件，就是当<code>cond</code>为<code>std::false_type</code>时递归中断并返回结果。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> test_seq1 = seq&lt;<span class="keyword">int</span>&amp;, <span class="keyword">double</span>, <span class="keyword">short</span>&amp;&gt;;</span><br><span class="line"><span class="keyword">using</span> test_seq2 = seq&lt;<span class="keyword">int</span>&amp;, <span class="keyword">double</span>&amp;, <span class="keyword">short</span>&amp;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> result_type1 = seq_is_all_reference&lt;test_seq1&gt;::type;<span class="comment">// result_type1为false_type</span></span><br><span class="line"><span class="keyword">using</span> result_type2 = seq_is_all_reference&lt;test_seq2&gt;::type; <span class="comment">// result_type2为true_type</span></span><br></pre></td></tr></table></figure><p>以上代码演示了对<code>seq_is_all_reference</code>的使用方法。其中序列<code>test_seq1</code>中由于<code>double</code>不是引用类型的关系，所以返回结果是<code>false_type</code>。而序列<code>test_seq2</code>中的所有元素都是引用类型于是返回了<code>true_type</code>。来看一个更加实际的例子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_class_need_ref</span> &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(seq_is_all_reference&lt;seq&lt;Args...&gt;&gt;::type::value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_class_need_ref&lt;<span class="keyword">int</span>&amp;, <span class="keyword">double</span>&amp;&gt; obj1;<span class="comment">// 编译成功</span></span><br><span class="line">some_class_need_ref&lt;<span class="keyword">int</span>&amp;, <span class="keyword">double</span>&gt; obj2;<span class="comment">// 触发static_assert，编译失败</span></span><br></pre></td></tr></table></figure><p>上面的代码定义了一个特别的类模板，它要求模板参数必须都是引用类型。它在定义中加上了<code>static_assert(seq_is_all_reference&lt;seq&lt;Args...&gt;&gt;::type::value);</code>以检查调用者是否正确实例化了类模板。在编译的过程中，编译器发现<code>obj2</code>的类型<code>some_class_need_ref&lt;int&amp;, double&gt;</code>的模板参数并不是规定中的引用类型，于是<code>static_assert</code>被触发导致编译失败。</p><p>到目前为止，我们已经了解了C++模板元编程中元函数和序列的基本概念和使用方法。另外我们还看到了用元函数来控制选择和循环等代码流程的方法，之后我们将选择和循环结合在一起完成了一个判断序列中的所有元素是否为引用类型的元函数示例。可以说我们现在已经有办法独立编写一些模板元程序了。接下来的文章将会更进一步，我们将会接触到更为复杂的元程序，在那里我们会一起实现一个轻量级C++模板元编程库——YAMPL。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>元函数和序列(1)</title>
      <link href="/2019/11/11/metaprogramming-metafunction-part1/"/>
      <url>/2019/11/11/metaprogramming-metafunction-part1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>元函数简单来说就是一种可以在编译期调用的函数，它操作的对象一定是编译期可以确定的，比如类型和常量。元函数也是模板元编程中最基础的组成部分，甚至代码中的选择和循环等控制流都是由元函数来完成。而序列则进一步释放了元函数的威力，我们可以通过元函数为序列提供丰富的算法以解决各种实际问题。</p><h2 id="元函数"><a href="#元函数" class="headerlink" title="元函数"></a>元函数</h2><p>一个普通的C++函数通常由函数名称、参数、返回类型以及函数主体这4个部分组成，比如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为对比，C++模板元编程的元函数同样也存在函数名称、参数以及函数主体3个部分，只不过它们的形式有一些不同罢了。还是以<code>plus</code>函数为例，将其改写为元函数后的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> a, <span class="keyword">int</span> b&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到以上代码，有人可能会惊呼道：“这哪是什么函数，它明明就是一个类模板！”。是的没错！它确实是一个类模板，可同时也是一个元函数。让我们先接受这个定义，这样可以让我们很容易的找到它和普通函数版本的对应关系：首先<code>plus</code>作为类模板名也是元函数名，然后类模板形参<code>int a, int b</code>对应是元函数的形参，最后元函数的函数体就是类模板的定义。虽然在元函数中我们没有办法定义返回类型（实际上也没有必要定义，因为大多数时候元函数返回的就是类型本身），但是可以通过约定元函数的函数体中静态变量名称的方法定义数值的返回值，体现在<code>plus</code>中即为<code>static constexpr int value = a + b;</code>，通常情况下，元函数会约定<code>value</code>为数值类型的返回值名称。</p><p>另外还有一种特殊的情况，当元函数没有形参时，对应的则是类或者实例化的类模板。比如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kilometer</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> plus11 = plus&lt;<span class="number">3</span>, <span class="number">8</span>&gt;;</span><br></pre></td></tr></table></figure><p>在C++模板元编程中，对于数值计算元函数的调用实际上就是访问起静态成员，根据约定会获取<code>value</code>的值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = plus&lt;<span class="number">7</span>, <span class="number">11</span>&gt;::value;</span><br><span class="line"><span class="keyword">auto</span> x2 = kilometer::value;</span><br><span class="line"><span class="keyword">auto</span> x3 = plus11::value;</span><br></pre></td></tr></table></figure><p>到此为止，我们看到的都是有关数值计算的元函数，但是我又强调过数值计算并非元函数的重点工作。其实这是有意为之，目的是为了方便元函数与普通函数的对比，接下来让我把数值转换为类型以帮助我们讨论类型计算元函数。</p><p>这里我并不打算让类型计算元函数的例子显得过于跳跃，所以还是以<code>plus</code>为例将其修改为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int_</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = int_&lt;T1::value + T2::value&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中新增了一个类模板<code>int_</code>。<code>int_</code>的实现非常简单，只是将数值转换成了类型。不过请不要小看了它的作用，因为它为类型计算元函数提供了计算数值的桥梁。我们发现元函数<code>plus</code>的参数不再是数值类型而是类型本身，更有意思的是它也不再返回数值而是返回类型本身。请注意，对于类型计算的元函数，返回的是可公开访问的嵌套类型，我们通常约定该类型名为<code>type</code>。在这个例子中即是：<code>using type = int_&lt;T1::value + T2::value&gt;;</code>。当然，除了使用<code>using</code>来定义别名以外，使用<code>typedef</code>也是允许的。我选择使用<code>using</code>，一方面因为它是新标准推荐的做法，另一方面从语法上看它更像是一个赋值语句，作为元函数的一部分它更容易理解。</p><p>同样的道理，调用类型计算元函数也需要用到<code>using</code>或者<code>typedef</code>，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> new_type = <span class="keyword">typename</span> plus&lt;int_&lt;<span class="number">7</span>&gt;, int_&lt;<span class="number">11</span>&gt;&gt;::type;</span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(std::is_same_v&lt;new_type, int_&lt;<span class="number">18</span>&gt;&gt;);</span><br></pre></td></tr></table></figure><p>上面的代码可以成功编译，这表明通过元函数<code>plus&lt;int_&lt;7&gt;, int_&lt;11&gt;&gt;::type</code>得出的新类型<code>new_type</code>和预期结果<code>int_&lt;18&gt;</code>是符合的。</p><p>还有需要解释的一点是，虽然上文中介绍一些编写元函数的常规约定，但是有时候也可以灵活处理。比如，作为元函数的本体类模板，完全有能力返回多个嵌套类型或者常量数值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = int_&lt;T1::value + T2::value&gt;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = type::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样修改的好处是能够直接访问元函数计算的数值结果，而不必通过<code>::type</code>间接的访问：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = plus&lt;int_&lt;<span class="number">7</span>&gt;, int_&lt;<span class="number">11</span>&gt;&gt;::value;</span><br></pre></td></tr></table></figure><p>最后也是元函数最重要的一个特点：特化。特化是C++模板元编程能够成立的根基。我们知道通过特化可以针对类模板的特定参数来规定类模板的具体行为，而元函数正是利用这一点来实现选择和循环等控制流的。关于特化在元函数中具体的使用方法，我将在后面的内容中详细介绍。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初探C++模板元编程</title>
      <link href="/2019/10/20/metaprogramming-overview/"/>
      <url>/2019/10/20/metaprogramming-overview/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>C++模板元编程，通常来说是指利用模板控制编译器产生临时源代码的技术。该临时源代码可以和以后代码共同编译为可执行程序。由于模板元编程控制的是编译器，所以这个过程是在编译期进行，对于代码运行期的状态没有影响。</p><p>使用C++模板元编程编写的程序我们可以称之为模板元程序，最简单的模板元程序我们可以写成这样：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> mytype = <span class="keyword">int</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;std::is_same&lt;mytype, int&gt;::value = &quot;</span></span><br><span class="line">            &lt;&lt; std::is_same&lt;mytype, <span class="keyword">int</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中<code>std::is_same&lt;mytype, int&gt;::value</code>是典型的模板元程序代码，编译器会在编译期对这句代码进行计算，最终产生以下临时代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;std::is_same&lt;mytype, int&gt;::value = &quot;</span></span><br><span class="line">            &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>进一步可以看出，由于<code>std::is_same&lt;mytype, int&gt;::value</code>在编译期已经得出结果，所以它并不会对程序的运行产生任何副作用。</p><p>解释到这里，我想读者应该对C++模板元编程和模板元程序有了一个大概的理解。实际上，在我刚刚接触到模板元程序的时候，最疑惑的问题就是它为什么叫做元程序（metaprogram）。经过一番研究后发现，meta起源于希腊语，有after和beyond的含义，作为前缀通常用于表达更高抽象水平的描述。比如在解释数据库元数据（MetaData）时，我们说它是定义数据的数据。而联想到元程序，同样也可以理解为定义程序的程序。熟悉编写编译器的读者应该会接触到flex和bison（或者lex和yacc）。它们是一对词法和语法的解析器生成器，我们可以通过定义词法和语法规则让它们生成出相当完善的词法和语法的解析器源代码，所以flex和bison就是一对最典型的元程序。</p><h2 id="最早的C-模板元程序"><a href="#最早的C-模板元程序" class="headerlink" title="最早的C++模板元程序"></a>最早的C++模板元程序</h2><p>1994年Erwin Unruh在C++委员会上提交了下面这份代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prime number computation by Erwin Unruh</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span> <span class="built_in">D</span>(<span class="keyword">void</span>*); <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> p, <span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> prim = (p%i) &amp;&amp; is_prime&lt;(i &gt; <span class="number">2</span> ? p : <span class="number">0</span>), i <span class="number">-1</span>&gt; :: prim &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">int</span> i &gt; <span class="class"><span class="keyword">struct</span> <span class="title">Prime_print</span> &#123;</span></span><br><span class="line">    Prime_print&lt;i<span class="number">-1</span>&gt; a;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> prim = is_prime&lt;i, i<span class="number">-1</span>&gt;::prim &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; D&lt;i&gt; d = prim; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span>&lt;</span><span class="number">0</span>,<span class="number">0</span>&gt; &#123; <span class="class"><span class="keyword">enum</span> &#123;</span>prim=<span class="number">1</span>&#125;; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span>&lt;</span><span class="number">0</span>,<span class="number">1</span>&gt; &#123; <span class="class"><span class="keyword">enum</span> &#123;</span>prim=<span class="number">1</span>&#125;; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Prime_print</span>&lt;</span><span class="number">2</span>&gt; &#123; <span class="class"><span class="keyword">enum</span> &#123;</span>prim = <span class="number">1</span>&#125;; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; D&lt;<span class="number">2</span>&gt; d = prim; &#125; &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">    Prime_print&lt;LAST&gt; a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从类模板命名上看，它似乎是一份打印质数的代码。但是请注意，这份代码在现在看来并不符合当前C++的语法规范，所以是无法通过编译的。实际上，当时Erwin Unruh使用的是一款叫做Metaware Compiler的编译器编译的上述代码，虽然仍然无法通过编译，但是却能输出一些有趣的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MetaWare High C&#x2F;C++ Compiler R2.6</span><br><span class="line">(c) Copyright 1987-94, MetaWare Incorporated</span><br><span class="line">E &quot;primes.cpp&quot;,L16&#x2F;C63(#416):   prim</span><br><span class="line">|    Type &#96;enum&#123;&#125;´ can´t be converted to txpe &#96;D&lt;2&gt;´ (&quot;primes.cpp&quot;,L2&#x2F;C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21&#x2F;C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11&#x2F;C25(#416):   prim</span><br><span class="line">|    Type &#96;enum&#123;&#125;´ can´t be converted to txpe &#96;D&lt;3&gt;´ (&quot;primes.cpp&quot;,L2&#x2F;C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21&#x2F;C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11&#x2F;C25(#416):   prim</span><br><span class="line">|    Type &#96;enum&#123;&#125;´ can´t be converted to txpe &#96;D&lt;5&gt;´ (&quot;primes.cpp&quot;,L2&#x2F;C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21&#x2F;C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11&#x2F;C25(#416):   prim</span><br><span class="line">|    Type &#96;enum&#123;&#125;´ can´t be converted to txpe &#96;D&lt;7&gt;´ (&quot;primes.cpp&quot;,L2&#x2F;C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21&#x2F;C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11&#x2F;C25(#416):   prim</span><br><span class="line">|    Type &#96;enum&#123;&#125;´ can´t be converted to txpe &#96;D&lt;11&gt;´ (&quot;primes.cpp&quot;,L2&#x2F;C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21&#x2F;C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11&#x2F;C25(#416):   prim</span><br><span class="line">|    Type &#96;enum&#123;&#125;´ can´t be converted to txpe &#96;D&lt;13&gt;´ (&quot;primes.cpp&quot;,L2&#x2F;C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21&#x2F;C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11&#x2F;C25(#416):   prim</span><br><span class="line">|    Type &#96;enum&#123;&#125;´ can´t be converted to txpe &#96;D&lt;17&gt;´ (&quot;primes.cpp&quot;,L2&#x2F;C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21&#x2F;C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11&#x2F;C25(#416):   prim</span><br><span class="line">|    Type &#96;enum&#123;&#125;´ can´t be converted to txpe &#96;D&lt;19&gt;´ (&quot;primes.cpp&quot;,L2&#x2F;C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21&#x2F;C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11&#x2F;C25(#416):   prim</span><br><span class="line">|    Type &#96;enum&#123;&#125;´ can´t be converted to txpe &#96;D&lt;23&gt;´ (&quot;primes.cpp&quot;,L2&#x2F;C25).</span><br><span class="line">-- Detected during instantiation of Prime_print&lt;30&gt; at &quot;primes.cpp&quot;,L21&#x2F;C5:</span><br><span class="line">E &quot;primes.cpp&quot;,L11&#x2F;C25(#416):   prim</span><br><span class="line">|    Type &#96;enum&#123;&#125;´ can´t be converted to txpe &#96;D&lt;29&gt;´ (&quot;primes.cpp&quot;,L2&#x2F;C25).</span><br></pre></td></tr></table></figure><p>观察上面这份编译器输出的错误信息，我们发现每条错误信息都给出了一个质数，例如<code>D&lt;2&gt;</code>、<code>D&lt;3&gt;</code>、<code>D&lt;4&gt;</code>等等，这说明编译器在编译阶段已经开始了对模板的计算。在1994年之后，Erwin Unruh发现上述代码已经不能被新语法所支持，所以在2002年发布了新代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prime number computation by Erwin Unruh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span> <span class="built_in">D</span>(<span class="keyword">void</span>*); <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> p, <span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">enum</span> &#123;</span> prim = (p==<span class="number">2</span>) || (p%i) &amp;&amp; is_prime&lt;(i&gt;<span class="number">2</span>?p:<span class="number">0</span>), i<span class="number">-1</span>&gt; :: prim &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Prime_print</span> &#123;</span></span><br><span class="line"> Prime_print&lt;i<span class="number">-1</span>&gt; a;</span><br><span class="line"> <span class="class"><span class="keyword">enum</span> &#123;</span> prim = is_prime&lt;i, i<span class="number">-1</span>&gt;::prim &#125;;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; D&lt;i&gt; d = prim ? <span class="number">1</span> : <span class="number">0</span>; a.<span class="built_in">f</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span>&lt;</span><span class="number">0</span>,<span class="number">0</span>&gt; &#123; <span class="class"><span class="keyword">enum</span> &#123;</span>prim=<span class="number">1</span>&#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">is_prime</span>&lt;</span><span class="number">0</span>,<span class="number">1</span>&gt; &#123; <span class="class"><span class="keyword">enum</span> &#123;</span>prim=<span class="number">1</span>&#125;; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Prime_print</span>&lt;</span><span class="number">1</span>&gt; &#123;</span><br><span class="line"> <span class="class"><span class="keyword">enum</span> &#123;</span>prim=<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; D&lt;<span class="number">1</span>&gt; d = prim ? <span class="number">1</span> : <span class="number">0</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>() &#123;</span><br><span class="line"> Prime_print&lt;LAST&gt; a;</span><br><span class="line"> a.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这份代码可以用较老版本的GCC编译，比如GCC 4.1，同样的它会让编译器计算并打印出关于质数的错误信息（由于错误信息过多影响阅读，所以这里省略了无用部分，想看完整错误信息的读者可以自己尝试编译上述代码。）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#39;D&lt;i&gt;::D(void*) [with int i &#x3D; 17]&#39;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#39;D&lt;i&gt;::D(void*) [with int i &#x3D; 13]&#39;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#39;D&lt;i&gt;::D(void*) [with int i &#x3D; 11]&#39;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#39;D&lt;i&gt;::D(void*) [with int i &#x3D; 7]&#39;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#39;D&lt;i&gt;::D(void*) [with int i &#x3D; 5]&#39;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#39;D&lt;i&gt;::D(void*) [with int i &#x3D; 3]&#39;</span><br><span class="line">...</span><br><span class="line">&lt;source&gt;:12: error:   initializing argument 1 of &#39;D&lt;i&gt;::D(void*) [with int i &#x3D; 2]&#39;</span><br></pre></td></tr></table></figure><p>虽然这份代码可以使用GCC编译，不过有些遗憾的是，它依然无法编译成功。为了弥补这个缺憾，我再次对这份代码进行了修改，修改的目的有两个：</p><ol><li>使用现代C++语法；</li><li>消除错误信息，让代码能够顺利的编译。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>... args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prime_values</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>...(args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">t</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="title">template</span> &lt;</span>T...&gt; <span class="class"><span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add_to</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">t</span>, <span class="title">template</span> &lt;</span>T...&gt; <span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">template</span> &lt;</span>T...&gt; <span class="class"><span class="keyword">class</span> <span class="title">R</span>,</span></span><br><span class="line"><span class="class">          <span class="title">T</span>... <span class="title">args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add_to</span>&lt;</span>T, t, U&lt;args...&gt;, R&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> result = R&lt;t, args...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">is_prime2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n, <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prime_list</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> result = <span class="keyword">typename</span> prime_list&lt;n - <span class="number">1</span>, <span class="built_in">is_prime2</span>(n - <span class="number">1</span>)&gt;::result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prime_list</span>&lt;</span>n, <span class="number">1</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> result =</span><br><span class="line">      <span class="keyword">typename</span> add_to&lt;<span class="keyword">int</span>, n,</span><br><span class="line">                      <span class="keyword">typename</span> prime_list&lt;n - <span class="number">1</span>, <span class="built_in">is_prime2</span>(n - <span class="number">1</span>)&gt;::result,</span><br><span class="line">                      prime_values&gt;::result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prime_list</span>&lt;</span><span class="number">2</span>, <span class="number">1</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> result = prime_values&lt;<span class="number">2</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">get_prime_list_t</span> = <span class="keyword">typename</span> prime_list&lt;n, n - <span class="number">2</span>&gt;::result;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic <span class="meta-keyword">warning</span> <span class="meta-string">&quot;-Wsign-compare&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DbgPrintType</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(T) &gt; <span class="number">-1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_TYPE(x) DbgPrintType<span class="meta-string">&lt;x&gt;</span>();</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_VALUE_TYPE(x) DbgPrintType<span class="meta-string">&lt;decltype(x)&gt;</span>();</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get_prime_list_t</span>&lt;LAST&gt; x;</span><br><span class="line">  <span class="built_in">PRINT_VALUE_TYPE</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不熟悉模板元编程的读者来说，上面的代码可能不是很好理解。不过没关系，后面会详细介绍模板元编程的细节。现在我只是想让读者看到模板元编程的强大和有趣之处。</p><p>使用支持C++17标准的GCC可以成功编译以上代码并且输出以下警告信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.cpp: In instantiation of &#39;struct DbgPrintType&lt;prime_values&lt;17, 13, 11, 7, 5, 3, 2&gt; &gt;&#39;:</span><br><span class="line">test.cpp:62:3:   required from here</span><br><span class="line">test.cpp:53:24: warning: comparison of integer expressions of different signedness: &#39;long long unsigned int&#39; and &#39;int&#39; [-Wsign-compare]</span><br><span class="line">   53 |   enum &#123; n &#x3D; sizeof(T) &gt; -1 &#125;;</span><br><span class="line">      |              ~~~~~~~~~~^~~~</span><br></pre></td></tr></table></figure><p>在这些警告信息中，我们可以清晰的看到一组倒序的质数序列<code>17, 13, 11, 7, 5, 3, 2</code>。值得注意的是，这条警告是我有意而为之的，目的是为了让编译器打印出质数序列。</p><p>事实上，从语法角度来说模板元编程是图灵完备（Turing Complete）的，也就是说理论上能够解决所有可计算的问题。不过有些遗憾的是，从编译器的角度来说模板元编程是图灵不完备的，因为作为循环的实现方法，递归在编译器中是有明确的深度限制的。</p><h2 id="范型编程与C-模板元编程"><a href="#范型编程与C-模板元编程" class="headerlink" title="范型编程与C++模板元编程"></a>范型编程与C++模板元编程</h2><p>泛型编程是一种编程风格，它允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，并在实例化时作为参数指明这些类型。在C++语言中，实现范型编程的基础就是模板，换句话说模板也是为了让C++具有范型能力而设计的。</p><p>模板元编程则有些不同，正如我们在上文中看到的，它的出现更像是一个意外而并非有意设计。这也能解释模板元编程的语法为什么如此晦涩难懂。不过幸运的是，模板元编程除了晦涩难懂之外，还是带来了一些意外的惊喜。比如它可以为范型编程加入静态类型检查以及策略定制的能力。</p><h2 id="接下来做什么"><a href="#接下来做什么" class="headerlink" title="接下来做什么"></a>接下来做什么</h2><p>如果只是用C++模板元编程做数值计算，那么我敢肯定的说这种计算有90%是几乎没有意义的，因为使用运行期做数值计算往往是更好的方法。而真正让模板元编程具有价值的是它对类型的计算能力，通过类型计算能够让我们的代码更加通用且有更高的运行效率，当然代价是更加晦涩难懂的代码，更长的编译时间，以及更加复杂的错误信息。不过读者也不必担心这些代价，因为后续部分就是围绕着类型计算以及其相关问题展开的。</p><p>在后面的内容中，我们首先将接触到序列和元函数的概念以及它们的习惯用法。然后我们会使用序列和元函数完成基本的判断和循环操作。以上是模板元编程的基础部分，在此之后我们将实现一套轻量级的模板元编程库YAMPL（Yet Another MPL），YAMPL在接口上将非常接近Boost的MPL。请注意，实现YAMPL的目的并不是取代MPL，而是让我们牢牢掌握模板元编程的一种手段。</p><p>事实上，无论什么时候，只要用到模板元编程，STL的type_traits和Boost的MPL这些成熟的模板元编程库都应该是优先考虑的对象。其中STL的type_traits专注于完成关于类型的一些基本操作，它是模板元编程的基础设施，是一个正规模板元编程程序库必不可少的组成部分。而Boost的MPL则是一个强大的模板元编程框架，它构建于Boost的type_traits的基础之上，并且提供一套强大且连贯的工具集，这些工具能让C++模板元编程变得简单有趣。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>打印机API相关的一点记录</title>
      <link href="/2019/09/03/printer-api-tip/"/>
      <url>/2019/09/03/printer-api-tip/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近研究了一点Windows上打印相关的内容，发现打印这块的东西的确挺多的。比如纸张，分辨率，打印处理器，打印数据类型等等。</p><p>首先我们需要通过<code>EnumPrintersW</code>枚举打印机，为了方便我写了一个简单的类模板：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> PRINTER_INFO_2, <span class="keyword">int</span> level = <span class="number">2</span>&gt;</span><br><span class="line">class CEnumPrinter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">Init</span>(ULONG flags)</span><br><span class="line">    &#123;</span><br><span class="line">        ULONG bytes_needed = <span class="number">0</span>;</span><br><span class="line">        ULONG elems_returned = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">EnumPrintersW</span>(flags, <span class="literal">nullptr</span>, level, <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;bytes_needed, &amp;elems_returned);</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(bytes_needed);</span><br><span class="line">        <span class="built_in">EnumPrintersW</span>(flags, <span class="literal">nullptr</span>, level, buffer_.<span class="built_in">data</span>(), bytes_needed, &amp;bytes_needed, &amp;elems_returned);</span><br><span class="line">        elems_returned_ = elems_returned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ULONG <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems_returned_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] (ULONG idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(idx &lt; elems_returned_);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(buffer_.<span class="built_in">data</span>())[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;UCHAR&gt; buffer_;</span><br><span class="line">    ULONG elems_returned_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在枚举和选择目标打印机之后可以通过<code>PRINTER_INFO_2</code>中的<code>pPrinterName</code>获得打印机句柄。为了方便也写了一个类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPrinterHandle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">CPrinterHandle</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Open</span><span class="params">(LPCWSTR printer_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        std::vector&lt;WCHAR&gt; name;</span><br><span class="line">        name.<span class="built_in">resize</span>(<span class="built_in">wcslen</span>(printer_name) + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">wcscpy_s</span>(name.<span class="built_in">data</span>(), name.<span class="built_in">size</span>(), printer_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">OpenPrinter</span>(name.<span class="built_in">data</span>(), &amp;printer_, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HANDLE <span class="title">Detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        HANDLE h = printer_;</span><br><span class="line">        printer_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HANDLE <span class="title">Attach</span><span class="params">(HANDLE printer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        HANDLE h = printer_;</span><br><span class="line">        printer_ = printer;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (printer_) &#123;</span><br><span class="line">            <span class="built_in">ClosePrinter</span>(printer_);</span><br><span class="line">            printer_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">HANDLE</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> printer_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HANDLE printer_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而通过这个句柄就可以做很多的事情了，比如获取打印机的具体配置，弹出打印机属性对话框等等，这里以获取其支持的纸张类型为例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> FORM_INFO_1, <span class="keyword">int</span> level = <span class="number">1</span>&gt;</span><br><span class="line">class CEnumPrinterForm &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">Init</span>(HANDLE hp)</span><br><span class="line">    &#123;</span><br><span class="line">        ULONG bytes_needed = <span class="number">0</span>;</span><br><span class="line">        ULONG elems_returned = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">EnumForms</span>(hp, level, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bytes_needed, &amp;elems_returned);</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(bytes_needed);</span><br><span class="line">        <span class="built_in">EnumForms</span>(hp, level, buffer_.<span class="built_in">data</span>(), bytes_needed, &amp;bytes_needed, &amp;elems_returned);</span><br><span class="line">        elems_returned_ = elems_returned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ULONG <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems_returned_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] (ULONG idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(idx &lt; elems_returned_);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(buffer_.<span class="built_in">data</span>())[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;UCHAR&gt; buffer_;</span><br><span class="line">    ULONG elems_returned_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以枚举出类似A3、A4、B5这种纸张类型。不过这套打印数据的函数有一些不太友好，因为通过打印机句柄打印数据，我们只能传输emf或者raw格式的数据。而我们比较熟悉的方法是通过DC绘制图形并且打印，这样所见即所得用起来会更舒适。不过，这套API没有提供用打印机句柄转换到HDC的方法。只能通过<code>PRINTER_INFO_2</code>中的<code>pPrinterName</code>和<code>pDevMode</code>重新打开一个HDC，然后通过HDC相关的API进行打印。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hdc = <span class="built_in">CreateDCW</span>(<span class="literal">NULL</span>, info.pPrinterName, <span class="literal">NULL</span>, info.pDevMode);</span><br><span class="line">DOCINFO docInfo = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">docInfo.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(docInfo);</span><br><span class="line">docInfo.lpszDocName = <span class="string">L&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">RECT rc = &#123; <span class="number">40</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">StartDoc</span>(hdc, &amp;docInfo);</span><br><span class="line"><span class="built_in">StartPage</span>(hdc);</span><br><span class="line"><span class="built_in">DrawTextA</span>(hdc, <span class="string">&quot;hello&quot;</span>, <span class="number">-1</span>, &amp;rc, DT_SINGLELINE | DT_NOCLIP);</span><br><span class="line"><span class="built_in">EndPage</span>(hdc);</span><br><span class="line"><span class="built_in">StartPage</span>(hdc);</span><br><span class="line"><span class="built_in">DrawTextA</span>(hdc, <span class="string">&quot;world&quot;</span>, <span class="number">-1</span>, &amp;rc, DT_SINGLELINE | DT_NOCLIP);</span><br><span class="line"><span class="built_in">EndPage</span>(hdc);</span><br><span class="line"><span class="built_in">EndDoc</span>(hdc);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vs使用qt4.natvis</title>
      <link href="/2019/08/01/vs-with-qt4-natvis/"/>
      <url>/2019/08/01/vs-with-qt4-natvis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上一篇blog讲到了windbg使用qt4.natvis解析qt数据结构的方法，那么接下来就该轮到VS了。在VS中使用natvis会更加简单，只需要将qt4.nativs拷贝到<code>%VSINSTALLDIR%\Common7\Packages\Debugger\Visualizers</code>即可。当然，这篇blog不可能只写这么点东西。qt4.natvis很好，它解析了很多QT的数据结构，比如QMap，QPoint，QVector，QMatrix等等，不过有一点很遗憾，它没有解析QObject。因为解析QObject可以获取对象的父子节点，这样很容易了解对象的树形结构。于是我这里对qt4.natvis进行了一点修改，添加了对QObject的解析：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Type</span> <span class="attr">Name</span>=<span class="string">&quot;QObject&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DisplayString</span>&gt;</span>&#123;&#123;&#123;*(char **)(*(char **)(*(char **)this - 4) + 12) + 12,sb&#125;&#125;&#125;<span class="tag">&lt;/<span class="name">DisplayString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Expand</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ExpandedItem</span>&gt;</span>d_ptr.d-&gt;children<span class="tag">&lt;/<span class="name">ExpandedItem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Expand</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释一下这段xml，<code>&lt;Type Name=&quot;QObject&quot;&gt;&quot;</code>是指定匹配的对象类型名，这里当然就是QObject了。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DisplayString</span>&gt;</span>&#123;&#123;&#123;*(char **)(*(char **)(*(char **)this - 4) + 12) + 12,sb&#125;&#125;&#125;<span class="tag">&lt;/<span class="name">DisplayString</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用于展示当前QObject的实际类型，也就是QObject的派生类名。这里采用的方法是获取虚表上的<code>RTTICompleteObjectLocator</code>对象指针，然后在获取<code>TypeDescriptor</code>。具体是怎么获取的那将是一篇长篇大论，这里就不展开了。最后<code>&lt;ExpandedItem&gt;d_ptr.d-&gt;children&lt;/ExpandedItem&gt;</code>则是将其子对象展示出来，这样就能一目了然的指定其子对象的真实类型了。</p><p><img src="/uploads/2019/08/20190801183332.png" alt="20190801183332"></p><p>从图中可以看到，除了str、str_list和str_map可以直接的看到数据之外，QMsgTest、QToolBar的子对象个数和类型也能一目了然。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windbg使用qt4.natvis</title>
      <link href="/2019/07/30/windbg-with-qt4-natvis/"/>
      <url>/2019/07/30/windbg-with-qt4-natvis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>用windbg调试QT程序或者分析QT程序的dump是一件痛苦的事情，因为windbg缺少对QT基础数据的展示能力，比如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    QList&lt;QString&gt; str_list;</span><br><span class="line">    str_list.<span class="built_in">append</span>(str);</span><br><span class="line">    QMap&lt;<span class="keyword">int</span>, QString&gt; str_map;</span><br><span class="line">    str_map[<span class="number">11</span>] = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这份代码使用windbg查看str，str_list或者str_map简直是一件折磨的事情。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; dv</span><br><span class="line">           argc &#x3D; 0n1</span><br><span class="line">           argv &#x3D; 0x02cc5e00</span><br><span class="line">            str &#x3D; class QString</span><br><span class="line">       str_list &#x3D; class QList&lt;QString&gt;</span><br><span class="line">        str_map &#x3D; class QMap&lt;int,QString&gt;</span><br><span class="line">              a &#x3D; class QApplication</span><br><span class="line">              w &#x3D; class QMsgTest</span><br><span class="line">0:000&gt; dx str</span><br><span class="line">str                 [Type: QString]</span><br><span class="line">    [+0x000] d                : 0x2cc5d80 [Type: QString::Data *]</span><br><span class="line">0:000&gt; dx str_list</span><br><span class="line">str_list                 [Type: QList&lt;QString&gt;]</span><br><span class="line">    [+0x000] p                [Type: QListData]</span><br><span class="line">    [+0x000] d                : 0x2cc7258 [Type: QListData::Data *]</span><br><span class="line">0:000&gt; dx str_map</span><br><span class="line">str_map                 [Type: QMap&lt;int,QString&gt;]</span><br><span class="line">    [+0x000] d                : 0x2cc72b8 [Type: QMapData *]</span><br><span class="line">    [+0x000] e                : 0x2cc72b8 [Type: QMapData::Node *]</span><br></pre></td></tr></table></figure><p>可以看到，windbg只会告诉你类型，根本不会给你展示数据本身，如果要查看数据还得自己来算，以最复杂的QMap为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; ?? str_map.d-&gt;forward[0]</span><br><span class="line">struct QMapData * 0x031470f8</span><br><span class="line">   +0x000 backward         : 0x03147068 QMapData</span><br><span class="line">   +0x004 forward          : [12] 0x03147068 QMapData</span><br><span class="line">   +0x034 ref              : QBasicAtomicInt</span><br><span class="line">   +0x038 topLevel         : 0n-17891602</span><br><span class="line">   +0x03c size             : 0n-17891602</span><br><span class="line">   +0x040 randomBits       : 0xfeeefeee</span><br><span class="line">   +0x044 insertInOrder    : 0y0</span><br><span class="line">   +0x044 sharable         : 0y1</span><br><span class="line">   +0x044 strictAlignment  : 0y1</span><br><span class="line">   +0x044 reserved         : 0y11111110111011101111111011101 (0x1fdddfdd)</span><br><span class="line"></span><br><span class="line">0:000&gt; ?? sizeof(@!&quot;qtmsgtest!QMapPayloadNode&lt;int,QString&gt;&quot;)-sizeof(qtmsgtest!QMapData::Node*)</span><br><span class="line">unsigned int 8</span><br><span class="line"></span><br><span class="line">0:000&gt; dt qtmsgtest!QMapNode&lt;int,QString&gt; (0x31470f8-8)</span><br><span class="line">   +0x000 key              : 0n11</span><br><span class="line">   +0x004 value            : QString</span><br><span class="line">   +0x008 backward         : 0x03147068 QMapData::Node</span><br><span class="line">   +0x00c forward          : [1] 0x03147068 QMapData::Node</span><br><span class="line"></span><br><span class="line">0:000&gt; ?? ((qtmsgtest!QString*)0x31470f4)-&gt;d</span><br><span class="line">struct QString::Data * 0x03145b30</span><br><span class="line">   +0x000 ref              : QBasicAtomicInt</span><br><span class="line">   +0x004 alloc            : 0n11</span><br><span class="line">   +0x008 size             : 0n11</span><br><span class="line">   +0x00c data             : 0x03145b42  -&gt; 0x68</span><br><span class="line">   +0x010 clean            : 0y0</span><br><span class="line">   +0x010 simpletext       : 0y0</span><br><span class="line">   +0x010 righttoleft      : 0y0</span><br><span class="line">   +0x010 asciiCache       : 0y0</span><br><span class="line">   +0x010 capacity         : 0y0</span><br><span class="line">   +0x010 reserved         : 0y11001101110 (0x66e)</span><br><span class="line">   +0x012 array            : [1] 0x68</span><br><span class="line"></span><br><span class="line">0:000&gt; du @@C++(((qtmsgtest!QString*)0x31470f4)-&gt;d-&gt;data)</span><br><span class="line">03145b42  &quot;hello world&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你们看，为了获取key=11、value=”hello world”需要这么折腾一通，如果数据多了那不得抓狂。</p><p>不过幸运了是windbg现在支持natvis了，简单的说就是通过natvis里的配置自动解析和符号匹配的数据结构。接下来要做的就是找一个好用的qt的natvis了。我这里找了一个qt配合vs2012里的qt4.natvis，让我们看看加载后的效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; .nvload qt4.natvis</span><br><span class="line">Successfully loaded visualizers in &quot;C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\Visualizers\qt4.natvis&quot;</span><br><span class="line">0:000&gt; dv</span><br><span class="line">           argc &#x3D; 0n1</span><br><span class="line">           argv &#x3D; 0x02cc5e00</span><br><span class="line">            str &#x3D; hello world</span><br><span class="line">       str_list &#x3D; &#123; size &#x3D; 1 &#125;</span><br><span class="line">        str_map &#x3D; &#123; size &#x3D; 1 &#125;</span><br><span class="line">              a &#x3D; class QApplication</span><br><span class="line">              w &#x3D; class QMsgTest</span><br><span class="line">0:000&gt; dx str</span><br><span class="line">str                 : hello world [Type: QString]</span><br><span class="line">    [&lt;Raw View&gt;]     [Type: QString]</span><br><span class="line">    [size]           : 11 [Type: int]</span><br><span class="line">    [referenced]     : 3 [Type: long]</span><br><span class="line">    [0]              : 0x68 [Type: unsigned short]</span><br><span class="line">    [1]              : 0x65 [Type: unsigned short]</span><br><span class="line">    [2]              : 0x6c [Type: unsigned short]</span><br><span class="line">    [3]              : 0x6c [Type: unsigned short]</span><br><span class="line">    [4]              : 0x6f [Type: unsigned short]</span><br><span class="line">    [5]              : 0x20 [Type: unsigned short]</span><br><span class="line">    [6]              : 0x77 [Type: unsigned short]</span><br><span class="line">    [7]              : 0x6f [Type: unsigned short]</span><br><span class="line">    [8]              : 0x72 [Type: unsigned short]</span><br><span class="line">    [9]              : 0x6c [Type: unsigned short]</span><br><span class="line">    [10]             : 0x64 [Type: unsigned short]</span><br><span class="line">0:000&gt; dx str_list</span><br><span class="line">str_list                 : &#123; size &#x3D; 1 &#125; [Type: QList&lt;QString&gt;]</span><br><span class="line">    [&lt;Raw View&gt;]     [Type: QList&lt;QString&gt;]</span><br><span class="line">    [referenced]     : 1 [Type: long]</span><br><span class="line">    [0x0]            : hello world [Type: QString]</span><br><span class="line">0:000&gt; dx str_map</span><br><span class="line">str_map                 : &#123; size &#x3D; 1 &#125; [Type: QMap&lt;int,QString&gt;]</span><br><span class="line">    [&lt;Raw View&gt;]     [Type: QMap&lt;int,QString&gt;]</span><br><span class="line">    [referenced]     : 1 [Type: long]</span><br><span class="line">    [0x0]            : 0x2cc7340 : (11, hello world) [Type: QMapNode&lt;int,QString&gt; *]</span><br></pre></td></tr></table></figure><p>看到了么，无论是str，str_list还是str_map都直接打印出了内部的数据，无需大费周章的折腾，这简直是windbg爱好者调试qt程序的神器。</p><p>最后附上qt4.natvis的地址：<a href="https://gist.github.com/gregseth/9bcd0112f8492fa7bfe7">https://gist.github.com/gregseth/9bcd0112f8492fa7bfe7</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dump QT objects</title>
      <link href="/2019/06/30/dump-qt-objects/"/>
      <url>/2019/06/30/dump-qt-objects/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在QT中，QObject有两个函数<code>dumpObjectInfo()</code>和<code>dumpObjectTree() </code>分别用于dump相关对象树形结构和相关的连接信息。不过这两个函数有个共同的问题，只能在debug模式下使用。因为在Release模式下，这两个函数不做任何事情：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dumpRecursive</span><span class="params">(<span class="keyword">int</span> level, QObject *object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(QT_DEBUG)</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(level)</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(object)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QObject::dumpObjectTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">dumpRecursive</span>(<span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QObject::dumpObjectInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(QT_DEBUG)</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能在Release模式下使用这两个函数，其中一个办法是删除<code>#if defined(QT_DEBUG)</code>宏，然后重新编译qtcore4.dll。不过重新编译QT需要一些准备工作，而且还需要较长的一段编译时间，所以我果断放弃了这种方法。</p><p>第二种想到的方法是自己实现<code>dumpObjectInfo()</code>和<code>dumpObjectTree() </code>这两个函数。实际上，实现<code>dumpObjectTree()</code>并不是一件难事，<code>qDebug()</code>本身就能dump QObject了，我们需要做的就是递归遍历对象节点：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dumpObjects</span><span class="params">(<span class="keyword">const</span> QObjectList &amp;objs, <span class="keyword">int</span> nIndent = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString strIndent;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nIndent; i++) &#123;</span><br><span class="line">        strIndent.<span class="built_in">append</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Q_FOREACH</span>(<span class="keyword">const</span> QObject *obj, objs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; strIndent.<span class="built_in">toAscii</span>().<span class="built_in">data</span>() &lt;&lt; obj;</span><br><span class="line">        <span class="keyword">if</span> (!obj-&gt;<span class="built_in">children</span>().<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="built_in">dumpObjects</span>(obj-&gt;<span class="built_in">children</span>(), nIndent + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在想要遍历QT对象时，我们只需要将对象的子节点列表传入函数即可：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMsgTest w;</span><br><span class="line"><span class="built_in">dumpObjects</span>(w.<span class="built_in">children</span>());</span><br></pre></td></tr></table></figure><p>输出的数据如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QMainWindowLayout(0x36ba208, name &#x3D; &quot;_layout&quot;) </span><br><span class="line"> QRubberBand(0x36ba778, name &#x3D; &quot;qt_rubberband&quot;) </span><br><span class="line"> QMenuBar(0x36bab78, name &#x3D; &quot;menuBar&quot;) </span><br><span class="line">   QToolButton(0x36bae88, name &#x3D; &quot;qt_menubar_ext_button&quot;) </span><br><span class="line"> QToolBar(0x36bb820, name &#x3D; &quot;mainToolBar&quot;) </span><br><span class="line">   QToolBarLayout(0x36bbb50) </span><br><span class="line">   QToolBarExtension(0x36bbc80, name &#x3D; &quot;qt_toolbar_ext_button&quot;) </span><br><span class="line">   QAction(0x36bc5a0) </span><br><span class="line">   QPropertyAnimation(0x36bcf90) </span><br><span class="line">   QPropertyAnimation(0x35098f8) </span><br><span class="line"> QWidget(0x36bcac0, name &#x3D; &quot;centralWidget&quot;) </span><br><span class="line">   QPropertyAnimation(0x36bbed8) </span><br><span class="line">   QPropertyAnimation(0x3509cf0) </span><br><span class="line"> QStatusBar(0x36bcd70, name &#x3D; &quot;statusBar&quot;) </span><br><span class="line">   QSizeGrip(0x36bbac0) </span><br><span class="line">   QHBoxLayout(0x36b3ad0) </span><br><span class="line">     QVBoxLayout(0x36bd5d8) </span><br><span class="line">       QHBoxLayout(0x36bd818) </span><br></pre></td></tr></table></figure><p>怎么样，是不是很容易实现。不过接下来就要泼一盆冷水了，因为<code>dumpObjectInfo()</code>函数就没有那么容易实现了。主要原因是<code>dumpObjectInfo()</code>函数中有大量的依赖关系，如果单纯的扣代码过来牵扯会非常广，所以这个方法似乎也进行不下去了。</p><p>最后，我想到了第三种方法，在Release模式下加载Debug版本的qtcored4.dll，获取其函数地址并且直接调用它。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PVOID dumpFunc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">void</span>* (*myInstallMsgHandler)(<span class="keyword">void</span>* h) = <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">myMsgHandler</span>(QtMsgType t, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">OutputDebugStringW</span>(<span class="built_in">QString</span>(<span class="string">&quot;%1\n&quot;</span>).<span class="built_in">arg</span>(str).<span class="built_in">utf16</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE h = <span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;qtcored4.dll&quot;</span>);</span><br><span class="line">    dumpFunc = <span class="built_in">GetProcAddress</span>(h, <span class="string">&quot;?dumpObjectInfo@QObject@@QAEXXZ&quot;</span>);</span><br><span class="line">    *(<span class="keyword">void</span> **)&amp;myInstallMsgHandler = <span class="built_in">GetProcAddress</span>(h, <span class="string">&quot;?qInstallMsgHandler@@YAP6AXW4QtMsgType@@PBD@ZP6AX01@Z@Z&quot;</span>);</span><br><span class="line">    <span class="built_in">myInstallMsgHandler</span>(myMsgHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpObjInfo</span><span class="params">(<span class="keyword">void</span> *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov ecx, obj</span><br><span class="line">        call dumpFunc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QMsgTest w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="built_in">dumpObjInfo</span>(&amp;w);</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解释一下这段代码，首先Init函数是用来加载qtcored4.dll以及初始化相关的函数，这里GetProcAddress获取的函数分别是<code>qInstallMsgHandler</code>和<code>dumpObjectInfo</code>，之所以代码中的函数名这么复杂是因为C++使用的Decorated Name规则导致的，可以用一些PE工具查看导出函数来获取这个名字。另外我们看到，出了获取<code>dumpObjectInfo</code>函数外，还获取了<code>qInstallMsgHandler</code>函数。因为我们需要使用这个函数注册输出调试信息的函数，在代码中是<code>myMsgHandler</code>。最后，为了方便的调用<code>dumpObjectInfo</code>的函数指针，我采用了内嵌汇编的方式。因为<code>dumpObjectInfo</code>是成员函数，所以肯定是thiscall，于是将obj赋予ecx寄存器并且调用函数指针即可。</p><p>编译运行可以看到输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BJECT QMsgTest::QMsgTestClass</span><br><span class="line">  SIGNALS OUT</span><br><span class="line">        signal: destroyed(QObject*)</span><br><span class="line">        signal: destroyed()</span><br><span class="line">        signal: customContextMenuRequested(QPoint)</span><br><span class="line">        signal: iconSizeChanged(QSize)</span><br><span class="line">          --&gt; QToolBar::mainToolBar _q_updateIconSize(QSize)</span><br><span class="line">        signal: toolButtonStyleChanged(Qt::ToolButtonStyle)</span><br><span class="line">          --&gt; QToolBar::mainToolBar _q_updateToolButtonStyle(Qt::ToolButtonStyle)</span><br><span class="line">  SIGNALS IN</span><br><span class="line">        &lt;None&gt;</span><br></pre></td></tr></table></figure><p>当然了，内嵌汇编不是一个好的代码风格，这里只是为了快速验证方案的可行性。更符合C++语法习惯的方式应该是声明一个成员函数指针，然后用<code>GetProcAddress</code>获取对应的函数地址对其赋值，最后调用成员函数指针。具体怎么实现仁者见仁智者见智，我这篇blog只是抛砖引玉。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windbg监听QT事件</title>
      <link href="/2019/05/29/qt-event-wds/"/>
      <url>/2019/05/29/qt-event-wds/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Windows平台下做过界面开发的程序员肯定知道窗口界面是由消息驱动的。为了能方便的调试窗口消息循环，Windows提供了spy++这样的工具帮助我们监控消息。但是Windows的消息在QT的程序上可能只有部分有用。所以我们还需要一个监控QT窗口事件的工具，不过可惜的是我并没有找到这样现成的工具。于是我用Windbg的断点命令写了一个。</p><p>不过写断点命令之前必须先搞清楚在QT中事件都是怎么发出来的。经过调试确认了几个函数，分别是：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QCoreApplication::sendEvent</span><br><span class="line">QCoreApplication::sendSpontaneousEvent</span><br><span class="line">QCoreApplication::postEvent</span><br></pre></td></tr></table></figure><p>接下来我们可以对它们下断点了。当然，这里不是直接了当下断点那么的简单。我们需要在断点中插入命令，让断点命中后打印我们想要的内容，然后继续运行。我这里的写法是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bm &#x2F;( qtcored4!QCoreApplication::postEvent &quot;.printf \&quot;P  \&quot;;?? @@C++(static_cast&lt;QtGuid4!QEvent::Type&gt;(event-&gt;t));g&quot;</span><br><span class="line">bc 2</span><br><span class="line">bm &#x2F;( qtcored4!QCoreApplication::sendEvent &quot;.printf \&quot;S  \&quot;;?? @@C++(static_cast&lt;QtGuid4!QEvent::Type&gt;(event-&gt;t));g&quot;</span><br><span class="line">bm &#x2F;( qtcored4!QCoreApplication::sendSpontaneousEvent &quot;.printf \&quot;SS \&quot;;?? @@C++(static_cast&lt;QtGuid4!QEvent::Type&gt;(event-&gt;t));g&quot;</span><br></pre></td></tr></table></figure><p>在windbg中执行后，运行程序就能看到事件一个一个的打印出来了，而且打印出来的并不是冷冰冰的事件数字，而是数字所代表的含义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SS QEvent::Type WindowDeactivate (0n25)</span><br><span class="line">P  QEvent::Type UpdateRequest (0n77)</span><br><span class="line">S  QEvent::Type WindowDeactivate (0n25)</span><br><span class="line">S  QEvent::Type WindowDeactivate (0n25)</span><br><span class="line">SS QEvent::Type ActivationChange (0n99)</span><br><span class="line">SS QEvent::Type ApplicationDeactivate (0n122)</span><br><span class="line">S  QEvent::Type UpdateRequest (0n77)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type ApplicationActivate (0n121)</span><br><span class="line">SS QEvent::Type WindowActivate (0n24)</span><br><span class="line">P  QEvent::Type UpdateRequest (0n77)</span><br><span class="line">S  QEvent::Type WindowActivate (0n24)</span><br><span class="line">S  QEvent::Type WindowActivate (0n24)</span><br><span class="line">S  QEvent::Type WindowActivate (0n24)</span><br><span class="line">SS QEvent::Type ActivationChange (0n99)</span><br><span class="line">S  QEvent::Type UpdateRequest (0n77)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type Paint (0n12)</span><br><span class="line">SS QEvent::Type NonClientAreaMouseMove (0n173)</span><br><span class="line">S  QEvent::Type Enter (0n10)</span><br><span class="line">S  QEvent::Type Enter (0n10)</span><br><span class="line">SS QEvent::Type MouseMove (0n5)</span><br><span class="line">S  QEvent::Type Leave (0n11)</span><br><span class="line">S  QEvent::Type Enter (0n10)</span><br><span class="line">SS QEvent::Type MouseMove (0n5)</span><br><span class="line">SS QEvent::Type MouseMove (0n5)</span><br><span class="line">SS QEvent::Type MouseMove (0n5)</span><br><span class="line">SS QEvent::Type MouseMove (0n5)</span><br><span class="line">SS QEvent::Type MouseMove (0n5)</span><br><span class="line">SS QEvent::Type MouseMove (0n5)</span><br><span class="line">S  QEvent::Type Leave (0n11)</span><br><span class="line">S  QEvent::Type Leave (0n11)</span><br><span class="line">SS QEvent::Type WindowDeactivate (0n25)</span><br><span class="line">P  QEvent::Type UpdateRequest (0n77)</span><br><span class="line">S  QEvent::Type WindowDeactivate (0n25)</span><br><span class="line">S  QEvent::Type WindowDeactivate (0n25)</span><br><span class="line">S  QEvent::Type WindowDeactivate (0n25)</span><br><span class="line">SS QEvent::Type ActivationChange (0n99)</span><br><span class="line">SS QEvent::Type ApplicationDeactivate (0n122)</span><br><span class="line">S  QEvent::Type UpdateRequest (0n77)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个时间同步脚本</title>
      <link href="/2019/04/25/timesync-script/"/>
      <url>/2019/04/25/timesync-script/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>家里有台电脑不知道为啥一直同步不了网络时间，每隔一段时间就慢个几分钟，于是在网上找了点资料和代码拼凑了一个用于Windows时间同步的python脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: 0cch</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> ctypes             <span class="keyword">import</span> Structure, windll, pointer</span><br><span class="line"><span class="keyword">from</span> ctypes.wintypes    <span class="keyword">import</span> WORD</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SYSTEMTIME</span>(<span class="params">Structure</span>):</span></span><br><span class="line">  _fields_ = [</span><br><span class="line">      ( <span class="string">&#x27;wYear&#x27;</span>,            WORD ),</span><br><span class="line">      ( <span class="string">&#x27;wMonth&#x27;</span>,           WORD ),</span><br><span class="line">      ( <span class="string">&#x27;wDayOfWeek&#x27;</span>,       WORD ),</span><br><span class="line">      ( <span class="string">&#x27;wDay&#x27;</span>,             WORD ),</span><br><span class="line">      ( <span class="string">&#x27;wHour&#x27;</span>,            WORD ),</span><br><span class="line">      ( <span class="string">&#x27;wMinute&#x27;</span>,          WORD ),</span><br><span class="line">      ( <span class="string">&#x27;wSecond&#x27;</span>,          WORD ),</span><br><span class="line">      ( <span class="string">&#x27;wMilliseconds&#x27;</span>,    WORD ),</span><br><span class="line">    ]</span><br><span class="line">SetLocalTime = windll.kernel32.SetLocalTime</span><br><span class="line"></span><br><span class="line">NTP_SERVER = <span class="string">&quot;pool.ntp.org&quot;</span></span><br><span class="line">TIME1970 = <span class="number">2208988800</span></span><br><span class="line"></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">clientSocket.settimeout(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">portNumber = <span class="number">123</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sntp_client</span>():</span></span><br><span class="line">    data = <span class="string">&#x27;\x1b&#x27;</span> + <span class="number">47</span> * <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">    clientSocket.sendto( data.encode(<span class="string">&#x27;utf-8&#x27;</span>), ( NTP_SERVER, portNumber ))</span><br><span class="line">    data, address = clientSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Response received from:&#x27;</span>, address)</span><br><span class="line">        t_time = struct.unpack( <span class="string">&#x27;!12I&#x27;</span>, data )[<span class="number">10</span>]</span><br><span class="line">        t_time -= TIME1970</span><br><span class="line">        </span><br><span class="line">        dt = datetime.datetime.fromtimestamp( t_time )</span><br><span class="line">        </span><br><span class="line">        dt_tuple = dt.timetuple()</span><br><span class="line">        st = SYSTEMTIME()</span><br><span class="line">        st.wYear            = dt_tuple.tm_year</span><br><span class="line">        st.wMonth           = dt_tuple.tm_mon</span><br><span class="line">        st.wDayOfWeek       = ( dt_tuple.tm_wday + <span class="number">1</span> ) % <span class="number">7</span></span><br><span class="line">        st.wDay             = dt_tuple.tm_mday</span><br><span class="line">        st.wHour            = dt_tuple.tm_hour</span><br><span class="line">        st.wMinute          = dt_tuple.tm_min</span><br><span class="line">        st.wSecond          = dt_tuple.tm_sec</span><br><span class="line">        st.wMilliseconds    = <span class="number">0</span></span><br><span class="line">         </span><br><span class="line">        ret = SetLocalTime( pointer( st ) )</span><br><span class="line">        <span class="keyword">if</span> ret == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>( <span class="string">&#x27;Setting failed. Try as administrator.&#x27;</span> )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>( <span class="string">&#x27;Successfully.&#x27;</span> )</span><br><span class="line">        </span><br><span class="line">    clientSocket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sntp_client()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11新增预定义的宏</title>
      <link href="/2019/03/20/cpp11-macro/"/>
      <url>/2019/03/20/cpp11-macro/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>C++11中新增了4个预定义的宏，他们分别为<code>__STDC__</code>，<code>__STDC_HOSTED__</code>，<code>__STDC_VERSION__</code>和<code>__STDC_ISO_10646__</code>。</p><ol><li><p><code>__STDC__</code>用于指示编译器是否支持ISO标准C语言，如果支持ISO标准C语言则<code>_STDC__</code>定义为1，否为定义为0。这个宏在不同的编译器上可能有不同的定义，甚至有未定义的情况。例如在GCC上，编译并输出该宏的值为1，而在Visual Studio C++上，默认情况下该宏处于未定义状态。</p></li><li><p><code>__STDC_HOSTED__</code>用于指示宿主环境是否具有标准C库的完整功能，如果具有标准C库的完整功能则<code>__STDC_HOSTED__</code>定义为1，否为定义为0。</p></li><li><p><code>__STDC_VERSION__</code>用于定义C标准的版本号，但是标准文档中并没有明确规定其实现，所以在很多编译器中这个宏处于未定义状态。</p></li><li><p><code>__STDC_ISO_10646__</code>用于指示<code>wchar_t</code>是否使用Unicode，如果使用Unicode那么<code>wchar_t</code>展开为yyyymmL的形式。</p></li></ol><p>编译运行下面这段代码用于检测这些宏的定义状态：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__cplusplus is &quot;</span> &lt;&lt; __cplusplus &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__DATE__ is &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__FILE__ is &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__LINE__ is &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDC_HOSTED__</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDC_HOSTED__ is &quot;</span> &lt;&lt; __STDC_HOSTED__ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDC_HOSTED__ is not defined&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__TIME__ is &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDC__</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDC__ is &quot;</span> &lt;&lt; __STDC__ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDC__ is not defined&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDC_MB_MIGHT_NEQ_WC__</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDC_MB_MIGHT_NEQ_WC__ is &quot;</span> &lt;&lt; __STDC_MB_MIGHT_NEQ_WC__ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDC_MB_MIGHT_NEQ_WC__ is not defined&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDC_VERSION__</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDC_VERSION__ is &quot;</span> &lt;&lt; __STDC_VERSION__ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDC_VERSION__ is not defined&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDC_ISO_10646__</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDC_ISO_10646__ is &quot;</span> &lt;&lt; __STDC_ISO_10646__ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDC_ISO_10646__ is not defined&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDCPP_DEFAULT_NEW_ALIGNMENT__</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDCPP_DEFAULT_NEW_ALIGNMENT__ is &quot;</span> &lt;&lt; __STDCPP_DEFAULT_NEW_ALIGNMENT__ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDCPP_DEFAULT_NEW_ALIGNMENT__ is not defined&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDCPP_STRICT_POINTER_SAFETY__</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDCPP_STRICT_POINTER_SAFETY__ is &quot;</span> &lt;&lt; __STDCPP_STRICT_POINTER_SAFETY__ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDCPP_STRICT_POINTER_SAFETY__ is not defined&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDCPP_THREADS__</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDCPP_THREADS__ is &quot;</span> &lt;&lt; __STDCPP_THREADS__ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;__STDCPP_THREADS__ is not defined&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Windows中编译GCC</title>
      <link href="/2019/02/22/compile-gcc-in-windows/"/>
      <url>/2019/02/22/compile-gcc-in-windows/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近心血来潮想体验下C++2a的标准，但是mingw中的GCC最新版本是8.2。于是乎就产生了编译thunk下最新代码的想法。</p><p>要在Windows上编译GCC没有在linux上方便，但是也是可以完成的。首先我们需要一个mingw的环境。自带mingw环境的软件有很多，这里我比较推荐MSYS2，因为这个环境更新的比较快。下载安装好了以后，运行MSYS2，会弹出类似linux终端窗口。这里我们首先下载需要的开发编译环境：</p><blockquote><p>pacman -S –needed mingw-w64-i686-toolchain mingw-w64-x86_64-toolchain</p></blockquote><p>下载安装好了开发环境后，可以下载GCC源代码：</p><blockquote><p>mkdir gcc-latest<br>cd gcc-latest<br>git clone git://gcc.gnu.org/git/gcc.git</p></blockquote><p>源代码比较大（2个多G），下载需要一点耐心。<br>源代码下载完成后，创建编译目录：</p><blockquote><p>mkdir build</p></blockquote><p>在开始编译之前，有一个坑需要注意下，我们需要将usr/bin/下的makeinfo改名。不知道为什么，最新的makeinfo对gcc的texi文件不兼容会导致编译失败。这个操作之后就可以开始配置了。</p><blockquote><p>../gcc/configure –enable-languages=c,c++ –disable-multilib –disable-bootstrap –disable-werror –disable-nls –prefix=/mingw64/gcc-latest –build=x86_64-w64-mingw32 –host=x86_64-w64-mingw32 –target=x86_64-w64-mingw32 –with-native-system-header-dir=/mingw64/x86_64-w64-mingw32/include –with-arch=x86-64 MAKEINFO=missing<br>export LIBRARY_PATH=/mingw64/x86_64-w64-mingw32/lib</p></blockquote><p>配置的选项比较多，我们可以参考GCC文档进行参照。这里的配置是我尝试后感觉必须加入的，否则编译的时候会出相应的问题。可以说是编译GCC血泪史了。<br>再然后就可以开始编译了：</p><blockquote><p>make -j 16</p></blockquote><p>使用多线程编译，编译速度会快不少。编译好了以后就可以安装了，注意安装的时候可能会遇到失败，需要注释build/gcc/makefile中，对应s-tm-texi的相关代码。</p><blockquote><p>make install</p></blockquote><p>最后检查gcc版本号：</p><blockquote><p>gcc -v</p></blockquote><p>注意目前最新的版本号为9.0.1。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在循环中使用CComPtr需要特别注意</title>
      <link href="/2019/01/20/use-ccomptr-in-loops-requires-special-attention/"/>
      <url>/2019/01/20/use-ccomptr-in-loops-requires-special-attention/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>CComPtr是ATL里提供给我们管理COM接口的智能指针类，使用它能够让我们无需关心接口的引用释放。例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CComPtr&lt;IShellFolder&gt; pDesktop;</span><br><span class="line"><span class="built_in">SHGetDesktopFolder</span>(&amp;pDesktop);</span><br></pre></td></tr></table></figure><p>但是这个类在循环中使用的时候要特别注意一下，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有问题</span></span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    CComPtr&lt;IShellFolder&gt; pDesktop;</span><br><span class="line">    <span class="built_in">SHGetDesktopFolder</span>(&amp;pDesktop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有问题，接口没有调用Release，内存泄露</span></span><br><span class="line">CComPtr&lt;IShellFolder&gt; pDesktop;</span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    <span class="built_in">SHGetDesktopFolder</span>(&amp;pDesktop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其根本原因是，CComPtr的&amp;操作符重载的时候没有做释放操作，只有Debug版本的assert来提醒程序员这样使用的问题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T** <span class="keyword">operator</span>&amp;() <span class="keyword">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ATLASSERT</span>(p==<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> &amp;p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们需要手动调用Release</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CComPtr&lt;IShellFolder&gt; pDesktop;</span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    <span class="built_in">SHGetDesktopFolder</span>(&amp;pDesktop);</span><br><span class="line">    ......</span><br><span class="line">    pDesktop.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里是调用CComPtr的Release成员函数，而不是其保护的接口对象的Release函数。</p><p>另外一个解决方案就是使用&lt;comdef.h&gt;里的_com_ptr_t，这个类对于上述情况做了更加合理的处理。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Interface** <span class="keyword">operator</span>&amp;() <span class="keyword">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">    _Release();</span><br><span class="line">    m_pInterface = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;m_pInterface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个类里，重载&amp;操作符的函数会先调用Release，然后再取地址避免了内存泄漏的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>给程序内部菜单增加指定的explorer菜单</title>
      <link href="/2018/12/02/add-the-specified-explorer-menu-to-the-internal-menu/"/>
      <url>/2018/12/02/add-the-specified-explorer-menu-to-the-internal-menu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>为了将explorer的右键菜单项的某个菜单增加到我们程序内部的菜单，我们需要做以下几件事情：</p><ol><li>获得指定文件的IShellFolder</li><li>获得指定文件的IContextMenu</li><li>创建菜单A，并且把IContextMenu的内容填充到菜单A</li><li>查询菜单A，找到我们想要的菜单项</li><li>取出我们想要的菜单项的内容，填充到我们想要真正弹出的菜单B</li><li>弹出菜单B</li><li>用IContextMenu响应用户对菜单的选择</li></ol><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CComPtr&lt;IShellFolder&gt; <span class="title">GetParentFolder</span><span class="params">(LPCWSTR szFolder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CComPtr&lt;IShellFolder&gt; pDesktop;</span><br><span class="line">    <span class="built_in">SHGetDesktopFolder</span>(&amp;pDesktop);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pDesktop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ULONG pchEaten = <span class="number">0</span>;</span><br><span class="line">    LPITEMIDLIST pidl = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwAttributes = <span class="number">0</span>;</span><br><span class="line">    HRESULT hr = pDesktop-&gt;<span class="built_in">ParseDisplayName</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTSTR)szFolder, <span class="literal">NULL</span>, &amp;pidl, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (S_OK != hr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CComPtr&lt;IShellFolder&gt; pParentFolder = <span class="literal">NULL</span>;</span><br><span class="line">    hr = pDesktop-&gt;<span class="built_in">BindToObject</span>(pidl, <span class="literal">NULL</span>, IID_IShellFolder, (<span class="keyword">void</span>**)&amp;pParentFolder);</span><br><span class="line">    <span class="keyword">if</span> (S_OK != hr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CoTaskMemFree</span>(pidl);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CoTaskMemFree</span>(pidl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pParentFolder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::wstring <span class="title">GetDirectory</span><span class="params">(LPCWSTR szFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WCHAR szDrive[_MAX_DRIVE];</span><br><span class="line">    WCHAR szDir[_MAX_DIR];</span><br><span class="line">    WCHAR szFName[_MAX_FNAME];</span><br><span class="line">    WCHAR szExt[_MAX_EXT];</span><br><span class="line">    _wsplitpath_s(szFile, szDrive, szDir, szFName, szExt);</span><br><span class="line"></span><br><span class="line">    std::wstring strResult = szDrive;</span><br><span class="line">    strResult += szDir;</span><br><span class="line">    <span class="keyword">return</span> strResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::wstring <span class="title">GetFileNameWithExt</span><span class="params">(LPCWSTR szFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WCHAR szDrive[_MAX_DRIVE];</span><br><span class="line">    WCHAR szDir[_MAX_DIR];</span><br><span class="line">    WCHAR szFName[_MAX_FNAME];</span><br><span class="line">    WCHAR szExt[_MAX_EXT];</span><br><span class="line">    _wsplitpath_s(szFile, szDrive, szDir, szFName, szExt);</span><br><span class="line"></span><br><span class="line">    std::wstring strResult = szFName;</span><br><span class="line">    strResult += szExt;</span><br><span class="line">    <span class="keyword">return</span> strResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qtmenutest::ShowContextMenu</span><span class="params">(<span class="keyword">const</span> QPoint &amp;pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_pContextMenu.<span class="built_in">Release</span>();</span><br><span class="line">    <span class="function">QMenu <span class="title">contextMenu</span><span class="params">(tr(<span class="string">&quot;Context menu&quot;</span>), <span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::wstring strFilePath = <span class="string">L&quot;d:\\1.jpg&quot;</span>;</span><br><span class="line">    CComPtr&lt;IShellFolder&gt; pParentFolder = <span class="built_in">GetParentFolder</span>(<span class="built_in">GetDirectory</span>(strFilePath.<span class="built_in">c_str</span>()).<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pParentFolder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::wstring strFile = <span class="built_in">GetFileNameWithExt</span>(strFilePath.<span class="built_in">c_str</span>());</span><br><span class="line">    ULONG pchEaten = <span class="number">0</span>;</span><br><span class="line">    LPITEMIDLIST pidl = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwAttributes = <span class="number">0</span>;</span><br><span class="line">    HRESULT hr = pParentFolder-&gt;<span class="built_in">ParseDisplayName</span>(<span class="built_in">WId</span>(), <span class="literal">NULL</span>, (LPWSTR)strFile.<span class="built_in">c_str</span>(), &amp;pchEaten, &amp;pidl, &amp;dwAttributes);</span><br><span class="line">    <span class="keyword">if</span> (S_OK != hr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    UINT refReversed = <span class="number">0</span>;</span><br><span class="line">    hr = pParentFolder-&gt;<span class="built_in">GetUIObjectOf</span>(<span class="built_in">WId</span>(), <span class="number">1</span>, (LPCITEMIDLIST *)&amp;pidl, IID_IContextMenu, &amp;refReversed, (<span class="keyword">void</span> **)&amp;m_pContextMenu);</span><br><span class="line">    <span class="keyword">if</span> (S_OK != hr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CoTaskMemFree</span>(pidl);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HMENU hMenu = <span class="built_in">CreatePopupMenu</span>();</span><br><span class="line">    <span class="keyword">if</span> (hMenu == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CoTaskMemFree</span>(pidl);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_pContextMenu-&gt;<span class="built_in">QueryContextMenu</span>(hMenu, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>, CMF_EXPLORE | CMF_NORMAL);</span><br><span class="line">    <span class="keyword">int</span> nMenuCount = <span class="built_in">GetMenuItemCount</span>(hMenu);</span><br><span class="line">    HMENU hSubMenu = <span class="literal">NULL</span>;</span><br><span class="line">    WCHAR szMenuText[MAX_PATH];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nMenuCount; i++) &#123;</span><br><span class="line">        <span class="built_in">GetMenuStringW</span>(hMenu, i, szMenuText, MAX_PATH, MF_BYPOSITION);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">wcsstr</span>(szMenuText, <span class="string">L&quot;some_ui_text&quot;</span>)) &#123;</span><br><span class="line">            hSubMenu = <span class="built_in">GetSubMenu</span>(hMenu, i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QMenu *subMenu = contextMenu.<span class="built_in">addMenu</span>(QString::<span class="built_in">fromWCharArray</span>(szMenuText));</span><br><span class="line">    <span class="keyword">int</span> nSubMenuCount = <span class="built_in">GetMenuItemCount</span>(hSubMenu);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nSubMenuCount; i++) &#123;</span><br><span class="line">        <span class="built_in">GetMenuStringW</span>(hSubMenu, i, szMenuText, MAX_PATH, MF_BYPOSITION);</span><br><span class="line">        <span class="keyword">int</span> nCmdId = <span class="built_in">GetMenuItemID</span>(hSubMenu, i);</span><br><span class="line">        QAction *curAct = subMenu-&gt;<span class="built_in">addAction</span>(QString::<span class="built_in">fromWCharArray</span>(szMenuText));</span><br><span class="line">        <span class="keyword">if</span> (curAct) &#123;</span><br><span class="line">            curAct-&gt;<span class="built_in">setData</span>(nCmdId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QAction *selAct = contextMenu.<span class="built_in">exec</span>(<span class="built_in">mapToGlobal</span>(pos));</span><br><span class="line">    <span class="keyword">if</span> (selAct) &#123;</span><br><span class="line">        <span class="keyword">int</span> nSelId = selAct-&gt;<span class="built_in">data</span>().<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="keyword">if</span> (nSelId) &#123;</span><br><span class="line">            CMINVOKECOMMANDINFO info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            info.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(CMINVOKECOMMANDINFOEX);</span><br><span class="line">            info.lpVerb = <span class="built_in">MAKEINTRESOURCEA</span>(nSelId - <span class="number">100</span>);</span><br><span class="line">            m_pContextMenu-&gt;<span class="built_in">InvokeCommand</span>(&amp;info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DestroyMenu</span>(hMenu);</span><br><span class="line">    <span class="built_in">CoTaskMemFree</span>(pidl);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0cchext插件更新 1.0.19.1</title>
      <link href="/2018/11/26/0cchext-plugin-update-1-0-19-1/"/>
      <url>/2018/11/26/0cchext-plugin-update-1-0-19-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近把windbg插件0cchext升级到1.0.19.1，完善了autocmd命令，并且增加了accessmask，oledata和cppexcr命令。</p><h3 id="autocmd更新："><a href="#autocmd更新：" class="headerlink" title="autocmd更新："></a>autocmd更新：</h3><blockquote><p>现在支持全局自动运行命令，区分应用层调试和内核调试，并且区分了普通调试和DUMP分析，配置文件依然是插件同目录下的autocmd.ini。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[all]</span><br><span class="line">? 88 * 66</span><br><span class="line"></span><br><span class="line">[kernel]</span><br><span class="line">!process 0 0 explorer.exe</span><br><span class="line"></span><br><span class="line">[kernel dump]</span><br><span class="line">!analyze -v</span><br><span class="line"></span><br><span class="line">[notepad.exe]</span><br><span class="line">.sympath+ c:\notepad_pdb</span><br><span class="line">~*k</span><br><span class="line"></span><br><span class="line">[calc.exe]</span><br><span class="line">.sympath+ c:\calc_pdb</span><br><span class="line">~*k</span><br><span class="line"></span><br><span class="line">[calc.exe dump]</span><br><span class="line">.excr</span><br></pre></td></tr></table></figure><p>在[all]区间的命令，会在所有情况下执行；[kernel]区间的命令会在内核调试的情况下执行；[kernel dump]区间的命令会在内核调试dump的情况下执行；[app.exe]区间是在调试某exe的时候执行；最后[app.exe dump]命令会在调试指定exe的dump的时候执行。</p><h3 id="accessmask命令："><a href="#accessmask命令：" class="headerlink" title="accessmask命令："></a>accessmask命令：</h3><blockquote><p>这个命令很简单，就是查询权限标志的，例如</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !accessmask process 0x1fffff</span><br><span class="line">Access mask: 0x1fffff</span><br><span class="line"></span><br><span class="line">Generic rights:</span><br><span class="line">STANDARD_RIGHTS_READ              (0x20000)</span><br><span class="line">STANDARD_RIGHTS_WRITE             (0x20000)</span><br><span class="line">STANDARD_RIGHTS_EXECUTE           (0x20000)</span><br><span class="line">STANDARD_RIGHTS_REQUIRED          (0xf0000)</span><br><span class="line">STANDARD_RIGHTS_ALL               (0x1f0000)</span><br><span class="line">READ_CONTROL                      (0x20000)</span><br><span class="line">DELETE                            (0x10000)</span><br><span class="line">SYNCHRONIZE                       (0x100000)</span><br><span class="line">WRITE_DAC                         (0x40000)</span><br><span class="line">WRITE_OWNER                       (0x80000)</span><br><span class="line"></span><br><span class="line">Specific rights:</span><br><span class="line">PROCESS_QUERY_LIMITED_INFORMATION    (0x1000)</span><br><span class="line">PROCESS_SUSPEND_RESUME            (0x800)</span><br><span class="line">PROCESS_QUERY_INFORMATION         (0x400)</span><br><span class="line">PROCESS_SET_INFORMATION           (0x200)</span><br><span class="line">PROCESS_SET_QUOTA                 (0x100)</span><br><span class="line">PROCESS_CREATE_PROCESS            (0x80)</span><br><span class="line">PROCESS_DUP_HANDLE                (0x40)</span><br><span class="line">PROCESS_VM_WRITE                  (0x20)</span><br><span class="line">PROCESS_VM_READ                   (0x10)</span><br><span class="line">PROCESS_VM_OPERATION              (0x8)</span><br><span class="line">PROCESS_CREATE_THREAD             (0x2)</span><br><span class="line">PROCESS_TERMINATE                 (0x1)</span><br><span class="line">PROCESS_ALL_ACCESS                (0x1fffff)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中第一个参数是对象类型，比如process，thread，file；第二个参数则是具体要查询的值。</p><h3 id="oledata命令："><a href="#oledata命令：" class="headerlink" title="oledata命令："></a>oledata命令：</h3><blockquote><p>这个命令是方便我们当前线程查询com和ole相关结构的命令，不需要参数。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !oledata</span><br><span class="line">dt combase!tagSOleTlsData 0x0000019370ad0360</span><br><span class="line">dx (combase!tagSOleTlsData *)0x0000019370ad0360</span><br><span class="line">0:000&gt; dt combase!tagSOleTlsData 0x0000019370ad0360</span><br><span class="line">   +0x000 pvThreadBase     : (null)</span><br><span class="line">   +0x008 pSmAllocator     : (null)</span><br><span class="line">   +0x010 dwApartmentID    : 0x1e3d4</span><br><span class="line">   +0x014 dwFlags          : 0x81</span><br><span class="line">   +0x018 TlsMapIndex      : 0n0</span><br><span class="line">   +0x020 ppTlsSlot        : 0x00000018&#96;66fc9758  -&gt; 0x00000193&#96;70ad0360 Void</span><br><span class="line">   +0x028 cComInits        : 3</span><br><span class="line">   +0x02c cOleInits        : 0</span><br><span class="line">   +0x030 cCalls           : 0</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>另外可以看<a href="https://0cch.com/2017/07/09/tip-about-com/">调试COM的一个tip</a>来简单了解以下这个命令的用途</p><h3 id="cppexcrname命令："><a href="#cppexcrname命令：" class="headerlink" title="cppexcrname命令："></a>cppexcrname命令：</h3><blockquote><p>这个命令用于查询C++ 异常名</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; .exr -1</span><br><span class="line">ExceptionAddress: 74e61812 (KERNELBASE!RaiseException+0x00000062)</span><br><span class="line">   ExceptionCode: e06d7363 (C++ EH exception)</span><br><span class="line">  ExceptionFlags: 00000001</span><br><span class="line">NumberParameters: 3</span><br><span class="line">   Parameter[0]: 19930520</span><br><span class="line">   Parameter[1]: 006ff46c</span><br><span class="line">   Parameter[2]: 00372294</span><br><span class="line">0:000&gt; !cppexcrname</span><br><span class="line">Exception name: .?AVexception@std@@</span><br></pre></td></tr></table></figure><p>这个的详情可以参考<a href="https://0cch.com/2015/12/06/cpp-exception-params/">C++异常的参数分析(0xE06D7363)</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不要使用GetFullPathName获得相对路径的全路径</title>
      <link href="/2018/10/27/dont-use-getfullpathname/"/>
      <url>/2018/10/27/dont-use-getfullpathname/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上周末在网上闲逛，看到一篇介绍Path*相关API的文章，发现文章中推荐了GetFullPathName这个API，因为他能方便的获得相对路径对于当前工作目录的全路径。然而，我对于这个推荐API是坚决反对的。如果所有工程代码都是一个人开发，这种情况下调用这个API，我认为尚可理解，但是如果对于多人维护的大型工程，就不要使用它了。原因很简单，这个API是根据当前工作目录去确定绝对路径的，然而你无法确定当前工作目录是否是你认为的工作目录。即使在调用GetFullPathName之前，检查了这个路径，我认为也是不可信的。因为在检查过后，也有可能在其他线程中改变当前工作目录，要知道这个变量是全局唯一的。  </p><p>所以，以下代码是不可取的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">WCHAR lpBuffer[MAX_PATH];</span><br><span class="line">LPWSTR lpFname = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetCurrentDirectoryW</span>(<span class="string">L&quot;C:\\some\\thing\\dir&quot;</span>);</span><br><span class="line"><span class="built_in">GetFullPathNameW</span>(<span class="string">L&quot;..\\other\\dir&quot;</span>, MAX_PATH, lpBuffer, &amp;lpFname);</span><br></pre></td></tr></table></figure><p>其实微软为我们提供挺好的API来代替他，比如PathCanonicalize以及PathCombine（实际上有更安全的API，比如 PathCchCanonicalize和PathCchCombine，只不过需要高版本的系统）。</p><p>所以，以下代码是正确的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">WCHAR lpBuffer[MAX_PATH];</span><br><span class="line">WCHAR lpSrc[MAX_PATH] = <span class="string">L&quot;C:\\some\\thing\\dir&quot;</span>;</span><br><span class="line"><span class="built_in">wcscat_s</span>(lpSrc, <span class="string">L&quot;..\\other\\dir&quot;</span>);</span><br><span class="line"><span class="built_in">PathCanonicalizeW</span>(lpBuffer, lpSrc);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">WCHAR lpBuffer[MAX_PATH];</span><br><span class="line"><span class="built_in">PathCombineW</span>(lpBuffer, <span class="string">L&quot;C:\\some\\thing\\dir&quot;</span>, <span class="string">L&quot;..\\other\\dir&quot;</span>);</span><br></pre></td></tr></table></figure><p>最后在介绍一个实用的函数：PathCompactPath，这个函数把路径缩写为指定的像素长度：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">WCHAR buffer[MAX_PATH] = <span class="string">L&quot;C:\\some\\thing\\very\\long\\long\\long\\long\\long\\path&quot;</span>;</span><br><span class="line"><span class="built_in">PathCompactPathW</span>(<span class="literal">NULL</span>, buffer, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// buffer=&quot;C:\some\thing\very...\path&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于TokenLinkedToken的一点记录2</title>
      <link href="/2018/09/24/tokenlinkedtoken-tip2/"/>
      <url>/2018/09/24/tokenlinkedtoken-tip2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="内核原理"><a href="#内核原理" class="headerlink" title="内核原理"></a>内核原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !process 0 1 explorer.exe</span><br><span class="line">PROCESS ffffc306d0c34580</span><br><span class="line">    SessionId: 11  Cid: 44e0    Peb: 006fc000  ParentCid: 5758</span><br><span class="line">    DirBase: 2b1d00002  ObjectTable: ffff8b8e568c7040  HandleCount: 29648.</span><br><span class="line">    Image: explorer.exe</span><br><span class="line">    VadRoot ffffc306ddf5fca0 Vads 1625 Clone 0 Private 403154. Modified 771103. Locked 50.</span><br><span class="line">    DeviceMap ffff8b8e3147ed30</span><br><span class="line">    Token                             ffff8b8e4937f940</span><br><span class="line">    ElapsedTime                       06:29:46.426</span><br><span class="line">    UserTime                          00:00:48.921</span><br><span class="line">    KernelTime                        00:00:53.250</span><br><span class="line">    QuotaPoolUsage[PagedPool]         2123416</span><br><span class="line">    QuotaPoolUsage[NonPagedPool]      225280</span><br><span class="line">    Working Set Sizes (now,min,max)  (56547, 50, 345) (226188KB, 200KB, 1380KB)</span><br><span class="line">    PeakWorkingSetSize                462611</span><br><span class="line">    VirtualSize                       2103798 Mb</span><br><span class="line">    PeakVirtualSize                   2104556 Mb</span><br><span class="line">    PageFaultCount                    2358568</span><br><span class="line">    MemoryPriority                    BACKGROUND</span><br><span class="line">    BasePriority                      8</span><br><span class="line">    CommitCharge                      426963</span><br><span class="line"></span><br><span class="line">0: kd&gt; !token ffff8b8e4937f940</span><br><span class="line">_TOKEN 0xffff8b8e4937f940</span><br><span class="line">TS Session ID: 0xb</span><br><span class="line">User: S-1-5-21-3854333306-943506906-3328512208-1001</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-5-21-3854333306-943506906-3328512208-513</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-114</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 03 S-1-5-21-3854333306-943506906-3328512208-1002</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 04 S-1-5-32-544</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 05 S-1-5-32-559</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 06 S-1-5-32-545</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 07 S-1-5-4</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 08 S-1-2-1</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 09 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 10 S-1-5-15</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 11 S-1-5-113</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 12 S-1-5-5-0-4234506195</span><br><span class="line">    Attributes - Mandatory Default Enabled LogonId </span><br><span class="line"> 13 S-1-2-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 14 S-1-5-64-10</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 15 S-1-16-8192</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S-1-5-21-3854333306-943506906-3328512208-513</span><br><span class="line">Privs: </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege               Attributes - Enabled </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege                 Attributes - </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege               Attributes - </span><br><span class="line">Authentication ID:         (0,fc65706c)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: User32             TokenFlags: 0x2a00 ( Token in use )</span><br><span class="line">Token ID: fc664685         ParentToken ID: fc65706f</span><br><span class="line">Modified ID:               (0, fe4096af)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 3e7</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0      Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0: kd&gt; dt _TOKEN 0xffff8b8e4937f940</span><br><span class="line">nt!_TOKEN</span><br><span class="line">   +0x000 TokenSource      : _TOKEN_SOURCE</span><br><span class="line">   +0x010 TokenId          : _LUID</span><br><span class="line">   +0x018 AuthenticationId : _LUID</span><br><span class="line">   +0x020 ParentTokenId    : _LUID</span><br><span class="line">   +0x028 ExpirationTime   : _LARGE_INTEGER 0x7fffffff&#96;ffffffff</span><br><span class="line">   +0x030 TokenLock        : 0xffffc306&#96;c7b5dd40 _ERESOURCE</span><br><span class="line">   +0x038 ModifiedId       : _LUID</span><br><span class="line">   +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x058 AuditPolicy      : _SEP_AUDIT_POLICY</span><br><span class="line">   +0x078 SessionId        : 0xb</span><br><span class="line">   +0x07c UserAndGroupCount : 0x11</span><br><span class="line">   +0x080 RestrictedSidCount : 0</span><br><span class="line">   +0x084 VariableLength   : 0x228</span><br><span class="line">   +0x088 DynamicCharged   : 0x1000</span><br><span class="line">   +0x08c DynamicAvailable : 0</span><br><span class="line">   +0x090 DefaultOwnerIndex : 0</span><br><span class="line">   +0x098 UserAndGroups    : 0xffff8b8e&#96;4937fdd0 _SID_AND_ATTRIBUTES</span><br><span class="line">   +0x0a0 RestrictedSids   : (null) </span><br><span class="line">   +0x0a8 PrimaryGroup     : 0xffff8b8e&#96;2b2a3b10 Void</span><br><span class="line">   +0x0b0 DynamicPart      : 0xffff8b8e&#96;2b2a3b10  -&gt; 0x501</span><br><span class="line">   +0x0b8 DefaultDacl      : 0xffff8b8e&#96;2b2a3b2c _ACL</span><br><span class="line">   +0x0c0 TokenType        : 1 ( TokenPrimary )</span><br><span class="line">   +0x0c4 ImpersonationLevel : 0 ( SecurityAnonymous )</span><br><span class="line">   +0x0c8 TokenFlags       : 0x2a00</span><br><span class="line">   +0x0cc TokenInUse       : 0x1 &#39;&#39;</span><br><span class="line">   +0x0d0 IntegrityLevelIndex : 0x10</span><br><span class="line">   +0x0d4 MandatoryPolicy  : 3</span><br><span class="line">   +0x0d8 LogonSession     : 0xffff8b8e&#96;143fc870 _SEP_LOGON_SESSION_REFERENCES</span><br><span class="line">   +0x0e0 OriginatingLogonSession : _LUID</span><br><span class="line">   +0x0e8 SidHash          : _SID_AND_ATTRIBUTES_HASH</span><br><span class="line">   +0x1f8 RestrictedSidHash : _SID_AND_ATTRIBUTES_HASH</span><br><span class="line">   +0x308 pSecurityAttributes : 0xffff8b8e&#96;0c3b7f30 _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION</span><br><span class="line">   +0x310 Package          : (null) </span><br><span class="line">   +0x318 Capabilities     : (null) </span><br><span class="line">   +0x320 CapabilityCount  : 0</span><br><span class="line">   +0x328 CapabilitiesHash : _SID_AND_ATTRIBUTES_HASH</span><br><span class="line">   +0x438 LowboxNumberEntry : (null) </span><br><span class="line">   +0x440 LowboxHandlesEntry : (null) </span><br><span class="line">   +0x448 pClaimAttributes : (null) </span><br><span class="line">   +0x450 TrustLevelSid    : (null) </span><br><span class="line">   +0x458 TrustLinkedToken : (null) </span><br><span class="line">   +0x460 IntegrityLevelSidValue : (null) </span><br><span class="line">   +0x468 TokenSidValues   : (null) </span><br><span class="line">   +0x470 IndexEntry       : 0xffff8b8e&#96;349cd270 _SEP_LUID_TO_INDEX_MAP_ENTRY</span><br><span class="line">   +0x478 DiagnosticInfo   : (null) </span><br><span class="line">   +0x480 BnoIsolationHandlesEntry : (null) </span><br><span class="line">   +0x488 SessionObject    : 0xffffc306&#96;cd464140 Void</span><br><span class="line">   +0x490 VariablePart     : 0xffff8b8e&#96;4937fee0</span><br><span class="line"></span><br><span class="line">0: kd&gt; dt 0xffff8b8e&#96;143fc870 _SEP_LOGON_SESSION_REFERENCES</span><br><span class="line">nt!_SEP_LOGON_SESSION_REFERENCES</span><br><span class="line">   +0x000 Next             : (null) </span><br><span class="line">   +0x008 LogonId          : _LUID</span><br><span class="line">   +0x010 BuddyLogonId     : _LUID</span><br><span class="line">   +0x018 ReferenceCount   : 0n1799</span><br><span class="line">   +0x020 Flags            : 0xd</span><br><span class="line">   +0x028 pDeviceMap       : 0xffff8b8e&#96;3147ed30 _DEVICE_MAP</span><br><span class="line">   +0x030 Token            : 0xffff8b8e&#96;20c65060 Void</span><br><span class="line">   +0x038 AccountName      : _UNICODE_STRING &quot;win&quot;</span><br><span class="line">   +0x048 AuthorityName    : _UNICODE_STRING &quot;DESKTOP-GJGV2E2&quot;</span><br><span class="line">   +0x058 CachedHandlesTable : _SEP_CACHED_HANDLES_TABLE</span><br><span class="line">   +0x068 SharedDataLock   : _EX_PUSH_LOCK</span><br><span class="line">   +0x070 SharedClaimAttributes : (null) </span><br><span class="line">   +0x078 SharedSidValues  : (null) </span><br><span class="line">   +0x080 RevocationBlock  : _OB_HANDLE_REVOCATION_BLOCK</span><br><span class="line">   +0x0a0 ServerSilo       : (null) </span><br><span class="line">   +0x0a8 SiblingAuthId    : _LUID</span><br><span class="line">   +0x0b0 TokenList        : _LIST_ENTRY [ 0x00000000&#96;00000000 - 0x00000000&#96;00000000 ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0: kd&gt; dt 0xffff8b8e&#96;143fc870 _SEP_LOGON_SESSION_REFERENCES BuddyLogonId.</span><br><span class="line">nt!_SEP_LOGON_SESSION_REFERENCES</span><br><span class="line">   +0x010 BuddyLogonId  : </span><br><span class="line">      +0x000 LowPart       : 0xfc657047</span><br><span class="line">      +0x004 HighPart      : 0n0</span><br><span class="line"></span><br><span class="line">0: kd&gt; ? 0xfc657047&amp;0xf</span><br><span class="line">Evaluate expression: 7 &#x3D; 00000000&#96;00000007</span><br><span class="line"></span><br><span class="line">0: kd&gt; dq nt!SepLogonSessions L1</span><br><span class="line">fffff802&#96;45a744a0  ffff8b8e&#96;0b0020d0</span><br><span class="line">0: kd&gt; dq ffff8b8e&#96;0b0020d0+8*7 L1</span><br><span class="line">ffff8b8e&#96;0b002108  ffff8b8e&#96;367ef010</span><br><span class="line"></span><br><span class="line">0: kd&gt; dt ffff8b8e&#96;367ef010 _SEP_LOGON_SESSION_REFERENCES</span><br><span class="line">nt!_SEP_LOGON_SESSION_REFERENCES</span><br><span class="line">   +0x000 Next             : 0xffff8b8e&#96;593ba230 _SEP_LOGON_SESSION_REFERENCES</span><br><span class="line">   +0x008 LogonId          : _LUID</span><br><span class="line">   +0x010 BuddyLogonId     : _LUID</span><br><span class="line">   +0x018 ReferenceCount   : 0n56</span><br><span class="line">   +0x020 Flags            : 0xa</span><br><span class="line">   +0x028 pDeviceMap       : 0xffff8b8e&#96;0e5e0890 _DEVICE_MAP</span><br><span class="line">   +0x030 Token            : 0xffff8b8e&#96;15b56940 Void</span><br><span class="line">   +0x038 AccountName      : _UNICODE_STRING &quot;win&quot;</span><br><span class="line">   +0x048 AuthorityName    : _UNICODE_STRING &quot;DESKTOP-GJGV2E2&quot;</span><br><span class="line">   +0x058 CachedHandlesTable : _SEP_CACHED_HANDLES_TABLE</span><br><span class="line">   +0x068 SharedDataLock   : _EX_PUSH_LOCK</span><br><span class="line">   +0x070 SharedClaimAttributes : (null) </span><br><span class="line">   +0x078 SharedSidValues  : (null) </span><br><span class="line">   +0x080 RevocationBlock  : _OB_HANDLE_REVOCATION_BLOCK</span><br><span class="line">   +0x0a0 ServerSilo       : (null) </span><br><span class="line">   +0x0a8 SiblingAuthId    : _LUID</span><br><span class="line">   +0x0b0 TokenList        : _LIST_ENTRY [ 0x00000000&#96;00000000 - 0x00000000&#96;00000000 ]</span><br><span class="line">   </span><br><span class="line">0: kd&gt; !token 0xffff8b8e&#96;15b56940</span><br><span class="line">_TOKEN 0xffff8b8e15b56940</span><br><span class="line">TS Session ID: 0xb</span><br><span class="line">User: S-1-5-21-3854333306-943506906-3328512208-1001</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-5-21-3854333306-943506906-3328512208-513</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-114</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 03 S-1-5-21-3854333306-943506906-3328512208-1002</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 04 S-1-5-32-544</span><br><span class="line">    Attributes - Mandatory Default Enabled Owner </span><br><span class="line"> 05 S-1-5-32-559</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 06 S-1-5-32-545</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 07 S-1-5-4</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 08 S-1-2-1</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 09 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 10 S-1-5-15</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 11 S-1-5-113</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 12 S-1-5-5-0-4234506195</span><br><span class="line">    Attributes - Mandatory Default Enabled LogonId </span><br><span class="line"> 13 S-1-2-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 14 S-1-5-64-10</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 15 S-1-16-12288</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S-1-5-21-3854333306-943506906-3328512208-513</span><br><span class="line">Privs: </span><br><span class="line"> 05 0x000000005 SeIncreaseQuotaPrivilege          Attributes - </span><br><span class="line"> 08 0x000000008 SeSecurityPrivilege               Attributes - </span><br><span class="line"> 09 0x000000009 SeTakeOwnershipPrivilege          Attributes - </span><br><span class="line"> 10 0x00000000a SeLoadDriverPrivilege             Attributes - </span><br><span class="line"> 11 0x00000000b SeSystemProfilePrivilege          Attributes - </span><br><span class="line"> 12 0x00000000c SeSystemtimePrivilege             Attributes - </span><br><span class="line"> 13 0x00000000d SeProfileSingleProcessPrivilege   Attributes - </span><br><span class="line"> 14 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes - </span><br><span class="line"> 15 0x00000000f SeCreatePagefilePrivilege         Attributes - </span><br><span class="line"> 17 0x000000011 SeBackupPrivilege                 Attributes - </span><br><span class="line"> 18 0x000000012 SeRestorePrivilege                Attributes - </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege               Attributes - </span><br><span class="line"> 20 0x000000014 SeDebugPrivilege                  Attributes - </span><br><span class="line"> 22 0x000000016 SeSystemEnvironmentPrivilege      Attributes - </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> 24 0x000000018 SeRemoteShutdownPrivilege         Attributes - </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege                 Attributes - </span><br><span class="line"> 28 0x00000001c SeManageVolumePrivilege           Attributes - </span><br><span class="line"> 29 0x00000001d SeImpersonatePrivilege            Attributes - Enabled Default </span><br><span class="line"> 30 0x00000001e SeCreateGlobalPrivilege           Attributes - Enabled Default </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege               Attributes - </span><br><span class="line"> 35 0x000000023 SeCreateSymbolicLinkPrivilege     Attributes - </span><br><span class="line"> 36 0x000000024 SeDelegateSessionUserImpersonatePrivilege  Attributes - </span><br><span class="line">Authentication ID:         (0,fc657047)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: User32             TokenFlags: 0x2020 ( Token NOT in use ) </span><br><span class="line">Token ID: fc657079         ParentToken ID: 0</span><br><span class="line">Modified ID:               (0, fc65706b)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 3e7</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0      Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于TokenLinkedToken的一点记录</title>
      <link href="/2018/08/24/tokenlinkedtoken-tip/"/>
      <url>/2018/08/24/tokenlinkedtoken-tip/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们用GetTokenInformation可以获得一个TokenLinkedToken，简单的说就是要获得与我们进程token关联的token。  </p><p>接下来就有趣了，如果当你的进程是一个提权的管理员权限的进程，那么你获得的token会是一个标准用户进程的token，也就是一个提权之前进程。那么这有什么用呢？比如我们的子程序需要运行其他开发者开发的插件，而我们不想给予他们过高的权限，那么这个就有用了。当然，如果你更谨慎一些，你希望给予他更低的权限，那就得实用CreateRestrictedToken来创建一个新的token了。  </p><p>聪明的程序员看到这里肯定就会想，既然管理员权限下的进程获得的TokenLinkedToken是一个标准用户权限的token，那么标准用户权限环境下的进程能不能获得一个管理员权限的TokenLinkedToken呢？没错，答案是可以。更聪明的程序员肯定会惊讶，那这个不是安全漏洞么？答案是并不是，因为虽然可以获得一个管理员权限的token，但是这个token只是一个IDENTIFY level token，这是一个token的_SECURITY_IMPERSONATION_LEVEL，不同的模仿等级，对应于不同的功能。比如SecurityIdentification，这个等级就只能用来查询token的信息。比方说有外部一个进程访问我们的进程，我们可以让他提供token验证其身份。但是外部进程为了防止我们用他的token干坏事，所以只给我们一个IDENTIFY level token，这样一来，我们就只能验证身份而无法做其他事情了。  </p><p>我们真的没办法通过TokenLinkedToken获得可以使用的管理员身份的token了么？也不是，我们确实有办法获得能够使用的管理员身份的token。但是有个前提，我们的进程必须有SeTcbPrivilege权限。那这不也是个安全漏洞么？不是，因为SeTcbPrivilege是SYSTEM用户的权限，简单的说，这个用户的权限比管理员还要高。那这玩意不是也没什么用么？也有用，当你想在系统服务中启动一个管理员身份的进程的时候，可以先获得标准用户权限的token，然后获得其TokenLinkedToken，最后CreateProcessAsUser来创建进程。  </p><p><a href="/uploads/2018/08/TokenLinkedToken.png"><img src="/uploads/2018/08/TokenLinkedToken.png" alt="TokenLinkedToken"></a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow入门 —— mnist</title>
      <link href="/2018/07/07/tensorflow-mnist/"/>
      <url>/2018/07/07/tensorflow-mnist/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>自从有tensorflow这样的平台工具横空出世，机器学习的代码编写逐渐变的平民化了。我们不需要太多的数学理论知识就能够完成一些机器学习的项目。比如在使用tensorflow的时候，我们只需要定义好损失函数，tensorflow会自动的帮我们完成反向传播改善参数。我们所需要做的就是合理利用tensorflow创建模型。</p><p>当然，我并不是在鼓动初学者跳过数学原理部分，而是认为，如果没有数学基础，入门就死磕原理容易产生挫败感导致放弃。这样就不如先接触简单的项目，在有了一定的体会后，再回头去看看数学原理的东西，这样会更容易接受。比如，当能用tensorflow完成对mnist的训练之后，再去理解反向传播这四个公式，应该会更有感觉。</p><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 38.587ex"><svg style="vertical-align: -9.056ex; min-width: 38.587ex" xmlns="http://www.w3.org/2000/svg" width="100%" height="19.243ex" role="img" focusable="false" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-I-1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path><path id="MJX-3-TEX-I-1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path><path id="MJX-3-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-3-TEX-N-2207" d="M46 676Q46 679 51 683H781Q786 679 786 676Q786 674 617 326T444 -26Q439 -33 416 -33T388 -26Q385 -22 216 326T46 676ZM697 596Q697 597 445 597T193 596Q195 591 319 336T445 80L697 596Z"></path><path id="MJX-3-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-3-TEX-I-1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path><path id="MJX-3-TEX-N-2299" d="M56 250Q56 394 156 488T384 583Q530 583 626 485T722 250Q722 110 625 14T390 -83Q249 -83 153 14T56 250ZM682 250Q682 322 649 387T546 497T381 542Q272 542 184 459T95 250Q95 132 178 45T389 -42Q515 -42 598 45T682 250ZM311 250Q311 285 332 304T375 328Q376 328 382 328T392 329Q424 326 445 305T466 250Q466 217 445 195T389 172Q354 172 333 195T311 250Z"></path><path id="MJX-3-TEX-I-1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path><path id="MJX-3-TEX-N-2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path><path id="MJX-3-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-3-TEX-I-1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path><path id="MJX-3-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-3-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-3-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-3-TEX-I-1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"></path><path id="MJX-3-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-3-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path><path id="MJX-3-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-3-TEX-I-1D715" d="M202 508Q179 508 169 520T158 547Q158 557 164 577T185 624T230 675T301 710L333 715H345Q378 715 384 714Q447 703 489 661T549 568T566 457Q566 362 519 240T402 53Q321 -22 223 -22Q123 -22 73 56Q42 102 42 148V159Q42 276 129 370T322 465Q383 465 414 434T455 367L458 378Q478 461 478 515Q478 603 437 639T344 676Q266 676 223 612Q264 606 264 572Q264 547 246 528T202 508ZM430 306Q430 372 401 400T333 428Q270 428 222 382Q197 354 183 323T150 221Q132 149 132 116Q132 21 232 21Q244 21 250 22Q327 35 374 112Q389 137 409 196T430 306Z"></path><path id="MJX-3-TEX-I-1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path><path id="MJX-3-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path><path id="MJX-3-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path id="MJX-3-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-3-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-3-TEX-N-34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0) scale(0.0181) translate(0, -4502.7)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2078, 0) translate(-2078, 0)"><g transform="translate(0 4502.7) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="6449.8 -4502.7 1 8505.3"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0, 3606.7)"><g data-mml-node="mtd" transform="translate(1456.2, 0)"><g data-mml-node="msup"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D6FF"></use></g><g data-mml-node="mi" transform="translate(444, 413) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D43F"></use></g></g></g><g data-mml-node="mtd" transform="translate(2431.7, 0)"><g data-mml-node="mi"></g><g data-mml-node="mo" transform="translate(277.8, 0)"><use xlink:href="#MJX-3-TEX-N-3D"></use></g><g data-mml-node="msub" transform="translate(1333.6, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-N-2207"></use></g><g data-mml-node="mi" transform="translate(833, -150) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D44E"></use></g></g><g data-mml-node="mi" transform="translate(2590.6, 0)"><use xlink:href="#MJX-3-TEX-I-1D436"></use></g><g data-mml-node="mo" transform="translate(3572.8, 0)"><use xlink:href="#MJX-3-TEX-N-2299"></use></g><g data-mml-node="msup" transform="translate(4573.1, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D70E"></use></g><g data-mml-node="mo" transform="translate(571, 413) scale(0.707)"><use xlink:href="#MJX-3-TEX-N-2032"></use></g></g><g data-mml-node="mo" transform="translate(5388.5, 0)"><use xlink:href="#MJX-3-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(5777.5, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D467"></use></g><g data-mml-node="mi" transform="translate(465, 413) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D43F"></use></g></g><g data-mml-node="mo" transform="translate(6774.1, 0)"><use xlink:href="#MJX-3-TEX-N-29"></use></g></g></g><g data-mml-node="mlabeledtr" transform="translate(0, 2153)"><g data-mml-node="mtd" transform="translate(1727, 0)"><g data-mml-node="msup"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D6FF"></use></g><g data-mml-node="mi" transform="translate(444, 413) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D459"></use></g></g></g><g data-mml-node="mtd" transform="translate(2431.7, 0)"><g data-mml-node="mi"></g><g data-mml-node="mo" transform="translate(277.8, 0)"><use xlink:href="#MJX-3-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(1333.6, 0)"><use xlink:href="#MJX-3-TEX-N-28"></use></g><g data-mml-node="mo" transform="translate(1722.6, 0)"><use xlink:href="#MJX-3-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(2111.6, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D464"></use></g><g data-mml-node="TeXAtom" transform="translate(716, 413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D459"></use></g><g data-mml-node="mo" transform="translate(298, 0)"><use xlink:href="#MJX-3-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(1076, 0)"><use xlink:href="#MJX-3-TEX-N-31"></use></g></g></g><g data-mml-node="msup" transform="translate(3992, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-3-TEX-N-29"></use></g><g data-mml-node="mi" transform="translate(389, 413) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D447"></use></g></g><g data-mml-node="msup" transform="translate(4928.8, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D6FF"></use></g><g data-mml-node="TeXAtom" transform="translate(444, 413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D459"></use></g><g data-mml-node="mo" transform="translate(298, 0)"><use xlink:href="#MJX-3-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(1076, 0)"><use xlink:href="#MJX-3-TEX-N-31"></use></g></g></g><g data-mml-node="mo" transform="translate(6537.2, 0)"><use xlink:href="#MJX-3-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(7148.4, 0)"><use xlink:href="#MJX-3-TEX-N-2299"></use></g><g data-mml-node="msup" transform="translate(8148.6, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D70E"></use></g><g data-mml-node="mo" transform="translate(571, 413) scale(0.707)"><use xlink:href="#MJX-3-TEX-N-2032"></use></g></g><g data-mml-node="mo" transform="translate(8964.1, 0)"><use xlink:href="#MJX-3-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(9353.1, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D467"></use></g><g data-mml-node="mi" transform="translate(465, 413) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D459"></use></g></g><g data-mml-node="mo" transform="translate(10078.8, 0)"><use xlink:href="#MJX-3-TEX-N-29"></use></g></g></g><g data-mml-node="mlabeledtr" transform="translate(0, 212)"><g data-mml-node="mtd" transform="translate(655.4, 0)"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(225.2, 676)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D715"></use></g><g data-mml-node="mi" transform="translate(566, 0)"><use xlink:href="#MJX-3-TEX-I-1D436"></use></g></g><g data-mml-node="mrow" transform="translate(220, -812.1)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D715"></use></g><g data-mml-node="msubsup" transform="translate(566, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D44F"></use></g><g data-mml-node="mi" transform="translate(429, 361.4) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(429, -293.8) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D457"></use></g></g></g><rect width="1536.3" height="60" x="120" y="220"></rect></g></g><g data-mml-node="mtd" transform="translate(2431.7, 0)"><g data-mml-node="mi"></g><g data-mml-node="mo" transform="translate(277.8, 0)"><use xlink:href="#MJX-3-TEX-N-3D"></use></g><g data-mml-node="msubsup" transform="translate(1333.6, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D6FF"></use></g><g data-mml-node="mi" transform="translate(444, 413) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(444, -247) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D457"></use></g></g></g></g><g data-mml-node="mlabeledtr" transform="translate(0, -2729.2)"><g data-mml-node="mtd"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(552.9, 676)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D715"></use></g><g data-mml-node="mi" transform="translate(566, 0)"><use xlink:href="#MJX-3-TEX-I-1D436"></use></g></g><g data-mml-node="mrow" transform="translate(220, -812.1)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D715"></use></g><g data-mml-node="msubsup" transform="translate(566, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D464"></use></g><g data-mml-node="mi" transform="translate(716, 361.4) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D459"></use></g><g data-mml-node="TeXAtom" transform="translate(716, -317.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D457"></use></g><g data-mml-node="mi" transform="translate(412, 0)"><use xlink:href="#MJX-3-TEX-I-1D458"></use></g></g></g></g><rect width="2191.7" height="60" x="120" y="220"></rect></g></g><g data-mml-node="mtd" transform="translate(2431.7, 0)"><g data-mml-node="mi"></g><g data-mml-node="mo" transform="translate(277.8, 0)"><use xlink:href="#MJX-3-TEX-N-3D"></use></g><g data-mml-node="msubsup" transform="translate(1333.6, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D44E"></use></g><g data-mml-node="TeXAtom" transform="translate(529, 413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D459"></use></g><g data-mml-node="mo" transform="translate(298, 0)"><use xlink:href="#MJX-3-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1076, 0)"><use xlink:href="#MJX-3-TEX-N-31"></use></g></g><g data-mml-node="mi" transform="translate(529, -315.7) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D458"></use></g></g><g data-mml-node="msubsup" transform="translate(3027, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D6FF"></use></g><g data-mml-node="mi" transform="translate(444, 413) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(444, -247) scale(0.707)"><use xlink:href="#MJX-3-TEX-I-1D457"></use></g></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="1278 -4502.7 1 8505.3"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn-1" transform="translate(0, 3606.7)"><g data-mml-node="mtext"><use xlink:href="#MJX-3-TEX-N-28"></use><use xlink:href="#MJX-3-TEX-N-31" transform="translate(389, 0)"></use><use xlink:href="#MJX-3-TEX-N-29" transform="translate(889, 0)"></use></g></g><g data-mml-node="mtd" id="mjx-eqn-2" transform="translate(0, 2153)"><g data-mml-node="mtext"><use xlink:href="#MJX-3-TEX-N-28"></use><use xlink:href="#MJX-3-TEX-N-32" transform="translate(389, 0)"></use><use xlink:href="#MJX-3-TEX-N-29" transform="translate(889, 0)"></use></g></g><g data-mml-node="mtd" id="mjx-eqn-3" transform="translate(0, 212)"><g data-mml-node="mtext"><use xlink:href="#MJX-3-TEX-N-28"></use><use xlink:href="#MJX-3-TEX-N-33" transform="translate(389, 0)"></use><use xlink:href="#MJX-3-TEX-N-29" transform="translate(889, 0)"></use></g></g><g data-mml-node="mtd" id="mjx-eqn-4" transform="translate(0, -2729.2)"><g data-mml-node="mtext"><use xlink:href="#MJX-3-TEX-N-28"></use><use xlink:href="#MJX-3-TEX-N-34" transform="translate(389, 0)"></use><use xlink:href="#MJX-3-TEX-N-29" transform="translate(889, 0)"></use></g></g></g></svg></g></g></g></g></svg></mjx-container><p>接下来相信看看这份代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># step1</span></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">&quot;.&quot;</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2</span></span><br><span class="line">INPUT_PARAMETERS = <span class="number">784</span></span><br><span class="line">L1_PARAMETERS = <span class="number">300</span></span><br><span class="line">W1 = tf.Variable(tf.truncated_normal([INPUT_PARAMETERS, L1_PARAMETERS], stddev=<span class="number">0.1</span>))</span><br><span class="line">b1 = tf.Variable(tf.truncated_normal([L1_PARAMETERS], stddev=<span class="number">0.1</span>))</span><br><span class="line">W2 = tf.Variable(tf.truncated_normal([L1_PARAMETERS, <span class="number">10</span>], stddev=<span class="number">0.1</span>))</span><br><span class="line">b2 = tf.Variable(tf.truncated_normal([<span class="number">10</span>], stddev=<span class="number">0.1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="literal">None</span>, INPUT_PARAMETERS])</span><br><span class="line">y_ = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># step4</span></span><br><span class="line">hidden1 = tf.nn.sigmoid(tf.matmul(x, W1) + b1)</span><br><span class="line">y =  tf.matmul(hidden1, W2) + b2</span><br><span class="line"></span><br><span class="line"><span class="comment"># step5</span></span><br><span class="line">loss = (tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(</span><br><span class="line">    logits=y, labels=y_)))</span><br><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.3</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step6</span></span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step7</span></span><br><span class="line">loss_array = []</span><br><span class="line">accuracy_array = []</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    tf.global_variables_initializer().run()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        batch_xs, batch_ys = mnist.train.next_batch(<span class="number">100</span>)</span><br><span class="line">        _, step_loss = sess.run([train_step, loss], feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">            step_accuracy = accuracy.<span class="built_in">eval</span>(&#123;x: mnist.test.images, y_: mnist.test.labels&#125;)</span><br><span class="line">            loss_array.append(step_loss)</span><br><span class="line">            accuracy_array.append(step_accuracy)</span><br><span class="line">            <span class="built_in">print</span>(step_loss, step_accuracy)</span><br><span class="line"></span><br><span class="line">loss_array.append(step_loss)</span><br><span class="line">accuracy_array.append(step_accuracy)</span><br><span class="line"><span class="built_in">print</span>(step_loss, step_accuracy)</span><br><span class="line"></span><br><span class="line">plt.plot([i*<span class="number">500</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(loss_array))], loss_array, <span class="string">&#x27;b-&#x27;</span>,</span><br><span class="line">          [i*<span class="number">500</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(accuracy_array))], accuracy_array, <span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>step1：</strong>read_data_sets是tf提供读取mnist数据的函数，运行时会有函数过时的警告提示，但是不用管它，因为用起来完全没有问题。one_hot参数在这里很重要，他将实际的标签值转化为一个向量，例如，将标签值3，转化成表示0-9是否置位的向量：\( \left(\begin{array}{cccccccccc}0;0;0;1;0;0;0;0;0;0;\end{array}\right)^T \)</p></blockquote><blockquote><p><strong>step2：</strong>创建权重和偏置，创建方法有很多，我用的是期望为0，标准差为0.1的随机分布。</p></blockquote><blockquote><p><strong>step3：</strong>创建输入层和标签的placeholder，大概的意思是占住空间，以方便后续数据喂给模型。</p></blockquote><blockquote><p><strong>step4：</strong>实际上是向前传播 \( z = w^{T}x,+,b\)，\( a = sigmoid(z)\)，其中sigmoid是\( \frac{1}{1+\exp(-z)}\)。这里可能有一个疑问，第二个隐藏层到输出层，没有使用sigmoid函数。原因继续往下看就知道了。</p></blockquote><blockquote><p><strong>step5：</strong>计算损失函数，调用了tf的sigmoid_cross_entropy_with_logits，这个函数把交叉熵和sigmoid的计算放在了一起，所以上面不需要去计算sigmoid了。这样做的好处很明显，就是方便我们修改从最后一个隐藏层到输出层的激活函数，比如将sigmoid_cross_entropy_with_logits替换为softmax_cross_entropy_with_logits，那么我们最后一个激活函数就变成了softmax。最后设置学习率并且把我们的损失函数传给梯度下降类的最小化函数中，tf就会自动的帮我们优化参数，从而最小化损失值了。</p></blockquote><blockquote><p><strong>step6：</strong>使用测试数据去计算模型的识别准确率</p></blockquote><blockquote><p><strong>step7：</strong>最后一步，我们将数据分为小份，随着迭代，逐步喂给模型。然后记录损失和准确率的变化，并做图。</p></blockquote><p>这里我们为了简单，没有使用softmax，dropout和正则化等优化方法，所以识别率只达到了90%，不过作为一个入门来说已经够了。</p><p><a href="/uploads/2018/07/2018-07-07-tensorflow-mnist.png"><img src="/uploads/2018/07/2018-07-07-tensorflow-mnist.png" alt="2018-07-07-tensorflow-mnist"></a></p>]]></content>
      
      
      <categories>
          
          <category> machinelearning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习练习题1</title>
      <link href="/2018/06/22/machine-learning-ex1/"/>
      <url>/2018/06/22/machine-learning-ex1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>掐指一算，已经有三个月没有更新blog了。因为最近一直在学习机器学习的内容，所以没空也没有新鲜的技术值得写下来分享。还好经过一段时间的积累（学习线性代数和概率论），机器学习这块内容也算是入门了。这是机器学习的第一个习题，线性回归。用最直白的话来说，就是用函数去拟合数据分布，从而达到预测新数据的效果。需要的知识是矩阵的计算，最小二乘法以及求偏微分。</p><p>关键的公式只有两个：</p><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 47.651ex"><svg style="vertical-align: -6.128ex; min-width: 47.651ex" xmlns="http://www.w3.org/2000/svg" width="100%" height="13.387ex" role="img" focusable="false" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path><path id="MJX-2-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-2-TEX-I-1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path><path id="MJX-2-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D703" d="M35 200Q35 302 74 415T180 610T319 704Q320 704 327 704T339 705Q393 701 423 656Q462 596 462 495Q462 380 417 261T302 66T168 -10H161Q125 -10 99 10T60 63T41 130T35 200ZM383 566Q383 668 330 668Q294 668 260 623T204 521T170 421T157 371Q206 370 254 370L351 371Q352 372 359 404T375 484T383 566ZM113 132Q113 26 166 26Q181 26 198 36T239 74T287 161T335 307L340 324H145Q145 321 136 286T120 208T113 132Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-2-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-2-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-2-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-2-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-2-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-2-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path><path id="MJX-2-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-2-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-2-TEX-I-1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-2-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path><path id="MJX-2-TEX-I-1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path><path id="MJX-2-TEX-I-1D715" d="M202 508Q179 508 169 520T158 547Q158 557 164 577T185 624T230 675T301 710L333 715H345Q378 715 384 714Q447 703 489 661T549 568T566 457Q566 362 519 240T402 53Q321 -22 223 -22Q123 -22 73 56Q42 102 42 148V159Q42 276 129 370T322 465Q383 465 414 434T455 367L458 378Q478 461 478 515Q478 603 437 639T344 676Q266 676 223 612Q264 606 264 572Q264 547 246 528T202 508ZM430 306Q430 372 401 400T333 428Q270 428 222 382Q197 354 183 323T150 221Q132 149 132 116Q132 21 232 21Q244 21 250 22Q327 35 374 112Q389 137 409 196T430 306Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0) scale(0.0181) translate(0, -3208.5)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2078, 0) translate(-2078, 0)"><g transform="translate(0 3208.5) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="8452.8 -3208.5 1 5916.9"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0, 1645.9)"><g data-mml-node="mtd" transform="translate(2531.8, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D436"></use></g><g data-mml-node="mi" transform="translate(760, 0)"><use xlink:href="#MJX-2-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(1245, 0)"><use xlink:href="#MJX-2-TEX-I-1D460"></use></g><g data-mml-node="mi" transform="translate(1714, 0)"><use xlink:href="#MJX-2-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(2075, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(2464, 0)"><use xlink:href="#MJX-2-TEX-I-1D703"></use></g><g data-mml-node="mo" transform="translate(2933, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(3599.8, 0)"><use xlink:href="#MJX-2-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(4655.6, 0)"><g data-mml-node="mn" transform="translate(659, 676)"><use xlink:href="#MJX-2-TEX-N-31"></use></g><g data-mml-node="mrow" transform="translate(220, -686)"><g data-mml-node="mn"><use xlink:href="#MJX-2-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(500, 0)"><use xlink:href="#MJX-2-TEX-I-1D45A"></use></g></g><rect width="1578" height="60" x="120" y="220"></rect></g><g data-mml-node="mstyle" transform="translate(6473.6, 0)"><g data-mml-node="mspace"></g></g><g data-mml-node="munderover" transform="translate(6806.9, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-LO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(148.2, -1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-2-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1123, 0)"><use xlink:href="#MJX-2-TEX-N-31"></use></g></g><g data-mml-node="TeXAtom" transform="translate(411.6, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D45A"></use></g></g></g><g data-mml-node="mstyle" transform="translate(8417.6, 0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(8584.2, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(8973.2, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-210E"></use></g><g data-mml-node="mi" transform="translate(576, -150) scale(0.707)"><use xlink:href="#MJX-2-TEX-I-1D703"></use></g></g><g data-mml-node="mo" transform="translate(9930.9, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(10319.9, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(572, 413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D456"></use></g></g></g><g data-mml-node="mo" transform="translate(11185.8, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(11797, 0)"><use xlink:href="#MJX-2-TEX-N-2212"></use></g><g data-mml-node="msup" transform="translate(12797.3, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D466"></use></g><g data-mml-node="TeXAtom" transform="translate(490, 413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D456"></use></g></g></g><g data-mml-node="msup" transform="translate(13581.2, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-N-29"></use></g><g data-mml-node="mn" transform="translate(389, 413) scale(0.707)"><use xlink:href="#MJX-2-TEX-N-32"></use></g></g></g></g><g data-mml-node="mlabeledtr" transform="translate(0, -1462.5)"><g data-mml-node="mtd"><g data-mml-node="msub"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D703"></use></g><g data-mml-node="TeXAtom" transform="translate(469, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D457"></use></g></g></g><g data-mml-node="mo" transform="translate(1088.1, 0)"><use xlink:href="#MJX-2-TEX-N-3D"></use></g><g data-mml-node="msub" transform="translate(2143.9, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D703"></use></g><g data-mml-node="TeXAtom" transform="translate(469, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D457"></use></g></g></g><g data-mml-node="mo" transform="translate(3176.4, 0)"><use xlink:href="#MJX-2-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(4176.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D6FC"></use></g><g data-mml-node="mfrac" transform="translate(4816.7, 0)"><g data-mml-node="mn" transform="translate(409, 676)"><use xlink:href="#MJX-2-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(220, -686)"><use xlink:href="#MJX-2-TEX-I-1D45A"></use></g><rect width="1078" height="60" x="120" y="220"></rect></g><g data-mml-node="mstyle" transform="translate(6134.7, 0)"><g data-mml-node="mspace"></g></g><g data-mml-node="munderover" transform="translate(6468, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-LO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(148.2, -1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-2-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1123, 0)"><use xlink:href="#MJX-2-TEX-N-31"></use></g></g><g data-mml-node="TeXAtom" transform="translate(411.6, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D45A"></use></g></g></g><g data-mml-node="mo" transform="translate(7912, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(8301, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-210E"></use></g><g data-mml-node="mi" transform="translate(576, -150) scale(0.707)"><use xlink:href="#MJX-2-TEX-I-1D703"></use></g></g><g data-mml-node="mo" transform="translate(9258.6, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(9647.6, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(572, 413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D456"></use></g></g></g><g data-mml-node="mo" transform="translate(10513.6, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(11124.8, 0)"><use xlink:href="#MJX-2-TEX-N-2212"></use></g><g data-mml-node="msup" transform="translate(12125, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D466"></use></g><g data-mml-node="TeXAtom" transform="translate(490, 413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D456"></use></g></g></g><g data-mml-node="mo" transform="translate(12909, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g><g data-mml-node="mfrac" transform="translate(13298, 0)"><g data-mml-node="mrow" transform="translate(220, 710)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D715"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(566, 0)"><g data-mml-node="msub"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-210E"></use></g><g data-mml-node="mi" transform="translate(576, -150) scale(0.707)"><use xlink:href="#MJX-2-TEX-I-1D703"></use></g></g><g data-mml-node="mo" transform="translate(957.6, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(1346.6, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(572, 363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D456"></use></g></g></g><g data-mml-node="mo" transform="translate(2212.6, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g><g data-mml-node="mrow" transform="translate(1115.6, -686)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D715"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(566, 0)"><g data-mml-node="msub"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D703"></use></g><g data-mml-node="TeXAtom" transform="translate(469, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D457"></use></g></g></g></g></g><rect width="3367.6" height="60" x="120" y="220"></rect></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="1278 -3208.5 1 5916.9"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn-1" transform="translate(0, 1645.9)"><g data-mml-node="mtext"><use xlink:href="#MJX-2-TEX-N-28"></use><use xlink:href="#MJX-2-TEX-N-31" transform="translate(389, 0)"></use><use xlink:href="#MJX-2-TEX-N-29" transform="translate(889, 0)"></use></g></g><g data-mml-node="mtd" id="mjx-eqn-2" transform="translate(0, -1462.5)"><g data-mml-node="mtext"><use xlink:href="#MJX-2-TEX-N-28"></use><use xlink:href="#MJX-2-TEX-N-32" transform="translate(389, 0)"></use><use xlink:href="#MJX-2-TEX-N-29" transform="translate(889, 0)"></use></g></g></g></svg></g></g></g></g></svg></mjx-container><p>那么最后需要确定的只剩下一个，我们希望用什么样的曲线去拟合样本，这个就需要经验和尝试了。这里的练习只需要用直线来拟合就足够了: \( h_\theta(x) = \theta^{T}x = \theta_{0}+\theta_{1}x_{1} \) .</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data = np.loadtxt(<span class="string">&#x27;ex1data1.txt&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离样本数据输入X和输出Y</span></span><br><span class="line">X = np.concatenate((np.ones((<span class="built_in">len</span>(data),<span class="number">1</span>)), data[:,<span class="number">0</span>].reshape((<span class="built_in">len</span>(data),<span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line">theta = np.random.randn(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">Y = data[:,<span class="number">1</span>].reshape((<span class="built_in">len</span>(data),<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了加速计算，把除法优化位乘法</span></span><br><span class="line">alpha = <span class="number">0.01</span></span><br><span class="line">div_m = <span class="number">1</span> / <span class="built_in">len</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> loop_count <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    Y1 = X.dot(theta)</span><br><span class="line">    <span class="comment"># 根据公式计算损失</span></span><br><span class="line">    cost = ((Y-Y1)**<span class="number">2</span>).<span class="built_in">sum</span>() * <span class="number">0.5</span> * div_m;</span><br><span class="line">    <span class="built_in">print</span>(cost)</span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        theta[i, <span class="number">0</span>] = theta[i, <span class="number">0</span>] - alpha * div_m * (np.diagflat(X[:, i]) * (Y1 - Y)).<span class="built_in">sum</span>()    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后把拟合直线画出来</span></span><br><span class="line">Xl = np.linspace(<span class="number">0</span>, <span class="number">30</span>, <span class="number">100</span>)</span><br><span class="line">Yl = Xl * theta[<span class="number">1</span>, <span class="number">0</span>] + theta[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(data[:,<span class="number">0</span>],data[:,<span class="number">1</span>],<span class="string">&#x27;x&#x27;</span>, Xl, Yl, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="/uploads/2018/06/2018-06-23-machine-learning-ex1.jpg"><img src="/uploads/2018/06/2018-06-23-machine-learning-ex1.jpg" alt="2018-06-23-machine-learning-ex1"></a></p>]]></content>
      
      
      <categories>
          
          <category> machinelearning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>广度遍历删除文件</title>
      <link href="/2018/03/29/breadth-first-traversal-to-del-file/"/>
      <url>/2018/03/29/breadth-first-traversal-to-del-file/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近遇到一个要删除文件夹的问题，文件夹内有大量文件和子文件夹，而且结构非常复杂，删除特别慢。于是思考了一下如何能加速文件删除的问题。我看到大部分的实现方法都是深度遍历，即遇到新的文件夹就进入文件夹遍历文件，直到结束后返回上一层继续遍历。实际上这种方法存在一个问题，在我们的硬盘上，文件夹和文件一般是B-Tree分布的，所以同一层文件夹的文件的数据都比较相近，而不同的层的文件夹的文件可能差距比较远，于是深度遍历让硬盘磁头从一个文件夹跨越到另外一个文件夹，磁头花的时间更长了，更何况子文件夹遍历结束，还得从子文件夹在移动回父文件夹。而是用广度遍历就不同，他把当前目录遍历完成后才去遍历另外一个，这样磁头移动的总距离肯定更少，遍历速度当然更快。以下代码我的一个实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFindHandle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AutoFindHandle</span>(HANDLE find_handle) : <span class="built_in">find_handle_</span>(find_handle) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">AutoFindHandle</span>() &#123;</span><br><span class="line">        <span class="built_in">FindClose</span>(find_handle_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HANDLE find_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CollectFileAndDir</span><span class="params">(<span class="keyword">const</span> std::wstring &amp;dir, std::vector&lt;std::wstring&gt; &amp;file_path, std::vector&lt;std::wstring&gt; &amp;dir_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE find_handle;</span><br><span class="line">    WIN32_FIND_DATAW data;</span><br><span class="line">    std::wstring temp_path;</span><br><span class="line">    std::wstring current_dir = dir;</span><br><span class="line">    std::stack&lt;std::wstring&gt; temp_dir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_dir[current_dir.<span class="built_in">length</span>() - <span class="number">1</span>] != <span class="string">L&#x27;\\&#x27;</span>) &#123;</span><br><span class="line">        current_dir += <span class="string">L&quot;\\&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::wstring path = current_dir + <span class="string">L&quot;*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    find_handle = <span class="built_in">FindFirstFileW</span>(path.<span class="built_in">c_str</span>(), &amp;data);</span><br><span class="line">    <span class="keyword">if</span> (find_handle == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AutoFindHandle <span class="title">auto_find_handle</span><span class="params">(find_handle)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wcscmp</span>(data.cFileName, <span class="string">L&quot;..&quot;</span>) != <span class="number">0</span> &amp;&amp; </span><br><span class="line">        <span class="built_in">wcscmp</span>(data.cFileName, <span class="string">L&quot;.&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            temp_path = current_dir;</span><br><span class="line">            temp_path += data.cFileName;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((data.dwFileAttributes &amp; (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">SetFileAttributesW</span>(temp_path.<span class="built_in">c_str</span>(), FILE_ATTRIBUTE_NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                temp_dir.<span class="built_in">push</span>(temp_path);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                file_path.<span class="built_in">push_back</span>(temp_path);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">FindNextFileW</span>(find_handle, &amp;data)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">wcscmp</span>(data.cFileName, <span class="string">L&quot;..&quot;</span>) != <span class="number">0</span> &amp;&amp; </span><br><span class="line">            <span class="built_in">wcscmp</span>(data.cFileName, <span class="string">L&quot;.&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                temp_path = current_dir;</span><br><span class="line">                temp_path += data.cFileName;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((data.dwFileAttributes &amp; (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">SetFileAttributesW</span>(temp_path.<span class="built_in">c_str</span>(), FILE_ATTRIBUTE_NORMAL);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    temp_dir.<span class="built_in">push</span>(temp_path);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    file_path.<span class="built_in">push_back</span>(temp_path);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!temp_dir.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CollectFileAndDir</span>(temp_dir.<span class="built_in">top</span>(), file_path, dir_path);</span><br><span class="line">        </span><br><span class="line">        temp_dir.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    dir_path.<span class="built_in">push_back</span>(dir);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">DeleteFolder</span><span class="params">(LPCWSTR path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::wstring&gt; file_path;</span><br><span class="line">    std::vector&lt;std::wstring&gt; dir_path;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CollectFileAndDir</span>(path, file_path, dir_path)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;std::wstring&gt;::iterator it = file_path.<span class="built_in">begin</span>(); it != file_path.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">DeleteFileW</span>(it-&gt;<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;std::wstring&gt;::iterator it = dir_path.<span class="built_in">begin</span>(); it != dir_path.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">RemoveDirectoryW</span>(it-&gt;<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鸡年总结，狗年计划</title>
      <link href="/2018/02/25/2018-plan/"/>
      <url>/2018/02/25/2018-plan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>虽然没到十五，但是这个年基本上也是过完了。是收心总结鸡年，展望狗年的时候了。</p><p>生活方面，鸡年过的不算顺心，尤其是上半年，麻烦事情接二连三，具体也事情也就不想多写了，不愉快的事情就应该被忘记。工作上，虽然没有明显的进步，但也算是得到了不错的回报，内心有愧的拿了一个优秀员工。重点来了，要说说技术方面的事情。去年下半年快到年底的时候，我做了一个决定，学习深度学习相关知识，作为今后转型的砝码。这里不得不说，做这个决定其实已经很晚了，因为已经有很多人早就踏入了这个领域。我总是想，如果能早两年开窍就好了，但是凡是哪有如果呢。更何况就在去年初我还在跟以前同事争论，坚定的认为个人PC行业还是非常宽阔的，但实际上那个想法也只是说自己的一厢情愿而已。下半年某企业找到我说想让我去他们的个人PC业务部门，给的等级还不错，薪资水平也很快给我翻倍了，但是我拒绝了，那个时候我就知道自己内心里已经不看好个人PC，尤其是Windows上面的发展了。于是乎，打算学习更接近未来趋势的一些东西。</p><p>当今最火的两个领域，区块链和深度学习，我很快的就选择学习深度学习的相关知识了。原因很简单，深度学习现在已经在很大程度上推进了社会发展。而区块链技术，除了在各种加密币方面非常火之外，貌似还没看到什么用途能促进社会进步，至少没有深度学习那么明显吧。下半年的两三个月里开始慢慢接触了深度学习，当然也包括一些其他的机器学习领域的知识。于是深深的感慨，数学在这些领域的重要性，当然又一次后悔没有学好数学，也不得不吐槽我们的高等数学教育是多么的死板无趣。</p><p>今年计划，生活上的事情其实没有什么计划可言，就希望过的更加顺心吧。工作方面，希望能主导一些真正有意义的项目，希望能推进公司往深度学习方面来发展。另外技术方面专注于数学和深度学习。具体的计划就不列了，因为貌似每次列出来也不一定能全部完成 =v=</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ssh的反向连接</title>
      <link href="/2018/01/20/reverse-ssh/"/>
      <url>/2018/01/20/reverse-ssh/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>家里有个树莓派，基本上用来当了一个微型服务器，24小时跑着。主要用途是在我不在家的时候控制家里网络，充分利用带宽。一直以来，我都是用树莓派把IP更新到DDNS（家里是外网IP），并且在路由器上做端口映射。这样就能在其他地方访问树莓派了。但是不知为何，这段时间无法从外网ping通家里（后来发现是光猫问题，换了个猫就好了），从外围直接联通家里的树莓派这条路被封了，所以就折腾了SSH的反向连接功能。用这个方法也可以克服家里是内网IP的情况，当然前提是我们在外网有一台服务器或者vps。原理上和其他的反向连接是一样的，这里就不讨论原理了，直接介绍方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ssh -fCNR remote_port:localhost:local_port user@remote_addr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f 后台执行ssh指令</span><br><span class="line">-C 允许压缩数据</span><br><span class="line">-N 不执行远程指令</span><br><span class="line">-R 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口</span><br></pre></td></tr></table></figure><p>这条命令的意思是：请将remote_addr机器里对remote_port的连接转发到本地机器的本地端口。举个例子，假设我有一台内网机器A，其ssh端口为6622，另外有一台VPS，地址是VPS_ADDR.com，SSH端口是8822。这个时候我想通过VPS的9922端口去访问树莓派的SSH。那么我需要用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ssh -fCNR 9922:localhost:6622 user@VPS_ADDR.com</span><br></pre></td></tr></table></figure><p>当完成了这个命令后，我们就可以在VPS上登陆树莓派了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ssh -p 9922 pi@localhost</span><br></pre></td></tr></table></figure><p>解决了这个问题后，我们需要解决另外一个问题。我们每次输入反向连接的命令的时候总需要输入VPS密码，这个非常不利于我们把命令设置为开机启动。为了解决这个问题，首先想到的是sshpass。这个工具可以帮助我们自动输入密码，命令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sshpass -p your_VPS_password ssh -fCNR 9922:localhost:6622 user@VPS_ADDR.com</span><br></pre></td></tr></table></figure><p>把命令放到树莓派的开机启动命令后，重启树莓派，成功从VPS连入了树莓派。不过第二天，我又发现了另外一个问题，SSH的反向连接在无人访问的时候会超时，超时后会断开链接。这样明显不符合我想连就连的需求。于是就得上autossh这个工具了，这个工具会守护ssh，让ssh的反向连接保持联通。但是autossh不支持自动输入密码，网上很多解决办法是用证书的方式省去了输入密码的过程，不过我这里提供另外一个方法，使用expect工具。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># expect -c &quot;</span><br><span class="line">spawn autossh -M 11122 -CNR 9922:localhost:6622 user@VPS_ADDR.com -o StrictHostKeyChecking&#x3D;no</span><br><span class="line">expect \&quot;Password:\&quot;</span><br><span class="line">send \&quot;your_password\r\&quot;</span><br><span class="line">expect eof</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure><p>这个工具可以自动和ssh进行交互，当VPS提示Password:的时候，我们send密码过去就行了，注意使用StrictHostKeyChecking=no来避免Host key的验证提示。把这个命令放在开机启动的时候执行，完美解决了外网访问家里树莓派的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>将图片转化成mnist格式</title>
      <link href="/2017/12/09/image-to-mnist1/"/>
      <url>/2017/12/09/image-to-mnist1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>利用mnist数据对数字符号进行识别基本上算是深度学习的Hello World了。在我学习这个“hello world”的过程中，多多少少有点不爽，原因是无论是训练数据还是测试数据，都是mnist准备好的，即使最后训练的数字识别率很高，我也没有什么参与感。其实，我特别想测试自己手写数字的识别率。<br>为了完成上述想法，我第一个想到的是将普通图片数据转换成mnist数据。mnist的数据格式非常简单，如下图所示：</p><p><a href="/uploads/2017/12/2017-12-10-t10k-images.idx3-ubyte.png"><img src="/uploads/2017/12/2017-12-10-t10k-images.idx3-ubyte.png" alt="2017-12-10-t10k-images.idx3-ubyte"></a></p><p><a href="/uploads/2017/12/2017-12-10-t10k-labels.idx1-ubyte.png"><img src="/uploads/2017/12/2017-12-10-t10k-labels.idx1-ubyte.png" alt="2017-12-10-t10k-labels.idx1-ubyte"></a></p><p>两幅图分别表示了图形数据和标签数据。他们都有一个4字节长度的magic number，用来识别数据的具体格式。如果是标签数据，那么格式相对简单，后续是一个标签数量，接着的是标签数据（0-9的值）。如果是图像数据，那么magic number后，出了4个字节的数据数量以外，还有分别占4字节的行列数据，最后的就是图像数据。结构非常简单，但是值得注意的事情有两点：</p><blockquote><ol><li>数据使用big endian组织的。</li><li>图像数据中，255表示前景，也就是黑色，0表示背景，也就是白色，这和我们平时看到的RGB是不同的。</li></ol></blockquote><p>知道了数据格式，接下来的事情就是用程序将图像转换到mnist了。说实在的，如果对于操作二进制的数据，C比python还是方便不少的。但是C读取图像更加麻烦。所以这里推荐还是使用python对数据做转化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导入图像处理库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 接下来打开图片，并且将像转化为8bit黑白像素</span></span><br><span class="line">im = Image.<span class="built_in">open</span>(path_to_image)</span><br><span class="line">im = im.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line"><span class="comment"># 转换图像到mnist的大小28*28</span></span><br><span class="line">im = im.resize((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line"><span class="comment"># 获取图像长宽</span></span><br><span class="line">width, height = im.size()</span><br><span class="line"><span class="comment"># 将图像数据转化位mnist</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,width):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,height):</span><br><span class="line">        data_image.append(<span class="number">255</span> - pixel[y,x])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据写到mnist文件中</span></span><br><span class="line">header = array(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="comment"># 写入magic number</span></span><br><span class="line">header.extend([<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 写入数据数量，以一个图片为例</span></span><br><span class="line">header.extend([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 写入行列像素数</span></span><br><span class="line">header.extend([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">28</span>])</span><br><span class="line">header.extend([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">28</span>])</span><br><span class="line"><span class="comment"># 写入数据</span></span><br><span class="line">header.extend(data_image)</span><br><span class="line"><span class="comment"># 最后写文件</span></span><br><span class="line">output_file = <span class="built_in">open</span>(<span class="string">r&#x27;data.mnist&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">header.tofile(output_file)</span><br><span class="line">output_file.close()</span><br></pre></td></tr></table></figure><p>以上是对图像数据的转换，标签数据的转换代码和以上代码基本一样，所以这里不再赘述。<br>有了这个方法，我们可以通过画图软件画上一堆自己手写的数字，通过python批量转化成mnist格式的数据，再让tensorflow进行测试，算出模型对我们自己手写数字的识别正确率。</p><p>好了，以上就是我说的第一种让模型识别自己的手写数字的方法。不过，这个方法不能实时的识别我手写的数字，让人总觉得缺点什么。于是就有了第二种方法，这种方法将借助浏览器，js以及web server等工具将手写的数字实时的传给后台的模型进行识别，然后把结果回复给用户。不过这个方法就要等待下一篇文章来描述了。</p>]]></content>
      
      
      <categories>
          
          <category> DeepLearner </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow pip安装（非GPU版）</title>
      <link href="/2017/11/26/tensorflow-install/"/>
      <url>/2017/11/26/tensorflow-install/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>TensorFlow安装有很多种方法，其中用dock安装是最方便的方式，源代码编译是最麻烦但是最能切合自己机器CPU的方法，当然了，你也可以用Anacaonda安装（一个科学计算的工具合集，以后有机会再介绍）。不过这次，我将介绍使用pip安装的方法。我个人认为这种方法其实是众多方法中最简单方便的方法了（系统基于ubuntu 16.04）。</p><p>先来说说常规用pip安装的方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade tensorflow</span><br></pre></td></tr></table></figure><p>首先当然是安装tensorflow框架了（当然你得有python，如果没有可以使用apt-get install python3-pip python3-dev来安装）</p><p>接下来就是安装temsorflow了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install tensorflow     # Python 3.n; CPU support (no GPU support)</span><br></pre></td></tr></table></figure><p>如果你的电脑和系统的配置正常，这个时候应该可以正常使用tensorflow了。不过，在我的电脑上出现了这么一个警告：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMA</span><br></pre></td></tr></table></figure><p>很明显，现代CPU支持折现特性已经很常见了，但是框架版本并不支持。难道真的要便宜一个么？（据我测试2G内存的机器是无法编译tensorflow的）。于是物品翻阅了github，发现以及有人走在前面，在 <a href="https://github.com/mind/wheels">https://github.com/mind/wheels</a> 里有很多已经编译的模块提供ubuntu。比如，在我的平台上适合的版本是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mind&#x2F;wheels&#x2F;releases&#x2F;download&#x2F;tf1.4-cpu&#x2F;tensorflow-1.4.0-cp35-cp35m-linux_x86_64.whl</span><br></pre></td></tr></table></figure><p>那么就可以使用这个版本来安装tensorflow：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip --no-cache-dir install https:&#x2F;&#x2F;github.com&#x2F;mind&#x2F;wheels&#x2F;releases&#x2F;download&#x2F;tf1.4-cpu&#x2F;tensorflow-1.4.0-cp35-cp35m-linux_x86_64.whl</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DeepLearner </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++20增加的生成器特性</title>
      <link href="/2017/10/23/yield-in-cpp/"/>
      <url>/2017/10/23/yield-in-cpp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>不得不说，C++的语法真是越来越高级了，编译器为程序做的事情也是越来越多了。<br>比方说下面的这个程序，有两个点可以说说：</p><ol><li><p>生成器 —— 编译器为了实现生成器，不得不把这一个函数拆成两个部分，分为初始化部分和程序运行部分。初始化部分主要用来初始保存生成器运行状态的内存空间。每当co_yield返回后，这片内存空间需要保持当前变量的值，以方便程序再次进入生成器后继续运行。</p></li><li><p>异步 —— 在新的标准里，我们实现异步的编码成本更低了。编译器同样为我们做了大量工作，这个例子中，主线程执行到subfuc函数的co_await后，会启动两个线程，一个执行异步函数awaitfuc，另外一个等待这个函数结束执行后面的代码，而主线程本身则是跳出函数执行printf函数。没错，我们简简单单的一句话就让编译器生成了这么多代码。</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;experimental/generator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::experimental;</span><br><span class="line"></span><br><span class="line"><span class="function">generator&lt;<span class="keyword">int</span>&gt; <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">co_yield</span> i + p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pp = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::future&lt;<span class="keyword">int</span>&gt; <span class="title">awaitfuc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::future&lt;<span class="keyword">int</span>&gt; <span class="title">subfuc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="keyword">co_await</span> std::<span class="built_in">async</span>(awaitfuc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;return 100\n&quot;</span>, p.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : <span class="built_in">foo</span>()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">subfuc</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调试器是怎么匹配程序的符号文件的</title>
      <link href="/2017/09/18/How-does-the-debugger-match-the-symbol-file/"/>
      <url>/2017/09/18/How-does-the-debugger-match-the-symbol-file/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>微软的天才软件工程师们设计的PE（Portable Executable）文件数据结构有极强的扩展性和兼容性。我们关心的符号文件信息存储在PE结构中，一个叫做Debug Directory的节里。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; !dh -f ntdll</span><br><span class="line"></span><br><span class="line">File Type: DLL</span><br><span class="line">FILE HEADER VALUES</span><br><span class="line">    8664 machine (X64)</span><br><span class="line">       7 number of sections</span><br><span class="line">590296CE time date stamp Thu Apr 27 18:11:42 2017</span><br><span class="line"></span><br><span class="line">       0 file pointer to symbol table</span><br><span class="line">       0 number of symbols</span><br><span class="line">      F0 size of optional header</span><br><span class="line">    2022 characteristics</span><br><span class="line">            Executable</span><br><span class="line">            App can handle &gt;2gb addresses</span><br><span class="line">            DLL</span><br><span class="line"></span><br><span class="line">OPTIONAL HEADER VALUES</span><br><span class="line">     20B magic #</span><br><span class="line">    9.00 linker version</span><br><span class="line">   FB800 size of code</span><br><span class="line">   A9600 size of initialized data</span><br><span class="line">       0 size of uninitialized data</span><br><span class="line">       0 address of entry point</span><br><span class="line">    1000 base of code</span><br><span class="line">         ----- new -----</span><br><span class="line">00000000774e0000 image base</span><br><span class="line">    1000 section alignment</span><br><span class="line">     200 file alignment</span><br><span class="line">       3 subsystem (Windows CUI)</span><br><span class="line">    6.01 operating system version</span><br><span class="line">    6.01 image version</span><br><span class="line">    6.01 subsystem version</span><br><span class="line">  1AA000 size of image</span><br><span class="line">     400 size of headers</span><br><span class="line">  1B5DB0 checksum</span><br><span class="line">0000000000040000 size of stack reserve</span><br><span class="line">0000000000001000 size of stack commit</span><br><span class="line">0000000000100000 size of heap reserve</span><br><span class="line">0000000000001000 size of heap commit</span><br><span class="line">     140  DLL characteristics</span><br><span class="line">            Dynamic base</span><br><span class="line">            NX compatible</span><br><span class="line">  101200 [    F1A3] address [size] of Export Directory</span><br><span class="line">       0 [       0] address [size] of Import Directory</span><br><span class="line">  14E000 [   5A028] address [size] of Resource Directory</span><br><span class="line">  13B000 [   127EC] address [size] of Exception Directory</span><br><span class="line">  1A2E00 [    4300] address [size] of Security Directory</span><br><span class="line">  1A9000 [     4E8] address [size] of Base Relocation Directory</span><br><span class="line">   FC58C [      38] address [size] of Debug Directory</span><br><span class="line">       0 [       0] address [size] of Description Directory</span><br><span class="line">       0 [       0] address [size] of Special Directory</span><br><span class="line">       0 [       0] address [size] of Thread Storage Directory</span><br><span class="line">       0 [       0] address [size] of Load Configuration Directory</span><br><span class="line">       0 [       0] address [size] of Bound Import Directory</span><br><span class="line">       0 [       0] address [size] of Import Address Table Directory</span><br><span class="line">       0 [       0] address [size] of Delay Import Directory</span><br><span class="line">       0 [       0] address [size] of COR20 Header Directory</span><br><span class="line">       0 [       0] address [size] of Reserved Directory</span><br><span class="line">       </span><br></pre></td></tr></table></figure><p>使用!dh命令可以显示PE文件的关键信息，这里可以看到Debug Directory的偏移地址是FC58C，大小是38个字节，其对应结构体是_IMAGE_DEBUG_DIRECTORY。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DEBUG_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Type;</span><br><span class="line">    DWORD   SizeOfData;</span><br><span class="line">    DWORD   AddressOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">&#125; IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_UNKNOWN          0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_COFF             1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_CODEVIEW         2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_FPO              3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_MISC             4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_EXCEPTION        5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_FIXUP            6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_OMAP_TO_SRC      7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_OMAP_FROM_SRC    8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_BORLAND          9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_RESERVED10       10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DEBUG_TYPE_CLSID            11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; dt ntdll+FC58C ole32!_IMAGE_DEBUG_DIRECTORY</span><br><span class="line">   +0x000 Characteristics  : 0</span><br><span class="line">   +0x004 TimeDateStamp    : 0x590288a9</span><br><span class="line">   +0x008 MajorVersion     : 0</span><br><span class="line">   +0x00a MinorVersion     : 0</span><br><span class="line">   +0x00c Type             : 2</span><br><span class="line">   +0x010 SizeOfData       : 0x22</span><br><span class="line">   +0x014 AddressOfRawData : 0xfc5c8</span><br><span class="line">   +0x018 PointerToRawData : 0xfb9c8</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>需要注意的是这三个数据成员，Type，SizeOfData以及AddressOfRawData。其中Type是Debug数据类型，SizeOfData是数据大小，AddressOfRawData是数据对应的内存地址。通过dt命令，可以查看结构体和数据的对应关系。从上面的输出可知Debug数据类型是CODEVIEW，数据大小是0x22个字节，数据的内存偏移是0xfc5c8。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; db ntdll+0xfc5c8</span><br><span class="line">00000000&#96;775dc5c8  52 53 44 53 49 7b 4d 74-81 7b 0c 47 a2 d8 a8 d2  RSDSI&#123;Mt.&#123;.G....</span><br><span class="line">00000000&#96;775dc5d8  62 fc 8a 29 02 00 00 00-6e 74 64 6c 6c 2e 70 64  b..)....ntdll.pd</span><br><span class="line">00000000&#96;775dc5e8  62 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  b...............</span><br><span class="line">00000000&#96;775dc5f8  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000000&#96;775dc608  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000000&#96;775dc618  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000000&#96;775dc628  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000000&#96;775dc638  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用db命令查看这部分数据，我们可以发现ntdll.pdb的字符串。实际上，通过type已经知道了Debug数据类型是CODEVIEW，这样就可以确定数据的结构体是：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CV_INFO_PDB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  DWORD  CvSignature;</span><br><span class="line">  GUID Signature;</span><br><span class="line">  DWORD Age;</span><br><span class="line">  BYTE PdbFileName[];</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; dt _guid ntdll+0xfc5c8+4</span><br><span class="line">ntdll!_GUID</span><br><span class="line"> &#123;744d7b49-7b81-470c-a2d8-a8d262fc8a29&#125;</span><br><span class="line">   +0x000 Data1            : 0x744d7b49</span><br><span class="line">   +0x004 Data2            : 0x7b81</span><br><span class="line">   +0x006 Data3            : 0x470c</span><br><span class="line">   +0x008 Data4            : [8]  &quot;???&quot;</span><br><span class="line">可以看到CvSignature &#x3D; “RSDS”， Signature &#x3D; &#123;744d7b49-7b81-470c-a2d8-a8d262fc8a29&#125;，Age &#x3D; 2，PdbFileName&#x3D;“ntdll.pdb”。</span><br><span class="line"></span><br><span class="line">0:000&gt; !lmi ntdll</span><br><span class="line">Loaded Module Info: [ntdll] </span><br><span class="line">         Module: ntdll</span><br><span class="line">   Base Address: 00000000774e0000</span><br><span class="line">     Image Name: ntdll.dll</span><br><span class="line">   Machine Type: 34404 (X64)</span><br><span class="line">     Time Stamp: 590296ce Thu Apr 27 18:11:42 2017</span><br><span class="line">           Size: 1aa000</span><br><span class="line">       CheckSum: 1b5db0</span><br><span class="line">Characteristics: 2022  perf</span><br><span class="line">Debug Data Dirs: Type  Size     VA  Pointer</span><br><span class="line">             CODEVIEW    22, fc5c8,   fb9c8 RSDS - GUID: &#123;744D7B49-7B81-470C-A2D8-A8D262FC8A29&#125;</span><br><span class="line">               Age: 2, Pdb: ntdll.pdb</span><br><span class="line">                CLSID     4, fc5c4,   fb9c4 [Data not mapped]</span><br><span class="line">     Image Type: FILE     - Image read successfully from debugger.</span><br><span class="line">                 C:\Windows\SYSTEM32\ntdll.dll</span><br><span class="line">    Symbol Type: PDB      - Symbols loaded successfully from image path.</span><br><span class="line">                 d:\symbols\ntdll.pdb\744D7B497B81470CA2D8A8D262FC8A292\ntdll.pdb</span><br><span class="line">    Load Report: public symbols , not source indexed </span><br><span class="line">                 d:\symbols\ntdll.pdb\744D7B497B81470CA2D8A8D262FC8A292\ntdll.pdb</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再来看看Windbg匹配ntdll.pdb的真实路径，d:\symbols\ntdll.pdb\744D7B497B81470CA2D8A8D262FC8A292\ntdll.pdb。对比一下就可以发现其中的奥秘。原来Windbg识别执行程序的PDB路径是依赖guid，age和PdbFileName。具体来说就是 {符号设置路径}{PdbFileName}{guid}{age}{PdbFileName}。<br>如果想写程序获取这些信息并不需要像上面那样解析PE文件结构，实际上微软给我们提供了这方面的支持，在dbghelp.dll里导出了一个叫做SymSrvGetFileIndexInfo的函数，这个函数获得的SYMSRV_INDEX_INFO结构中，就包含以上我们需要的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试math-plugin</title>
      <link href="/2017/08/17/test-math-plugin/"/>
      <url>/2017/08/17/test-math-plugin/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Inline"><a href="#Inline" class="headerlink" title="Inline"></a>Inline</h2><p>Simple inline \(a = b + c\).</p><p>This equation \(\cos 2\theta = \cos^2 \theta - \sin^2 \theta =  2 \cos^2 \theta - 1 \) is inline.</p><h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>$$\frac{\partial u}{\partial t}<br>= h^2 \left( \frac{\partial^2 u}{\partial x^2} +<br>\frac{\partial^2 u}{\partial y^2} +<br>\frac{\partial^2 u}{\partial z^2}\right)$$</p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -3.507ex" xmlns="http://www.w3.org/2000/svg" width="15.761ex" height="8.145ex" role="img" focusable="false" viewBox="0 -2050 6966.4 3600" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-2D9" d="M190 609Q190 637 208 653T252 669Q275 667 292 652T309 609Q309 579 292 564T250 549Q225 549 208 564T190 609Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-I-1D70C" d="M58 -216Q25 -216 23 -186Q23 -176 73 26T127 234Q143 289 182 341Q252 427 341 441Q343 441 349 441T359 442Q432 442 471 394T510 276Q510 219 486 165T425 74T345 13T266 -10H255H248Q197 -10 165 35L160 41L133 -71Q108 -168 104 -181T92 -202Q76 -216 58 -216ZM424 322Q424 359 407 382T357 405Q322 405 287 376T231 300Q217 269 193 170L176 102Q193 26 260 26Q298 26 334 62Q367 92 389 158T418 266T424 322Z"></path><path id="MJX-1-TEX-I-1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path><path id="MJX-1-TEX-I-1D6FD" d="M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mtable"><g data-mml-node="mtr" transform="translate(0, 1300)"><g data-mml-node="mtd"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(63.8, -47)"><use xlink:href="#MJX-1-TEX-N-2D9"></use></g></g></g></g><g data-mml-node="mtd" transform="translate(572, 0)"><g data-mml-node="mi"></g><g data-mml-node="mo" transform="translate(277.8, 0)"><use xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(1333.6, 0)"><use xlink:href="#MJX-1-TEX-I-1D70E"></use></g><g data-mml-node="mo" transform="translate(1904.6, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(2293.6, 0)"><use xlink:href="#MJX-1-TEX-I-1D466"></use></g><g data-mml-node="mo" transform="translate(3005.8, 0)"><use xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(4006, 0)"><use xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(4578, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g><g data-mml-node="mtr" transform="translate(0, 0)"><g data-mml-node="mtd" transform="translate(16.4, 0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi" transform="translate(5, 0)"><use xlink:href="#MJX-1-TEX-I-1D466"></use></g><g data-mml-node="mo" transform="translate(55.6, -47)"><use xlink:href="#MJX-1-TEX-N-2D9"></use></g></g></g></g><g data-mml-node="mtd" transform="translate(572, 0)"><g data-mml-node="mi"></g><g data-mml-node="mo" transform="translate(277.8, 0)"><use xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(1333.6, 0)"><use xlink:href="#MJX-1-TEX-I-1D70C"></use></g><g data-mml-node="mi" transform="translate(1850.6, 0)"><use xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(2644.8, 0)"><use xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(3645, 0)"><use xlink:href="#MJX-1-TEX-I-1D466"></use></g><g data-mml-node="mo" transform="translate(4357.2, 0)"><use xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(5357.4, 0)"><use xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(5929.4, 0)"><use xlink:href="#MJX-1-TEX-I-1D467"></use></g></g></g><g data-mml-node="mtr" transform="translate(0, -1300)"><g data-mml-node="mtd" transform="translate(16.4, 0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi" transform="translate(17.5, 0)"><use xlink:href="#MJX-1-TEX-I-1D467"></use></g><g data-mml-node="mo" transform="translate(55.6, -47)"><use xlink:href="#MJX-1-TEX-N-2D9"></use></g></g></g></g><g data-mml-node="mtd" transform="translate(572, 0)"><g data-mml-node="mi"></g><g data-mml-node="mo" transform="translate(277.8, 0)"><use xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(1333.6, 0)"><use xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(2111.6, 0)"><use xlink:href="#MJX-1-TEX-I-1D6FD"></use></g><g data-mml-node="mi" transform="translate(2677.6, 0)"><use xlink:href="#MJX-1-TEX-I-1D467"></use></g><g data-mml-node="mo" transform="translate(3364.8, 0)"><use xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(4365, 0)"><use xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(4937, 0)"><use xlink:href="#MJX-1-TEX-I-1D466"></use></g></g></g></g></g></g></svg></mjx-container>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试COM的一个tip</title>
      <link href="/2017/07/09/tip-about-com/"/>
      <url>/2017/07/09/tip-about-com/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近遇到朋友的一个程序崩溃，原因是接口没有释放的时候调用了CoUninitialize，接着才释放接口。这个应该是个很明显的问题，但是朋友告诉我以前代码就是这个样子的，没有崩溃过，最近修改了部分代码但并不是这一块的。为了看看究竟什么回事，我把没有崩溃的程序抓了dump，看了COM的初始化引用计数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; dt _teb @$teb ReservedForOle</span><br><span class="line">ntdll!_TEB</span><br><span class="line">   +0x1758 ReservedForOle : 0x00000000&#96;00271b00 Void</span><br><span class="line"></span><br><span class="line">0:000&gt; dt ole32!SOleTlsData 0x00000000&#96;00271b00 cComInits pNativeApt</span><br><span class="line">   +0x028 cComInits  : 5</span><br><span class="line">   +0x080 pNativeApt : 0x00000000&#96;00272680 CComApartment</span><br><span class="line">   </span><br><span class="line">0:000&gt; dt 0x00000000&#96;00272680 CComApartment _AptKind</span><br><span class="line">ole32!CComApartment</span><br><span class="line">   +0x010 _AptKind : 4 ( APTKIND_APARTMENTTHREADED )</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>没有崩溃的时候，引用计数确实不为0，也能看出是个STA。后来朋友发现，之所以之前没有崩溃，是因为之前线程加载的某个dll中，有初始化COM的调用，所以引用计数不为0。后来移开了这个dll，问题就出现了。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gotcha sdk 文件监控功能更新</title>
      <link href="/2017/07/02/gotcha-sdk-monitor-update/"/>
      <url>/2017/07/02/gotcha-sdk-monitor-update/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在15年的一篇blog中，我介绍了gotcha sdk。<a href="/2015/11/24/gotcha-sdk/" title="gotcha sdk 全盘文件名搜索开发库">gotcha sdk 全盘文件名搜索开发库</a></p><p>当时gotcha sdk没有提供文件监控功能，也就是说当搜索文件发生变化的时候，这个变化不会体现到搜索结果列表中。其实这个功能一直在todo list中，只不过忙的时候没时间写这部分代码，闲的时候又忘了。前几天终于有时间把这部分代码补上，升级了sdk。</p><p>gotcha sdk 代码SVN:<br><a href="http://code.taobao.org/svn/gotcha_sdk/">http://code.taobao.org/svn/gotcha_sdk/</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>切换到session 0</title>
      <link href="/2017/06/25/switch-to-session-0/"/>
      <url>/2017/06/25/switch-to-session-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是一个小技巧，可以帮助我们从session 1切换到session 0，并且获得system权限。有了system权限，可以做一些admin做不了的事情，具体哪些事情大伙可以自己挖掘。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">切换到session 0：    rundll32 winsta.dll WinStationSwitchToServicesSession</span><br><span class="line">切换会原session：    rundll32 winsta.dll WinStationRevertFromServicesSession</span><br></pre></td></tr></table></figure><p>但是如果直接切换到session 0，会发现一个问题，我们没有桌面程序，所以什么事情也做不了。解决方法也很简单，创建一个explorer就可以了。但是普通方法创建explorer，怎么会不能创建到session 0，于是这里可想而知，我们需要一个服务来创建explorer。专门写一个服务程序未免太麻烦，这里可以使用cmd来快速创建explorer。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc create desktop0 binpath&#x3D; &quot;cmd &#x2F;c start explorer.exe&quot; type&#x3D; own type&#x3D; interact</span><br><span class="line">net start desktop0</span><br></pre></td></tr></table></figure><p>虽然cmd不是服务，但是也会被运行起来，只不过不能与服务管理器交互，所以在超时的时候会被结束。不过那个时候已经没关系了，因为explorer已经创建起来了。接下来就可以切换了session 0，用system权限管理电脑了。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0cchext插件实用命令dttoc</title>
      <link href="/2017/05/02/0cchext-dttoc-command/"/>
      <url>/2017/05/02/0cchext-dttoc-command/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近给<a href="https://github.com/0cch/0cchext/releases/tag/1.0.16.3.55">0cchext</a>添加了一个实用的逆向命令，dttoc，这个命令可以把dt命令输出的结构体转化为C的结构，方便我们做逆向还原工作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !0cchext.dttoc nt!_peb</span><br><span class="line">struct _PEB &#123;</span><br><span class="line">    BYTE InheritedAddressSpace;</span><br><span class="line">    BYTE ReadImageFileExecOptions;</span><br><span class="line">    BYTE BeingDebugged;</span><br><span class="line">    union &#123;</span><br><span class="line">        BYTE BitField;</span><br><span class="line">        struct &#123;</span><br><span class="line">            BYTE ImageUsesLargePages:1;</span><br><span class="line">            BYTE IsProtectedProcess:1;</span><br><span class="line">            BYTE IsImageDynamicallyRelocated:1;</span><br><span class="line">            BYTE SkipPatchingUser32Forwarders:1;</span><br><span class="line">            BYTE IsPackagedProcess:1;</span><br><span class="line">            BYTE IsAppContainer:1;</span><br><span class="line">            BYTE IsProtectedProcessLight:1;</span><br><span class="line">            BYTE IsLongPathAwareProcess:1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Mutant;</span><br><span class="line">    VOID* ImageBaseAddress;</span><br><span class="line">    _PEB_LDR_DATA* Ldr;</span><br><span class="line">    _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;</span><br><span class="line">    VOID* SubSystemData;</span><br><span class="line">    VOID* ProcessHeap;</span><br><span class="line">    _RTL_CRITICAL_SECTION* FastPebLock;</span><br><span class="line">    _SLIST_HEADER* AtlThunkSListPtr;</span><br><span class="line">    VOID* IFEOKey;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD CrossProcessFlags;</span><br><span class="line">        struct &#123;</span><br><span class="line">            DWORD ProcessInJob:1;</span><br><span class="line">            DWORD ProcessInitializing:1;</span><br><span class="line">            DWORD ProcessUsingVEH:1;</span><br><span class="line">            DWORD ProcessUsingVCH:1;</span><br><span class="line">            DWORD ProcessUsingFTH:1;</span><br><span class="line">            DWORD ReservedBits0:27;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    union &#123;</span><br><span class="line">        VOID* KernelCallbackTable;</span><br><span class="line">        VOID* UserSharedInfoPtr;</span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD SystemReserved[1];</span><br><span class="line">    _SLIST_HEADER* AtlThunkSListPtr32;</span><br><span class="line">    VOID* ApiSetMap;</span><br><span class="line">    DWORD TlsExpansionCounter;</span><br><span class="line">    VOID* TlsBitmap;</span><br><span class="line">    DWORD TlsBitmapBits[2];</span><br><span class="line">    VOID* ReadOnlySharedMemoryBase;</span><br><span class="line">    VOID* SparePvoid0;</span><br><span class="line">    VOID** ReadOnlyStaticServerData;</span><br><span class="line">    VOID* AnsiCodePageData;</span><br><span class="line">    VOID* OemCodePageData;</span><br><span class="line">    VOID* UnicodeCaseTableData;</span><br><span class="line">    DWORD NumberOfProcessors;</span><br><span class="line">    DWORD NtGlobalFlag;</span><br><span class="line">    _LARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">    DWORD HeapSegmentReserve;</span><br><span class="line">    DWORD HeapSegmentCommit;</span><br><span class="line">    DWORD HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    DWORD HeapDeCommitFreeBlockThreshold;</span><br><span class="line">    DWORD NumberOfHeaps;</span><br><span class="line">    DWORD MaximumNumberOfHeaps;</span><br><span class="line">    VOID** ProcessHeaps;</span><br><span class="line">    VOID* GdiSharedHandleTable;</span><br><span class="line">    VOID* ProcessStarterHelper;</span><br><span class="line">    DWORD GdiDCAttributeList;</span><br><span class="line">    _RTL_CRITICAL_SECTION* LoaderLock;</span><br><span class="line">    DWORD OSMajorVersion;</span><br><span class="line">    DWORD OSMinorVersion;</span><br><span class="line">    WORD OSBuildNumber;</span><br><span class="line">    WORD OSCSDVersion;</span><br><span class="line">    DWORD OSPlatformId;</span><br><span class="line">    DWORD ImageSubsystem;</span><br><span class="line">    DWORD ImageSubsystemMajorVersion;</span><br><span class="line">    DWORD ImageSubsystemMinorVersion;</span><br><span class="line">    DWORD ActiveProcessAffinityMask;</span><br><span class="line">    DWORD GdiHandleBuffer[34];</span><br><span class="line">    void* PostProcessInitRoutine;</span><br><span class="line">    VOID* TlsExpansionBitmap;</span><br><span class="line">    DWORD TlsExpansionBitmapBits[32];</span><br><span class="line">    DWORD SessionId;</span><br><span class="line">    _ULARGE_INTEGER AppCompatFlags;</span><br><span class="line">    _ULARGE_INTEGER AppCompatFlagsUser;</span><br><span class="line">    VOID* pShimData;</span><br><span class="line">    VOID* AppCompatInfo;</span><br><span class="line">    _UNICODE_STRING CSDVersion;</span><br><span class="line">    _ACTIVATION_CONTEXT_DATA* ActivationContextData;</span><br><span class="line">    _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;</span><br><span class="line">    _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;</span><br><span class="line">    _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;</span><br><span class="line">    DWORD MinimumStackCommit;</span><br><span class="line">    _FLS_CALLBACK_INFO* FlsCallback;</span><br><span class="line">    _LIST_ENTRY FlsListHead;</span><br><span class="line">    VOID* FlsBitmap;</span><br><span class="line">    DWORD FlsBitmapBits[4];</span><br><span class="line">    DWORD FlsHighIndex;</span><br><span class="line">    VOID* WerRegistrationData;</span><br><span class="line">    VOID* WerShipAssertPtr;</span><br><span class="line">    VOID* pUnused;</span><br><span class="line">    VOID* pImageHeaderHash;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD TracingFlags;</span><br><span class="line">        struct &#123;</span><br><span class="line">            QWORD HeapTracingEnabled:1;</span><br><span class="line">            QWORD CritSecTracingEnabled:1;</span><br><span class="line">            QWORD LibLoaderTracingEnabled:1;</span><br><span class="line">            QWORD SpareTracingBits:29;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    QWORD CsrServerReadOnlySharedMemoryBase;</span><br><span class="line">    DWORD TppWorkerpListLock;</span><br><span class="line">    _LIST_ENTRY TppWorkerpList;</span><br><span class="line">    VOID* WaitOnAddressHashTable[128];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Delphi异常0EEDFADE</title>
      <link href="/2017/04/04/delphi-exception/"/>
      <url>/2017/04/04/delphi-exception/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>0EEDFADE是Delphi内部异常代码，该异常通常有7个参数，我们用的上的是第二个参数，这个参数指向的是Exception的对象，通过这个对象，我们就可以查出异常的一些信息。</p><p>以Delphi XE2为例,Class name的偏移为（不同的版本偏移有所不同）：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x86_vmtClassName &#x3D; -56(0x38);</span><br><span class="line">x64_vmtClassName &#x3D; -112(0x70);</span><br></pre></td></tr></table></figure><p>我们可以用如下命令获取相关信息：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x86: da poi(poi(exception_object)-38)+1;du &#x2F;c 100 poi(exception_object+4)  </span><br><span class="line">x64: da poi(poi(exception_object)-70)+1;du &#x2F;c 100 poi(exception_object+8)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上命令就能获取异常的类名，而exception_object+sizeof(pointer)则是Exception Message的所在偏移，这是一个unicode string。实际效果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:002&gt; da poi(poi(003a2800)-38)+1;du &#x2F;c 100 poi(003a2800 +4)</span><br><span class="line">00b9ec47  &quot;TTransportExceptionUnknown&quot;</span><br><span class="line">00375b8c  &quot;ServerTransport.Accept() may not return NULL&quot;</span><br></pre></td></tr></table></figure><p>当然，我们也可以设置event filter去截获异常：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x86: sxe -c &quot;da poi(poi(poi(@ebp+1c))-38)+1;du &#x2F;c 100 poi(poi(@ebp+1c)+4)&quot; 0EEDFADE</span><br><span class="line">x64: sxe -c &quot;da poi(poi(poi(@rbp+48))-70)+1;du &#x2F;c 100 poi(poi(@rbp+48)+8)&quot; 0EEDFADE</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10设置系统DPI</title>
      <link href="/2017/03/08/set-dpi/"/>
      <url>/2017/03/08/set-dpi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>现在的显示器分辨率越来越高2K，4K甚至5K，而很多程序并不支持这一的高分辨率，所以这些程序在桌面上会显示的很小，好在Windows 8以后的系统中，我们可以设置DPI来放大程序的窗口，如下图所示：  </p><p><a href="/uploads/2017/03/20170309145111.png"><img src="/uploads/2017/03/20170309145111.png" alt="20170309145111"></a></p><p>但是，微软并没有把设置DPI的接口文档化。所以我把这个功能逆了一下，还原的代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BOOL ApplyDpiSetting(int val);</span></span><br><span class="line"><span class="comment">val 为DPI要设置的数字，例如0是100%，1是125%，以此类推，注意250%以后是300%。</span></span><br><span class="line"><span class="comment">另外上面的对应关系只是通常情况下的，还有可能有其他对应关系，例如0是300%，-1是250%等等。</span></span><br><span class="line"><span class="comment">具体怎么对应可以通过GetDpiForMonitor函数来获取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SET_DPI</span> &#123;</span></span><br><span class="line">    DISPLAYCONFIG_DEVICE_INFO_HEADER header;</span><br><span class="line">    ULONG val;</span><br><span class="line">&#125; SET_DPI;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ApplyDpiSetting</span><span class="params">(ULONG val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT32 num_of_paths = <span class="number">0</span>;</span><br><span class="line">    UINT32 num_of_modes = <span class="number">0</span>;</span><br><span class="line">    DISPLAYCONFIG_PATH_INFO* display_paths = <span class="literal">NULL</span>; </span><br><span class="line">    DISPLAYCONFIG_MODE_INFO* display_modes = <span class="literal">NULL</span>;</span><br><span class="line">    BOOL retval = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetDisplayConfigBufferSizes</span>(QDC_ONLY_ACTIVE_PATHS, </span><br><span class="line">            &amp;num_of_paths, </span><br><span class="line">            &amp;num_of_modes) != ERROR_SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        display_paths = (DISPLAYCONFIG_PATH_INFO*)<span class="built_in">calloc</span>((<span class="keyword">int</span>)num_of_paths, <span class="built_in"><span class="keyword">sizeof</span></span>(DISPLAYCONFIG_PATH_INFO));</span><br><span class="line">        display_modes = (DISPLAYCONFIG_MODE_INFO*)<span class="built_in">calloc</span>((<span class="keyword">int</span>)num_of_modes, <span class="built_in"><span class="keyword">sizeof</span></span>(DISPLAYCONFIG_MODE_INFO));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">QueryDisplayConfig</span>(QDC_ONLY_ACTIVE_PATHS, </span><br><span class="line">            &amp;num_of_paths, </span><br><span class="line">            display_paths, </span><br><span class="line">            &amp;num_of_modes, </span><br><span class="line">            display_modes, </span><br><span class="line">            <span class="literal">NULL</span>) != ERROR_SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SET_DPI dpi;</span><br><span class="line">        dpi.header.type = (DISPLAYCONFIG_DEVICE_INFO_TYPE)<span class="number">0xFFFFFFFC</span>;</span><br><span class="line">        dpi.header.size = <span class="built_in"><span class="keyword">sizeof</span></span>(dpi);</span><br><span class="line">        dpi.header.adapterId = display_paths[<span class="number">0</span>].sourceInfo.adapterId;</span><br><span class="line">        dpi.header.id = display_paths[<span class="number">0</span>].sourceInfo.id;</span><br><span class="line">        dpi.val = val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">DisplayConfigSetDeviceInfo</span>((DISPLAYCONFIG_DEVICE_INFO_HEADER*)&amp;dpi) == ERROR_SUCCESS) &#123;</span><br><span class="line">            retval = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (display_paths) &#123;</span><br><span class="line">        <span class="built_in">free</span>(display_paths);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (display_modes) &#123;</span><br><span class="line">        <span class="built_in">free</span>(display_modes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>让编译器不推荐(deprecate)使用一个函数</title>
      <link href="/2017/02/12/deprecate-a-function/"/>
      <url>/2017/02/12/deprecate-a-function/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在开发一些公共库函数的时候，我们常常会对函数进行改写，这个时候我们会希望使用者用新的函数。为了提醒使用者，我们可以通过将函数声明为deprecated，这样编译器在编译的时候会抛出一个C4995或者C4996的警告。这个警告我们应该也经常看到过，比如使用strcpy，编译器会提示我们使用strcpy_s。  </p><p>使用这个编译器特性有两种方法：  </p><ol><li>__declspec(deprecated)</li><li>#pragma deprecated</li></ol><ul><li>__declspec(deprecated)<br><a href="https://msdn.microsoft.com/en-us/library/044swk7y.aspx">https://msdn.microsoft.com/en-us/library/044swk7y.aspx</a><br>这种方法直接声明在函数或者类之前，在使用函数的地方会抛出C4996的警告  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__declspec(deprecated) void func1(int) &#123;&#125;  </span><br></pre></td></tr></table></figure>当然我们还可以给警告自定义消息信息  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__declspec(deprecated(&quot;** this is a deprecated function **&quot;)) void func2(int) &#123;&#125;  </span><br></pre></td></tr></table></figure></li></ul><ul><li>#pragma deprecated<br><a href="https://msdn.microsoft.com/en-us/library/c8xdzzhh.aspx">https://msdn.microsoft.com/en-us/library/c8xdzzhh.aspx</a><br>这种方法可以一次性声明多个函数或者类，使用函数的地方会抛出C4995的警告  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma deprecated(func1, func2)  </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PDB 下载工具</title>
      <link href="/2017/01/02/pdbdownloader/"/>
      <url>/2017/01/02/pdbdownloader/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前段时间微软的符号服务器特别不稳定，Windbg下载符号文件老是失败，所以就专门写了个pdb的下载工具(<a href="https://github.com/0cch/pdbdownloader">pdbdownloader</a>)放到Github上。  </p><p>P.S. 用WPF写界面确实是很有趣  </p><p><a href="/uploads/2017/01/20170103120319.png"><img src="/uploads/2017/01/20170103120319.png" alt="20170103120319"></a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速抛出失败的方法 INT 29H</title>
      <link href="/2016/12/13/int29h/"/>
      <url>/2016/12/13/int29h/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>从Windows8开始，Windows设计了一个新的中断，INT 29H，用来快速的抛出失败。在sdk中，他被声明为 __fastfail:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_LEGACY_GS_VIOLATION          0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_VTGUARD_CHECK_FAILURE        1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_STACK_COOKIE_CHECK_FAILURE   2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_CORRUPT_LIST_ENTRY           3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INCORRECT_STACK              4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_ARG                  5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_GS_COOKIE_INIT               6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_FATAL_APP_EXIT               7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_RANGE_CHECK_FAILURE          8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_UNSAFE_REGISTRY_ACCESS       9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_GUARD_ICALL_CHECK_FAILURE    10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_GUARD_WRITE_CHECK_FAILURE    11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_FIBER_SWITCH         12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_SET_OF_CONTEXT       13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_REFERENCE_COUNT      14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_JUMP_BUFFER          18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_MRDATA_MODIFIED              19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_CERTIFICATION_FAILURE        20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_EXCEPTION_CHAIN      21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_CRYPTO_LIBRARY               22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT  23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_IMAGE_BASE           24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_DLOAD_PROTECTION_FAILURE     25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_UNSAFE_EXTENSION_CALL        26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_DEPRECATED_SERVICE_INVOKED   27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_BUFFER_ACCESS        28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_BALANCED_TREE        29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_NEXT_THREAD          30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED 31         <span class="comment">// Telemetry, nonfatal</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_APCS_DISABLED                32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_IDLE_STATE           33</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_MRDATA_PROTECTION_FAILURE    34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION    35</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_FAIL_INVALID_FAST_FAIL_CODE       0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _MSC_VER &gt;= 1610</span></span><br><span class="line"></span><br><span class="line">DECLSPEC_NORETURN</span><br><span class="line">VOID</span><br><span class="line">__fastfail(</span><br><span class="line">    _In_ <span class="keyword">unsigned</span> <span class="keyword">int</span> Code</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> intrinsic(__fastfail)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 汇编代码为</span></span><br><span class="line"><span class="comment">mov ecx, code</span></span><br><span class="line"><span class="comment">int 29h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在中断代码执行后，操作系统会根据执行代码的环境来做出不同的处理。<br>如果__fastfail发生在Ring0中，操作系统会抛出一个KERNEL_SECURITY_CHECK_FAILURE (0x139)的蓝屏。如果__fastfail发生在Ring3，系统会抛出一个第二次机会的不可继续执行的异常，异常代码为0xC0000409，然后走进我们熟悉的Windows Error Reporting(WER)流程。另外，无论__fastfail发生在R0或者R3，如果有调试器正在调试系统或进程，都将得到一次中断到调试器的机会，这让我们能够看清楚具体发生了什么事情。但是正如我上面所说，这个是一个不可继续执行的异常，所以我们不能在调试器里处理了异常后让程序继续向前跑，当然也不能用try和except去捕获异常。</p><p>我觉得__fastfail是个非常不错的设计，它让程序可以快速的进入内核异常处理流程，不需要执行额外的用户层的代码，也不需要额外的内存空间，提高了不可恢复的异常处理的性能，更重要的是，简单快速不依赖内存的执行方式也保证了系统的安全。所以在系统的安全检查失败处理中，大量使用了这个方式，减少被攻击的可能性。</p><p>最后，如果INT 29H发生在Windows8以下的系统上，内核里会抛出一个常规的UNEXPECTED_KERNEL_MODE_TRAP的蓝屏，而用户层程序会抛出一个ACCESS VIOLATION的异常。</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windbg的lua脚本扩展luadbg</title>
      <link href="/2016/11/15/luadbg-windbg-ext/"/>
      <url>/2016/11/15/luadbg-windbg-ext/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>2012年的时候，我在blog上写到过开发了一个windbg的lua扩展<a href="https://0cch.com/debugging/2012/08/16/dbglua-ef-bc-8c-e8-ae-a9lua-e8-84-9a-e6-9c-ac-e4-b9-9f-e8-83-bd-e6-8e-a7-e5-88-b6windbg-e8-bf-9b-e8-a1-8c-e8-b0-83-e8-af-95.html">dbglua</a>，当时觉得windbg的原生脚本语法太奇怪了，而且太不容易使用。现在来看，依旧如此，只不过我已经很熟悉这个原生脚本了。而这个lua扩展反倒是没什么用，因为用起来也不太方便，比如访问结构体。</p><p>最近无意之中看了一眼pykd，他用重载.操作符的方式访问符号和结构体深深的吸引了我，感觉非常有趣。而python本身依赖比较多，这也促使我拿起之前的代码看了看，并且决定在github上重新建立这个项目叫做<a href="https://github.com/0cch/luadbg">luadbg</a>，这次我决定长期维护这个项目，想到新的功能就往里面写，就像我一直维护的<a href="https://github.com/0cch/0cchext">0cchext</a>一样。luadbg除了兼容了老dbglua的函数以外，还添加了几个我觉得很方便的类，主要是用重载.操作符的方式来访问模块和结构体的数据，效果如下图所示：</p><p><a href="/uploads/2016/11/20161116113129.png"><img src="/uploads/2016/11/20161116113129.png" alt="20161116113129"></a></p><p>当然，也可以用!luacmd命令进入input模式，从而一条一条的输入语句来测试正确性。</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译时自动增加build number</title>
      <link href="/2016/10/18/auto-increase-build-number/"/>
      <url>/2016/10/18/auto-increase-build-number/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近和朋友讨论版本号常用的几种规范，前三位&lt;主版本&gt;.&lt;子版本&gt;.&lt;修正版本&gt;基本上一致，不需要详说。主要区别产生在最后一位，有的是build number，有的是时间日期，还有的是git或者svn的revision。我习惯用build number，每次编译都会增加版本号最后一位的数字。但是手动去修改明显不科学也不可靠，所以给和我有一样习惯的朋友分享一个我早年写的python脚本，无论是自己的工具还是公司的产品我一直都在用这个。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法就是在VS的工程属性Build Event -&gt; Pre Build Event里设置x:\incbuildnum.py $(ProjectDir)$(ProjectName).rc。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.isfile(sys.argv[<span class="number">1</span>] + <span class="string">&quot;.bak&quot;</span>):</span><br><span class="line">    os.remove(sys.argv[<span class="number">1</span>] + <span class="string">&quot;.bak&quot;</span>)</span><br><span class="line">shutil.copy(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">1</span>] + <span class="string">&quot;.bak&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">1</span>], <span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> content_file:</span><br><span class="line">    content = content_file.read()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    m = re.search(<span class="string">&quot;VALUE \&quot;FileVersion\&quot;, \&quot;(([\\d]+).[ ]*)*([\\d]+)\&quot;&quot;</span>, content)</span><br><span class="line">    new_ver = <span class="built_in">str</span>(<span class="built_in">int</span>(m.group(<span class="number">3</span>)) + <span class="number">1</span>)</span><br><span class="line">    content = re.sub(<span class="string">&quot;(VALUE \&quot;FileVersion\&quot;, \&quot;([\\d]+.[ ]*)*)[\\d]+\&quot;&quot;</span>, <span class="string">&quot;\\g&lt;1&gt;&quot;</span> + new_ver + <span class="string">&quot;\&quot;&quot;</span>, content)</span><br><span class="line"></span><br><span class="line">    m = re.search(<span class="string">&quot;FILEVERSION (([\\d]+).[ ]*)*([\\d]+)&quot;</span>, content)</span><br><span class="line">    new_ver = <span class="built_in">str</span>(<span class="built_in">int</span>(m.group(<span class="number">3</span>)) + <span class="number">1</span>)</span><br><span class="line">    content = re.sub(<span class="string">&quot;(FILEVERSION ([\\d]+.[ ]*)*)([\\d]+)&quot;</span>, <span class="string">&quot;\\g&lt;1&gt;&quot;</span> + new_ver, content)</span><br><span class="line"></span><br><span class="line">    m = re.search(<span class="string">&quot;VALUE \&quot;ProductVersion\&quot;, \&quot;(([\\d]+).[ ]*)*([\\d]+)\&quot;&quot;</span>, content)</span><br><span class="line">    new_ver = <span class="built_in">str</span>(<span class="built_in">int</span>(m.group(<span class="number">3</span>)) + <span class="number">1</span>)</span><br><span class="line">    content = re.sub(<span class="string">&quot;(VALUE \&quot;ProductVersion\&quot;, \&quot;([\\d]+.[ ]*)*)[\\d]+\&quot;&quot;</span>, <span class="string">&quot;\\g&lt;1&gt;&quot;</span> + new_ver + <span class="string">&quot;\&quot;&quot;</span>, content)</span><br><span class="line"></span><br><span class="line">    m = re.search(<span class="string">&quot;PRODUCTVERSION (([\\d]+).[ ]*)*([\\d]+)&quot;</span>, content)</span><br><span class="line">    new_ver = <span class="built_in">str</span>(<span class="built_in">int</span>(m.group(<span class="number">3</span>)) + <span class="number">1</span>)</span><br><span class="line">    content = re.sub(<span class="string">&quot;(PRODUCTVERSION ([\\d]+.[ ]*)*)([\\d]+)&quot;</span>, <span class="string">&quot;\\g&lt;1&gt;&quot;</span> + new_ver, content)</span><br><span class="line">    </span><br><span class="line">    content_file.seek(<span class="number">0</span>)</span><br><span class="line">    content_file.write(content)</span><br><span class="line">    content_file.truncate()</span><br><span class="line">    content_file.close()</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>验证文件签名</title>
      <link href="/2016/09/21/verify-cert/"/>
      <url>/2016/09/21/verify-cert/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Sysinternal(<a href="http://forum.sysinternals.com/howto-verify-the-digital-signature-of-a-file_topic19247.html)%E4%B8%8A%E6%9C%89%E5%85%B3%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%8D%E8%BF%87%E4%BB%A3%E7%A0%81%E6%9C%89%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%96%E5%8F%AA%E8%83%BD%E9%AA%8C%E8%AF%81PE%E7%AD%BE%E5%90%8D%EF%BC%8C%E6%97%A0%E6%B3%95%E9%AA%8C%E8%AF%81%E6%96%87%E4%BB%B6%E7%AD%BE%E5%90%8D%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E8%BF%99%E9%87%8C%E7%A8%8D%E4%BD%9C%E4%BA%86%E7%82%B9%E4%BF%AE%E6%94%B9%EF%BC%8C%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B">http://forum.sysinternals.com/howto-verify-the-digital-signature-of-a-file_topic19247.html)上有关于验证签名的代码，不过代码有点问题，他只能验证PE签名，无法验证文件签名，所以我这里稍作了点修改，记录一下</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENCODING (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING)</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CheckFileTrust</span><span class="params">(LPCTSTR filename, CString &amp;signer_file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HCATADMIN cat_admin_handle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CryptCATAdminAcquireContext</span>(&amp;cat_admin_handle, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileW</span>(filename, GENERIC_READ, FILE_SHARE_READ,</span><br><span class="line">        <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CryptCATAdminReleaseContext</span>(cat_admin_handle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD hash_count = <span class="number">100</span>;</span><br><span class="line">    BYTE hash_data[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">CryptCATAdminCalcHashFromFileHandle</span>(hFile, &amp;hash_count, hash_data, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line">    LPWSTR member_tag = <span class="keyword">new</span> WCHAR[hash_count * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (DWORD dw = <span class="number">0</span>; dw &lt; hash_count; ++dw)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wsprintfW</span>(&amp;member_tag[dw * <span class="number">2</span>], <span class="string">L&quot;%02X&quot;</span>, hash_data[dw]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WINTRUST_DATA wd = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WINTRUST_FILE_INFO wfi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WINTRUST_CATALOG_INFO wci = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CATALOG_INFO ci = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HCATINFO cat_admin_info = <span class="built_in">CryptCATAdminEnumCatalogFromHash</span>(cat_admin_handle,</span><br><span class="line">        hash_data, hash_count, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == cat_admin_info)</span><br><span class="line">    &#123;</span><br><span class="line">        wfi.cbStruct = <span class="built_in"><span class="keyword">sizeof</span></span>(WINTRUST_FILE_INFO);</span><br><span class="line">        wfi.pcwszFilePath = filename;</span><br><span class="line">        wfi.hFile = <span class="literal">NULL</span>;</span><br><span class="line">        wfi.pgKnownSubject = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        wd.cbStruct = <span class="built_in"><span class="keyword">sizeof</span></span>(WINTRUST_DATA);</span><br><span class="line">        wd.dwUnionChoice = WTD_CHOICE_FILE;</span><br><span class="line">        wd.pFile = &amp;wfi;</span><br><span class="line">        wd.dwUIChoice = WTD_UI_NONE;</span><br><span class="line">        wd.fdwRevocationChecks = WTD_REVOKE_NONE;</span><br><span class="line">        wd.dwStateAction = WTD_STATEACTION_IGNORE;</span><br><span class="line">        wd.dwProvFlags = WTD_SAFER_FLAG;</span><br><span class="line">        wd.hWVTStateData = <span class="literal">NULL</span>;</span><br><span class="line">        wd.pwszURLReference = <span class="literal">NULL</span>;</span><br><span class="line">        signer_file = filename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CryptCATCatalogInfoFromContext</span>(cat_admin_info, &amp;ci, <span class="number">0</span>);</span><br><span class="line">        wci.cbStruct = <span class="built_in"><span class="keyword">sizeof</span></span>(WINTRUST_CATALOG_INFO);</span><br><span class="line">        wci.pcwszCatalogFilePath = ci.wszCatalogFile;</span><br><span class="line">        wci.pcwszMemberFilePath = filename;</span><br><span class="line">        wci.pcwszMemberTag = member_tag;</span><br><span class="line">        wci.pbCalculatedFileHash = hash_data;</span><br><span class="line">        wci.cbCalculatedFileHash = hash_count;</span><br><span class="line"></span><br><span class="line">        wd.cbStruct = <span class="built_in"><span class="keyword">sizeof</span></span>(WINTRUST_DATA);</span><br><span class="line">        wd.dwUnionChoice = WTD_CHOICE_CATALOG;</span><br><span class="line">        wd.pCatalog = &amp;wci;</span><br><span class="line">        wd.dwUIChoice = WTD_UI_NONE;</span><br><span class="line">        wd.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;</span><br><span class="line">        wd.dwProvFlags = <span class="number">0</span>;</span><br><span class="line">        wd.hWVTStateData = <span class="literal">NULL</span>;</span><br><span class="line">        wd.pwszURLReference = <span class="literal">NULL</span>;</span><br><span class="line">        signer_file = ci.wszCatalogFile;</span><br><span class="line">    &#125;</span><br><span class="line">    GUID action = WINTRUST_ACTION_GENERIC_VERIFY_V2;</span><br><span class="line">    HRESULT hr = <span class="built_in">WinVerifyTrust</span>(<span class="literal">NULL</span>, &amp;action, &amp;wd);</span><br><span class="line">    BOOL retval = <span class="built_in">SUCCEEDED</span>(hr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != cat_admin_info) &#123;</span><br><span class="line">        <span class="built_in">CryptCATAdminReleaseCatalogContext</span>(cat_admin_handle, cat_admin_info, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CryptCATAdminReleaseContext</span>(cat_admin_handle, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] member_tag;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetCertificateInfo</span><span class="params">(PCCERT_CONTEXT cert_context, CString &amp;signer_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPTSTR name = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data = <span class="built_in">CertGetNameString</span>(cert_context,</span><br><span class="line">        CERT_NAME_SIMPLE_DISPLAY_TYPE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for subject name.</span></span><br><span class="line">    name = (LPTSTR)<span class="built_in">LocalAlloc</span>(LPTR, data * <span class="built_in"><span class="keyword">sizeof</span></span>(TCHAR));</span><br><span class="line">    <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get subject name.</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">CertGetNameString</span>(cert_context,</span><br><span class="line">        CERT_NAME_SIMPLE_DISPLAY_TYPE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        name,</span><br><span class="line">        data))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">LocalFree</span>(name);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    signer_name = name;</span><br><span class="line">    <span class="built_in">LocalFree</span>(name);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetFileSigner</span><span class="params">(LPCTSTR szFileName, CString &amp;signer_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HCERTSTORE store_handle = <span class="literal">NULL</span>;</span><br><span class="line">    HCRYPTMSG msg_handle = <span class="literal">NULL</span>;</span><br><span class="line">    PCCERT_CONTEXT cert_context = <span class="literal">NULL</span>;</span><br><span class="line">    BOOL retval = FALSE;</span><br><span class="line">    DWORD encoding, content_type, format_type;</span><br><span class="line">    PCMSG_SIGNER_INFO signer_info = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD signer_info_size;</span><br><span class="line">    CERT_INFO cert_info;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get message handle and store handle from the signed file.</span></span><br><span class="line">        retval = <span class="built_in">CryptQueryObject</span>(CERT_QUERY_OBJECT_FILE,</span><br><span class="line">            szFileName,</span><br><span class="line">            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,</span><br><span class="line">            CERT_QUERY_FORMAT_FLAG_BINARY,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            &amp;encoding,</span><br><span class="line">            &amp;content_type,</span><br><span class="line">            &amp;format_type,</span><br><span class="line">            &amp;store_handle,</span><br><span class="line">            &amp;msg_handle,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!retval) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get signer information size.</span></span><br><span class="line">        retval = <span class="built_in">CryptMsgGetParam</span>(msg_handle,</span><br><span class="line">            CMSG_SIGNER_INFO_PARAM,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            &amp;signer_info_size);</span><br><span class="line">        <span class="keyword">if</span> (!retval) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allocate memory for signer information.</span></span><br><span class="line">        signer_info = (PCMSG_SIGNER_INFO)<span class="built_in">LocalAlloc</span>(LPTR, signer_info_size);</span><br><span class="line">        <span class="keyword">if</span> (!signer_info) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get Signer Information.</span></span><br><span class="line">        retval = <span class="built_in">CryptMsgGetParam</span>(msg_handle,</span><br><span class="line">            CMSG_SIGNER_INFO_PARAM,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            (PVOID)signer_info,</span><br><span class="line">            &amp;signer_info_size);</span><br><span class="line">        <span class="keyword">if</span> (!retval) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Search for the signer certificate in the temporary </span></span><br><span class="line">        <span class="comment">// certificate store.</span></span><br><span class="line">        cert_info.Issuer = signer_info-&gt;Issuer;</span><br><span class="line">        cert_info.SerialNumber = signer_info-&gt;SerialNumber;</span><br><span class="line"></span><br><span class="line">        cert_context = <span class="built_in">CertFindCertificateInStore</span>(store_handle,</span><br><span class="line">            ENCODING,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            CERT_FIND_SUBJECT_CERT,</span><br><span class="line">            (PVOID)&amp;cert_info,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!cert_context) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        retval = <span class="built_in">GetCertificateInfo</span>(cert_context, signer_name);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signer_info != <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="built_in">LocalFree</span>(signer_info); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cert_context != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CertFreeCertificateContext</span>(cert_context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (store_handle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CertCloseStore</span>(store_handle, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg_handle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CryptMsgClose</span>(msg_handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在NTFS元文件目录里创建文件</title>
      <link href="/2016/08/23/create-file-in-metadata/"/>
      <url>/2016/08/23/create-file-in-metadata/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>说到Rootkit就不能提到他的文件隐藏，Rootkit隐藏文件的方式千奇百怪，这里说其中一个通过NTFS元文件目录无法被普通程序显示的特性隐藏文件的方法。</p><p>我们都知道NTFS是有元文件的，比如$MFT(NTFS主文件表)，这种文件是我们看不到的，但是系统能访问。同样还有一种元文件目录，这个目录也是看不到的，无论你是否打开了显示系统文件，隐藏文件的选项。那么如果我们把要隐藏的文件放在这种目录下，那么就达到了隐藏的效果。</p><p>举个例子 $Extend\$RmMetadata 这个目录。我们可以通过Winhex解析NTFS来读取这个目录的情况，而普通程序不行。这里我们通过这样的代码来创建文件。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPA(x) *(FARPROC *)&amp;My##x = GetProcAddress(GetModuleHandle(<span class="meta-string">L&quot;ntdll.dll&quot;</span>), #x)</span></span><br><span class="line">    <span class="built_in">GPA</span>(NtCreateFile);</span><br><span class="line">    <span class="built_in">GPA</span>(RtlInitUnicodeString);</span><br><span class="line">    IO_STATUS_BLOCK iob;</span><br><span class="line">    HANDLE h;</span><br><span class="line">    UNICODE_STRING uni_str;</span><br><span class="line">    <span class="built_in">MyRtlInitUnicodeString</span>(&amp;uni_str, <span class="string">L&quot;\\??\\Global\\D:\\$Extend\\$RmMetadata\\$0cch&quot;</span>);</span><br><span class="line"></span><br><span class="line">    OBJECT_ATTRIBUTES oa;</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;oa, &amp;uni_str, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">    LONG l = <span class="built_in">MyNtCreateFile</span>(&amp;h, </span><br><span class="line">    FILE_APPEND_DATA | SYNCHRONIZE, </span><br><span class="line">    &amp;oa, </span><br><span class="line">    &amp;iob, </span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, </span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    FILE_SUPERSEDE, </span><br><span class="line">    FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, </span><br><span class="line">    <span class="literal">NULL</span>, </span><br><span class="line">    <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buffer[] = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">    <span class="built_in">WriteFile</span>(h, buffer, <span class="built_in">strlen</span>(buffer), (ULONG *)&amp;l, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(h);</span><br></pre></td></tr></table></figure><p>值得注意的是我们必须用System用户权限去运行这个程序，才能创建文件到元文件目录，这里要用到psexec：</p><p>psexec  -s C:\0cch\Test.exe</p><p>然后我们看看效果</p><p><a href="/uploads/2016/08/20160824115523.png"><img src="/uploads/2016/08/20160824115523.png" alt="20160824115523"></a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Windows Timer精确度</title>
      <link href="/2016/07/24/something-about-windows-timer-resolution/"/>
      <url>/2016/07/24/something-about-windows-timer-resolution/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Windows Timer相比大家都用过，WM_TIMER, WM_SYSTIMER, Waitable Timer, Multimedia Timer, Timer Queue Timer，这么多种Timer，给我们变成提供了很大的方便，有窗口无窗口都能自如选择。所以尽量也不要自己再造轮子，用什么Sleep来写Timer。这种“自定义”的Timer肯定是没有由系统内核DPC触发的Timer效率高的。</p><p>OK，回到正题，关于Timer的精确度。首先看看SysInternal工具集的clockres的显示：</p><p><a href="/uploads/2016/07/20160725102628.png"><img src="/uploads/2016/07/20160725102628.png" alt="20160725102628"></a></p><p>从图中可以看出，我这个系统的最大精确度15.6毫秒，最小是0.5毫秒，当前是15.6毫秒。默认情况下，Windows会用最大精确度，因为这样可以减少CPU的消耗，而且高精度的定时器，绝大多数程序都不会用到。基于15.6毫秒这个精度，那么我们设置Timer间隔为15.6毫秒以下都是没有意义的，这里再提一下，Sleep函数在内核也是用的定时器，也就是说这个精确度下，Sleep(10)也是没有意义的，间隔会达到15-16毫秒。</p><p>当然，我们有的时候也是需要高精度的定时器的，这个时候我们需要设置时间精度。timeBeginPeriod这个函数就可以完成这个任务，这个函数调用了ntdll的NtSetTimerResolution函数，我们也可以直接调用这个ntdll函数，只不过我们需要动态获得这个函数的地址罢了。值得注意的是，并不是你想设置什么精确度都可以，Windows内部实际上维护了一份可以设置的精度列表，他会选择一个和你设置相近的的精度设置上去，这个列表保存在Hal里面。</p><p>好了，再说下Windows时钟，Windows时钟更新时间总是用的最大精度，在我个系统上也就是每次更新时间都是间隔15.6毫秒。也就是说如果用GetTickCount来统计性能问题，最大精度也就是15-16毫秒。举个例子，一段代码运行时间不足15.6毫秒，要么统计结果是0，要么是15-16毫秒，时间精度不会影响Windows时钟更新。</p><p>最后说下Windows高精度时钟查询的实现，在2000和XP时代，系统用TSC来演算时间，但是那个时候，多核并不支持TSC同步，这回带来一些问题。Vista系统采用了High Precision Event Timer (HPET)或者ACPI Power Management Timer (PM timer)，但是这种Timer的延时比较高，当然，这个延时是百纳秒级别的，可以说基本上不会对普通程序有什么影响。之后的系统就使用了固定频率的TSC，这样在多核状态下也能保证同步，而且延时很低。更详细的资料可以参考：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10 任务管理器结束任务流程</title>
      <link href="/2016/06/26/win10-taskmgr-killproc/"/>
      <url>/2016/06/26/win10-taskmgr-killproc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>从Win8开始，任务管理已经悄然发生变化了，这篇文章要说的就是结束任务这一个功能。以Win10的任务管理器为主来说明，没有了从窗口关闭进程的标签。取而代之的是一个区分前台和后台程序的进程树。通过这个界面结束进程也不再像以前一样调用User32的EndTask(<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633492(v=vs.85).aspx)%EF%BC%8C%E8%80%8C%E6%98%AF%E9%87%8D%E6%96%B0%E8%A7%84%E5%88%92%E4%BA%86%E4%B8%80%E5%A5%97%E9%80%BB%E8%BE%91%E3%80%82">https://msdn.microsoft.com/en-us/library/windows/desktop/ms633492(v=vs.85).aspx)，而是重新规划了一套逻辑。</a></p><p>具体逻辑如下：  </p><blockquote><p>1.区分程序类型  </p><p>2.如果是窗口程序，则给窗口发送WM_SYSCOMMAND+SC_CLOSE结束窗口来结束进程  </p><p>3.如果是服务程序，则调用ControlService+SERVICE_CONTROL_STOP结束服务来结束进程  </p><p>4.如果既没有窗口也不是服务的程序，或者说在第2，3步没有结束成功的进程，会调用TerminateProcess来强行结束进程。  </p><p> 5.第五步是和之前结束任务最大的一个区别，以前的任务管理器，如果没能结束进程，例如一些僵尸进程，他就不会做其他动作了，而新的任务管理器为了释放这种进程所占用的内核资源，他还会做另外一些事情，那就是关闭目标进程的所有句柄。使用的方式就是DuplicateHandle+DUPLICATE_CLOSE_SOURCE。这样做的另外一个好处就是，如果顽固进程还在运行，句柄关闭会造成其崩溃而结束。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 8 Shell API对于长路径文件名的支持</title>
      <link href="/2016/05/17/win8-shell-long-filename/"/>
      <url>/2016/05/17/win8-shell-long-filename/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在Windows 8之前，Shell API对于长路径的文件名的支持并不理想。比如PathAppend这个函数，函数规定pszPath，也就是第一个参数，它的buffer大小必须要能够容纳MAX_PATH个字符。第二个参数pszMore也不能超过MAX_PATH的长度。这样的API不仅不能满足我们对长文件路径需求，同时也可能让我们的软件由于字符串检查不严格出现严重BUG和漏洞。</p><p>还好，这个问题在Windows 8以及以后的系统上得到了解决。还是以路径拼接为例。微软向我们介绍了PathCchAppend和PathCchAppendEx函数。其中PathCchAppend函数，增加了cchPath参数，用来指定输出buffer的大小。用这样的方式来加强参数的检查，增加了函数的安全性。而PathCchAppendEx这个函数在PathCchAppend基础上，又加入了dwFlags，现在这个标志只有PATHCCH_ALLOW_LONG_PATHS，意思就是让我们的路径名超过MAX_PATH。</p><p>不知道微软设计PathCchAppend和PathCchAppendEx这两个API的时候是怎么样的一个想法，我觉得完全没必要设计成两个函数，一个PathCchAppendEx就足够了。大家是不是也有这个疑问呢？</p><p>最后，由于Windows 7现在的使用量还是非常大的，我们也不能因为要使用这些新的API而放弃兼容老版本的Windows。比较合适的做法还是动态导入这些函数，如果成功了就可以使用新的函数，失败就用老的函数。另外值得注意的是，PathCchAppend这类新的函数并不是放在shlwapi.dll里面，而是在kernelbase.dll，动态获取函数的时候需要注意这一点。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获取桌面图标位置</title>
      <link href="/2016/04/12/get-desktop-icon-pos/"/>
      <url>/2016/04/12/get-desktop-icon-pos/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>用来干什么就不用说了，反正不是什么好事情 =v=</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DESKTOP_ICON_INFO</span> &#123;</span></span><br><span class="line">    LVITEMW item;</span><br><span class="line">    WCHAR item_text[MAX_PATH];</span><br><span class="line">    RECT rc;</span><br><span class="line">&#125; DESKTOP_ICON_INFO, *PDESKTOP_ICON_INFO;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetDesktopIconInfo</span><span class="params">(LPCWSTR pattern, RECT &amp;rc, HWND &amp;desktop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HWND progman = <span class="built_in">FindWindow</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Progman&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;Program Manager&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (progman == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    HWND def_view = <span class="built_in">FindWindowEx</span>(progman, <span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;SHELLDLL_DefView&quot;</span>), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (def_view == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HWND list_view = <span class="built_in">FindWindowEx</span>(def_view, <span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;SysListView32&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;FolderView&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (list_view == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    desktop = list_view;</span><br><span class="line"></span><br><span class="line">    ULONG process_id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">GetWindowThreadProcessId</span>(progman, &amp;process_id);</span><br><span class="line">    <span class="keyword">if</span> (process_id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)::<span class="built_in">SendMessage</span>(list_view, LVM_GETITEMCOUNT, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    HANDLE process_handle = <span class="built_in">OpenProcess</span>(</span><br><span class="line">        PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, FALSE, process_id);</span><br><span class="line">    <span class="keyword">if</span> (process_handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUCHAR remote_addr = (PUCHAR)<span class="built_in">VirtualAllocEx</span>(process_handle, <span class="literal">NULL</span>, </span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(DESKTOP_ICON_INFO), MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    DESKTOP_ICON_INFO icon_info;</span><br><span class="line">    icon_info.item.iItem = <span class="number">0</span>;</span><br><span class="line">    icon_info.item.iSubItem = <span class="number">0</span>;</span><br><span class="line">    icon_info.item.mask = LVIF_TEXT;</span><br><span class="line">    icon_info.item.pszText = (WCHAR *)(remote_addr + <span class="built_in">offsetof</span>(DESKTOP_ICON_INFO, item_text));</span><br><span class="line">    icon_info.item.cchTextMax = MAX_PATH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        icon_info.rc.left = LVIR_BOUNDS;</span><br><span class="line">        <span class="built_in">ZeroMemory</span>(icon_info.item_text, <span class="built_in"><span class="keyword">sizeof</span></span>(icon_info.item_text));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WriteProcessMemory</span>(process_handle, remote_addr, &amp;icon_info, <span class="built_in"><span class="keyword">sizeof</span></span>(icon_info), <span class="literal">NULL</span>)) &#123;</span><br><span class="line">             ::<span class="built_in">SendMessage</span>(list_view, LVM_GETITEMTEXT, (WPARAM)i, (LPARAM)(remote_addr + <span class="built_in">offsetof</span>(DESKTOP_ICON_INFO, item)));</span><br><span class="line">             ::<span class="built_in">SendMessage</span>(list_view, LVM_GETITEMRECT, (WPARAM)i, (LPARAM)(remote_addr + <span class="built_in">offsetof</span>(DESKTOP_ICON_INFO, rc)));</span><br><span class="line">             <span class="built_in">ReadProcessMemory</span>(process_handle, remote_addr, &amp;icon_info, <span class="built_in"><span class="keyword">sizeof</span></span>(icon_info), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (_wcsicmp(icon_info.item_text, pattern) == <span class="number">0</span>) &#123;</span><br><span class="line">                 rc = icon_info.rc;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(process_handle, remote_addr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(process_handle);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查看消息窗口工具</title>
      <link href="/2016/03/17/msg-wnd-view/"/>
      <url>/2016/03/17/msg-wnd-view/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们都知道用Spy++去查看窗口句柄的相关信息，但是这款工具无法找到消息窗口(Message-Only Windows)。所以写了个查看消息窗口的工具，帮我排查一些这方面的问题。</p><p><a href="/uploads/2016/03/20160317120246.png"><img src="/uploads/2016/03/20160317120246.png" alt="20160317120246"></a></p><p>下载：<a href="/uploads/2016/03/MsgOnlyWnd.zip">MsgOnlyWnd</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c06d007f异常的解决方法</title>
      <link href="/2016/02/23/delay-load-error/"/>
      <url>/2016/02/23/delay-load-error/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>c06d007f这个异常通常是在PE的延迟加载dll的时候发生的，加载器找不到对应的dll就会抛出这个异常。如果我们对这个异常不熟悉，按照常规方式去找上下文，那么结果肯定会让你失望。例如3.2526.1373.0版本的libcef在XP上运行的情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; kb</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">00 0012f218 7c92d9ac 7c86449d d0000144 00000004 ntdll!KiFastSystemCallRet</span><br><span class="line">01 0012f21c 7c86449d d0000144 00000004 00000000 ntdll!ZwRaiseHardError+0xc</span><br><span class="line">02 0012f4a0 7c843892 0012f4c8 7c839b21 0012f4d0 kernel32!UnhandledExceptionFilter+0x628</span><br><span class="line">03 0012f4a8 7c839b21 0012f4d0 00000000 0012f4d0 kernel32!BaseProcessStart+0x39</span><br><span class="line">04 0012f4d0 7c9232a8 0012f5bc 0012ffe0 0012f5d4 kernel32!_except_handler3+0x61</span><br><span class="line">05 0012f4f4 7c92327a 0012f5bc 0012ffe0 0012f5d4 ntdll!ExecuteHandler2+0x26</span><br><span class="line">06 0012f5a4 7c92e46a 00000000 0012f5d4 0012f5bc ntdll!ExecuteHandler+0x24</span><br><span class="line">07 0012f5a4 00000000 00000000 0012f5d4 0012f5bc ntdll!KiUserExceptionDispatcher+0xe</span><br><span class="line">WARNING: Frame IP not in any known module. Following frames may be wrong.</span><br><span class="line">08 0012fff4 004a991e 00000000 78746341 00000020 0x0</span><br><span class="line">09 0012fff8 00000000 78746341 00000020 00000001 cefclient!pre_c_init+0xb9 [f:\dd\vctools\crt_bld\self_x86\crt\src\crtexe.c @ 261]</span><br><span class="line"></span><br><span class="line">0:000&gt; .cxr 0012f5d4;k</span><br><span class="line">eax&#x3D;0012f8a4 ebx&#x3D;1314a58c ecx&#x3D;00000000 edx&#x3D;00000001 esi&#x3D;0012f954 edi&#x3D;68d60000</span><br><span class="line">eip&#x3D;00000000 esp&#x3D;0012fff8 ebp&#x3D;00000000 iopl&#x3D;0         nv up ei pl nz na po nc</span><br><span class="line">cs&#x3D;001b  ss&#x3D;0023  ds&#x3D;0023  es&#x3D;0023  fs&#x3D;003b  gs&#x3D;0000             efl&#x3D;00000202</span><br><span class="line">00000000 ??              ???</span><br><span class="line">  *** Stack trace for last set context - .thread&#x2F;.cxr resets it</span><br><span class="line"> # ChildEBP RetAddr  </span><br><span class="line">WARNING: Frame IP not in any known module. Following frames may be wrong.</span><br><span class="line">00 0012fff4 004a991e 0x0</span><br><span class="line">01 0012fff8 00000000 cefclient!pre_c_init+0xb9 [f:\dd\vctools\crt_bld\self_x86\crt\src\crtexe.c @ 261]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接看栈回溯或者通过设置cxr看栈回溯，并没有帮助我们找到什么有用的信息。</p><p>这里要使用的方法是，利用异常的参数来找到具体延迟加载谁的时候发生了异常。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; .exr 0012f5bc </span><br><span class="line">ExceptionAddress: 7c812aeb (kernel32!RaiseException+0x00000053)</span><br><span class="line">   ExceptionCode: c06d007f</span><br><span class="line">  ExceptionFlags: 00000000</span><br><span class="line">NumberParameters: 1</span><br><span class="line">   Parameter[0]: 0012f918</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>这里的参数0，就是我们要找的目标，记录了出错时候ebp-0x30的数据，也就是含有关键信息的地方。让我们仔细看看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; dds 0012f918</span><br><span class="line">0012f918  00000024</span><br><span class="line">0012f91c  1314a58c libcef!_DELAY_IMPORT_DESCRIPTOR_dbghelp_dll</span><br><span class="line">0012f920  13181dbc libcef!_imp__SymGetSearchPathW</span><br><span class="line">0012f924  12ebdd20 libcef!_sz_dbghelp_dll</span><br><span class="line">0012f928  00000001</span><br><span class="line">0012f92c  1314ac8e libcef!dxva2_NULL_THUNK_DATA_DLN+0x7e</span><br><span class="line">0012f930  68d60000 dbghelp!_imp__CryptAcquireContextA &lt;PERF&gt; (dbghelp+0x0)</span><br><span class="line">0012f934  00000000</span><br><span class="line">0012f938  0000007f</span><br><span class="line">0012f93c  1314c138 libcef!dxva2_NULL_THUNK_DATA_DLN+0x1528</span><br><span class="line">0012f940  00000003</span><br><span class="line">0012f944  00000000</span><br><span class="line">0012f948  0012f9f8</span><br><span class="line">0012f94c  11d17587 libcef!_tailMerge_dbghelp_dll+0xd</span><br><span class="line">0012f950  0012f918</span><br><span class="line">0012f954  13181dbc libcef!_imp__SymGetSearchPathW</span><br><span class="line">0012f958  00000008</span><br><span class="line">0012f95c  7c9301bb ntdll!RtlAllocateHeap+0xeac</span><br><span class="line">0012f960  1019014e libcef!base::debug::&#96;anonymous namespace&#39;::InitializeSymbols+0x9e [f:\stnts\browser\cef\ws\src\chromium\src\base\debug\stack_trace_win.cc @ 79]</span><br><span class="line">0012f964  ffffffff</span><br><span class="line">0012f968  00170880</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以清楚的看到加载器延迟加载SymGetSearchPathW的时候发生了问题。让我们进一步用depends工具验证一下</p><p><a href="/uploads/2016/02/20160223003624.png"><img src="/uploads/2016/02/20160223003624.png" alt="20160223003624"></a></p><p>如上图所示，XP自带的dbghelp里没有SymGetSearchPathW这个导出函数。要解决这个异常，实际上就需要在运行目录里添加一个稍微新一点的dbghelp文件，我这里替换的是6.2.9200.16384的dbghelp，替换过后问题已经不再出现了。</p><p><a href="/uploads/2016/02/20160223003711.png"><img src="/uploads/2016/02/20160223003711.png" alt="20160223003711"></a></p>]]></content>
      
      
      <categories>
          
          <category> debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调试器最早的中断应用程序的方法</title>
      <link href="/2016/02/02/app-cpr-event/"/>
      <url>/2016/02/02/app-cpr-event/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这篇Blog分享一个Windbg的小技巧，就是让被调试程序更早的中断到调试器。熟悉Windbg的朋友都知道，用调试器运行程序，默认情况下都会中断到ntdll!LdrpDoDebuggerBreak。但是有时候我们会想去调试程序加载的过程，这个时候就需要我们更早的中断下来。那么这里就用利用到调试器最早接受到的调试事件了。CREATE_PROCESS_DEBUG_EVENT，这个调试事件是创建进程的时候进程发给调试器的，在这个时候，你甚至连ntdll都没有完成加载，这也导致ntdll的符号无法加载，很多有用的功能用不上。但幸运的是，虽然ntdll没有完成加载，但是已经加载到了内存，另外我们可以用手动加载符号的方法，把符号文件加载到ntdll的内存上去。</p><p>演示如下：</p><p>windbg.EXE -xe cpr -xe ld notepad.exe</p><p>这里设置中断系统事件cpr，也就是CREATE_PROCESS_DEBUG_EVENT</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; lm</span><br><span class="line">start             end                 module name</span><br><span class="line">00007ff7&#96;3f6e0000 00007ff7&#96;3f721000   notepad    (deferred)             </span><br><span class="line">0:000&gt; !teb</span><br><span class="line">TEB at 000000d995d21000</span><br><span class="line">error InitTypeRead( TEB )...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中断下来后我们可以看到，!teb是没法用的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; .imgscan</span><br><span class="line">MZ at 00007ff7&#96;3f6e0000, prot 00000002, type 01000000 - size 41000</span><br><span class="line">  Name: notepad.exe</span><br><span class="line">MZ at 00007ffb&#96;7c7b0000, prot 00000002, type 01000000 - size 1c1000</span><br><span class="line">  Name: ntdll.dll</span><br><span class="line">0:000&gt; .reload &#x2F;f ntdll.dll&#x3D;00007ffb&#96;7c7b0000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们需要找到ntdll的模块，然后手动加载符号，然后就可以使用和ntdll有关系的命令了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; lm</span><br><span class="line">start             end                 module name</span><br><span class="line">00007ff7&#96;3f6e0000 00007ff7&#96;3f721000   notepad    (deferred)             </span><br><span class="line">00007ffb&#96;7c7b0000 00007ffb&#96;7c971000   ntdll      (pdb symbols)          e:\workspace\mysymbols\ntdll.pdb\F296699DB5314A06935E88564D8CD2731\ntdll.pdb</span><br><span class="line"></span><br><span class="line">0:000&gt; !teb</span><br><span class="line">TEB at 000000d995d21000</span><br><span class="line">    ExceptionList:        0000000000000000</span><br><span class="line">    StackBase:            000000d995af0000</span><br><span class="line">    StackLimit:           000000d995adf000</span><br><span class="line">    SubSystemTib:         0000000000000000</span><br><span class="line">    FiberData:            0000000000001e00</span><br><span class="line">    ArbitraryUserPointer: 0000000000000000</span><br><span class="line">    Self:                 000000d995d21000</span><br><span class="line">    EnvironmentPointer:   0000000000000000</span><br><span class="line">    ClientId:             0000000000001c8c . 00000000000017c4</span><br><span class="line">    RpcHandle:            0000000000000000</span><br><span class="line">    Tls Storage:          0000000000000000</span><br><span class="line">    PEB Address:          000000d995d20000</span><br><span class="line">    LastErrorValue:       0</span><br><span class="line">    LastStatusValue:      0</span><br><span class="line">    Count Owned Locks:    0</span><br><span class="line">    HardErrorMode:        0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>总结和展望：转折的一年</title>
      <link href="/2016/01/11/2016-zjzw/"/>
      <url>/2016/01/11/2016-zjzw/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>过去的2015年应该是我工作和生活中的一个大转折。</p><p>这一年里，我选择从北京回到了武汉。这件事情上还是需要一些魄力的，最主要的就是收入拦腰截断，剩下原来的二分之一。其次发展空间上也不能和帝都相提并论。就拿接到猎头电话这件事情上说，回来大半年里，猎头电话一个接一个，但是绝大部分都是北京打来的。不过，在家乡有父母，有亲戚，有未婚妻，这种“交换”也是值得的，毕竟我不能期待什么都能得到。回来后，健身依然在坚持，只不过没有跑步机，还是觉得缺少了很多东西。自己的兴趣方面，MiniKernel，编译器和虚拟机依旧没什么进展，有一种写不动了的感觉，有进展的依旧是小工具合集，有些工具增加了一些新的功能，比如everything_study就优化了算法，现在查找速度已经和everthing看不出区别了。今年最美好的事情就是求婚，最悲催的事情就是学车。求婚对每个人来说想必都是最美好的事情，这个自然不必多说。至于学车，也是找了个不靠谱的驾校，被坑的不轻。幸运的是自己对车接受的比较快，没被教练坑的太惨，科目一到科目三都是满分通过，现在就剩下科目四了，春节前就把驾照给拿了。另外IXWebhosting这个主机我也不准备用了，换成GitHub Page来当blog，过段时间把0CCh.net这个域名也转移的godaddy算了。</p><p>新的2016将会是一个真正新的开始！我将在这一年组建自己的小家，要买车，要装修房子。工作上希望武汉的互联网大环境会更好，希望我的劳动能给公司带来更高的价值。健身方面，我打算在新家里买上一个跑步机，过时如同北京时那样的健康生活。另外，练字也应该继续。兴趣方面，小工具集可以继续壮大，MiniKernel，编译器和虚拟机中，我更倾向多花时间写写编译器。</p><p>另外，好友初步完成了自己的梦想，去美国工作了。很羡慕，祝福他能扎根那边，别回来吸雾霾了=v=。</p><p>最后，还是祝愿家人，朋友，在新的2016健健康康，平平安安，开开心心，财源广进！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++异常的参数分析(0xE06D7363)</title>
      <link href="/2015/12/06/cpp-exception-params/"/>
      <url>/2015/12/06/cpp-exception-params/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Visual C++ 的编译器用0xE06D7363表示C++异常。 0xE06D7363表示的意思就是.msc。  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:025&gt; .formats 0xE06D7363</span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     e06d7363</span><br><span class="line">  Decimal: -529697949</span><br><span class="line">  Octal:   34033271543</span><br><span class="line">  Binary:  11100000 01101101 01110011 01100011</span><br><span class="line">  Chars:   .msc</span><br><span class="line">  Time:    ***** Invalid</span><br><span class="line">  Float:   low -6.84405e+019 high 0</span><br><span class="line">  Double:  1.86029e-314</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>抛出异常代码的同时，还会带有三个到四个参数：<br>参数0是一个magic code，一般为0x19930520，我们不用管他<br>参数1是时异常抛出的对象指针<br>参数2是抛出异常的基本信息<br>参数3是抛出异常的模块基址(只有64位的程序才会有这个参数)，该基址加上异常信息的偏移才能获得信息的真正内存地址。  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:025&gt; .exr -1</span><br><span class="line">ExceptionAddress: 75c8c41f (KERNELBASE!RaiseException+0x00000058)</span><br><span class="line">   ExceptionCode: e06d7363 (C++ EH exception)</span><br><span class="line">  ExceptionFlags: 00000001</span><br><span class="line">NumberParameters: 3</span><br><span class="line">   Parameter[0]: 19930520</span><br><span class="line">   Parameter[1]: 09c9f324</span><br><span class="line">   Parameter[2]: 6b5d0298</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>6b5d0298就是我们想要取得的信息，信息存储的格式为_s__ThrowInfo。  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:025&gt; dt 6b5d0298 ole32!_s__ThrowInfo</span><br><span class="line">   +0x000 attributes       : 0</span><br><span class="line">   +0x004 pmfnUnwind       : 0x6b523b50     void  +0</span><br><span class="line">   +0x008 pForwardCompat   : (null) </span><br><span class="line">   +0x00c pCatchableTypeArray : 0x6b5d028c _s__CatchableTypeArray</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>然后可以取得pCatchableTypeArray，我们可以从中获取抛出异常的类型信息。  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:025&gt; dt 0x6b5d028c ole32!_s__CatchableTypeArray -r1</span><br><span class="line">   +0x000 nCatchableTypes  : 0n2</span><br><span class="line">   +0x004 arrayOfCatchableTypes : [0] 0x6b5d0270 _s__CatchableType</span><br><span class="line">      +0x000 properties       : 0</span><br><span class="line">      +0x004 pType            : 0x6b5e58f0 _TypeDescriptor</span><br><span class="line">      +0x008 thisDisplacement : _PMD</span><br><span class="line">      +0x014 sizeOrOffset     : 0n48</span><br><span class="line">      +0x018 copyFunction     : 0x6b523cc0        void  +0</span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>到这里我们就取得了类型的描述结构体了，最后就能从中获取抛出的异常类型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:025&gt; dt 0x6b5e58f0 ole32!_TypeDescriptor</span><br><span class="line">   +0x000 pVFTable         : 0x6b5c36e8 Void</span><br><span class="line">   +0x004 spare            : (null) </span><br><span class="line">   +0x008 name             : [0]  &quot;.?AVinterprocess_exception@interprocess@boost@@&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gotcha sdk 全盘文件名搜索开发库</title>
      <link href="/2015/11/24/gotcha-sdk/"/>
      <url>/2015/11/24/gotcha-sdk/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>想必大家都知道著名的全盘搜索工具everything，它极速的搜索速度让人眼前一亮。虽然everything提供了SDK，但是SDK是通过IPC的方式，获得everything程序里的数据。也就是说想在自己的程序中使用搜索功能那么必须带everything的主程序，这就是我开发gotcha sdk的主要原因，他能集成到程序当中，不需要依赖其他主程序，只需要你的程序是管理员权限运行，因为这样才能直接访问磁盘数据。另外网上也有一些关于everything原理和实现的代码，但是大部分都有问题，比如崩溃，死锁，内存占用过高等，并不适合直接用到产品当中。而gotcha sdk在自己开发了everything_study，并且使用了相当长的时间，解决性能，内存占用，死锁等问题的基础上提炼出来的开发库，我对其稳定性还是比较有信心的。</p><p>利用gotcha sdk，既可以开发出everything_study这样用C++写的程序，也能够开发出如gotcha sdk的sample里的gotcha，一个C#编写的全盘搜索程序，该程序也展示了gotcha sdk的用法。</p><p>gotcha sdk的用法非常简单，详细情况可以参考sample里的simple例子，该例子展示了sdk最简单的使用方式，我下一篇blog会介绍这套sdk的用法。</p><p><a href="/uploads/2015/11/20151124233627.png"><img src="/uploads/2015/11/20151124233627.png" alt="20151124233627"></a></p><p>gotcha sdk 代码SVN:<br><a href="http://code.taobao.org/svn/gotcha_sdk/">http://code.taobao.org/svn/gotcha_sdk/</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序初始化失败DUMP分析</title>
      <link href="/2015/11/01/app-startup-fail-dump/"/>
      <url>/2015/11/01/app-startup-fail-dump/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>拿到程序初始化失败的DUMP，一般情况下我们看到的栈是这个样子的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">0012fc7c 7c92d9ca 7c972b53 c0000145 00000001 ntdll!KiFastSystemCallRet</span><br><span class="line">0012fc80 7c972b53 c0000145 00000001 00000000 ntdll!NtRaiseHardError+0xc</span><br><span class="line">0012fca4 7c960f9f c0000005 0012fd30 00370034 ntdll!LdrpInitializationFailure+0x2d</span><br><span class="line">0012fd1c 7c92e457 0012fd30 7c920000 00000000 ntdll!_LdrpInitialize+0x1f9</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 ntdll!KiUserApcDispatcher+0x7</span><br><span class="line"></span><br><span class="line">0:000&gt; !error c0000145</span><br><span class="line">Error code: (NTSTATUS) 0xc0000145 (3221225797) - &#123;Application Error&#125;  The application was unable to start correctly (0x%lx). Click OK to close the application.</span><br><span class="line"></span><br><span class="line">0:000&gt; !error c0000005</span><br><span class="line">Error code: (NTSTATUS) 0xc0000005 (3221225477) - The instruction at 0x%p referenced memory at 0x%p. The memory could not be %s.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到最后报错是c0000145，应用程序无法运行。而引起出错的是LdrpInitializationFailure，出错原因内存访问异常。但是具体是哪出错还不无法从此刻的栈看到，我们需要进一步分析。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; dds esp-1000 esp</span><br><span class="line">...</span><br><span class="line">0012f3c0  7c92e920 ntdll!_except_handler3</span><br><span class="line">0012f3c4  00000001</span><br><span class="line">0012f3c8  0012f470</span><br><span class="line">0012f3cc  0012fd0c</span><br><span class="line">0012f3d0  7c953fdc ntdll!RtlDispatchException+0xb1</span><br><span class="line">0012f3d4  0012f470</span><br><span class="line">0012f3d8  0012fd0c</span><br><span class="line">0012f3dc  0012f48c</span><br><span class="line">0012f3e0  0012f444</span><br><span class="line">0012f3e4  7c92e920 ntdll!_except_handler3</span><br><span class="line">0012f3e8  003d3810 someapp!PostMsg+0x27aa0</span><br><span class="line">0012f3ec  0012f470</span><br><span class="line">0012f3f0  b36caf32</span><br><span class="line">0012f3f4  00153960</span><br><span class="line">0012f3f8  7c93e584 ntdll!DbgPrint+0x1c</span><br><span class="line">0012f3fc  00150178</span><br><span class="line">0012f400  000000e8</span><br><span class="line">0012f404  00000668</span><br><span class="line">0012f408  00150000</span><br><span class="line">0012f40c  0012f204</span><br><span class="line">0012f410  7c940571 ntdll!RtlCreateActivationContext+0x2c</span><br><span class="line">0012f414  c0000000</span><br><span class="line">0012f418  00153960</span><br><span class="line">0012f41c  003f0000</span><br><span class="line">0012f420  00000000</span><br><span class="line">0012f424  0012f444</span><br><span class="line">0012f428  7c940610 ntdll!RtlCreateActivationContext+0xed</span><br><span class="line">0012f42c  001539b4</span><br><span class="line">0012f430  00000002</span><br><span class="line">0012f434  00000008</span><br><span class="line">0012f438  00000000</span><br><span class="line">0012f43c  00000000</span><br><span class="line">0012f440  00000000</span><br><span class="line">0012f444  0012f750</span><br><span class="line">0012f448  7c814880 kernel32!CreateActCtxW+0x75c</span><br><span class="line">0012f44c  00130000</span><br><span class="line">0012f450  0012d000</span><br><span class="line">0012f454  00000000</span><br><span class="line">0012f458  0012f76c</span><br><span class="line">0012f45c  7c92e48a ntdll!KiUserExceptionDispatcher+0xe</span><br><span class="line">0012f460  00000000</span><br><span class="line">0012f464  0012f48c</span><br><span class="line">0012f468  0012f470</span><br><span class="line">0012f46c  0012f48c</span><br><span class="line">0012f470  c0000005</span><br><span class="line">0012f474  00000000</span><br><span class="line">0012f478  00000000</span><br><span class="line">0012f47c  7c93ccf2 ntdll!LdrpHandleOneOldFormatImportDescriptor+0x21</span><br><span class="line">0012f480  00000002</span><br><span class="line">0012f484  00000000</span><br><span class="line">0012f488  d16cca32</span><br><span class="line">0012f48c  0001003f</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们就可以看到异常发生的栈了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; .exr 0012f470</span><br><span class="line">ExceptionAddress: 7c93ccf2 (ntdll!LdrpHandleOneOldFormatImportDescriptor+0x00000021)</span><br><span class="line">   ExceptionCode: c0000005 (Access violation)</span><br><span class="line">  ExceptionFlags: 00000000</span><br><span class="line">NumberParameters: 2</span><br><span class="line">   Parameter[0]: 00000000</span><br><span class="line">   Parameter[1]: d16cca32</span><br><span class="line">Attempt to read from address d16cca32</span><br><span class="line"></span><br><span class="line">0:000&gt; .cxr 0012f48c</span><br><span class="line">eax&#x3D;003a0000 ebx&#x3D;00253010 ecx&#x3D;d132ca32 edx&#x3D;00033810 esi&#x3D;b36caf32 edi&#x3D;003d3810</span><br><span class="line">eip&#x3D;7c93ccf2 esp&#x3D;0012f758 ebp&#x3D;0012f76c iopl&#x3D;0         nv up ei ng nz na po nc</span><br><span class="line">cs&#x3D;001b  ss&#x3D;0023  ds&#x3D;0023  es&#x3D;0023  fs&#x3D;003b  gs&#x3D;0000             efl&#x3D;00010282</span><br><span class="line">ntdll!LdrpHandleOneOldFormatImportDescriptor+0x21:</span><br><span class="line">7c93ccf2 833c0800        cmp     dword ptr [eax+ecx],0 ds:0023:d16cca32&#x3D;????????</span><br><span class="line">0:000&gt; kb</span><br><span class="line">  *** Stack trace for last set context - .thread&#x2F;.cxr resets it</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">0012f76c 7c93ccc4 7ffd9000 00020498 00253010 ntdll!LdrpHandleOneOldFormatImportDescriptor+0x21</span><br><span class="line">0012f784 7c93bc1e 7ffd9000 00020498 00253010 ntdll!LdrpHandleOldFormatImportDescriptors+0x1f</span><br><span class="line">0012f800 7c93d216 00020498 00253010 00434398 ntdll!LdrpWalkImportDescriptor+0x19e</span><br><span class="line">0012fa50 7c93cd1d 00020498 004396ca 00400000 ntdll!LdrpLoadImportModule+0x1c8</span><br><span class="line">0012fa80 7c93ccc4 7ffd9000 00020498 00251ec0 ntdll!LdrpHandleOneOldFormatImportDescriptor+0x5e</span><br><span class="line">0012fa98 7c93bc1e 7ffd9000 00020498 00251ec0 ntdll!LdrpHandleOldFormatImportDescriptors+0x1f</span><br><span class="line">0012fb14 7c9418b5 00020498 00251ec0 7ffdf000 ntdll!LdrpWalkImportDescriptor+0x19e</span><br><span class="line">0012fc94 00000000 0012fca0 00000000 0012fd1c ntdll!LdrpInitializeProcess+0xe02</span><br><span class="line"></span><br><span class="line">0:000&gt; dt ntdll!_LDR_DATA_TABLE_ENTRY 00253010 </span><br><span class="line">   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x251e9c - 0x252ee0 ]</span><br><span class="line">   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x251ea4 - 0x252ee8 ]</span><br><span class="line">   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]</span><br><span class="line">   +0x018 DllBase          : 0x003a0000 Void</span><br><span class="line">   +0x01c EntryPoint       : 0x003c1ae4 Void</span><br><span class="line">   +0x020 SizeOfImage      : 0x43000</span><br><span class="line">   +0x024 FullDllName      : _UNICODE_STRING &quot;C:\Program Files\S-dir\Some-dir\someapp.dll&quot;</span><br><span class="line">   +0x02c BaseDllName      : _UNICODE_STRING &quot;someapp.dll&quot;</span><br><span class="line">   +0x034 Flags            : 0x200006</span><br><span class="line">   +0x038 LoadCount        : 0</span><br><span class="line">   +0x03a TlsIndex         : 0</span><br><span class="line">   +0x03c HashLinks        : _LIST_ENTRY [ 0x7c99e2f0 - 0x252a5c ]</span><br><span class="line">   +0x03c SectionPointer   : 0x7c99e2f0 Void</span><br><span class="line">   +0x040 CheckSum         : 0x252a5c</span><br><span class="line">   +0x044 TimeDateStamp    : 0x5618c3dc</span><br><span class="line">   +0x044 LoadedImports    : 0x5618c3dc Void</span><br><span class="line">   +0x048 EntryPointActivationContext : 0x00153960 Void</span><br><span class="line">   +0x04c PatchInformation : (null) </span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>可以看到正在加载someapp.dll，并且处理导入表的时候出了错。来看看这个模块的导入表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:000&gt; !dh someapp -f</span><br><span class="line"></span><br><span class="line">File Type: DLL</span><br><span class="line">FILE HEADER VALUES</span><br><span class="line">     14C machine (i386)</span><br><span class="line">       6 number of sections</span><br><span class="line">5618C3DC time date stamp Sat Oct 10 15:53:00 2015</span><br><span class="line"></span><br><span class="line">       0 file pointer to symbol table</span><br><span class="line">       0 number of symbols</span><br><span class="line">      E0 size of optional header</span><br><span class="line">    2102 characteristics</span><br><span class="line">            Executable</span><br><span class="line">            32 bit word machine</span><br><span class="line">            DLL</span><br><span class="line"></span><br><span class="line">OPTIONAL HEADER VALUES</span><br><span class="line">     10B magic #</span><br><span class="line">   10.00 linker version</span><br><span class="line">   27A00 size of code</span><br><span class="line">   15C00 size of initialized data</span><br><span class="line">       0 size of uninitialized data</span><br><span class="line">   21AE4 address of entry point</span><br><span class="line">    1000 base of code</span><br><span class="line">         ----- new -----</span><br><span class="line">10000000 image base</span><br><span class="line">    1000 section alignment</span><br><span class="line">     200 file alignment</span><br><span class="line">       2 subsystem (Windows GUI)</span><br><span class="line">    5.01 operating system version</span><br><span class="line">    0.00 image version</span><br><span class="line">    5.01 subsystem version</span><br><span class="line">   43000 size of image</span><br><span class="line">     400 size of headers</span><br><span class="line">   4943E checksum</span><br><span class="line">00100000 size of stack reserve</span><br><span class="line">00001000 size of stack commit</span><br><span class="line">00100000 size of heap reserve</span><br><span class="line">00001000 size of heap commit</span><br><span class="line">     140  DLL characteristics</span><br><span class="line">            Dynamic base</span><br><span class="line">            NX compatible</span><br><span class="line">   34BE0 [     1E0] address [size] of Export Directory</span><br><span class="line">   33810 [      B4] address [size] of Import Directory</span><br><span class="line">   3A000 [     4CC] address [size] of Resource Directory</span><br><span class="line">       0 [       0] address [size] of Exception Directory</span><br><span class="line">       0 [       0] address [size] of Security Directory</span><br><span class="line">   3B000 [    3954] address [size] of Base Relocation Directory</span><br><span class="line">   29340 [      1C] address [size] of Debug Directory</span><br><span class="line">       0 [       0] address [size] of Description Directory</span><br><span class="line">       0 [       0] address [size] of Special Directory</span><br><span class="line">   2DD80 [      18] address [size] of Thread Storage Directory</span><br><span class="line">   2DD38 [      40] address [size] of Load Configuration Directory</span><br><span class="line">       0 [       0] address [size] of Bound Import Directory</span><br><span class="line">   29000 [     2CC] address [size] of Import Address Table Directory</span><br><span class="line">       0 [       0] address [size] of Delay Import Directory</span><br><span class="line">       0 [       0] address [size] of COR20 Header Directory</span><br><span class="line">       0 [       0] address [size] of Reserved Directory</span><br><span class="line"></span><br><span class="line">0:000&gt; dc someapp+33810 someapp+33810+B4</span><br><span class="line">003d3810  60325c32 68326432 90326c32 b332af32  2\2&#96;2d2h2l2.2.2.</span><br><span class="line">003d3820  d132ca32 df32db32 0032fc32 30332033  2.2.2.2.2.2.3 30</span><br><span class="line">003d3830  40333833 4c334833 54335033 5c335833  383@3H3L3P3T3X3\</span><br><span class="line">003d3840  64336033 6c336833 74337033 7c337833  3&#96;3d3h3l3p3t3x3|</span><br><span class="line">003d3850  84338033 8c338833 94339033 ce33b433  3.3.3.3.3.3.3.3.</span><br><span class="line">003d3860  e933d233 f733f333 b134a633 0434e134  3.3.3.3.3.4.4.4.</span><br><span class="line">003d3870  44353935 94357135 d435c935 57361a35  595D5q5.5.5.5.6W</span><br><span class="line">003d3880  be366736 0c36d036 4b374037 b3377b37  6g6.6.6.7@7K7&#123;7.</span><br><span class="line">003d3890  ea37cf37 45380e37 81385e38 a0388a38  7.7.7.8E8^8.8.8.</span><br><span class="line">003d38a0  fb38d338 4b392438 a4399939 0039dd39  8.8.8$9K9.9.9.9.</span><br><span class="line">003d38b0  403a353a c33a863a 2a3ad33a 6b3b3c3b  :5:@:.:.:.:*;&lt;;k</span><br><span class="line">003d38c0  cf3b933b 1d3bea3b                    ;.;.;.;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以这样就清楚了，someapp.dll的输入表被破坏了，导致加载他的程序无法运行起来。</p>]]></content>
      
      
      <categories>
          
          <category> debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windbg插件0cchext</title>
      <link href="/2015/10/05/0cchext/"/>
      <url>/2015/10/05/0cchext/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://github.com/0cch/0cchext">0cchext.dll</a>是我一直在开发和维护的一个Windbg扩展程序。扩展程序中包含了一些或者有趣，或者实用，或者纯个人偏好的功能。这篇文章就来介绍一些主要的功能：</p><hr><h4 id="a"><a href="#a" class="headerlink" title="!a"></a>!a</h4><blockquote><p> !a               - Assembles instruction mnemonics and puts the resulting<br>                     instruction codes into memory.</p></blockquote><p>  这个指令是写入汇编代码的扩展，虽然Windbg有自己的汇编命令a，但是这个命令无法配合脚本使用。你一旦输入命令a，Windbg就会进入汇编模式，此时你就无法让脚本继续进行了。所以我开发了!a，这个命令只会对一条命令进行汇编，并且将下一条汇编的地址存储在@#LastAsmAddr中，然后马上执行下面的命令，对脚本而已再好不过了。<br>例如下面这个脚本，他可以注入dll到debuggee</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ad &#x2F;q $&#123;&#x2F;v:alloc_addr&#125;</span><br><span class="line">ad &#x2F;q $&#123;&#x2F;v:@#LastAsmAddr&#125;</span><br><span class="line">x kernel32!LoadlibraryA</span><br><span class="line">.foreach &#x2F;pS 5 (alloc_addr &#123;.dvalloc 0x200&#125;) &#123;r $.u0 &#x3D; alloc_addr&#125;</span><br><span class="line">.block &#123;aS $&#123;&#x2F;v:@#LastAsmAddr&#125; 0; !a $u0 pushfd&#125;;</span><br><span class="line">.block &#123;!a $&#123;@#LastAsmAddr&#125; pushad&#125;</span><br><span class="line">.block &#123;!a $&#123;@#LastAsmAddr&#125; push 0x$u0+0x100&#125;</span><br><span class="line">.block &#123;!a $&#123;@#LastAsmAddr&#125; call kernel32!LoadLibraryA&#125;</span><br><span class="line">.block &#123;!a $&#123;@#LastAsmAddr&#125; popad&#125;</span><br><span class="line">.block &#123;!a $&#123;@#LastAsmAddr&#125; popfd&#125;</span><br><span class="line">.block &#123; eza 0x$u0+0x100 &quot;$&#123;$arg1&#125;&quot;&#125;</span><br><span class="line">r @$t0&#x3D;@eip</span><br><span class="line">r @eip&#x3D;$u0</span><br><span class="line">.block &#123;g $&#123;@#LastAsmAddr&#125;&#125;</span><br><span class="line">r @eip&#x3D;@$t0</span><br><span class="line">.dvfree 0x$u0 0</span><br></pre></td></tr></table></figure><hr><h4 id="autocmd"><a href="#autocmd" class="headerlink" title="!autocmd"></a>!autocmd</h4><blockquote><p>!autocmd         - Execute the debugger commands.(The config file is<br>                     autocmd.ini)</p></blockquote><p>自动执行特定指令。有的时候我希望调试器附加到进程或者运行程序的时候能够自动运行一连串的命令，这个功能虽然可以由脚本完成，但是对我而言还是不够简洁，所以就有了这个命令。我可以在0cchext.dll的目录下，创建autocmd.ini文件，然后输入以下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[notepad.exe]</span><br><span class="line">.sympath+ c:\notepad_pdb</span><br><span class="line">~*k</span><br><span class="line"></span><br><span class="line">[calc.exe]</span><br><span class="line">.sympath+ c:\calc_pdb</span><br><span class="line">~*k</span><br></pre></td></tr></table></figure><p>这样，在调试不同程序的时候输入!autocmd会执行不同的命令。</p><hr><h4 id="bing-amp-google"><a href="#bing-amp-google" class="headerlink" title="!bing &amp; !google"></a>!bing &amp; !google</h4><blockquote><p>!bing            - Use bing to search.<br>!google          - Use google to search.</p></blockquote><p>这个命令非常简单，就是用bing和google去搜索指定的字符串。</p><hr><h4 id="favcmd"><a href="#favcmd" class="headerlink" title="!favcmd"></a>!favcmd</h4><blockquote><p>!favcmd           - Display the favorite debugger commands.(The config file is<br>                     favcmd.ini)</p></blockquote><p>这个命令也非常简单，只需要把自己喜欢的命令一行一行的写在favcmd.ini文件里就行了，当然这个文件也需要和0cchext.dll在同一个目录。然后运行这个命令后，你所喜欢的命令就会打印到Windbg上，你可以用鼠标选择执行这些命令。</p><p>例如在文件中分别写入：</p><blockquote><p>~*k<br>!address<br>!heap</p></blockquote><p><a href="/uploads/2015/10/20151005162754.png"><img src="/uploads/2015/10/20151005162754.png" alt="20151005162754"></a></p><hr><h4 id="hwnd"><a href="#hwnd" class="headerlink" title="!hwnd"></a>!hwnd</h4><blockquote><p>!hwnd            - Show window information by handle.</p></blockquote><p>这个命令很简单，可以输入窗口句柄为参数，查看窗口相关信息。主要作用是在内核调试的时候，用调试器看到窗口信息会比较方便。</p><hr><h4 id="url"><a href="#url" class="headerlink" title="!url"></a>!url</h4><blockquote><p>!url             - Open a URL in a default browser.</p></blockquote><p>这个命令会打开一个url，实际上他就是一个ShellExecute。Windbg本来就有.shell功能了，这个似乎是多余了一点。</p><hr><h4 id="init-script-env"><a href="#init-script-env" class="headerlink" title="!init_script_env"></a>!init_script_env</h4><blockquote><p>!init_script_env - Initialize script environment.</p></blockquote><p>这个命令是我给脚本准备的，他方便了脚本判断系统环境。如下图所示</p><p><a href="/uploads/2015/10/20151005163744.png"><img src="/uploads/2015/10/20151005163744.png" alt="20151005163744"></a></p><hr><h4 id="import-vs-bps"><a href="#import-vs-bps" class="headerlink" title="!import_vs_bps"></a>!import_vs_bps</h4><blockquote><p>!import_vs_bps   - Import visual studio breakpoints.</p></blockquote><p>这个命令可以将VS存储在suo文件的断点导入到Windbg中。我有的时候会碰到这样的情况，VS里设置了一堆断点，但是调试环境里只有Windbg，那么我需要把这些断点转移到Windbg，有了这个命令，我只需要将VS解决方案的suo文件拷贝到调试环境中，然后运行这条命令即可。</p><p>例如</p><blockquote><p>!import_vs_bps c:\proj\xxx.suo</p></blockquote><hr><h4 id="setvprot"><a href="#setvprot" class="headerlink" title="!setvprot"></a>!setvprot</h4><blockquote><p>!setvprot        - Set the protection on a region of committed pages in the<br>                     virtual address space of the debuggee process.</p></blockquote><p>这个命令能帮助我设置debuggee的内存属性，一个有趣的用法就是模仿Ollydbg的内存断点功能，比如给目标内存设置一个PAGE_GUARD属性，这样访问这部分内存的时候就会触发访问异常，调试器就能捕获到它了。</p><p>例如</p><blockquote><p>!setvprot 0x410000 0x1000 0x100</p></blockquote><hr><h4 id="pe-export-amp-pe-import"><a href="#pe-export-amp-pe-import" class="headerlink" title="!pe_export &amp; !pe_import"></a>!pe_export &amp; !pe_import</h4><blockquote><p>!pe_export       - Dump PE export functions<br>!pe_import       - Dump PE import modules and functions</p></blockquote><p>这两个命令可以分别帮助我们查看导出和导入函数，他们都支持通配符查找函数，在没有符号的情况下有时候会起到很好的作用。另外，他们配合好参数/b和.foreach命令，可以发挥出API Monitor的作用。</p><p>例如</p><blockquote><p>.foreach( place  { !pe_export /b kernel32 *Create* } ) { bp place “g” }</p></blockquote><hr><h4 id="wql"><a href="#wql" class="headerlink" title="!wql"></a>!wql</h4><blockquote><p>!wql             - Query system information with WMI.</p></blockquote><p>这也是我比较喜欢的一个功能，他可以在调试的时候通过WQL来查询系统的一些信息，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !0cchext.wql select * from win32_process where name&#x3D;&quot;explorer.exe&quot;</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">  Caption                                   local       CIM_STRING  explorer.exe</span><br><span class="line">  CommandLine                               local       CIM_STRING  C:\Windows\Explorer.EXE</span><br><span class="line">  CreationClassName                         local       CIM_STRING  Win32_Process</span><br><span class="line">  CreationDate                              local       CIM_DATETIME  2015-09-17 09:41:53.959</span><br><span class="line">  CSCreationClassName                       local       CIM_STRING  Win32_ComputerSystem</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ThreadCount                               local       CIM_UINT32  40</span><br><span class="line">  UserModeTime                              local       CIM_UINT64  605439881</span><br><span class="line">  VirtualSize                               local       CIM_UINT64  435580928</span><br><span class="line">  WindowsVersion                            local       CIM_STRING  6.1.7601</span><br><span class="line">  WorkingSetSize                            local       CIM_UINT64  109813760</span><br><span class="line">  WriteOperationCount                       local       CIM_UINT64  399</span><br><span class="line">  WriteTransferCount                        local       CIM_UINT64  1545945</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="logcmd"><a href="#logcmd" class="headerlink" title="!logcmd"></a>!logcmd</h4><blockquote><p>!logcmd          - Log command line to log file</p></blockquote><p>这个命令是一个开关，打开后，他会记录调试的命令到文件中，这样下次调试相同的程序的时候就不需要在此去输入这些命令了，只需要读取这个命令文件，就可以用鼠标点击执行命令了。</p><p><a href="/uploads/2015/10/20151005170422.png"><img src="/uploads/2015/10/20151005170422.png" alt="20151005170422"></a></p><hr><h4 id="dpx"><a href="#dpx" class="headerlink" title="!dpx"></a>!dpx</h4><blockquote><p>!dpx             - Display the contents of memory in the given range.</p></blockquote><p>这个命令是集dps dpa dpu大成者。他的会对目标指针做一个简单的判断，判断是符号，字符串，还是宽字符串。这样在我们查看栈信息的时候就不会漏掉一些有用的线索了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !dpx esp 100</span><br><span class="line">00c3f28c  7605cb33  [S] USER32!GetMessageA+0x53 (7605cb33)</span><br><span class="line">...</span><br><span class="line">00c3f2b4  012b6ca9  [S] usbview!WinMain+0xe3 (012b6ca9)</span><br><span class="line">...</span><br><span class="line">00c3f2f4  012ce723  [S] usbview!WinMainCRTStartup+0x151 (012ce723)</span><br><span class="line">00c3f2f8  01260000  [S] usbview!__guard_check_icall_fptr &lt;PERF&gt; (usbview+0x0) </span><br><span class="line">...</span><br><span class="line">00c3f320  01025618  [A] &quot;Winsta0\Default&quot;</span><br><span class="line">00c3f324  01025640  [A] &quot;C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\usbview.exe&quot;</span><br><span class="line">00c3f328  00000000  [D] ....</span><br></pre></td></tr></table></figure><hr><h4 id="dtx"><a href="#dtx" class="headerlink" title="!dtx"></a>!dtx</h4><blockquote><p>!dtx             - Displays information about structures. (The config file is<br>                     struct.ini)</p></blockquote><p>这个命令主要用在逆向工程的时候。因为逆向工程的时候，我们往往没有符号文件，就不可能直接知道内存数据的结构是什么样子的，我们需要自己通过代码推断出来。在IDA中，我们可以自己设置结构体帮助分析。但是在Windbg中，并没有一个功能能方便的帮助我们用这推断的结构体去显示内存。不可否认我们其实可以用其他的办法来完成这个目的，但操作很繁琐。那么这个命令就解决了这些问题。我们可以在struct.ini文件中写入我们推断的结构体，然后通过这个命令去打印内存数据。当然，这个文件也必须在0cchext.dll的同目录下。</p><p><a href="/uploads/2015/10/20151005172455.png"><img src="/uploads/2015/10/20151005172455.png" alt="20151005172455"></a></p><p>到目前位置脚本解析器支持的基本类型有BYTE WORD DWORD CHAR WCHAR，支持数组和指针，支持结构体嵌套，有了这些，对于基本的逆向就能够满足需求了。</p><hr><p>现在0cchext.dll就是这些命令了，我也会根据自己的需求继续添加命令，如果你有什么有趣或者实用的想法，可以通过邮件或者留言告诉我。</p>]]></content>
      
      
      <categories>
          
          <category> debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Foxmail无法响应</title>
      <link href="/2015/09/07/foxmail-hung/"/>
      <url>/2015/09/07/foxmail-hung/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Foxmail是一款不错的邮件客户端软件，小巧实用，我在公司就是用的它。早上一如既往的先打开Foxmail，然后去倒杯水，回来发现Foxmail还在收取邮件的状态，“这也太慢了”，我心想。用鼠标点了点，出现了程序挂起的特征，标题栏上显示无法响应，程序界面变白。经验告诉我挂起的问题70%都还是比较容易调的，好吧，就让我看看这是怎么回事。</p><p>打开Windbg，Attach到Foxmail上，习惯做的第一件事情就是保存Full dump</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.dump &#x2F;ma &#x2F;u e:\foxmail.dmp</span><br></pre></td></tr></table></figure><p>由于程序的主界面出现了挂起的现象，而一般情况下主线程就是程序的界面线程，所以此时根本没必要去查看所有线程的情况，直接看看主线程的栈信息吧。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; k</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line">0018f454 770fd993 ntdll!ZwWaitForSingleObject+0x15</span><br><span class="line">0018f4b8 770fd877 ntdll!RtlpWaitOnCriticalSection+0x13e</span><br><span class="line">0018f4e0 770f84ca ntdll!RtlEnterCriticalSection+0x150</span><br><span class="line">0018f514 76734e8c ntdll!RtlLockHeap+0x3d</span><br><span class="line">0018f558 004091af KERNELBASE!GlobalAlloc+0x92</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">0018f578 0042bf97 Foxmail+0x91af</span><br><span class="line">0018f588 0042c115 Foxmail+0x2bf97</span><br><span class="line">0018f5a4 007c5f25 Foxmail+0x2c115</span><br><span class="line">0018f9fc 007c50ce Foxmail+0x3c5f25</span><br><span class="line">0018fa34 007c516a Foxmail+0x3c50ce</span><br><span class="line">0018fa44 007c9e57 Foxmail+0x3c516a</span><br><span class="line">0018faac 007ca28b Foxmail+0x3c9e57</span><br><span class="line">0018fae0 007c9370 Foxmail+0x3ca28b</span><br><span class="line">0018fb10 007ca3fb Foxmail+0x3c9370</span><br><span class="line">0018fb1c 00dd8a96 Foxmail+0x3ca3fb</span><br><span class="line">0018fb44 007c93bb Foxmail+0x9d8a96</span><br><span class="line">0018fb64 007c9479 Foxmail+0x3c93bb</span><br><span class="line">0018fba8 00dd0492 Foxmail+0x3c9479</span><br><span class="line">0018fcd4 00dd019d Foxmail+0x9d0492</span><br><span class="line">0018fd00 00dd454a Foxmail+0x9d019d</span><br><span class="line">0018fd44 00dcf20d Foxmail+0x9d454a</span><br><span class="line">0018fd60 007ca59d Foxmail+0x9cf20d</span><br><span class="line">0018fd84 0044e9d6 Foxmail+0x3ca59d</span><br><span class="line">0018fd94 0044e844 Foxmail+0x4e9d6</span><br><span class="line">0018fdbc 00434a96 Foxmail+0x4e844</span><br><span class="line">0018fdd4 74aa62fa Foxmail+0x34a96</span><br><span class="line">0018fe00 74aa6d3a user32!InternalCallWinProc+0x23</span><br><span class="line">0018fe78 74aa77c4 user32!UserCallWinProcCheckWow+0x109</span><br><span class="line">0018fed8 74aa7bca user32!DispatchMessageWorker+0x3bc</span><br><span class="line">0018fee8 00dc5e7a user32!DispatchMessageA+0xf</span><br><span class="line">0018ff04 00dc5ee4 Foxmail+0x9c5e7a</span><br><span class="line">0018ff2c 00dc61bf Foxmail+0x9c5ee4</span><br><span class="line">0018ff5c 00ded3a0 Foxmail+0x9c61bf</span><br><span class="line">0018ff88 75b9336a Foxmail+0x9ed3a0</span><br><span class="line">0018ff94 770f9882 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">0018ffd4 770f9855 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">0018ffec 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure><p>可以看到界面线程调用GlobalAlloc的时候在等HeapLock被释放。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; kb L5</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">0018f454 770fd993 00000698 00000000 00000000 ntdll!ZwWaitForSingleObject+0x15</span><br><span class="line">0018f4b8 770fd877 00000000 00000000 00000000 ntdll!RtlpWaitOnCriticalSection+0x13e</span><br><span class="line">0018f4e0 770f84ca 014d0138 0044e9b8 0018f4ac ntdll!RtlEnterCriticalSection+0x150</span><br><span class="line">0018f514 76734e8c 014d0000 4d5402d1 00000000 ntdll!RtlLockHeap+0x3d</span><br><span class="line">0018f558 004091af 00000002 00002000 0042c07c KERNELBASE!GlobalAlloc+0x92</span><br></pre></td></tr></table></figure><p>那么014d0138比如是默认堆的Critical Section了。来看看这个cs的数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !cs 014d0138 </span><br><span class="line">*************************************************************************</span><br><span class="line">***                                                                   ***</span><br><span class="line">***                                                                   ***</span><br><span class="line">***    Either you specified an unqualified symbol, or your debugger   ***</span><br><span class="line">***    doesn&#39;t have full symbol information.  Unqualified symbol      ***</span><br><span class="line">***    resolution is turned off by default. Please either specify a   ***</span><br><span class="line">***    fully qualified symbol module!symbolname, or enable resolution ***</span><br><span class="line">***    of unqualified symbols by typing &quot;.symopt- 100&quot;. Note that   ***</span><br><span class="line">***    enabling unqualified symbol resolution with network symbol     ***</span><br><span class="line">***    server shares in the symbol path may cause the debugger to     ***</span><br><span class="line">***    appear to hang for long periods of time when an incorrect      ***</span><br><span class="line">***    symbol name is typed or the network symbol server is down.     ***</span><br><span class="line">***                                                                   ***</span><br><span class="line">***    For some commands to work properly, your symbol path           ***</span><br><span class="line">***    must point to .pdb files that have full type information.      ***</span><br><span class="line">***                                                                   ***</span><br><span class="line">***    Certain .pdb files (such as the public OS symbols) do not      ***</span><br><span class="line">***    contain the required information.  Contact the group that      ***</span><br><span class="line">***    provided you with these symbols if you need this command to    ***</span><br><span class="line">***    work.                                                          ***</span><br><span class="line">***                                                                   ***</span><br><span class="line">***    Type referenced: ntdll!_RTL_CRITICAL_SECTION                   ***</span><br><span class="line">***                                                                   ***</span><br><span class="line">*************************************************************************</span><br><span class="line">Bad symbols for NTDLL (error 3). Aborting.</span><br></pre></td></tr></table></figure><p>嗯，ntdll的符号文件的结构体信息没有了！这个问题发生在2015年7月份的，安装KB3071756和KB3060716补丁后产生的。详情可以查看<br><a href="http://www.osronline.com/showthread.cfm?link=269221">http://www.osronline.com/showthread.cfm?link=269221</a></p><p>既然新的符号不让用，那就只有用老的了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; .reload &#x2F;f &#x2F;i E:\WorkSpace\MySymbols\ntdll.dll\49900AFA96000\ntdll.dll&#x3D;77ffe000   </span><br><span class="line">0:000&gt; lm m ntdll*</span><br><span class="line">start    end        module name</span><br><span class="line">770c0000 77240000   ntdll      (pdb symbols)          e:\workspace\mysymbols\wntdll.pdb\FA9C48F9C11D4E0894B8970DECD92C972\wntdll.pdb</span><br><span class="line">77ffe000 78094000   ntdll_77ffe000   (pdb symbols)          e:\workspace\mysymbols\ntdll.pdb\6992F4DAF4B144068D78669D6CB5D2072\ntdll.pdb</span><br><span class="line">0:000&gt; dt ntdll_77ffe000!_RTL_CRITICAL_SECTION 014d0138</span><br><span class="line">   +0x000 DebugInfo        : 0x771c4960 _RTL_CRITICAL_SECTION_DEBUG</span><br><span class="line">   +0x004 LockCount        : 0n-30</span><br><span class="line">   +0x008 RecursionCount   : 0n1</span><br><span class="line">   +0x00c OwningThread     : 0x00001730 Void</span><br><span class="line">   +0x010 LockSemaphore    : 0x00000698 Void</span><br><span class="line">   +0x014 SpinCount        : 0xfa0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好了，这样就够用了。可以看到TID=1730的线程正在占用这个cs，马上去看看这个线程在干什么。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0:041&gt; k</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line">06e1f214 770fd993 ntdll!ZwWaitForSingleObject+0x15</span><br><span class="line">06e1f278 770fd877 ntdll!RtlpWaitOnCriticalSection+0x13e</span><br><span class="line">06e1f2a0 770f84ca ntdll!RtlEnterCriticalSection+0x150</span><br><span class="line">06e1f2d4 7717fd7d ntdll!RtlLockHeap+0x3d</span><br><span class="line">06e1f3bc 7714de8e ntdll!RtlpQueryExtendedHeapInformation+0xbd</span><br><span class="line">06e1f3fc 7716476b ntdll!RtlQueryHeapInformation+0x4a</span><br><span class="line">06e1f4a0 77143320 ntdll!RtlQueryProcessHeapInformation+0x288</span><br><span class="line">06e1f51c 75c15f4b ntdll!RtlQueryProcessDebugInformation+0x28a</span><br><span class="line">Unable to load image D:\Program Files\Foxmail 7.2\libeay32.dll, Win32 error 0n2</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to export symbols for libeay32.dll - </span><br><span class="line">06e1f54c 0606ad6a kernel32!Heap32Next+0x4d</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">06e1fab0 06069c77 libeay32!RAND_poll+0x5fa</span><br><span class="line">06e1facc 06023db7 libeay32!RAND_SSLeay+0x447</span><br><span class="line">06e1fb00 06069f71 libeay32!CRYPTO_set_ex_data_implementation+0x387</span><br><span class="line">00000000 00000000 libeay32!RAND_SSLeay+0x741</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从栈的信息看来，这个线程是OpenSSL的一个线程，正在做随机数处理，而枚举Heap的信息应该也是随机数的一个组成部分。在枚举Heap的时候也处于等待一个HeapLock的情况，来具体看看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:041&gt; kb L5</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">06e1f214 770fd993 00000b10 00000000 00000000 ntdll!ZwWaitForSingleObject+0x15</span><br><span class="line">06e1f278 770fd877 00000000 00000000 06e1f428 ntdll!RtlpWaitOnCriticalSection+0x13e</span><br><span class="line">06e1f2a0 770f84ca 04560138 00000000 00000000 ntdll!RtlEnterCriticalSection+0x150</span><br><span class="line">06e1f2d4 7717fd7d 04560000 71edefe5 06e1f468 ntdll!RtlLockHeap+0x3d</span><br><span class="line">06e1f3bc 7714de8e 06e1f428 771640d3 00000000 ntdll!RtlpQueryExtendedHeapInformation+0xbd</span><br></pre></td></tr></table></figure><p>看来正在等一个基地址是04560000的Heap的cs。顺藤摸瓜看看这个cs又被谁占用了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:041&gt; dt ntdll_77ffe000!_RTL_CRITICAL_SECTION 04560138 </span><br><span class="line">   +0x000 DebugInfo        : 0x0151df40 _RTL_CRITICAL_SECTION_DEBUG</span><br><span class="line">   +0x004 LockCount        : 0n-6</span><br><span class="line">   +0x008 RecursionCount   : 0n1</span><br><span class="line">   +0x00c OwningThread     : 0x00001994 Void</span><br><span class="line">   +0x010 LockSemaphore    : 0x00000b10 Void</span><br><span class="line">   +0x014 SpinCount        : 0xfa0</span><br></pre></td></tr></table></figure><p>继续看看0x00001994这个线程在做什么事情</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:002&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">0438d2c4 770fd993 00000698 00000000 00000000 ntdll!ZwWaitForSingleObject+0x15</span><br><span class="line">0438d328 770fd877 00000000 00000000 014d0000 ntdll!RtlpWaitOnCriticalSection+0x13e</span><br><span class="line">0438d350 770fdaf8 014d0138 7334c875 00078000 ntdll!RtlEnterCriticalSection+0x150</span><br><span class="line">0438d42c 770f2fe3 000001f8 00000200 00000000 ntdll!RtlpAllocateHeap+0x159</span><br><span class="line">0438d4b0 770f7bfb 014d0000 00800000 000001f8 ntdll!RtlAllocateHeap+0x23a</span><br><span class="line">0438d4fc 770f70f1 00000028 7334c9d5 07240048 ntdll!RtlpAllocateUserBlock+0xae</span><br><span class="line">0438d58c 770ee0e2 07240048 07240048 00000000 ntdll!RtlpLowFragHeapAllocFromContext+0x802</span><br><span class="line">0438d600 770f8129 014d0000 00000000 00000020 ntdll!RtlAllocateHeap+0x206</span><br><span class="line">0438d610 770f3f21 04560000 07240048 00000000 ntdll!RtlpAllocateDebugInfo+0x28</span><br><span class="line">0438d64c 770f4262 07240048 00000000 00000000 ntdll!RtlInitializeCriticalSectionEx+0x93</span><br><span class="line">0438d660 771031e2 07240048 07240048 04560000 ntdll!RtlInitializeCriticalSection+0x12</span><br><span class="line">0438d674 771031b0 00000000 00000800 04560000 ntdll!RtlpInitializeLowFragHeap+0x28</span><br><span class="line">0438d684 77102f5a 7334cae5 045600cc 04560000 ntdll!RtlpCreateLowFragHeap+0x28</span><br><span class="line">0438d6bc 77103002 04560000 04560194 0438d7a8 ntdll!RtlpActivateLowFragmentationHeap+0xc9</span><br><span class="line">0438d6cc 77102fce 04560000 7334cbf1 00000000 ntdll!RtlpPerformHeapMaintenance+0x2a</span><br><span class="line">0438d7a8 770f2fe3 00000008 00000010 04560194 ntdll!RtlpAllocateHeap+0x172</span><br><span class="line">0438d82c 6fef1e62 04560000 00000008 00000008 ntdll!RtlAllocateHeap+0x23a</span><br><span class="line">0438d844 6fef20f9 0438d858 04560984 00000007 nlaapi!NlapAllocNlaDataSet+0x18</span><br><span class="line">0438d85c 6fef2096 00000007 00000003 045608f0 nlaapi!QueryCtxtDeserializeTuplesToTrieMap+0x20</span><br><span class="line">0438d888 6fef23a7 045608f0 000003c8 04560958 nlaapi!QueryCtxtDeserializeEntityToTrieMap+0x38</span><br><span class="line">0438d924 6fef58e0 7972514e 00000001 00000000 nlaapi!NLA_QUERY_HANDLE_completion_internal+0x21f</span><br><span class="line">0438d944 6fef5cd7 00000000 00000000 0c7507d0 nlaapi!NlaRegisterQuery+0x7d</span><br><span class="line">0438d99c 6fef5bac 044907d0 4e3f415a 014587b0 nlaapi!GetNlaV2Handle+0x7e</span><br><span class="line">0438d9d0 769d59b1 01435244 0438db88 044907d0 nlaapi!WSM_NSPLookupServiceBegin_v2+0xc9</span><br><span class="line">0438d9ec 769d598d 01435208 0438db88 00000000 ws2_32!NSPROVIDER::NSPLookupServiceBegin+0x1b</span><br><span class="line">0438da08 769d591c 01458960 0438db88 00000000 ws2_32!NSPROVIDERSTATE::LookupServiceBegin+0x1d</span><br><span class="line">0438da6c 769d57cc 014587b0 0438db88 00000ff0 ws2_32!NSQUERY::LookupServiceBegin+0x18d</span><br><span class="line">0438dabc 0fd7fca2 0438db88 00000ff0 0438dbd0 ws2_32!WSALookupServiceBeginW+0x7f</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">0438dd18 0fd0c6a1 0fa9df49 03ac9c20 03b5da80 libcef!cef_time_delta+0x3ddc22</span><br><span class="line">0438e2f0 0fa9ec71 0438e698 03a91e00 0438e310 libcef!cef_time_delta+0x36a621</span><br><span class="line">0438e37c 0fa8d58f 0438e698 03ac9c00 03b5da80 libcef!cef_time_delta+0xfcbf1</span><br><span class="line">0438eb88 0fa9915f 0438ebc8 fffffffe ffffffff libcef!cef_time_delta+0xeb50f</span><br><span class="line">0438ebe8 0fb3605d 03b5da80 fffffffe 03ac9d20 libcef!cef_time_delta+0xf70df</span><br><span class="line">0438ec04 0fb3744d 03b5da80 fffffffe fffffffe libcef!cef_time_delta+0x193fdd</span><br><span class="line">0438ecd8 0fb37ad2 00000003 fffffffe 00000000 libcef!cef_time_delta+0x1953cd</span><br><span class="line">0438edc0 0fb37f5d 03ac9400 11c9bee1 03ac9400 libcef!cef_time_delta+0x195a52</span><br><span class="line">0438edfc 0fa9ab19 03ac9400 03ac9c38 03ac9c00 libcef!cef_time_delta+0x195edd</span><br><span class="line">0438f20c 0fa9b466 03ac9400 00000000 03ac9c38 libcef!cef_time_delta+0xf8a99</span><br><span class="line">0438f220 0fb3c815 00000000 03ac9400 0fb3aee5 libcef!cef_time_delta+0xf93e6</span><br><span class="line">0438f2e8 0fb3d2e3 00000000 03b53384 03ac9c38 libcef!cef_time_delta+0x19a795</span><br><span class="line">0438f690 0fb3ad7b 0438f600 03b53384 03b2ddc0 libcef!cef_time_delta+0x19b263</span><br><span class="line">0438f8ac 0f985613 0438fb64 03b53384 00000001 libcef!cef_time_delta+0x198cfb</span><br><span class="line">0438fbec 0f98016a ffffffff ffffffff 03b53368 libcef!cef_string_multimap_free+0x18b63</span><br><span class="line">0438fc28 0fa208a4 03b53340 03ac0dd0 03a87b00 libcef!cef_string_multimap_free+0x136ba</span><br><span class="line">0438fd70 0fa223ba 0438fdd0 03a878c0 03ac0d00 libcef!cef_time_delta+0x7e824</span><br><span class="line">0438fe0c 0fa4edfc 00000000 03a878c0 03ac0dd0 libcef!cef_time_delta+0x8033a</span><br><span class="line">0438fe3c 0fa4ec2e 00000000 03ac0dd0 03ac0dd0 libcef!cef_time_delta+0xacd7c</span><br><span class="line">0438fe5c 0fa2177f 03ac0dd0 0438ff34 03ac0dd0 libcef!cef_time_delta+0xacbae</span><br><span class="line">0438ff24 0fa3a323 03a8d7d0 0fa1fc56 03ac0dd0 libcef!cef_time_delta+0x7f6ff</span><br><span class="line">0438ff50 0fa39b9b 0438ff74 0fa39c6a 03ac0dd0 libcef!cef_time_delta+0x982a3</span><br><span class="line">0438ff58 0fa39c6a 03ac0dd0 03a80f40 03a8d7d0 libcef!cef_time_delta+0x97b1b</span><br><span class="line">0438ff74 0fa22ad8 00000000 00000000 03a80f40 libcef!cef_time_delta+0x97bea</span><br><span class="line">0438ff88 75b9336a 000001a8 0438ffd4 770f9882 libcef!cef_time_delta+0x80a58</span><br><span class="line">0438ff94 770f9882 03a80f40 7334e38d 00000000 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">0438ffd4 770f9855 0fa22a80 03a80f40 00000000 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">0438ffec 00000000 0fa22a80 03a80f40 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个线程正在为04560000这个heap创建LowFragHeap，但是在获取014d0138的cs的时候被卡住了。这里就发现问题所在了！014d0138不正是我们主线程在等待的cs么，这个线程的10f0和1994都在等待1730的cs=014d0138，而1730却在等待1994的cs=04560138。</p><p><a href="/uploads/2015/09/20150908002438.png"><img src="/uploads/2015/09/20150908002438.png" alt="20150908002438"></a></p><p>反汇编RtlpQueryExtendedHeapInformation就能知道这里造成死锁的真正原因。实际上Heap32Next函数枚举所有Heap信息的时候，先统一锁住进程里面所有的Heap，然后做枚举工作，最后再统一释放锁。所以它在正在锁住所有HeapLock过程中的时候，例如锁住了一半，正在尝试锁住另一半，另外一个线程正好拥有他没锁住的HeapLock，但是不巧的时候他在给这个Heap创建LowFragHeap，而创建LowFragHeap需要初始化HeapLock，其中HeapLock的DebugInfo又是用默认Heap去分配内存的，默认堆的锁正好在第一个线程被锁住的那一半里，这就是事情的真相！</p><p>那么微软为什么要提供一个会造成死锁的API，而且不去修复呢？按照Raymond的说法，这个系列的函数目的只是诊断，性能很低，不应该用于普通程序中。<br><a href="http://blogs.msdn.com/b/oldnewthing/archive/2012/03/23/10286665.aspx">http://blogs.msdn.com/b/oldnewthing/archive/2012/03/23/10286665.aspx</a><br>但是，我觉得既然是文档化的接口，而且文档里面没有提到会造成死锁，那么它就应该是安全的。</p>]]></content>
      
      
      <categories>
          
          <category> debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>介绍三个有趣的API</title>
      <link href="/2015/08/27/3-interesting-API/"/>
      <url>/2015/08/27/3-interesting-API/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>####PickIconDlg</p><p>相信给快捷方式指定过图标的朋友肯定看过一个这样的对话框吧，如果你看到过，你肯定已经知道了这个API是怎么一回事。这个API会弹出一个选择图标的窗口给你选择，确定后返回图标在资源中的索引值。这样你可以通过这个索引值和ExtractIcon函数获得这个图标的句柄。</p><p><a href="/uploads/2015/08/20150827113011.png"><img src="/uploads/2015/08/20150827113011.png" alt="20150827113011"></a></p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Index = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> DWORD BuffSize = MAX_PATH;</span><br><span class="line">TCHAR Path[BuffSize] = _T(<span class="string">&quot;c:\\windows\\system32\\shell32.dll&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Sel = <span class="built_in">PickIconDlg</span>(<span class="literal">NULL</span>, Path, BuffSize, &amp;Index);</span><br><span class="line"><span class="keyword">if</span>(Sel)</span><br><span class="line">&#123;</span><br><span class="line">    HMODULE hMod = ::<span class="built_in">LoadLibrary</span>(Path);</span><br><span class="line">    HICON hIcon = <span class="built_in">ExtractIcon</span>(hMod, Path, Index);</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hMod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>####WNetConnectionDialog和WNetConnectionDialog1</p><p>这两个函数是帮助我们在程序中显示映射网络驱动器对话框的，虽然用的不多，但是也应该见到过它。这两个函数区别不大，只不过WNetConnectionDialog1比WNetConnectionDialog提供了更多的参数去设置。</p><p><a href="/uploads/2015/08/20150827114516.png"><img src="/uploads/2015/08/20150827114516.png" alt="20150827114516"></a></p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Mpr.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">CONNECTDLGSTRUCT condlg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">condlg.cbStructure = <span class="built_in"><span class="keyword">sizeof</span></span>(condlg);</span><br><span class="line">condlg.hwndOwner = <span class="built_in">GetConsoleWindow</span>();</span><br><span class="line">condlg.dwFlags =  CONNDLG_USE_MRU;</span><br><span class="line"></span><br><span class="line">NETRESOURCE nr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">nr.dwScope = RESOURCE_GLOBALNET;</span><br><span class="line">nr.dwType = RESOURCETYPE_DISK;</span><br><span class="line">nr.lpRemoteName = <span class="literal">NULL</span>;</span><br><span class="line">nr.dwDisplayType = RESOURCEDISPLAYTYPE_DOMAIN;</span><br><span class="line"></span><br><span class="line">condlg.lpConnRes = &amp;nr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> RetVal = <span class="built_in">WNetConnectionDialog1</span>(&amp;condlg);</span><br></pre></td></tr></table></figure><hr><p>####SHOpenWithDialog</p><p>这个API所显示的对话框我们应该是最多见的，它显示了一个打开方式的对话框。不过有点可惜的是，XP并不支持这个API，我们只能将它用在Vista开始的系统上。</p><p><a href="/uploads/2015/08/20150827115225.png"><img src="/uploads/2015/08/20150827115225.png" alt="20150827115225"></a></p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OPENASINFO Info = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Info.pcszFile = _T(<span class="string">&quot;C:\\Windows\\win.ini&quot;</span>);</span><br><span class="line">Info.oaifInFlags = OAIF_EXEC | OAIF_ALLOW_REGISTRATION;</span><br><span class="line"><span class="built_in">SHOpenWithDialog</span>(<span class="literal">NULL</span>, &amp;Info);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OleFileView 查看Ole文件数据结构的工具</title>
      <link href="/2015/08/03/ole-file-view-tool/"/>
      <url>/2015/08/03/ole-file-view-tool/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>OleFileView是一个查看结构化存储文件的工具，我们熟悉的Ole存储的文件就是这种格式，虽然很老了，但是依旧被广泛使用，例如老版本Office的文件doc，xls等，包括msi，jumplist等，都是采用的这种格式。<br>所以我也就抽了点时间研究了一下这个数据结构，可以说这就是个小型的文件系统，虽然比不上NTFS，但是对于一般的存储可以说是小菜一碟。</p><p><a href="/uploads/2015/08/20150803003316.png"><img src="/uploads/2015/08/20150803003316.png" alt="20150803003316"></a></p><p>下载：<a href="/uploads/2015/08/OleFileView.zip">OleFileView.zip</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用WMI监控进程创建和结束</title>
      <link href="/2015/07/13/monitor-process-with-wmi/"/>
      <url>/2015/07/13/monitor-process-with-wmi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Windows Management Instrumentation (WMI) 是微软实现的一套可以通过网页管理计算机的系统，我们可以通过WMI查询计算机的方方面面。从Vista开始，这个机制增加了Instance Event的提醒机制，这个机制可以帮助我们监控各种Instance的创建、删除和修改。所以，我们可以想到的是进程也是在WMI里的Win32_Process有Instance的记录，这样我们就可以跟踪到进程的创建和结束了。当然，我们还可能监控到文件等等WMI里的各种Instance。下面是一个监控进程的例子：</p><p><a href="/uploads/2015/05/20150712232158.png"><img src="/uploads/2015/07/20150712232158.png" alt="20150712232158"></a></p><p>下载：<a href="/uploads/2015/07/MonitorProcessWithWMI.zip">MonitorProcessWithWMI.zip</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用Windbg script将内存中的PE文件dump出来</title>
      <link href="/2015/07/01/dump-pe-with-windbg-script/"/>
      <url>/2015/07/01/dump-pe-with-windbg-script/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近看到有些恶意程序，从网络上下载PE文件后，直接放在内存里重定位和初始化，为了能将其dump出来，所以写了这个Windbg脚本。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.foreach( place  &#123; !address &#x2F;f:VAR,MEM_PRIVATE,MEM_COMMIT &#x2F;c:&quot;s -[1]a %1 %2 \&quot;MZ\&quot;&quot; &#125; ) </span><br><span class="line">&#123;</span><br><span class="line">    ad *</span><br><span class="line">    .catch &#123;</span><br><span class="line">        r @$t2 &#x3D; place;</span><br><span class="line">        r @$t0 &#x3D; place;</span><br><span class="line">        r @$t1 &#x3D; @@C++(((ntdll!_IMAGE_DOS_HEADER *)@$t0)-&gt;e_lfanew);</span><br><span class="line">        r @$t0 &#x3D; @$t0 + @$t1;</span><br><span class="line">        r @$t1 &#x3D; $vvalid(@$t0, 4);</span><br><span class="line"></span><br><span class="line">        .if (@@C++(@$t1 &amp;&amp; @@C++(((ntdll!_IMAGE_NT_HEADERS *)@$t0)-&gt;Signature) &#x3D;&#x3D; 0x00004550))</span><br><span class="line">        &#123;</span><br><span class="line">            r @$t1 &#x3D; @@C++(((ntdll!_IMAGE_NT_HEADERS *)@$t0)-&gt;OptionalHeader.SizeOfImage);</span><br><span class="line">            .printf &quot;%08x  %08x\n&quot;, @$t2, @$t1;</span><br><span class="line">            aS &#x2F;x start_addr @$t2</span><br><span class="line">            aS &#x2F;x dump_size @$t1</span><br><span class="line">            .block &#123;</span><br><span class="line">                aS target_file e:\\$&#123;start_addr&#125;.dll</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            .block &#123;</span><br><span class="line">                .printf &quot;$&#123;target_file&#125;&quot;</span><br><span class="line">                .writemem &quot;$&#123;target_file&#125;&quot; $&#123;start_addr&#125; L?$&#123;dump_size&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>将blog迁移到了jekyll</title>
      <link href="/2015/06/28/move-blog-to-jekyll/"/>
      <url>/2015/06/28/move-blog-to-jekyll/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上周终于下定决心把blog从<a href="http://0cch.net/">wordpress</a>转到<a href="http://0cch.com/">jekyll</a>，不是因为wordpress臃肿，也不是因为jekyll的更加Geek，纯粹是因为穷。我一直都觉得wordpress是一个非常伟大的blog程序，虽然臃肿了点，但确实功能强大操作简单，对于我这种懒人和对前端代码完全不熟的程序员来说，wordpress确实是一个非常好的选择。但是问题就出在了webhost上，我使用的webhost刚刚买的时候是50多刀一年，之后每年涨价，今年续费看了下需要100刀左右，这个确实让我心中无数的羊驼奔腾了起来。于是就决定把blog搬离这个地方。</p><p>刚开始我只是想找便宜的地方转移wordpress的blog。网上也有很多这类的webhost，第一年进去都很便宜，甚至有1刀一个月的。但是一朝被蛇咬啊，为了防止以后又被迫搬家，于是打消了这个念头。想要便宜和稳定的blog空间，看来是只有伟大的Github。而Github只支持静态程序，那么我也只能放弃wordpress的方便，自己折腾点静态博客程序了。摆在眼前的选择其实很多最基础jekyll，加强版的octopress以及hexo。第一个程序的优点就是简单基础，缺点就是太基础了，而octopress在jekyll的基础之上加上了一些插件，让blog默认的功能变得丰富起来。之后hexo，也是一个自带很多基础功能的程序而且还带了很多非常漂亮的主题，主题控的bloger不妨选择这个，我就特别喜欢他其中的一个默认主题，但是折腾样式的时候jekyll的基本结构都搭建好了，所以就没有更换hexo程序，于是极度痛苦的折腾了一周的css和ruby插件才把现在的blog折腾的和之前的差不多。</p><p>简单说下用jekyll在Github上搭建blog的步骤，其实网上很多很多教程，这里记录下就是防止自己忘了把。  </p><ol><li>首先在<a href="http://rubyinstaller.org/downloads/">http://rubyinstaller.org/downloads/</a>下载ruby和DevKit，安装分别安装他们，然后运行Devkit，分别执行：    <ol><li>dk.rb init  </li><li>dk.rb review  </li><li>dk.rb install  </li></ol></li><li>接下来就是安装jekyll了，安装之前推荐更换Gem的源到<a href="https://ruby.taobao.org/">https://ruby.taobao.org/</a> 这样下载程序比较快。具体方式是：  <ol><li>gem source -r (url)  </li><li>gem source -a (new url)  </li><li>gem source -u  </li></ol></li><li>然后就可以开始下载jekyll和他的代码高亮程序rouge了，gem install (app name)  </li><li>最后记得要设置_config.yml文件，尤其是高亮highlighter: rouge</li></ol><p>这样，最基础功能的blog就搭建好了，接下来就是把blog从wordpress转移到jekyll了。方法是使用exitwp这个python脚本。  </p><ol><li>先导出wordpress的数据到一个xml里，这个功能wordpress是自带的。  </li><li>然后同个这个脚本把数据转换成markdown文件，放在jekyll生产的_post里面。并且把里面的图片和下载的url替换了。  </li><li>最后把wordpress的upload目录下载下来，放到jekyll里面即可。</li></ol><p>这样我们看到的就是一个最简单的jekyll的blog，要想改变主题，自己去折腾吧。我能做的就是推荐两个jekyll的插件，分别是按日期和分类生成归档网页的，可以在我的<a href="https://github.com/0cch/0CChBlog/tree/master/_plugins">Github</a>上看到。</p><p>最后要说的是rouge语法高亮有个bug，在使用显示行号linenos参数的时候会出现嵌套错误的问题，解决方法倒是有，不过有了行号之后高亮的显示极其丑陋，所以还是我还是没用这个参数。如果有需求可以使用代码<a href="https://gist.github.com/0cch/775e4a8a94be175cae9c">rouge_linenos_patch.rb</a>覆盖”\lib\ruby\gems\2.2.0\gems\jekyll-2.5.3\lib\jekyll\tags\highlight.rb”里对应的函数即可。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Zone.Identifier的一点记录</title>
      <link href="/2015/06/15/e585b3e4ba8ezone-identifiere79a84e4b880e782b9e8aeb0e5bd95/"/>
      <url>/2015/06/15/e585b3e4ba8ezone-identifiere79a84e4b880e782b9e8aeb0e5bd95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>自从Windows XP SP2开始，微软对文件加入了Zone.Identifier的数据流，所以这个也不算什么新东西了，最近偶然有机会研究了下所以就记录了下来。<br>说起Zone.Identifier，我们最常见的应用就是在我们从Internet上下载了可执行文件后，运行的时候会弹出如下图的警告窗口：</p><p><a href="/uploads/2015/06/20150615150628.png"><img src="/uploads/2015/06/20150615150628.png" alt="20150615150628"></a></p><p>弹出这个窗口就是因为Explorer在运行这个文件的时候先检查了Zone.Identifier的数据，发现了如下文本<br>[ZoneTransfer]<br>ZoneId=3</p><p>这个ZoneId=3，就是指明这个文件是由Internet上下载的。根据MSDN，这个id有以下几种：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">tagURLZONE</span> &#123;</span> </span><br><span class="line">  URLZONE_INVALID         = <span class="number">-1</span>,</span><br><span class="line">  URLZONE_PREDEFINED_MIN  = <span class="number">0</span>,</span><br><span class="line">  URLZONE_LOCAL_MACHINE   = <span class="number">0</span>,</span><br><span class="line">  URLZONE_INTRANET,</span><br><span class="line">  URLZONE_TRUSTED,</span><br><span class="line">  URLZONE_INTERNET,</span><br><span class="line">  URLZONE_UNTRUSTED,</span><br><span class="line">  URLZONE_PREDEFINED_MAX  = <span class="number">999</span>,</span><br><span class="line">  URLZONE_USER_MIN        = <span class="number">1000</span>,</span><br><span class="line">  URLZONE_USER_MAX        = <span class="number">10000</span></span><br><span class="line">&#125; URLZONE; </span><br></pre></td></tr></table></figure><p>查看这个数据流的方法也很简单，用notepad就行了。</p><p><a href="/uploads/2015/06/20150615153805.png"><img src="/uploads/2015/06/20150615153805.png" alt="20150615153805"></a></p><p>另外如果想给添加或者去除这个数据流，我们这里有两种方法：<br>1.直接读写数据流，其实这个跟普通文件读写没什么两样。<br>2.调用微软提供的com接口，这个比较是规范的。  </p><p>对于第一种方法，没什么可说的，无非就是文件操作的那些API。第二种方法我们需要用到以下两个接口：<br>IPersistFile<br>IZoneIdentifier</p><p>我们先创建IZoneIdentifier接口，然后query出IPersistFile打开文件，最后读取或者写入文件。<br>代码详见：<a href="http://blogs.msdn.com/b/oldnewthing/archive/2013/11/04/10463035.aspx">http://blogs.msdn.com/b/oldnewthing/archive/2013/11/04/10463035.aspx</a></p><p>最后说一下，之所以能有Zone.Identifier这种功能，完全依赖于NTFS文件系统，它允许多个数据流的存在，对它而言，每个数据流无非就是一个属性而已，只不过Zone.Identifier是一个名字为Zone.Identifier的数据流，而文件本身的数据是一个没有命名的数据流而已。用ntfs_study查看，如下图，第一个Data数据没有名字是文件本身的数据，第二个就是Zone.Identifier的数据了。<br><a href="/uploads/2015/06/20150615160110.png"><img src="/uploads/2015/06/20150615160110.png" alt="20150615160110"></a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 8 SpellChecking API</title>
      <link href="/2015/05/18/windows-8-spellchecking-api/"/>
      <url>/2015/05/18/windows-8-spellchecking-api/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在Windows 8下，多了一套很有趣的API，SpellChecking，这套API的作用也是一目了然，是做拼写检查的。这么有趣的一套API怎么能不写个程序玩玩呢，于是我写了个小程序，看了看对英文拼写检查的效果，如图。<br><a href="/uploads/2015/05/20150518202121.png"><img src="/uploads/2015/05/20150518202121.png" alt="20150518202121"></a><br>拼写检查会给出三个结果，分别是删除，替换和建议，根据不同的结果我们可以调用不同的接口来获得最佳的体验。代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SpellCheck.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlbase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlstr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Spellcheck.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCoInitialize</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CCoInitialize</span>() &#123;</span><br><span class="line">        <span class="built_in">CoInitializeEx</span>(<span class="literal">NULL</span>, COINIT_MULTITHREADED);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CCoInitialize</span>() &#123; <span class="built_in">CoUninitialize</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LPCWSTR kActionStrings[] = &#123;</span><br><span class="line">    <span class="string">L&quot;CORRECTIVE_ACTION_NONE&quot;</span>,</span><br><span class="line">    <span class="string">L&quot;CORRECTIVE_ACTION_GET_SUGGESTIONS&quot;</span>,</span><br><span class="line">    <span class="string">L&quot;CORRECTIVE_ACTION_REPLACE&quot;</span>,</span><br><span class="line">    <span class="string">L&quot;CORRECTIVE_ACTION_DELETE&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CCoInitialize com_init;</span><br><span class="line">    CComPtr spell_checker_factory;</span><br><span class="line">    HRESULT hr = <span class="built_in">CoCreateInstance</span>(__uuidof(SpellCheckerFactory), <span class="literal">NULL</span>, CLSCTX_INPROC_SERVER, __uuidof(spell_checker_factory),</span><br><span class="line">        <span class="built_in"><span class="keyword">reinterpret_cast</span></span>(&amp;spell;_checker_factory));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LPCWSTR lang_tag = <span class="string">L&quot;en-US&quot;</span>;</span><br><span class="line">    BOOL suppored = FALSE;</span><br><span class="line">    spell_checker_factory-&gt;<span class="built_in">IsSupported</span>(lang_tag, &amp;suppored;);</span><br><span class="line">    <span class="keyword">if</span> (!suppored) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CComPtr spell_checker;</span><br><span class="line">    hr = spell_checker_factory-&gt;<span class="built_in">CreateSpellChecker</span>(lang_tag, &amp;spell;_checker);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WCHAR my_text[] = <span class="string">L&quot;Helloo world, I am am new heere, hvae fun&quot;</span>;</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;%s\n\n&quot;</span>, my_text);</span><br><span class="line">    CComPtr spell_errors;</span><br><span class="line">    hr = spell_checker-&gt;<span class="built_in">Check</span>(my_text, &amp;spell;_errors);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CComPtr spell_error;</span><br><span class="line">    <span class="keyword">while</span> (spell_errors-&gt;<span class="built_in">Next</span>(&amp;spell;_error) == S_OK) &#123;</span><br><span class="line">        ULONG index, length;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(spell_error-&gt;<span class="built_in">get_StartIndex</span>(&amp;index;)) &amp;&amp; <span class="built_in">SUCCEEDED</span>(spell_error-&gt;<span class="built_in">get_Length</span>(&amp;length;))) &#123;</span><br><span class="line">            <span class="function">CStringW <span class="title">tmp_str</span><span class="params">(my_text + index, length)</span></span>;</span><br><span class="line">            <span class="built_in">wprintf</span>(<span class="string">L&quot;%-10s    &quot;</span>, tmp_str.<span class="built_in">GetString</span>());</span><br><span class="line"></span><br><span class="line">            CORRECTIVE_ACTION action;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(spell_error-&gt;<span class="built_in">get_CorrectiveAction</span>(&amp;action;))) &#123;</span><br><span class="line">                <span class="built_in">wprintf</span>(<span class="string">L&quot;%-40s    &quot;</span>, kActionStrings[action]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (action == CORRECTIVE_ACTION_DELETE) &#123;</span><br><span class="line">                <span class="built_in">wprintf</span>(<span class="string">L&quot;delete %s\n&quot;</span>, tmp_str.<span class="built_in">GetString</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (action == CORRECTIVE_ACTION_GET_SUGGESTIONS) &#123;</span><br><span class="line">                CComPtr spell_suggestions;</span><br><span class="line">                hr = spell_checker-&gt;<span class="built_in">Suggest</span>(tmp_str.<span class="built_in">GetString</span>(), &amp;spell;_suggestions);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                WCHAR *suggestion_str;</span><br><span class="line">                <span class="keyword">while</span> (spell_suggestions-&gt;<span class="built_in">Next</span>(<span class="number">1</span>, &amp;suggestion;_str, <span class="literal">NULL</span>) == S_OK) &#123;</span><br><span class="line">                    <span class="built_in">wprintf</span>(<span class="string">L&quot;%s &quot;</span>, suggestion_str);</span><br><span class="line">                    <span class="built_in">CoTaskMemFree</span>(suggestion_str);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">wprintf</span>(<span class="string">L&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (action == CORRECTIVE_ACTION_REPLACE) &#123;</span><br><span class="line">                WCHAR *replace_str;</span><br><span class="line">                hr = spell_error-&gt;<span class="built_in">get_Replacement</span>(&amp;replace;_str);</span><br><span class="line">                <span class="built_in">wprintf</span>(<span class="string">L&quot;%s\n&quot;</span>, replace_str);</span><br><span class="line">                <span class="built_in">CoTaskMemFree</span>(replace_str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spell_error.<span class="built_in">Release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 8.1 GenericMapping对应的ACCESS_MASK</title>
      <link href="/2015/05/01/windows-8-1-genericmappinge5afb9e5ba94e79a84access_mask/"/>
      <url>/2015/05/01/windows-8-1-genericmappinge5afb9e5ba94e79a84access_mask/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们在创建或者打开对象的时候需要指定ACCESS_MASK，有的时候为了方便，我们会在ACCESS_MASK的参数中填GenericRead,GenericWrite这样的值，那么对于这些对象来说，这些GenericXXX究竟是什么样的ACCESS_MASK都是保存在对象的GenericMapping中，以下就是Windows 8.1中所有对象的GenericMapping了。<br><a href="/uploads/2015/05/20150502010045.png"><img src="/uploads/2015/05/20150502010045.png" alt="20150502010045"></a></p><p>将ACCESS_MASK数字转换成我们看得懂的宏，可以使用我写的一个小网页：<br><a href="http://0cch.com/accessmask.html">http://0cch.com/accessmask.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MemMapView —— 查看共享内存映射的工具</title>
      <link href="/2015/04/18/memmapview-e69fa5e79c8be585b1e4baabe58685e5ad98e698a0e5b084e79a84e5b7a5e585b7/"/>
      <url>/2015/04/18/memmapview-e69fa5e79c8be585b1e4baabe58685e5ad98e698a0e5b084e79a84e5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>MemMapView是一个查看Named Shared Memory的工具，它能够枚举系统中的命名共享内存的名称，并且浏览其数据。</p><p><a href="/uploads/2015/04/20150418234836.png"><img src="/uploads/2015/04/20150418234836.png" alt="20150418234836"></a></p><p>下载：<a href="/uploads/2015/04/MemMapView.zip">MemMapView</a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> NTInternals </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>防止Global Windows Hooks注入的一个方法</title>
      <link href="/2015/04/10/e998b2e6ada2global-windows-hookse6b3a8e585a5e79a84e4b880e4b8aae696b9e6b395/"/>
      <url>/2015/04/10/e998b2e6ada2global-windows-hookse6b3a8e585a5e79a84e4b880e4b8aae696b9e6b395/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们都知道SetWindowsHookEx可以设置全局钩子，让自己的dll注入到有窗口的进程中去。注入原理就不再赘述了，网上资料很多，简单看一下调用堆栈方便我们说明怎么去防注入。<br>kernel32!LoadLibraryExW<br>USER32!__ClientLoadLibrary<br>ntdll!KiUserCallbackDispatcher<br>nt!KiCallUserMode<br>nt!KeUserModeCallback<br>win32k!ClientLoadLibrary<br>win32k!xxxLoadHmodIndex<br>win32k!xxxCallHook2<br>win32k!xxxCallHook<br>win32k!xxxCreateWindowEx<br>win32k!NtUserCreateWindowEx<br>nt!KiFastCallEntry<br>ntdll!KiFastSystemCallRet<br>ntdll!KiUserCallbackDispatcher<br>USER32!NtUserCreateWindowEx<br>USER32!_CreateWindowEx  </p><p>看着个堆栈，防注入的方法这里就可以大概说出三种：  </p><ol><li>被创建窗口程序了。  </li><li>Hook LoadLibraryExW，判断是否是自己的模块。  </li><li>Hook __ClientLoadLibrary，替换为空函数。  </li></ol><p>第一个方法其实也谈不上方法，也就是说控制台程序就不用担心这些了。第二个方法需要是否是判断自己的模块，这个方法也挺麻烦的，因为你得放过一些不是自己的模块，比如微软的模块。所以这里重点说第三个方法，我们去Hook __ClientLoadLibrary，这样我们就只是避免了全局钩子的注入了。这里我们不用去Inline Hook该函数，Inline Hook比较麻烦。我们的做法是修改user32!apfnDispatch这个数组，直接替换对应于__ClientLoadLibrary所在位置的值。这样摆在我们面前的稍微麻烦一点的事情有两个，一个是确定数组开始的地址，第二就是确定__ClientLoadLibrary在数组中的index。<br>那么分别来解决这两个问题：</p><ol><li><p>组数的位置<br>其实就是PEB的KernelCallbackTable，虽然PEB没有文档化，但是也没见过他变过什么。所以我们可以写死KernelCallbackTable的偏移。说稍微有点麻烦就是指的，这个偏移在32bit和64bit的系统上是不同的而已，32位系统的偏移是0x2c，64位系统是0x58。另外一个就是获得PEB的方法了，32位程序你既可以写点汇编从fs中获取，也能调用__readfsdword获得，64位程序会麻烦点，你需要先获得TEB，然后从TEB里得到PEB，至于获得TEB的方法，你可以直接调用__readgsqword获得，也可以调用ntdll的NtCurrentTeb获得。</p></li><li><p>__ClientLoadLibrary在数组中的index<br>这个就稍微繁琐点，我们需要把我们关心的系统用windbg带上符号都看一眼才能知道是多少了。<br>我这里提供几个常用系统中__ClientLoadLibrary在数组中的index：<br>XP=0x42，Win7=0x41，Win8.1=0x47</p></li></ol><p>好了，知道了这些，后面的就不用说太详细了，无非就是这三步：  </p><ol><li>写个空的__ClientLoadLibrary函数MyClientLoadLibrary。  </li><li>VirtualProtect设置KernelCallbackTable + index * sizeof(PVOID)地址内存保护属性为PAGE_READWRITE。  </li><li>替换__ClientLoadLibrary为MyClientLoadLibrary，再把内存属性换回原来的。  </li></ol><p>OK，大功告成了。</p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>发现File System Minifilter的一处问题</title>
      <link href="/2015/03/26/e58f91e78eb0file-system-minifiltere79a84e4b880e5a484e997aee9a298/"/>
      <url>/2015/03/26/e58f91e78eb0file-system-minifiltere79a84e4b880e5a484e997aee9a298/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这两天有个朋友一直问我用用户普通权限连接minifilter server port的问题。给他解答的同时，也发现了这个方面的一个问题。首先说用普通用户权限连接port的方法，其实就是设置FltCreateCommunicationPort参数里ObjectAttributes的SecurityDescriptor，加入everyone的ACE就行了。那么加入everyone的ace你就要指定一个ACCESS_MASK，在MSDN里，介绍了两个可以使用的MASK</p><p><a href="/uploads/2015/03/20150326155009.png"><img src="/uploads/2015/03/20150326155009.png" alt="20150326155009"></a></p><p>其中FLT_PORT_CONNECT=1，FLT_PORT_ALL_ACCESS=1F0001。看到这里，多数人都可能会认为如果只想让everyone连接上去，不给他所用权限，那么在这个ACE里加入FLT_PORT_CONNECT就可以了。然后就掉到微软的坑里了，和我那个朋友一样:)。</p><p><a href="/uploads/2015/03/20150326154028.png"><img src="/uploads/2015/03/20150326154028.png" alt="20150326154028"></a></p><p>实际上指定FLT_PORT_CONNECT会让R3的程序无法连接驱动的port，原因就是FilterConnectCommunicationPort函数没有让你指定你需求的ACCESS，而是在底层打开port的时候直接请求FLT_PORT_ALL_ACCESS。这个时候如果你的ACE里面是FLT_PORT_CONNECT，那当然无法连接上去了。所以这里把ACE里的ACCESS_MASK设置为FLT_PORT_ALL_ACCESS就行了。</p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windbg查看Object Hook的脚本</title>
      <link href="/2015/03/24/windbge69fa5e79c8bobject-hooke79a84e8849ae69cac/"/>
      <url>/2015/03/24/windbge69fa5e79c8bobject-hooke79a84e8849ae69cac/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>学好Windbg，基本上可以代替很多工具，这次分享一个查看Object Hook的脚本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">r @$t0 = <span class="number">2</span>;</span><br><span class="line">r? @$t1 = ((nt!_OBJECT_TYPE**)@@(nt!ObTypeIndexTable))[@$t0];</span><br><span class="line"></span><br><span class="line">.<span class="keyword">while</span> ((@$t1 &amp; <span class="number">0xffffffff</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    .printf <span class="string">&quot;Type Name:%-20msu\t&quot;</span>, @@C++(&amp;@$t1-&gt;Name);</span><br><span class="line">    .printf /D <span class="string">&quot;detail\n&quot;</span>, @$t1;</span><br><span class="line">    .printf <span class="string">&quot;DumpProcedure        : %y\n&quot;</span>, @@C++(@$t1-&gt;TypeInfo.DumpProcedure);</span><br><span class="line">    .printf <span class="string">&quot;OpenProcedure        : %y\n&quot;</span>, @@C++(@$t1-&gt;TypeInfo.OpenProcedure);</span><br><span class="line">    .printf <span class="string">&quot;CloseProcedure       : %y\n&quot;</span>, @@C++(@$t1-&gt;TypeInfo.CloseProcedure);</span><br><span class="line">    .printf <span class="string">&quot;DeleteProcedure      : %y\n&quot;</span>, @@C++(@$t1-&gt;TypeInfo.DeleteProcedure);</span><br><span class="line">    .printf <span class="string">&quot;ParseProcedure       : %y\n&quot;</span>, @@C++(@$t1-&gt;TypeInfo.ParseProcedure);</span><br><span class="line">    .printf <span class="string">&quot;SecurityProcedure    : %y\n&quot;</span>, @@C++(@$t1-&gt;TypeInfo.SecurityProcedure);</span><br><span class="line">    .printf <span class="string">&quot;QueryNameProcedure   : %y\n&quot;</span>, @@C++(@$t1-&gt;TypeInfo.QueryNameProcedure);</span><br><span class="line">    .printf <span class="string">&quot;OkayToCloseProcedure : %y\n\n&quot;</span>, @@C++(@$t1-&gt;TypeInfo.OkayToCloseProcedure);</span><br><span class="line">    </span><br><span class="line">    r @$t0 = @$t0 + <span class="number">1</span>;</span><br><span class="line">    r? @$t1 = ((nt!_OBJECT_TYPE**)@@(nt!ObTypeIndexTable))[@$t0];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><a href="/uploads/2015/03/20150324095806.png"><img src="/uploads/2015/03/20150324095806.png" alt="20150324095806"></a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个解析INI文件的类</title>
      <link href="/2015/03/17/e4b880e4b8aae8a7a3e69e90inie69687e4bbb6e79a84e7b1bb/"/>
      <url>/2015/03/17/e4b880e4b8aae8a7a3e69e90inie69687e4bbb6e79a84e7b1bb/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>虽然微软强烈推荐用注册表代替ini来记录软件配置，但是由于写ini文件的方便性和可读性的优势，还是让很多程序员选择把配置记录到ini文件中。但是用Windows API操作ini文件有个缺点，就是每次调用如GetPrivateProfileInt，WritePrivateProfileString等函数，都会产生一次文件打开关闭以及读写操作，并且对ini文件重新解析，这是非常低效的。所以如果需要大量的操作ini文件，例如需要读取很多配置信息以启动软件，那么这样的用法无疑会增加软件的冷启动时间。为了解决这个问题，我们就需要自己写一个模块，他能够一次性读取并且解析好ini文件。在需要读取的时候直接从内存读取，需要些的时候先全部写到内存里，最后在刷新到文件上。所以我写了一个ParseIni的类，来完成这个工作。代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PARSE_INI_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PARSE_INI_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INI_KEY_LINE1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INI_SECTION_LINE2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INI_COMMENT_LINE3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INI_NC_KEY_LINE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INI_WORNG_SYNTAX0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CParseIniA</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CParseIniA</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">CParseIniA</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">Open</span><span class="params">(<span class="keyword">const</span> string &amp;IniPath;, BOOL OpenAlways = TRUE)</span></span>;</span><br><span class="line">    <span class="function">vector <span class="title">EnumSectionNames</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">vector <span class="title">EnumKeyNamesInSection</span><span class="params">(<span class="keyword">const</span> string &amp;SectionName;)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">GetSectionKeyValue</span><span class="params">(<span class="keyword">const</span> string &amp;SectionName;, <span class="keyword">const</span> string &amp;KeyName;, <span class="keyword">const</span> string &amp;DefaultValue;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSectionKeyValueInt</span><span class="params">(<span class="keyword">const</span> string &amp;SectionName;, <span class="keyword">const</span> string &amp;KeyName;, <span class="keyword">int</span> DefaultValue)</span></span>;</span><br><span class="line">    <span class="function">BOOL <span class="title">SetSectionKeyValueInt</span><span class="params">(<span class="keyword">const</span> string &amp;SectionName;, <span class="keyword">const</span> string &amp;KeyName;, <span class="keyword">int</span> value, BOOL CreateNew = TRUE)</span></span>;</span><br><span class="line">    <span class="function">BOOL <span class="title">SetSectionKeyValue</span><span class="params">(<span class="keyword">const</span> string &amp;SectionName;, <span class="keyword">const</span> string &amp;KeyName;, <span class="keyword">const</span> string &amp;Value;, BOOL CreateNew = TRUE)</span></span>;</span><br><span class="line">    <span class="function">BOOL <span class="title">Flush</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">VOID <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ULONG <span class="title">SyntaxCheck</span><span class="params">(<span class="keyword">const</span> string &amp;KeyLine;)</span></span>;</span><br><span class="line">    <span class="function">vector::iterator <span class="title">CreateSection</span><span class="params">(<span class="keyword">const</span> string &amp;SectionName;)</span></span>;</span><br><span class="line">    <span class="function">VOID <span class="title">CreateKeyValue</span><span class="params">(vector::iterator it, <span class="keyword">const</span> string &amp;KeyName;, <span class="keyword">const</span> string &amp;Value;)</span></span>;</span><br><span class="line">    <span class="function">BOOL <span class="title">IsSection</span><span class="params">(string &amp;Line;)</span></span>;</span><br><span class="line">    <span class="function">BOOL <span class="title">SetKeyValue</span><span class="params">(string &amp;Line;, <span class="keyword">const</span> string &amp;Value;)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">GetKeyValue</span><span class="params">(string &amp;Line;)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">GetSectionName</span><span class="params">(string &amp;Line;)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">GetKeyName</span><span class="params">(string &amp;Line;)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">trim</span><span class="params">(<span class="keyword">const</span> string&amp; s ,<span class="keyword">const</span> string&amp; drop = <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">    vector m_IniContext; </span><br><span class="line">    string m_IniPath;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> BOOL <span class="title">CParseIniA::Open</span><span class="params">( <span class="keyword">const</span> string &amp;IniPath;, BOOL OpenAlways)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">IniFile</span><span class="params">(IniPath.c_str())</span></span>;</span><br><span class="line">    INT FileSize;</span><br><span class="line">    vector::iterator it;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IniFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!OpenAlways) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_IniPath = IniPath;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_IniPath = IniPath;</span><br><span class="line"></span><br><span class="line">    IniFile.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios_base::end);</span><br><span class="line">    FileSize = IniFile.<span class="built_in">tellg</span>();</span><br><span class="line">    IniFile.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios_base::beg);</span><br><span class="line">    <span class="keyword">if</span> (FileSize == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (IniFile) &#123;</span><br><span class="line">        string IniLine;</span><br><span class="line">        <span class="built_in">getline</span>(IniFile, IniLine);</span><br><span class="line"></span><br><span class="line">        m_IniContext.<span class="built_in">push_back</span>(IniLine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = m_IniContext.<span class="built_in">end</span>();</span><br><span class="line">    it--;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">trim</span>(*it).<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        m_IniContext.<span class="built_in">pop_back</span>();</span><br><span class="line">        it = m_IniContext.<span class="built_in">end</span>();</span><br><span class="line">        it--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> BOOL <span class="title">CParseIniA::IsSection</span><span class="params">( string &amp;Line; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string SectionLine = <span class="built_in">trim</span>(Line);</span><br><span class="line">    BOOL Ret = FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (SectionLine[<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span> &amp;&amp; SectionLine[SectionLine.<span class="built_in">length</span>() - <span class="number">1</span>] == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        Ret = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vector <span class="title">CParseIniA::EnumSectionNames</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector SectionNames;</span><br><span class="line">    vector::iterator it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (it = m_IniContext.<span class="built_in">begin</span>(); it != m_IniContext.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsSection</span>(*it)) &#123;</span><br><span class="line"></span><br><span class="line">            SectionNames.<span class="built_in">push_back</span>(<span class="built_in">GetSectionName</span>(*it));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SectionNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vector <span class="title">CParseIniA::EnumKeyNamesInSection</span><span class="params">(<span class="keyword">const</span> string &amp;SectionName; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector::iterator it;</span><br><span class="line">    vector KeyNames;</span><br><span class="line">    ULONG ScanState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (it = m_IniContext.<span class="built_in">begin</span>(); it != m_IniContext.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ScanState == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">IsSection</span>(*it) || <span class="built_in">GetSectionName</span>(*it) != SectionName) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ScanState = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ScanState == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsSection</span>(*it)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            KeyNames.<span class="built_in">push_back</span>(<span class="built_in">GetKeyName</span>(*it));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> KeyNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">CParseIniA::GetSectionName</span><span class="params">( string &amp;Line; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT Count = Line.<span class="built_in">length</span>();</span><br><span class="line">    INT i;</span><br><span class="line">    BOOL Start = FALSE;</span><br><span class="line">    string SectionName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Count; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Line[i] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">            Start = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Line[i] == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Start) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Start) &#123;</span><br><span class="line"></span><br><span class="line">                SectionName += Line[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SectionName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">CParseIniA::GetKeyName</span><span class="params">( string &amp;Line; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string KeyName;</span><br><span class="line"></span><br><span class="line">    KeyName = Line.<span class="built_in">substr</span>(<span class="number">0</span>, Line.<span class="built_in">find_first_of</span>(<span class="string">&#x27;=&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">trim</span>(KeyName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">CParseIniA::trim</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">const</span> string&amp; drop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">t</span><span class="params">(s)</span></span>;</span><br><span class="line">    string r = t.<span class="built_in">erase</span>(t.<span class="built_in">find_last_not_of</span>(drop) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r.<span class="built_in">erase</span>(<span class="number">0</span>,r.<span class="built_in">find_first_not_of</span>(drop));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">CParseIniA::GetSectionKeyValueInt</span><span class="params">( <span class="keyword">const</span> string &amp;SectionName;, <span class="keyword">const</span> string &amp;KeyName;, <span class="keyword">int</span> DefaultValue )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> DefaultValueString[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf_s</span>(DefaultValueString, <span class="string">&quot;%d&quot;</span>, DefaultValue);</span><br><span class="line">    string ValueString = <span class="built_in">GetSectionKeyValue</span>(SectionName, KeyName, DefaultValueString);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">atoi</span>(ValueString.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">CParseIniA::GetSectionKeyValue</span><span class="params">(<span class="keyword">const</span> string &amp;SectionName;, <span class="keyword">const</span> string &amp;KeyName;, <span class="keyword">const</span> string &amp;DefaultValue; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector::iterator it;</span><br><span class="line">    ULONG ScanState = <span class="number">0</span>;</span><br><span class="line">    string Value = DefaultValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (it = m_IniContext.<span class="built_in">begin</span>(); it != m_IniContext.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ScanState == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">IsSection</span>(*it) || <span class="built_in">GetSectionName</span>(*it) != SectionName) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ScanState = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ScanState == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsSection</span>(*it)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">SyntaxCheck</span>(*it) != INI_KEY_LINE) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetKeyName</span>(*it) == KeyName) &#123;</span><br><span class="line"></span><br><span class="line">                Value = <span class="built_in">GetKeyValue</span>(*it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">CParseIniA::GetKeyValue</span><span class="params">( string &amp;Line; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string KeyName;</span><br><span class="line"></span><br><span class="line">    KeyName = Line.<span class="built_in">substr</span>(Line.<span class="built_in">find_first_of</span>(<span class="string">&#x27;=&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">trim</span>(KeyName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> BOOL <span class="title">CParseIniA::SetKeyValue</span><span class="params">( string &amp;Line;, <span class="keyword">const</span> string &amp;Value; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT Pos = Line.<span class="built_in">find_first_of</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Pos == string::npos) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pos = Line.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>, Pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Pos == string::npos) &#123;</span><br><span class="line"></span><br><span class="line">        Pos = Line.<span class="built_in">find_first_of</span>(<span class="string">&#x27;=&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Line.<span class="built_in">erase</span>(Pos);</span><br><span class="line">    Line += Value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> BOOL <span class="title">CParseIniA::SetSectionKeyValueInt</span><span class="params">( <span class="keyword">const</span> string &amp;SectionName;, <span class="keyword">const</span> string &amp;KeyName;, <span class="keyword">int</span> Value, BOOL CreateNew <span class="comment">/*= TRUE*/</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ValueString[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf_s</span>(ValueString, <span class="string">&quot;%d&quot;</span>, Value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SetSectionKeyValue</span>(SectionName, KeyName, ValueString, CreateNew);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> BOOL <span class="title">CParseIniA::SetSectionKeyValue</span><span class="params">( <span class="keyword">const</span> string &amp;SectionName;, <span class="keyword">const</span> string &amp;KeyName;, <span class="keyword">const</span> string &amp;Value;, BOOL CreateNew )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector::iterator it;</span><br><span class="line">    ULONG ScanState = <span class="number">0</span>;</span><br><span class="line">    BOOL Ret = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (it = m_IniContext.<span class="built_in">begin</span>(); it != m_IniContext.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ScanState == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">IsSection</span>(*it) || <span class="built_in">GetSectionName</span>(*it) != SectionName) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ScanState = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ScanState == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsSection</span>(*it)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">SyntaxCheck</span>(*it) == INI_KEY_LINE || <span class="built_in">SyntaxCheck</span>(*it) == INI_NC_KEY_LINE) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">GetKeyName</span>(*it) == KeyName) &#123;</span><br><span class="line"></span><br><span class="line">                    Ret = <span class="built_in">SetKeyValue</span>(*it, Value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CreateNew &amp;&amp; !Ret) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ScanState == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            it = <span class="built_in">CreateSection</span>(SectionName);</span><br><span class="line">            <span class="built_in">CreateKeyValue</span>(it, KeyName, Value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ScanState == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            it--;</span><br><span class="line">            <span class="built_in">CreateKeyValue</span>(it, KeyName, Value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Ret = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> BOOL <span class="title">CParseIniA::Flush</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">IniFile</span><span class="params">(m_IniPath.c_str())</span></span>;</span><br><span class="line">    vector::iterator it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IniFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (it = m_IniContext.<span class="built_in">begin</span>(); it != m_IniContext.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line"></span><br><span class="line">        IniFile &lt;&lt; it-&gt;<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">CParseIniA::Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vector::iterator <span class="title">CParseIniA::CreateSection</span><span class="params">( <span class="keyword">const</span> string &amp;SectionName; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string FullSectionName;</span><br><span class="line">    vector::iterator it;</span><br><span class="line"></span><br><span class="line">    FullSectionName += <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    FullSectionName += SectionName;</span><br><span class="line">    FullSectionName += <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    m_IniContext.<span class="built_in">push_back</span>(FullSectionName);</span><br><span class="line">    it = m_IniContext.<span class="built_in">begin</span>() + m_IniContext.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">CParseIniA::CreateKeyValue</span><span class="params">( vector::iterator it, <span class="keyword">const</span> string &amp;KeyName;, <span class="keyword">const</span> string &amp;Value; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string KeyInfo;</span><br><span class="line"></span><br><span class="line">    KeyInfo += KeyName;</span><br><span class="line">    KeyInfo += <span class="string">&quot; = &quot;</span>;</span><br><span class="line">    KeyInfo += Value;</span><br><span class="line">    <span class="keyword">while</span> (it != m_IniContext.<span class="built_in">begin</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">trim</span>(*it).<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        it--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_IniContext.<span class="built_in">insert</span>(it + <span class="number">1</span>, KeyInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ULONG <span class="title">CParseIniA::SyntaxCheck</span><span class="params">( <span class="keyword">const</span> string &amp;KeyLine; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string Line = <span class="built_in">trim</span>(KeyLine);</span><br><span class="line">    INT Pos, CommentPos1, CommentPos2;</span><br><span class="line">    string KeyName;</span><br><span class="line">    string Value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsSection</span>(Line)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INI_SECTION_LINE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Line[<span class="number">0</span>] == <span class="string">&#x27;;&#x27;</span> || Line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INI_COMMENT_LINE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        Pos = Line.<span class="built_in">find_first_of</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (string::npos == Pos) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> INI_WORNG_SYNTAX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        KeyName = <span class="built_in">trim</span>(Line.<span class="built_in">substr</span>(<span class="number">0</span>, Pos));</span><br><span class="line">        <span class="keyword">if</span> (KeyName.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> INI_WORNG_SYNTAX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Value = <span class="built_in">trim</span>(Line.<span class="built_in">substr</span>(Pos + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (Value.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> INI_NC_KEY_LINE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CommentPos1 = Value.<span class="built_in">find_first_of</span>(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        CommentPos2 = Value.<span class="built_in">find_first_of</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (CommentPos1 == string::npos &amp;&amp; CommentPos2 == string::npos) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> INI_KEY_LINE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CommentPos1 = CommentPos1 &lt; CommentPos2 ? CommentPos1 : CommentPos2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Value.<span class="built_in">erase</span>(CommentPos1).<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> INI_NC_KEY_LINE;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> INI_KEY_LINE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Windows未使用内存原理和应用</title>
      <link href="/2015/02/02/e4bdbfe794a8windowse69caae4bdbfe794a8e58685e5ad98e58e9fe79086e5928ce5ba94e794a8/"/>
      <url>/2015/02/02/e4bdbfe794a8windowse69caae4bdbfe794a8e58685e5ad98e58e9fe79086e5928ce5ba94e794a8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="/uploads/2015/02/20150202104522.png"><img src="/uploads/2015/02/20150202104522.png" alt="20150202104522"></a></p><p>配置4G内存，并且使用过32bit Windows系统的人都知道，虽然自己有4G的物理内存，但是Windows还是明确的告诉你，它只会用其中的3GB多，还有几百MB物理内存是用不到的，即使你开启了PAE。当然如果你用的服务器系统，那就当我没说。至于微软为啥服务端32bit系统可以用4GB以上，而限制普通客户端系统，按照Windows Internals的说法，是为了考虑驱动程序的兼容性问题。我这里想介绍的是，如何使用这些没有使用的物理内存。</p><p><a href="/uploads/2015/02/20150202105145.png"><img src="/uploads/2015/02/20150202105145.png" alt="20150202105145"></a></p><p>首先，要想使用这些内存，我们必须找到他们，但是找到他们之前，我们还得了解物理内存地址是怎么分配。物理内存地址除了要给RAM提供地址之外，还需要给设备内存提供地址。为了考虑驱动的兼容性，这些设备内存被分配到4G以内的地址上，这样一来，就会有部分RAM不得不分配到4G以外的地址上了，所以我们无法使用它们。</p><p><a href="/uploads/2015/02/20150202110332.png"><img src="/uploads/2015/02/20150202110332.png" alt="20150202110332"></a></p><p>知道了这些，我们就需要聚焦到如何访问超过4GB内存的方法上了。不过方法也很简单，就是MmMapIoSpace函数，这个函数可以访问64bit的物理内存地址，并且将其映射到我们可以访问的虚拟内存上。</p><p>说到这里，程序的代码仿佛就呈现在脑海了，不过等等，还忽略了一个最困难的问题！到底有存在多少RAM内存在4GB以上的地址空间呢？说这个问题最为困难，是因为你需要根据不同的情况做出不同的选择。</p><p><a href="/uploads/2015/02/20150202095553.png"><img src="/uploads/2015/02/20150202095553.png" alt="20150202095553"></a></p><p>1.主板支持通过Bios查询RAM内存分配情况，在这种情况下，我们可以调用中断来获得最真实的RAM分配表。<br>2.主板不支持通过Bios查询RAM内存分配情况，那么我们很无奈的必须采用一个简单粗暴的方法，Write &amp; Test来获得4GB以外到底有多少RAM可用。  </p><p>对于第二种情况，我们的做法是通过MmMapIoSpace函数，把4GB以上的物理地址逐一映射到虚拟内存中，然后写入特殊值，写入后马上读取，看是否写入成功，成功则证明RAM可用。<br>对于第一种情况，这里又要分为两个分支：<br>首先你的系统是NT6内核以下的情况，这时可以调用Ke386CallBios函数，调用中断接口。<br>而对于NT6的内核，我们需要调用新的x86BiosCall等一套函数。<br>需要调用的中断函数是0x15以及AX=E820，通过这个中断和功能号，我们就能获得SYSTEM MEMORY MAP  </p><p>下面附带上这个功能的使用方法  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INT 15 - newer BIOSes - GET SYSTEM MEMORY MAP  </span><br><span class="line">   AX &#x3D; E820h  </span><br><span class="line">   EAX &#x3D; 0000E820h  </span><br><span class="line">   EDX &#x3D; 534D4150h (&#39;SMAP&#39;)  </span><br><span class="line">   EBX &#x3D; continuation value or 00000000h to start at beginning of map  </span><br><span class="line">   ECX &#x3D; size of buffer for result, in bytes (should be &gt;&#x3D; 20 bytes)  </span><br><span class="line">   ES:DI -&gt; buffer for result (see #00581)  </span><br><span class="line">Return: CF clear if successful  </span><br><span class="line">    EAX &#x3D; 534D4150h (&#39;SMAP&#39;)  </span><br><span class="line">    ES:DI buffer filled  </span><br><span class="line">    EBX &#x3D; next offset from which to copy or 00000000h if all done  </span><br><span class="line">    ECX &#x3D; actual length returned in bytes  </span><br><span class="line">   CF set on error  </span><br><span class="line">    AH &#x3D; error code (86h) (see #00496 at INT 15&#x2F;AH&#x3D;80h)  </span><br><span class="line">Notes:   originally introduced with the Phoenix BIOS v4.0, this function is  </span><br><span class="line">    now supported by most newer BIOSes, since various versions of Windows  </span><br><span class="line">    call it to find out about the system memory  </span><br><span class="line">   a maximum of 20 bytes will be transferred at one time, even if ECX is  </span><br><span class="line">    higher; some BIOSes (e.g. Award Modular BIOS v4.50PG) ignore the  </span><br><span class="line">    value of ECX on entry, and always copy 20 bytes  </span><br><span class="line">   some BIOSes expect the high word of EAX to be clear on entry, i.e.  </span><br><span class="line">    EAX&#x3D;0000E820h  </span><br><span class="line">   if this function is not supported, an application should fall back  </span><br><span class="line">    to AX&#x3D;E802h, AX&#x3D;E801h, and then AH&#x3D;88h  </span><br><span class="line">   the BIOS is permitted to return a nonzero continuation value in EBX  </span><br><span class="line">    and indicate that the end of the list has already been reached by  </span><br><span class="line">    returning with CF set on the next iteration  </span><br><span class="line">   this function will return base memory and ISA&#x2F;PCI memory contiguous  </span><br><span class="line">    with base memory as normal memory ranges; it will indicate  </span><br><span class="line">    chipset-defined address holes which are not in use and motherboard  </span><br><span class="line">    memory-mapped devices, and all occurrences of the system BIOS as  </span><br><span class="line">    reserved; standard PC address ranges will not be reported  </span><br><span class="line">SeeAlso: AH&#x3D;C7h,AX&#x3D;E801h&quot;Phoenix&quot;,AX&#x3D;E881h,MEM xxxxh:xxx0h&quot;ACPI&quot;  </span><br><span class="line">Format of Phoenix BIOS system memory map address range descriptor:  </span><br><span class="line">Offset   Size   Description   (Table 00580)  </span><br><span class="line">00h   QWORD   base address  </span><br><span class="line">08h   QWORD   length in bytes  </span><br><span class="line">10h   DWORD   type of address range (see #00581)  </span><br><span class="line">(Table 00581)  </span><br><span class="line">Values for System Memory Map address type:  </span><br><span class="line">01h   memory, available to OS  </span><br><span class="line">02h   reserved, not available (e.g. system ROM, memory-mapped device)  </span><br><span class="line">03h   ACPI Reclaim Memory (usable by OS after reading ACPI tables)  </span><br><span class="line">04h   ACPI NVS Memory (OS is required to save this memory between NVS  </span><br><span class="line">    sessions)  </span><br><span class="line">other   not defined yet -- treat as Reserved  </span><br><span class="line">（from http:&#x2F;&#x2F;www.ctyme.com&#x2F;intr&#x2F;rb-1741.htm</span><br></pre></td></tr></table></figure><p>获得了4GB内存以上的RAM范围以后，再加上MmMapIoSpace，我们就能够访问系统没有使用的内存了。</p><p>说了这么多，这个有什么具体应用呢？我见过最多利用这个特性做的产品就是内存盘了。也没看到什么用的特别好的其他应用的方面，我想原因主要有三点，第一，即使获得了物理内存，最后还是映射了4GB以内的虚拟内存上，内存操作终究无法访问直接更多物理内存；第二，这部分内存没有系统统一管理，同类型的软件无法共存；第三，有4G内存赶紧快去换个64位系统吧=v=。</p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分享SSD TRIM代码</title>
      <link href="/2015/01/31/e58886e4baabssd-trime4bba3e7a081/"/>
      <url>/2015/01/31/e58886e4baabssd-trime4bba3e7a081/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>14年的早些时候发布过<a href="/tips/2014/02/11/ssd-trime58a9fe883bde79a84e4b880e4ba9be8aeb0e5bd95.html">SSD TRIM技术的文章</a>，文章里面记录了关于TRIM技术的一些东西，其中就包括在Windows上如何使用TRIM。当然Windows 7及其更高版本的系统都是自带TRIM功能的，只有XP没有这个功能，当时我就写了个工具，在XP下进行TRIM。现在想想确实也没啥意思，就把代码分享说来吧。</p><p><a href="https://github.com/0cch/SSDTrim.git">https://github.com/0cch/SSDTrim.git</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用Service Tag区分共享类型服务线程</title>
      <link href="/2015/01/24/e794a8service-tage58cbae58886e585b1e4baabe7b1bbe59e8be69c8de58aa1e7babfe7a88b/"/>
      <url>/2015/01/24/e794a8service-tage58cbae58886e585b1e4baabe7b1bbe59e8be69c8de58aa1e7babfe7a88b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Windows中有一种共享类型的服务，这种服务的特点是，他们可能同时有多个不同服务运行在同一个进程内。这些服务通常都是一些dll，他们被加载到宿主进程内运行，这个宿主进程我们见到最多的就是svchost了，如下图所示：</p><p><a href="/uploads/2015/01/20150124220922.png"><img src="/uploads/2015/01/20150124220922.png" alt="20150124220922"></a></p><p>Windows这样做的好处就是尽可能的节约资源，当然不好地方就是，如果出了问题那么难以调试和定位。所以，为了更好的定位共享服务的工作线程，微软支持了一种叫做Service Tag的东西。Service Tag简单的说就是标注线程属于哪个服务的，这个是由Service Control Manager支持的。在TEB中有一个SubProcessTag字段，每当一个服务注册并且运行的时候，Service Control Manager会分配给服务线程一个id，这个id就是SubProcessTag，它能够唯一的表示服务，而且这个值是一直都被继承的，也就是说，如果服务线程再创建线程，那么新的线程的SubProcessTag也会被标记为父线程的id。当然，也有一种例外，那就是如果用了线程池，就不会继承SubProcessTag了。</p><p>在Advapi32.dll中有一个函数，叫做I_QueryTagInformation，这个函数可以根据SubProcessTag去查询Service的信息，有兴趣的同学可以看看下面的链接：<a href="http://wj32.org/wp/2010/03/30/howto-use-i_querytaginformation/">http://wj32.org/wp/2010/03/30/howto-use-i_querytaginformation/</a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>总结和展望：东方不亮西方亮</title>
      <link href="/2015/01/11/e680bbe7bb93e5928ce5b195e69c9befbc9ae4b89ce696b9e4b88de4baaee8a5bfe696b9e4baae/"/>
      <url>/2015/01/11/e680bbe7bb93e5928ce5b195e69c9befbc9ae4b89ce696b9e4b88de4baaee8a5bfe696b9e4baae/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一转眼，一年又过去了，又到了总结过去的一年，计划新年的时候了。过去的一年里，最大的感觉是，好想经过了好多事情，但却没有经历什么事情。说起来挺绕的，慢慢来回忆下吧。</p><p>首先是工作上的事情，由于在前年整个部门被裁，去了一个价值观上和自己的很不同公司。事实证明，这确实不是什么好的决定，吐槽的事情就不细说了。之所以没换公司，是因为我觉得在北京待不了多久了，跳槽只会坑了其他的公司。所以也就勉强的继续干着。虽说是勉强的干活，但是工作的时间还是将近占用了每天的三分之二。工作的内容也没有什么创造性，基本上就是在可怕的代码里改来改去，当然了，也许这也是他这么可怕的原因吧。</p><p>多米乐骨效应，工作占用大量的时间，也导致我2014年的计划大打折扣。脚本编译器，写了一半听了下来，minikernel也没什么进展，唯一比较让人舒心的是，0CCh的山寨小工具，还是在慢慢的变多，其中还有花了大量精力写的everything_study，不过由于算法还没没达到目标效果（没有everything快，数据库也比他的大很多），所以没有放出来，也就是自己在用。确实也是因为工作的原因，没有太多时间和精力去改造文件id间相互索引的算法了。再说说健身，同样的理由，工作时间长影响身体和健身，现在25分钟基本上就跑个4.7km，13年的最后，都是能跑5km多点的。</p><p>不过东方不亮西方亮了，有失意的地方，总会在其他地方补回来=v=，生命中终于又多了一个人，能让我更加坚定的回老家了。所以，今年的计划特别难定，因为不知道回老家后到底是什么个情况。只能说回去之前继续坚持着，回去之后去找个心仪的事情。然后，编译器和minikernel希望能继续写，编译器希望能写玩，因为并不难。minikernel就比较复杂了，只能说能写多少写多少。另外我也特别喜欢山寨各种各样的小工具，自己造轮子自己用，赶紧挺开心的。健身方面，回去前照旧，回去后尽量保持。</p><p>其实生活上14年真的还算挺开心的，和sysdbg的博主一起还打完了好几个ps3的游戏。比如《神秘海域3》，《第一次世界大战——勇敢的心》等等=v=，还有他13年欠我的金钱豹还没请我吃呢…</p><p>最后，我还是希望2015年，我自己和家人、亲戚以及基友们，身体健康，阖家辛福快乐，工作顺利发大财！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python获得文件版本信息</title>
      <link href="/2014/12/21/pythone88eb7e5be97e69687e4bbb6e78988e69cace4bfa1e681af/"/>
      <url>/2014/12/21/pythone88eb7e5be97e69687e4bbb6e78988e69cace4bfa1e681af/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Python干啥都挺方便的，出了调用win32的api。当然了，可以用pywin32这种库。但我不喜欢为了一两个api又给简单的东西加一堆依赖。比如获取文件版本，本来想在网上找个函数复制过去用得了，却发现还真没啥好用的。无奈自己就写了一个。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VS_FIXEDFILEINFO</span>(<span class="params">Structure</span>):</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;dwSignature&quot;</span>, c_int), </span><br><span class="line">        (<span class="string">&quot;dwStrucVersion&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwFileVersionMS&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwFileVersionLS&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwProductVersionMS&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwProductVersionLS&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwFileFlagsMask&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwFileFlags&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwFileOS&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwFileType&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwFileSubtype&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwFileDateMS&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;dwFileDateLS&quot;</span>, c_int)</span><br><span class="line">    ]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LOWORD</span>(<span class="params">dword</span>):</span> <span class="keyword">return</span> dword &amp; <span class="number">0x0000ffff</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HIWORD</span>(<span class="params">dword</span>):</span> <span class="keyword">return</span> dword &gt;&gt; <span class="number">16</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFileVersion</span>(<span class="params">filename</span>):</span></span><br><span class="line">    size = windll.version.GetFileVersionInfoSizeW(filename, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> size:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    res = create_string_buffer(size)</span><br><span class="line">    windll.version.GetFileVersionInfoW(filename, <span class="literal">None</span>, size, res)</span><br><span class="line">    r = VS_FIXEDFILEINFO()</span><br><span class="line">    l = c_uint()</span><br><span class="line">    p = c_void_p()</span><br><span class="line">    windll.version.VerQueryValueW(res, <span class="string">&#x27;\\&#x27;</span>, byref(p), byref(l));</span><br><span class="line">    memmove(byref(r), p, sizeof(VS_FIXEDFILEINFO))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l.value:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&#x27;%d.%d.%d.%d&#x27;</span> % (HIWORD(r.dwFileVersionMS), LOWORD(r.dwFileVersionMS), </span><br><span class="line">        HIWORD(r.dwProductVersionLS), LOWORD(r.dwProductVersionLS)));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DNSSwitcher —— 一个方便切换DNS的小工具</title>
      <link href="/2014/12/14/dnsswitcher-e4b880e4b8aae696b9e4bebfe58887e68da2dnse79a84e5b08fe5b7a5e585b7/"/>
      <url>/2014/12/14/dnsswitcher-e4b880e4b8aae696b9e4bebfe58887e68da2dnse79a84e5b08fe5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近百度也推出的自己的公共DNS，现在可供我们选择使用的DNS也多了起来。但是每次更改DNS都输入IP，确实挺麻烦的。于是我周末在家就写了个切换DNS的小程序，绿色且易用，能在配置好的DNS直接切换，当然也能切换回自动获取DNS的模式。至于配置文件，可以手动修改，也可以通过程序来修改，都挺方便的。</p><p><a href="/uploads/2014/12/20141214190237.png"><img src="/uploads/2014/12/20141214190237.png" alt="20141214190237"></a></p><p>配置文件格式如<br>[Google DNS]<br>dns1=8.8.8.8<br>dns2=8.8.4.4<br>[Open DNS]<br>dns1=208.67.222.222<br>dns2=208.67.220.220<br>…  </p><p>下载：<a href="/uploads/2014/12/DNSSwitcher.zip">DNSSwitcher</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tcpview_study——查看TCP连接工具</title>
      <link href="/2014/12/07/tcpview_study-e69fa5e79c8btcpe8bf9ee68ea5e5b7a5e585b7/"/>
      <url>/2014/12/07/tcpview_study-e69fa5e79c8btcpe8bf9ee68ea5e5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>tcpview_study是一款监控TCP连接的小工具，实际上功能就是山寨的sysinternals工具集的tcpview，功能也差不多，主要是没事拿来练练手。</p><p><a href="/uploads/2014/12/20141207175522.png"><img src="/uploads/2014/12/20141207175522.png" alt="20141207175522"></a></p><p>下载：<a href="/uploads/2014/12/tcpview_study.zip">tcpview_study</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获得使用打开保存对话框操作文件的记录</title>
      <link href="/2014/11/17/e88eb7e5be97e4bdbfe794a8e68993e5bc80e4bf9de5ad98e5afb9e8af9de6a186e6938de4bd9ce69687e4bbb6e79a84e8aeb0e5bd95/"/>
      <url>/2014/11/17/e88eb7e5be97e4bdbfe794a8e68993e5bc80e4bf9de5ad98e5afb9e8af9de6a186e6938de4bd9ce69687e4bbb6e79a84e8aeb0e5bd95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天无意中看到了HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePidlMRU这个键值的用途，虽然感觉没啥实际用途，但是也挺有趣的，于是写了个小程序读取它。这个键值的意义非常明确，就是记录打开保存对话框的最近操作的文件的PIDL。所以我们可以通过PIDL来获得文件路径，就这么简单，确实没啥特别的实际用途吧，就当娱乐了。枚举的效果如下：</p><p><a href="/uploads/2014/11/20141117231005.png"><img src="/uploads/2014/11/20141117231005.png" alt="20141117231005"></a></p><p>代码也很简单：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlbase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlstr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Shlobj.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;shell32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TCHAR mru_path[] = <span class="built_in">TEXT</span>(<span class="string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ComDlg32\\OpenSavePidlMRU&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnumMRUValue</span><span class="params">(HKEY subkey, std::vector &amp;mru;_files)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    TCHAR value_name[MAX_PATH];</span><br><span class="line">    ULONG value_name_length = MAX_PATH;</span><br><span class="line">    UCHAR data_buffer[<span class="number">1024</span>];</span><br><span class="line">    ULONG data_length = <span class="built_in"><span class="keyword">sizeof</span></span>(data_buffer);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">RegEnumValue</span>(subkey, i++, value_name, &amp;value;_name_length, <span class="number">0</span>, <span class="literal">NULL</span>, data_buffer, &amp;data;_length) == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_tcscmp(value_name, <span class="built_in">TEXT</span>(<span class="string">&quot;MRUListEx&quot;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            CComPtr malloc_ptr;</span><br><span class="line">            HRESULT hr = <span class="built_in">SHGetMalloc</span>(&amp;malloc;_ptr);</span><br><span class="line">            LPITEMIDLIST file_pidl = (LPITEMIDLIST)malloc_ptr-&gt;<span class="built_in">Alloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(UCHAR) + data_length);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (file_pidl) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(file_pidl, data_buffer, data_length);</span><br><span class="line">                WCHAR file_path[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">SHGetPathFromIDList</span>(file_pidl, file_path)) &#123;</span><br><span class="line">                    mru_files.<span class="built_in">push_back</span>(file_path);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                malloc_ptr-&gt;<span class="built_in">Free</span>(file_pidl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        value_name_length = MAX_PATH;</span><br><span class="line">        data_length = <span class="built_in"><span class="keyword">sizeof</span></span>(data_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">PrintMRUFiles</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HKEY subkey;</span><br><span class="line">    LSTATUS l = <span class="built_in">RegOpenKeyEx</span>(HKEY_CURRENT_USER, mru_path, <span class="number">0</span>, KEY_READ, &amp;subkey;);</span><br><span class="line">    <span class="keyword">if</span> (l != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    ULONG i = <span class="number">0</span>;</span><br><span class="line">    TCHAR key_name[MAX_PATH];</span><br><span class="line">    ULONG key_name_length = MAX_PATH;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">RegEnumKeyEx</span>(subkey, i++, key_name, &amp;key;_name_length, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        HKEY ext_key;</span><br><span class="line">        LSTATUS l = <span class="built_in">RegOpenKeyEx</span>(subkey, key_name, <span class="number">0</span>, KEY_READ, &amp;ext;_key);</span><br><span class="line">        <span class="keyword">if</span> (l == ERROR_SUCCESS) &#123;</span><br><span class="line">            </span><br><span class="line">            std::vector mru_files;</span><br><span class="line">            <span class="built_in">EnumMRUValue</span>(ext_key, mru_files);</span><br><span class="line">            <span class="keyword">if</span> (mru_files.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                _tprintf(<span class="built_in">TEXT</span>(<span class="string">&quot;Extension Name : %s\n&quot;</span>), key_name);</span><br><span class="line">                ULONG j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (std::vector::iterator it = mru_files.<span class="built_in">begin</span>(); it != mru_files.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line"></span><br><span class="line">                    WIN32_FILE_ATTRIBUTE_DATA attribute_data = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">GetFileAttributesEx</span>(it-&gt;<span class="built_in">GetString</span>(), GetFileExInfoStandard, &amp;attribute;_data)) &#123;</span><br><span class="line">                        ULONGLONG file_size = ((ULONGLONG)attribute_data.nFileSizeHigh) &lt;&lt; <span class="number">32</span> | attribute_data.nFileSizeLow;</span><br><span class="line">                        _tprintf(<span class="built_in">TEXT</span>(<span class="string">&quot;\t %u %s  % 11I64u KB] %s\n&quot;</span>), j++,</span><br><span class="line">                            (attribute_data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) == <span class="number">0</span> ? <span class="built_in">TEXT</span>(<span class="string">&quot;[FILE&quot;</span>) : <span class="built_in">TEXT</span>(<span class="string">&quot;[DIR &quot;</span>),</span><br><span class="line">                            (file_size + <span class="number">1023</span>) / <span class="number">1024</span>,</span><br><span class="line">                            it-&gt;<span class="built_in">GetString</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        _tprintf(<span class="built_in">TEXT</span>(<span class="string">&quot;\t %u [ERROR_FILE_NOT_FOUND] %s\n&quot;</span>), j++,</span><br><span class="line">                            it-&gt;<span class="built_in">GetString</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">RegCloseKey</span>(ext_key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        key_name_length = MAX_PATH;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">RegCloseKey</span>(subkey);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;chs&quot;</span>);</span><br><span class="line">    <span class="built_in">PrintMRUFiles</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>主线程退出前请先退出子线程</title>
      <link href="/2014/11/10/e4b8bbe7babfe7a88be98080e587bae5898de8afb7e58588e98080e587bae5ad90e7babfe7a88b/"/>
      <url>/2014/11/10/e4b8bbe7babfe7a88be98080e587bae5898de8afb7e58588e98080e587bae5ad90e7babfe7a88b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们知道理论上如果一个进程的主线程退出，整个进程就会销毁，子线程自然也是要退出的。但是这并不意味着，程序退出的时候我们就能不问不管自己创建的子线程，因为不管他还真有可能出问题。下面是一个典型的主线程退出过程中，而子线程未退出，造成死锁整个进程的分析图，死锁在c runtime里，死锁原因看图便知，也不用太多解释了。</p><p><a href="/uploads/2014/11/20141106094954.png"><img src="/uploads/2014/11/20141106094954.png" alt="20141106094954"></a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ClipMonitor 简单的剪切板监控工具</title>
      <link href="/2014/11/02/clipmonitor-e7ae80e58d95e79a84e589aae58887e69dbfe79b91e68ea7e5b7a5e585b7/"/>
      <url>/2014/11/02/clipmonitor-e7ae80e58d95e79a84e589aae58887e69dbfe79b91e68ea7e5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>周末花了点时间写了个剪切板监控工具，他会记录剪切板里面的数据，并且支持用HEX和TEXT对数据进行分析。<br>涉及到的技术很简单，网上已经有一堆了，没什么可说的，我这里主要是加入了HEX的模块，方便对未知的剪切板数据进行分析而已。</p><p><a href="/uploads/2014/11/20141102204618.png"><img src="/uploads/2014/11/20141102204618.png" alt="20141102204618"></a></p><p><a href="/uploads/2014/11/20141102204638.png"><img src="/uploads/2014/11/20141102204638.png" alt="20141102204638"></a></p><p><a href="/uploads/2014/11/20141102204651.png"><img src="/uploads/2014/11/20141102204651.png" alt="20141102204651"></a></p><p>下载：<a href="/uploads/2014/11/ClipMonitor.zip">ClipMonitor</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用Windbg脚本监控DLL加载状态</title>
      <link href="/2014/10/27/e588a9e794a8windbge8849ae69cace79b91e68ea7dlle58aa0e8bdbde78ab6e68081/"/>
      <url>/2014/10/27/e588a9e794a8windbge8849ae69cace79b91e68ea7dlle58aa0e8bdbde78ab6e68081/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>开发过大型程序的人都遇到过这样的问题，一个版本Release后，发现有的功能怎么也不对。但是每个模块在开发人员单独的环境下又是正常运行。那么遇到这样的问题，其中一个能想到的就是DLL模块没有加载正确。一般情况下，这种时候我们可以使用depends这样的工具查看模块的依赖情况，以判断出哪个模块是出问题的那个。但是如果如果真的遇上大型的程序，DLL模块很多，而且动态静态加载不一，这样光靠depends这样的工具是不能满足需求的。所以我这里写了个Windbg脚本来监控DLL加载状态，因为是动态调试，所以很轻松的就能找到加载问题，无论DLL是静态加载还是动态加载。</p><p>以下脚本是Windows 7 32Bit，对于64bit，稍微修改下就行。不过如果是Windows 8，DLL的加载细节已经发生变化，所以这个脚本就不适用了。希望能抛砖引玉一下，期待更多系统的脚本分享出来。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bp ntdll!LdrpFindOrMapDll <span class="string">&quot;</span></span><br><span class="line"><span class="string">.push /r /q</span></span><br><span class="line"><span class="string">r @$t0 = poi(@esp+4)</span></span><br><span class="line"><span class="string">r @$t1 = poi(@esp+8)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">g @$ra</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.printf \&quot;name         = %msu\\n\&quot;, @$t0</span></span><br><span class="line"><span class="string">.printf \&quot;path         = %msu\\n\&quot;, @$t1</span></span><br><span class="line"><span class="string">.printf \&quot;Load status  = %08X\&quot;, @eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.if((@eax&amp;0xffffffff) != 0) &#123;.printf /D \&quot; WARNNING\\n\&quot;&#125; .else &#123;.printf \&quot;\\n\&quot;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.pop /r /q</span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>最后看看脚本的效果吧，如果加载失败了，那么返回的状态值就不是0。<br><a href="/uploads/2014/10/20141027164220.png"><img src="/uploads/2014/10/20141027164220.png" alt="20141027164220"></a><br><a href="/uploads/2014/10/20141027164424.png"><img src="/uploads/2014/10/20141027164424.png" alt="20141027164424"></a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用Windows Event监控前台窗口变化</title>
      <link href="/2014/10/19/e794a8windows-evente79b91e68ea7e5898de58fb0e7aa97e58fa3e58f98e58c96/"/>
      <url>/2014/10/19/e794a8windows-evente79b91e68ea7e5898de58fb0e7aa97e58fa3e58f98e58c96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>网络上有这样一种小工具，号称可以提高计算机响应速度。简单看了下其中的一款工具，实现原理很简单，就是监控前台窗口的变化，设置进程线程的优先级。设置进程线程的优先级无非就是SetPriorityClass和SetThreadPriority这两个函数，主要问题就是要获得前台窗口的情况。<br>Windows提供了一种叫做Windows Event Hook的机制，来让我们获得多种不同的事件，其中一种就是前台窗口变化事件。所以要完成这个功能很简单，只需要注册一个针对EVENT_SYSTEM_FOREGROUND的HOOK就行了。注册和反注册Hook的函数分别是SetWinEventHook和UnhookWinEvent。<br>比如注册EVENT_SYSTEM_FOREGROUND事件的Hook，我们只需要这样：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HWINEVENTHOOK hWinEventHook = <span class="built_in">SetWinEventHook</span>(</span><br><span class="line">        EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND,</span><br><span class="line">        <span class="literal">NULL</span>, WinEventProc, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>前两个参数设置我们感兴趣的事件范围，由于我们最后一个参数设置的WINEVENT_OUTOFCONTEXT，表示Hook函数并不在产生Event的进程内部，所以hmodWinEventProc设置为NULL。WinEventProc则是我们的Hook函数idProcess和idThread为0，表示我们关心所有桌面上的进程线程，最后的flags还有一个WINEVENT_SKIPOWNPROCESS表示我们对自己的进程不感兴趣。<br>要反注册Hook只需要</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UnhookWinEvent</span>(hWinEventHook);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>WinEventProc的很简单</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">WinEventProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWINEVENTHOOK hWinEventHook,</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD event,</span></span></span><br><span class="line"><span class="function"><span class="params">HWND hwnd,</span></span></span><br><span class="line"><span class="function"><span class="params">LONG idObject,</span></span></span><br><span class="line"><span class="function"><span class="params">LONG idChild,</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwEventThread,</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwmsEventTime</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hwnd &amp;&amp;</span><br><span class="line">        idObject == OBJID_WINDOW &amp;&amp;</span><br><span class="line">        idChild == CHILDID_SELF &amp;&amp;</span><br><span class="line">        event == EVENT_SYSTEM_FOREGROUND) &#123;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>其中只需要知道hwnd就是当前的前台窗口就行了。然后通过hwnd和函数GetWindowThreadProcessId，获得进程线程id，自然就能获得其句柄，最后调用调整进程线程优先级的函数即可。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>更新Windbg扩展0cchext</title>
      <link href="/2014/09/20/e69bb4e696b0windbge689a9e5b1950cchext/"/>
      <url>/2014/09/20/e69bb4e696b0windbge689a9e5b1950cchext/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>更新了pe_export和pe_import两个命令，功能如图</p><p><a href="/uploads/2014/09/20140919095914.png"><img src="/uploads/2014/09/20140919095914.png" alt="20140919095914"></a></p><p><a href="/uploads/2014/09/20140919100003.png"><img src="/uploads/2014/09/20140919100003.png" alt="20140919100003"></a></p><p><a href="/uploads/2014/09/20140919100101.png"><img src="/uploads/2014/09/20140919100101.png" alt="20140919100101"></a></p><p>Commands for 0cchext.dll:<br>  !autocmd         - Execute the debugger commands.(The config file is<br>                     autocmd.ini)<br>  !dpx             - Display the contents of memory in the given range.<br>  !dtx             - Displays information about structures. (The config file is<br>                     struct.ini)<br>  !favcmd          - Display the favorite debugger commands.(The config file is<br>                     favcmd.ini)<br>  !grep            - Search plain-text data sets for lines matching a regular<br>                     expression.<br>  !help            - Displays information on available extension commands<br>  !hwnd            - Show window information by handle.<br>  !init_script_env - Initialize script environment.<br>  !pe_export       - Dump PE export functions<br>  !pe_import       - Dump PE import modules and functions<br>  !setvprot        - Set the protection on a region of committed pages in the<br>                     virtual address space of the debuggee process.<br>  !url             - Open a URL in a default browser.<br>  !version         - Displays the version information for 0cchext.dll<br>!help  will give more information for a particular command  </p><p>下载：<a href="/uploads/2014/09/0cchext.zip">0cchext</a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dump stl的vector，list，map的三个windbg脚本</title>
      <link href="/2014/08/16/dump-stle79a84vectorefbc8clistefbc8cmape79a84e4b889e4b8aawindbge8849ae69cac/"/>
      <url>/2014/08/16/dump-stle79a84vectorefbc8clistefbc8cmape79a84e4b889e4b8aawindbge8849ae69cac/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>用Windbg查看stl的容器实在是已经让人悲伤的事情，为了方便，所以写了这么3个脚本<br>vector:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">r? $t0 = $&#123;$arg1&#125;</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> ($&#123;/d:$VectorType&#125;) &#123;</span><br><span class="line">    r? $t0 = @@C++(*(($&#123;$VectorType&#125; *)@$t0))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> ($&#123;/d:$arg2&#125;) &#123; </span><br><span class="line">    .<span class="keyword">if</span> ($<span class="built_in">sicmp</span>(<span class="string">&quot;$&#123;$arg2&#125;&quot;</span>, <span class="string">&quot;-c&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        r $t2 = <span class="number">0</span> </span><br><span class="line">        aS $&#123;/v:command&#125; <span class="string">&quot;$&#123;$arg3&#125;&quot;</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">.<span class="keyword">else</span> &#123; </span><br><span class="line">    r $t2 = <span class="number">1</span> </span><br><span class="line">    aS $&#123;/v:command&#125; <span class="string">&quot; &quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r? $t1 = @@C++(@$t0._Mylast)</span><br><span class="line">r? $t0 = @@C++(@$t0._Myfirst)</span><br><span class="line"></span><br><span class="line">.printf <span class="string">&quot;size = %d\n&quot;</span>, @@C++((@$t1 - @$t0))  </span><br><span class="line"></span><br><span class="line">.<span class="keyword">while</span> (@$t0 != @$t1) &#123;</span><br><span class="line">    .<span class="keyword">if</span> ($t2 == <span class="number">1</span>) &#123;</span><br><span class="line">        ?? @@c++(@$t0-&gt;_Bx)</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="keyword">else</span> &#123;</span><br><span class="line">        r? $t9 = @$t0-&gt;_Bx</span><br><span class="line">        command</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r? $t0=@$t0+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ad command </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>list:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">r? $t0 = $&#123;$arg1&#125;</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> ($&#123;/d:$ListType&#125;) &#123;</span><br><span class="line">    r? $t0 = @@C++(*(($&#123;$ListType&#125; *)@$t0))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> ($&#123;/d:$arg2&#125;) &#123; </span><br><span class="line">    .<span class="keyword">if</span> ($<span class="built_in">sicmp</span>(<span class="string">&quot;$&#123;$arg2&#125;&quot;</span>, <span class="string">&quot;-c&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        r $t2 = <span class="number">0</span> </span><br><span class="line">        aS $&#123;/v:command&#125; <span class="string">&quot;$&#123;$arg3&#125;&quot;</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">.<span class="keyword">else</span> &#123; </span><br><span class="line">    r $t2 = <span class="number">1</span> </span><br><span class="line">    aS $&#123;/v:command&#125; <span class="string">&quot; &quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.printf <span class="string">&quot;size = %d\n&quot;</span>, @@C++(@$t0._Mysize)</span><br><span class="line"></span><br><span class="line">r? $t1 = @@C++(@$t0._Myhead)</span><br><span class="line">r? $t0 = @@C++(@$t0._Myhead)</span><br><span class="line">r? $t0 = @@C++(@$t0-&gt;_Next)</span><br><span class="line"></span><br><span class="line">.<span class="keyword">while</span> (@$t0 != @$t1) &#123;</span><br><span class="line">    .<span class="keyword">if</span> ($t2 == <span class="number">1</span>) &#123;</span><br><span class="line">        ?? @@c++(@$t0-&gt;_Myval._Bx)</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="keyword">else</span> &#123;</span><br><span class="line">        r? $t9 = @$t0-&gt;_Myval._Bx</span><br><span class="line">        command</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r? $t0 = @@C++(@$t0-&gt;_Next)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ad command </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>map:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">if</span> ($<span class="built_in">sicmp</span>(<span class="string">&quot;$&#123;$arg1&#125;&quot;</span>, <span class="string">&quot;-n&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line"></span><br><span class="line">    .<span class="keyword">if</span> (@@C++(@$t0-&gt;_Left) != @@C++(@$t1)) &#123; </span><br><span class="line">        .push /r /q </span><br><span class="line">        r? $t0 = @$t0-&gt;_Left </span><br><span class="line">        $$&gt;a&lt; $&#123;$arg0&#125; -n </span><br><span class="line">        .pop /r /q </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    .<span class="keyword">if</span> (@@C++(@$t0-&gt;_Isnil) == <span class="number">0</span>) &#123; </span><br><span class="line">        .<span class="keyword">if</span> (@$t2 == <span class="number">1</span>) &#123; </span><br><span class="line">            .printf /D <span class="string">&quot;%p\n&quot;</span>, @$t0, @$t0 </span><br><span class="line">            .printf <span class="string">&quot;key = &quot;</span> </span><br><span class="line">            ?? @$t0-&gt;_Myval.first </span><br><span class="line">            .printf <span class="string">&quot;value = &quot;</span> </span><br><span class="line">            ?? @$t0-&gt;_Myval.second </span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">else</span> &#123; </span><br><span class="line">            r? $t9 = @$t0-&gt;_Myval </span><br><span class="line">            command </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .<span class="keyword">if</span> (@@C++(@$t0-&gt;_Right) != @@C++(@$t1)) &#123; </span><br><span class="line">        .push /r /q </span><br><span class="line">        r? $t0 = @$t0-&gt;_Right </span><br><span class="line">        $$&gt;a&lt; $&#123;$arg0&#125; -n </span><br><span class="line">        .pop /r /q </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">.<span class="keyword">else</span> &#123; </span><br><span class="line"></span><br><span class="line">    r? $t0 = $&#123;$arg1&#125;</span><br><span class="line"></span><br><span class="line">    .<span class="keyword">if</span> ($&#123;/d:$MapType&#125;) &#123;</span><br><span class="line">        r? $t0 = @@C++(*(($&#123;$MapType&#125; *)@$t0))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="keyword">if</span> ($&#123;/d:$arg2&#125;) &#123; </span><br><span class="line">        .<span class="keyword">if</span> ($<span class="built_in">sicmp</span>(<span class="string">&quot;$&#123;$arg2&#125;&quot;</span>, <span class="string">&quot;-c&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">            r $t2 = <span class="number">0</span> </span><br><span class="line">            aS $&#123;/v:command&#125; <span class="string">&quot;$&#123;$arg3&#125;&quot;</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="keyword">else</span> &#123; </span><br><span class="line">        r $t2 = <span class="number">1</span> </span><br><span class="line">        aS $&#123;/v:command&#125; <span class="string">&quot; &quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    .printf <span class="string">&quot;size = %d\n&quot;</span>, @@C++(@$t0._Mysize)  </span><br><span class="line">     </span><br><span class="line">    r? $t0 = @$t0._Myhead-&gt;_Parent </span><br><span class="line">    r? $t1 = @$t0-&gt;_Parent</span><br><span class="line">    </span><br><span class="line">    $$&gt;a&lt; $&#123;$arg0&#125; -n</span><br><span class="line"></span><br><span class="line">    ad command </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用ATLTRACE打造轻量级Debug Log</title>
      <link href="/2014/07/18/e4bdbfe794a8atltracee68993e980a0e8bdbbe9878fe7baa7debug-log/"/>
      <url>/2014/07/18/e4bdbfe794a8atltracee68993e980a0e8bdbbe9878fe7baa7debug-log/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>众所周知，Debug Log是非常好的调试手段。所以我经常也尝试各种各样的第三方Log库。Log库分很多类型，例如可以给服务器使用的功能完备Log，也有轻量级的Log库，只是为Debug所设计。作为客户端开发，我还是比较喜欢后者这种Log库。不过使用第三方库有一个这样的麻烦事，走到哪你都得下一个，然后添加到自己的代码里。对于Log这样的功能，几乎所有程序都是需要的，使用的极其频繁。所以我就想找到一种方法，它可以使用SDK现有功能，来完成一个轻量级Log的功能。对我来说，不需要这个Log有多么高效，完备，唯一需要的就是方便，拿来就可以用。</p><p>结合这些目的，我第一个想到的就是ATL的ATLTRACE。但是，ATLTRACE输出的日志都是显示在Debug Output窗口。如果想将信息输出到文件或者控制台上，这就够呛了。那么，接下来就要想办法改变ATLTRACE的输出设备了。由于ATL是有代码的，所以很容易的可以看到代码运行的脉络。看完这份代码的第一个收获就是知道了ATLTRACE运行效率不会很高，不过这个对我来说并不重要。另外一个就是，找到了改变输出设备的方法。</p><p>在没有定义_ATL_NO_DEBUG_CRT的情况下，ATLTRACE最终的输出是通过_CrtDbgReport实现的，而如果定义了这个宏，那么输出是直接调用OutputDebugString。但一般程序都不会使用_ATL_NO_DEBUG_CRT这个宏，所以大部分情况下ATLTRACE都是调用的_CrtDbgReport。那么办法就来了_CrtDbgReport输出的数据，是可以通过_CrtSetReportMode和_CrtSetReportFile来改变输出设备的。例如我们想输出到控制台，我们只需要这样：<br>_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);<br>_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);  </p><p>如果要输出到文件也只需要这样：<br>HANDLE log_file;<br>log_file = CreateFile(“c:\log.txt”, GENERIC_WRITE,<br>    FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,<br>    FILE_ATTRIBUTE_NORMAL, NULL);<br>_CrtSetReportFile(_CRT_WARN, log_file);<br>CloseHandle(log_file);<br>或者<br>freopen( “c:\log2.txt”, “w”, stdout);<br>_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);<br>_CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);  </p><p>好了，这样就能解决输出设备的问题。既然已经说到这里，继续介绍下ATLTRACE很少人知道的其他优点吧。<br>1.可以通过ATL/MFT TRACE Tool 随时设定Log的输出Filter，并且可以保持配置（工具用法很简单，具体直接用用就知道了）。<br>2.通过AtlDebugAPI的接口，可以给自己的代码中添加读取配置文件的函数。这样每次修改配置文件就能改变ATLTRACE的行为。<br>3.通过AtlDebugAPI的接口，可以直接制定输出内容，不用配置文件也可以。<br>这三条涉及到的接口有：<br>AtlTraceOpenProcess<br>AtlTraceModifyProcess<br>AtlTraceCloseProcess<br>AtlTraceLoadSettings  </p><p>为了更方便使用，我这写了几个宏代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlbase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atltrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atldebugapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlpath.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRACEHELPA(fmt, ...)\</span></span><br><span class="line"><span class="keyword">do</span>\</span><br><span class="line">&#123;\</span><br><span class="line">    SYSTEMTIME tm;\</span><br><span class="line">    <span class="built_in">GetLocalTime</span>(&amp;tm;);\</span><br><span class="line">    <span class="built_in">ATLTRACE</span>(<span class="string">&quot;%s: [%02d-%02d-%02d %02d:%02d:%02d:%03d] &quot;</span>fmt, __FUNCTION__,\</span><br><span class="line">    tm.wYear, tm.wMonth, tm.wDay, tm.wHour, tm.wMinute, tm.wSecond, tm.wMilliseconds, __VA_ARGS__);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRACEHELPW(fmt, ...)\</span></span><br><span class="line"><span class="keyword">do</span>\</span><br><span class="line">&#123;\</span><br><span class="line">    SYSTEMTIME tm;\</span><br><span class="line">    <span class="built_in">GetLocalTime</span>(&amp;tm;);\</span><br><span class="line">    <span class="built_in">ATLTRACE</span>(<span class="string">L&quot;%S: [%02d-%02d-%02d %02d:%02d:%02d:%03d] &quot;</span>fmt, __FUNCTION__,\</span><br><span class="line">    tm.wYear, tm.wMonth, tm.wDay, tm.wHour, tm.wMinute, tm.wSecond, tm.wMilliseconds, __VA_ARGS__);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRACEHELPEXA(category, level, fmt, ...)\</span></span><br><span class="line"><span class="keyword">do</span>\</span><br><span class="line">&#123;\</span><br><span class="line">    SYSTEMTIME tm;\</span><br><span class="line">    <span class="built_in">GetLocalTime</span>(&amp;tm;);\</span><br><span class="line">    <span class="built_in">ATLTRACE</span>(category, level, <span class="string">&quot;%s: [%02d-%02d-%02d %02d:%02d:%02d:%03d] &quot;</span>fmt, __FUNCTION__,\</span><br><span class="line">    tm.wYear, tm.wMonth, tm.wDay, tm.wHour, tm.wMinute, tm.wSecond, tm.wMilliseconds, __VA_ARGS__);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRACEHELPEXW(category, level, fmt, ...)\</span></span><br><span class="line"><span class="keyword">do</span>\</span><br><span class="line">&#123;\</span><br><span class="line">    SYSTEMTIME tm;\</span><br><span class="line">    <span class="built_in">GetLocalTime</span>(&amp;tm;);\</span><br><span class="line">    <span class="built_in">ATLTRACE</span>(category, level, <span class="string">L&quot;%S: [%02d-%02d-%02d %02d:%02d:%02d:%03d] &quot;</span>fmt, __FUNCTION__,\</span><br><span class="line">    tm.wYear, tm.wMonth, tm.wDay, tm.wHour, tm.wMinute, tm.wSecond, tm.wMilliseconds, __VA_ARGS__);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetAtlTraceOpt(level, enable, category, filename_lineno, report_type, report_file)\</span></span><br><span class="line"><span class="keyword">do</span>\</span><br><span class="line">&#123;\</span><br><span class="line">    DWORD_PTR trace_process = <span class="built_in">AtlTraceOpenProcess</span>(<span class="built_in">GetCurrentProcessId</span>());\</span><br><span class="line">    <span class="built_in">AtlTraceModifyProcess</span>(trace_process, level, enable, category, filename_lineno);\</span><br><span class="line">    <span class="built_in">AtlTraceCloseProcess</span>(trace_process);\</span><br><span class="line">    _CrtSetReportMode(level, report_type);\</span><br><span class="line">    <span class="keyword">if</span> (report_type == _CRTDBG_MODE_FILE) &#123;\</span><br><span class="line">        _CrtSetReportFile(level, report_file);\</span><br><span class="line">    &#125;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LoadAtlDebugCfgExA(path)\</span></span><br><span class="line"><span class="keyword">do</span>\</span><br><span class="line">&#123;\</span><br><span class="line">    DWORD_PTR trace_process = <span class="built_in">AtlTraceOpenProcess</span>(<span class="built_in">GetCurrentProcessId</span>());\</span><br><span class="line">    <span class="built_in">AtlTraceLoadSettingsA</span>(path, trace_process);\</span><br><span class="line">    <span class="built_in">AtlTraceCloseProcess</span>(trace_process);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LoadAtlDebugCfgExW(path)\</span></span><br><span class="line"><span class="keyword">do</span>\</span><br><span class="line">&#123;\</span><br><span class="line">    DWORD_PTR trace_process = <span class="built_in">AtlTraceOpenProcess</span>(<span class="built_in">GetCurrentProcessId</span>());\</span><br><span class="line">    <span class="built_in">AtlTraceLoadSettingsU</span>(path, trace_process);\</span><br><span class="line">    <span class="built_in">AtlTraceCloseProcess</span>(trace_process);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LoadAtlDebugCfgA()\</span></span><br><span class="line"><span class="keyword">do</span>\</span><br><span class="line">&#123;\</span><br><span class="line">    CHAR debug_cfg_path[MAX_PATH] = &#123;<span class="number">0</span>&#125;;\</span><br><span class="line">    <span class="built_in">GetModuleFileNameA</span>(<span class="literal">NULL</span>, debug_cfg_path, MAX_PATH);\</span><br><span class="line">    <span class="function">CPathA <span class="title">debug_cfg_path_obj</span><span class="params">(debug_cfg_path)</span></span>;\</span><br><span class="line">    debug_cfg_path_obj.<span class="built_in">RemoveExtension</span>();\</span><br><span class="line">    debug_cfg_path_obj.<span class="built_in">AddExtension</span>(<span class="string">&quot;.trc&quot;</span>);\</span><br><span class="line">    <span class="built_in">LoadAtlDebugCfgExA</span>(debug_cfg_path_obj.m_strPath.<span class="built_in">GetString</span>());\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LoadAtlDebugCfgW()\</span></span><br><span class="line"><span class="keyword">do</span>\</span><br><span class="line">&#123;\</span><br><span class="line">    WCHAR debug_cfg_path[MAX_PATH] = &#123;<span class="number">0</span>&#125;;\</span><br><span class="line">    <span class="built_in">GetModuleFileNameW</span>(<span class="literal">NULL</span>, debug_cfg_path, MAX_PATH);\</span><br><span class="line">    <span class="function">CPathW <span class="title">debug_cfg_path_obj</span><span class="params">(debug_cfg_path)</span></span>;\</span><br><span class="line">    debug_cfg_path_obj.<span class="built_in">RemoveExtension</span>();\</span><br><span class="line">    debug_cfg_path_obj.<span class="built_in">AddExtension</span>(<span class="string">L&quot;.trc&quot;</span>);\</span><br><span class="line">    <span class="built_in">LoadAtlDebugCfgExW</span>(debug_cfg_path_obj.m_strPath.<span class="built_in">GetString</span>());\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetAtlTraceOpt</span>(_CRT_WARN, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, _CRTDBG_MODE_FILE, _CRTDBG_FILE_STDOUT);</span><br><span class="line">    <span class="built_in">LoadAtlDebugCfgW</span>();</span><br><span class="line">    <span class="function">CTraceCategory <span class="title">MY_CATEGORY</span><span class="params">(_T(<span class="string">&quot;MyCategoryName&quot;</span>))</span></span>;</span><br><span class="line">    <span class="built_in">TRACEHELPEXA</span>(MY_CATEGORY, <span class="number">0</span>, <span class="string">&quot;test test test\n&quot;</span>);</span><br><span class="line">    <span class="built_in">TRACEHELPEXW</span>(MY_CATEGORY, <span class="number">0</span>, <span class="string">L&quot;test test test\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dump右键菜单的小工具——RightMenuDump</title>
      <link href="/2014/06/29/dumpe58fb3e994aee88f9ce58d95e79a84e5b08fe5b7a5e585b7-rightmenudump/"/>
      <url>/2014/06/29/dumpe58fb3e994aee88f9ce58d95e79a84e5b08fe5b7a5e585b7-rightmenudump/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近没空更新blog，只能把以前写的小工具拿出来充数，表明这个blog还是活着的。这个挺无聊的小工具，主要是看看电脑里右键菜单的情况。</p><p>直接运行后当前目录下出现rm.log，内容大概是：</p><p><a href="/uploads/2014/06/20140629222145.png"><img src="/uploads/2014/06/20140629222145.png" alt="20140629222145"></a></p><p>下载：<a href="/uploads/2014/06/RightMenuDump.zip">RightMenuDump</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>更新:Windbg扩展0cchext.dll</title>
      <link href="/2014/06/23/e69bb4e696b0windbge689a9e5b1950cchext-dll/"/>
      <url>/2014/06/23/e69bb4e696b0windbge689a9e5b1950cchext-dll/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Commands for 0cchext.dll:<br>  !autocmd         - Execute the debugger commands.(The config file is<br>                     autocmd.ini)<br>  !dpx             - Display the contents of memory in the given range.<br>  !dtx             - Displays information about structures. (The config file is<br>                     struct.ini)<br>  !favcmd          - Display the favorite debugger commands.(The config file is<br>                     favcmd.ini)<br>  !grep            - Search plain-text data sets for lines matching a regular<br>                     expression.<br>  !help            - Displays information on available extension commands<br>  !hwnd            - Show window information by handle.<br>  !init_script_env - Initialize script environment.<br>  !setvprot        - Set the protection on a region of committed pages in the<br>                     virtual address space of the debuggee process.<br>  !url             - Open a URL in a default browser.<br>  !version         - Displays the version information for 0cchext.dll<br>!help  will give more information for a particular command  </p><p>下载：<a href="/uploads/2014/06/0cchext.zip">0cchext</a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>系统进程创建管理员进程的方法</title>
      <link href="/2014/05/06/e7b3bbe7bb9fe8bf9be7a88be5889be5bbbae7aea1e79086e59198e8bf9be7a88be79a84e696b9e6b395/"/>
      <url>/2014/05/06/e7b3bbe7bb9fe8bf9be7a88be5889be5bbbae7aea1e79086e59198e8bf9be7a88be79a84e696b9e6b395/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ProcessHelper &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(__stdcall *CREATEENVIRONMENTBLOCK)</span><span class="params">(LPVOID *lpEnvironment,</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hToken,</span></span></span><br><span class="line"><span class="function"><span class="params">BOOL bInherit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">CreateProcessAsExplorer</span><span class="params">(LPCTSTR AppName, LPTSTR CommandLine, PPROCESS_INFORMATION pi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ULONG ExplorerID = <span class="number">0</span>;</span><br><span class="line">        HANDLE ExplorerHandle;</span><br><span class="line">        HANDLE Snapshot;</span><br><span class="line">        ULONG CreationFlags = <span class="number">0</span>;</span><br><span class="line">        CREATEENVIRONMENTBLOCK CreateEnvironmentBlock;</span><br><span class="line">        HANDLE ExplorerToken;</span><br><span class="line">        HANDLE NewToken = <span class="number">0</span>;</span><br><span class="line">        LPVOID Environment = <span class="literal">NULL</span>;</span><br><span class="line">        ULONG ReturnLength = <span class="number">0</span>;</span><br><span class="line">        TOKEN_LINKED_TOKEN LinkedToken = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        STARTUPINFO si = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        PROCESSENTRY32 pe;</span><br><span class="line">        BOOL Ret;</span><br><span class="line">        HMODULE UserenvModule;</span><br><span class="line">        LUID Luid = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (Snapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pe.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(pe);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Process32FirstW</span>(Snapshot, &amp;pe;)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (_tcsicmp(pe.szExeFile, <span class="string">L&quot;explorer.exe&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">ProcessIdToSessionId</span>(pe.th32ProcessID, &amp;Luid.LowPart;);</span><br><span class="line">                    ExplorerID = pe.th32ProcessID;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">Process32Next</span>(Snapshot, &amp;pe;)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseHandle</span>(Snapshot);</span><br><span class="line">        <span class="keyword">if</span> (ExplorerID == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExplorerHandle = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION, FALSE, ExplorerID);</span><br><span class="line">        <span class="keyword">if</span> (ExplorerHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(ExplorerHandle, TOKEN_ALL_ACCESS_P, &amp;ExplorerToken;)) &#123;</span><br><span class="line">            <span class="built_in">CloseHandle</span>(ExplorerHandle);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseHandle</span>(ExplorerHandle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetTokenInformation</span>(ExplorerToken, </span><br><span class="line">            TokenLinkedToken, </span><br><span class="line">            &amp;LinkedToken;, </span><br><span class="line">            <span class="built_in"><span class="keyword">sizeof</span></span>(TOKEN_LINKED_TOKEN), </span><br><span class="line">            &amp;ReturnLength;)) &#123;</span><br><span class="line"></span><br><span class="line">                NewToken = LinkedToken.LinkedToken;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">LookupPrivilegeValueW</span>(<span class="number">0</span>, <span class="string">L&quot;SeDebugPrivilege&quot;</span>, &amp;Luid;);</span><br><span class="line">            <span class="built_in">DuplicateTokenEx</span>(ExplorerToken, MAXIMUM_ALLOWED, <span class="literal">NULL</span>, SecurityIdentification, TokenPrimary, &amp;NewToken;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseHandle</span>(ExplorerToken);</span><br><span class="line"></span><br><span class="line">        UserenvModule = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Userenv.dll&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (UserenvModule == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CreateEnvironmentBlock = (CREATEENVIRONMENTBLOCK)<span class="built_in">GetProcAddress</span>(UserenvModule, <span class="string">&quot;CreateEnvironmentBlock&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (CreateEnvironmentBlock == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">FreeLibrary</span>(UserenvModule);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CreateEnvironmentBlock</span>(&amp;Environment;, NewToken, TRUE)) &#123;</span><br><span class="line">            CreationFlags = CREATE_UNICODE_ENVIRONMENT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        si.cb = <span class="built_in"><span class="keyword">sizeof</span></span>(si);</span><br><span class="line">        Ret = <span class="built_in">CreateProcessAsUser</span>(</span><br><span class="line">            NewToken,</span><br><span class="line">            AppName,</span><br><span class="line">            CommandLine,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            FALSE,</span><br><span class="line">            CreationFlags,</span><br><span class="line">            Environment,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            &amp;si;,</span><br><span class="line">            pi);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseHandle</span>(NewToken);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Environment != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DestroyEnvironmentBlock</span>(Environment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!Ret) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个查找指定栈回溯符号并执行命令的Windbg脚本</title>
      <link href="/2014/04/20/e4b880e4b8aae69fa5e689bee68c87e5ae9ae6a088e59b9ee6baafe7aca6e58fb7e5b9b6e689a7e8a18ce591bde4bba4e79a84windbge8849ae69cac/"/>
      <url>/2014/04/20/e4b880e4b8aae69fa5e689bee68c87e5ae9ae6a088e59b9ee6baafe7aca6e58fb7e5b9b6e689a7e8a18ce591bde4bba4e79a84windbge8849ae69cac/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是自己没事在家调试程序的一个小需求。</p><p>有时候比如IE这样的程序，线程实在是非常的多，我想操作某个特殊线程就比较麻烦，需要先找到线程然后再实行命令，为了偷懒就写了这个脚本。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$$ If a frame of a thread has the target symbol, we execute the command.</span><br><span class="line">$$ Author: nighxie </span><br><span class="line">$$ Blog: <span class="number">0</span>cch.net</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> ($&#123;/d:$arg1&#125; &amp; $&#123;/d:$arg2&#125; &amp; $&#123;/d:$arg3&#125;) &#123;</span><br><span class="line">    .<span class="keyword">for</span> (r @$t0 = <span class="number">0</span>; @$t0 &lt; <span class="number">0</span>n$&#123;$arg1&#125;; r @$t0 = @$t0 + <span class="number">1</span>) &#123;</span><br><span class="line">        r @$t1 = <span class="number">0</span>;</span><br><span class="line">        ~[@$t0]s;</span><br><span class="line">        !for_each_frame .<span class="keyword">if</span>($<span class="built_in">spat</span>(<span class="string">&quot;$&#123;@#SymbolName&#125;&quot;</span>, <span class="string">&quot;$&#123;$arg2&#125;&quot;</span>)) &#123;r @$t1 = <span class="number">1</span>&#125;</span><br><span class="line">        .<span class="keyword">if</span> (@$t1 == <span class="number">1</span>) &#123;</span><br><span class="line">            $&#123;$arg3&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="keyword">else</span> &#123;</span><br><span class="line">    .echo <span class="string">&quot;Usage $$&gt;a&lt;$&#123;$arg0&#125; thread_count pattern cmd&quot;</span>;</span><br><span class="line">    .echo <span class="string">&quot;e.g. $$&gt;a&lt;$&#123;$arg0&#125; 5 ntdll* ~n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>就如同上面的例子指定线程数量，要匹配的符号，最后就是要执行的命令。<br>$$&gt;a&lt;${$arg0} 5 ntdll* <del>n就表示在前5个线程里寻找栈回溯有关ntdll的线程，然后执行</del>n命令挂起线程。</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 8.1中获得系统版本信息的方法</title>
      <link href="/2014/04/13/windows-8-1e4b8ade88eb7e5be97e7b3bbe7bb9fe78988e69cace4bfa1e681afe79a84e696b9e6b395/"/>
      <url>/2014/04/13/windows-8-1e4b8ade88eb7e5be97e7b3bbe7bb9fe78988e69cace4bfa1e681afe79a84e696b9e6b395/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在Windows 8.1之前的系统版本上，我们一直可以使用 <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724451(v=vs.85).aspx">GetVersionEx</a> 这个函数来获取当前系统的MajorVersion和MinorVersion。但是当Windows系统来到8.1时代，这个API似乎就不好用了。如果在Windows 8.1上调用这个函数，我们更有可能获得的版本号是Windows 8的版本6.2，而不是我们想要的6.3。在MSDN上提供了这样一段说明：</p><blockquote>With the release of Windows 8.1, the behavior of the **GetVersionEx** API has changed in the value it will return for the operating system version. The value returned by the **GetVersionEx** function now depends on how the application is manifested.<p>Applications not manifested for Windows 8.1 will return the Windows 8 OS version value (6.2). Once an application is manifested for a given operating system version, <strong>GetVersionEx</strong> will always return the version that the application is manifested for in future releases.</blockquote></p><p>好了，既然微软都这么说了，也没办法，还好微软也给我们提供了另一套函数，叫做<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dn424972(v=vs.85).aspx">Version Helper functions</a> ，看起来是一套很不错的API，能帮助我们方便的判断系统版本。但是，仔细一看，这套函数需要头文件VersionHelpers.h，而这个文件是 Windows 8.1 software development kit 的一部分。对于使用低版本的VS还得装新版SDK，岂不麻烦。那么我们希望能找到一套更好的解决方法。</p><p>我第一个能想到了，当然就是万能的WMI，使用Win32_OperatingSystem class中的Version可以获得一个形如6.3.9600的字符串，我们就能通过解析这个获得系统的版本了。但是说实话，不到万不得已我不太喜欢用WMI这套API，总感觉为了一个小功能，牵扯了一堆东西。</p><p>那么第二套方案，是我觉得比较满意的，那就是调用<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms725493(v=vs.85).aspx">VerSetConditionMask</a>和<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms725492(v=vs.85).aspx">VerifyVersionInfo</a>来完成对系统版本的判断。具体做法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsWindows8Point1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OSVERSIONINFOEX version_info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    version_info.dwOSVersionInfoSize = <span class="built_in"><span class="keyword">sizeof</span></span>(OSVERSIONINFOEX);</span><br><span class="line">    version_info.dwMajorVersion = <span class="number">6</span>;</span><br><span class="line">    version_info.dwMinorVersion = <span class="number">3</span>;</span><br><span class="line">    ULONGLONG mask = <span class="built_in">VerSetConditionMask</span>(<span class="number">0</span>, VER_MAJORVERSION, VER_EQUAL);</span><br><span class="line">    mask = <span class="built_in">VerSetConditionMask</span>(mask, VER_MINORVERSION, VER_EQUAL);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">VerifyVersionInfo</span>(&amp;version;_info, VER_MAJORVERSION | VER_MINORVERSION, mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>那么，我们就可以用这个函数来判断系统是否是Windows 8.1，如果不是，我们就可以用老办法，GetVersionEx来获得系统的版本号作判断了。当然了，大家看到这估计也能看出，我们自己也能用这两个函数实现一套所谓的Version Helper functions。举个例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">IsWindowsVersionOrGreater</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">WORD wMajorVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">WORD wMinorVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">WORD wServicePackMajor</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OSVERSIONINFOEX version_info = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    version_info.dwOSVersionInfoSize = <span class="built_in"><span class="keyword">sizeof</span></span>(OSVERSIONINFOEX);</span><br><span class="line">    version_info.dwMajorVersion = wMajorVersion;</span><br><span class="line">    version_info.dwMinorVersion = wMinorVersion;</span><br><span class="line">    version_info.wServicePackMajor = wServicePackMajor;</span><br><span class="line"></span><br><span class="line">    ULONGLONG mask = <span class="built_in">VerSetConditionMask</span>(<span class="number">0</span>, VER_MAJORVERSION, VER_GREATER_EQUAL);</span><br><span class="line">    mask = <span class="built_in">VerSetConditionMask</span>(mask, VER_MINORVERSION, VER_GREATER_EQUAL);</span><br><span class="line">    mask = <span class="built_in">VerSetConditionMask</span>(mask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">VerifyVersionInfo</span>(&amp;version;_info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR, mask);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>怎么样，是不是达到了以假乱真的效果了。那么最后，咱再看看这么写出来的API的效果如何：</p><p><a href="/uploads/2014/04/20140413233019.png"><img src="/uploads/2014/04/20140413233019.png" alt="20140413233019"></a></p><p>===============想睡觉的分割线====================</p><p>更新另外一个方法，在网上看到的，感觉也还行。只不过需要引入其他DLL，可以作为备选方案。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ULONG <span class="title">MyGetVersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPBYTE raw_data;</span><br><span class="line">    ULONG retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NetWkstaGetInfo</span>(<span class="literal">NULL</span>, <span class="number">100</span>, &amp;raw;_data) == NERR_Success) &#123;</span><br><span class="line">        WKSTA_INFO_100 * ws_info = <span class="built_in"><span class="keyword">reinterpret_cast</span></span>(raw_data);</span><br><span class="line">        retval = (ws_info-&gt;wki100_ver_major &lt;&lt; <span class="number">16</span>) | ws_info-&gt;wki100_ver_minor;</span><br><span class="line">        <span class="built_in">NetApiBufferFree</span>(raw_data);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Global Logger打开开机启动ETW日志</title>
      <link href="/2014/04/05/global-loggere68993e5bc80e5bc80e69cbae590afe58aa8etwe697a5e5bf97/"/>
      <url>/2014/04/05/global-loggere68993e5bc80e5bc80e69cbae590afe58aa8etwe697a5e5bf97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在我看来XP确实应该寿终正寝了，因为确实在很多机制方面不如新的系统，比如ETW。而微软的XPERF也没有能在XP上直接安装的。当然，老版本的XPERF还能在XP上运行，只是监控能力有限，到了新版本的XPERF，在XP上就运行不了了。但是，XP却在中国还活的好好的，所以优化其性能必不可少。于是，在没有XPERF支持的情况下，要做到开启ETW日志，我们就需要微软提供的Global Logger机制，打开开机启动的Trace Session。</p><p>微软对打开Global Logger的方法做了详细的说明：<a href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff546686(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/hardware/ff546686(v=vs.85).aspx </a>，我这里没必要再赘述了，只有一个地方需要注意，要说明一下<strong>EnableKernelFlags</strong>这个变量，他是一个REG_BINARY类型，他的值是EVENT_TRACE_PROPERTIES的EnableFlags。但是EnableFlags是一个DWORD，而<strong>EnableKernelFlags</strong>是一个32字节的数组。如果你设置的时候，只是设置了一个DWORD，那么你会发现ETW 日志不会开启。</p><p>话说到这，<strong>EnableKernelFlags</strong>中前4字节的DWORD是EVENT_TRACE_PROPERTIES的组合，那么后面还有28字节是干什么的呢？实际上ETW能记录的标志还有很多，只是没有在EVENT_TRACE_PROPERTIES中说明，他们都被分到8个分组里面去了，这也是为什么有32个字节的Flags。具体怎么分组，还有哪些标志位，可以参考WRK的代码。</p><p>我这里写了个小工具可以用来设置Global Flags，不过如果你能找到XP上可以用的XPERF当然是最好的选择了！</p><p><a href="/uploads/2014/04/20140405104746.png"><img src="/uploads/2014/04/20140405104746.png" alt="20140405104746"></a></p><p>下载:<a href="/uploads/2014/04/GlobalLog.zip">GlobalLog</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不显示对话框格式化磁盘的方法</title>
      <link href="/2014/03/16/e4b88de698bee7a4bae5afb9e8af9de6a186e6a0bce5bc8fe58c96e7a381e79b98e79a84e696b9e6b395/"/>
      <url>/2014/03/16/e4b88de698bee7a4bae5afb9e8af9de6a186e6a0bce5bc8fe58c96e7a381e79b98e79a84e696b9e6b395/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们都知道格式化磁盘会弹出如下图所示的这样的一个对话框。</p><p><a href="/uploads/2014/03/20140316210304.png"><img src="/uploads/2014/03/20140316210304-177x300.png" alt="20140316210304"></a></p><p>编写格式化磁盘的程序的时候，我们需要用到SHFormatDrive这个API，同样的，他也会弹出一个对话框。出现对话框当然是为了安全考虑，防止磁盘被用户不知情的情况下格式化，导致数据丢失。但是，某些情况下，确实希望静默的去格式化，而不去打扰用户，例如格式化Ramdisk。那么就需要找点一个办法要求不弹出对话框的格式化磁盘。既然Windows并没有提供这样的API，那我们只能深入分析下调用过程，找出可以使用的API。</p><p>怎么找的就不想说了，无非用ProcMon看一下堆栈就清楚明白了。在fmifs.dll中有一些导出的API可以帮助完成这一的任务，比如FormatEx，FormatEx2。</p><p>这里简单的描述下FormatEx的用法：<br>函数原型是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">FormatEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPCWSTR DriveRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">MEDIA_TYPE MediaType,</span></span></span><br><span class="line"><span class="function"><span class="params">LPCWSTR FileSystemTypeName,</span></span></span><br><span class="line"><span class="function"><span class="params">LPCWSTR Label,</span></span></span><br><span class="line"><span class="function"><span class="params">BOOL QuickFormat,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG ClusterSize,</span></span></span><br><span class="line"><span class="function"><span class="params">FILE_SYSTEM_CALLBACK Callback</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>参数<br>DriveRoot —— 盘符，如”K:&quot;<br>MediaType —— 磁盘类型，如FixedMedia<br>FileSystemTypeName —— 要格式化的文件系统，如”NTFS”<br>Label —— 标签，随便写吧<br>QuickFormat —— 快速格式化<br>ClusterSize —— 簇大小<br>Callback —— 状态回调函数  </p><p>回调函数原型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOLEAN</span> <span class="params">(__stdcall *FILE_SYSTEM_CALLBACK)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG                        Command,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG                        Action,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID                        pData</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>Command 表示Action和pData的意义，比如Command = 0表示pData是进度，Command = 11表示完成。还有其他的状态，例如错误等等，这些google一下就知道了。这个函数返回TRUE表示函数继续运行，FALSE表示停止格式化。</p><p>比如，下面是格式化K盘：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">FormatEx</span>(<span class="string">L&quot;K:\&quot;, FixedMedia, L&quot;</span>NTFS<span class="string">&quot;, L&quot;</span><span class="number">0</span>CCh<span class="string">&quot;, TRUE, 4096, FormatExCallback);</span></span><br><span class="line"><span class="string"> </span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个有意思的warning —— C4930</title>
      <link href="/2014/03/01/e4b880e4b8aae69c89e6848fe6809de79a84warning-c4930/"/>
      <url>/2014/03/01/e4b880e4b8aae69c89e6848fe6809de79a84warning-c4930/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>C4930是微软的C++编译器提示的一个警告，在维基百科中，把造成这种警告的语句描述成最让人为难的解析的语句。那么这里我们看看到底是有多么为难，这个可以帮助我们进一步了解C++和编译器。</p><p>那么首先，我最开始发现这个问题是在类似这样的代码中碰到的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">s</span><span class="params">(<span class="string">&quot;d:\\xxx.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(std::istream_iterator&lt;<span class="keyword">char</span>&gt;(s), std::istream_iterator&lt;<span class="keyword">char</span>&gt;())</span></span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>如果编译这个，编译器会毫不留情地扔给你一个C4930警告，提示编译器不知道怎么做，所以跳过编译。如果你没看懂这警告，后果就是这句话根本不会编译进去，即使编译通过了，运行也会和设想的不同。</p><p>先说个简单的C4930的例子吧。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">sample</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这句代码非常简单，也很容易明白。如果这么写，那么编译器就混乱，因为这句话可以是描述：<br>1.一个变量的定义，调用默认构造。<br>2.一个函数的声明。<br>所以编译器就傻了，他把这个认为是函数声明，所以不会做任何事情。<br>同样的事情发生在  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(std::istream_iterator&lt;<span class="keyword">char</span>&gt;(s), std::istream_iterator&lt;<span class="keyword">char</span>&gt;())</span></span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这里，我们实际上就是给string的构造函数传入iterator来构造这个string。但是编译器可不是这么觉得，他认为这句话应该这样解析：一个返回string的函数，函数名为str，函数参数有两个并且类型相同，都是istream_iterator<char>，不同的是一个有参数名s，一个省略了参数名！</p><p>编译器这么解析，也真没错，我们就只能通过修改代码来明确目的了。通常的做法是给第一个iterator外加上括<br>号：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">((std::istream_iterator&lt;<span class="keyword">char</span>&gt;(s)), std::istream_iterator&lt;<span class="keyword">char</span>&gt;())</span></span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>不过，我写这两行代码也就是为了偷懒读取一个文件的字符串，所以我可以干脆改成一行：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(std::istream_iterator&lt;<span class="keyword">char</span>&gt;(std::ifstream(<span class="string">&quot;d:\\xxx.txt&quot;</span>)), std::istream_iterator&lt;<span class="keyword">char</span>&gt;())</span></span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这样就能顺利编译运行了。</p><p>最近在看新版的《The C++ Standard Library A Tutorial and Reference》里面也看到了这个东西，很有意思所<br>以拿出来说下。而且新版的书中，已经包含了C++11的解释，很有意思。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GUID TOOL —— 一个转换GUID格式的小工具</title>
      <link href="/2014/02/23/guid-tool-e4b880e4b8aae8bdace68da2guide6a0bce5bc8fe79a84e5b08fe5b7a5e585b7/"/>
      <url>/2014/02/23/guid-tool-e4b880e4b8aae8bdace68da2guide6a0bce5bc8fe79a84e5b08fe5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>周末闲来无事，逆向点有趣的功能的时候遇到这样一个问题。有些16进制的数貌似就是GUID，但是需要转换为注册表形式，才方便在注册表里面搜索。所以就写了个小工具转换16进制，C语言格式以及注册表格式的GUID。</p><p>usage: guid.exe &lt;&lt;-r|-c|-h&gt; guid_string&gt; | &lt;-g&gt;<br>-r Format registry guid string.<br>-c Format C code guid string.<br>-x Format HEX guid string.<br>-g Create new guid.  </p><p><a href="/uploads/2014/02/20140223220404.png"><img src="/uploads/2014/02/20140223220404-1024x549.png" alt="20140223220404"></a></p><p><a href="/uploads/2014/02/20140223220314.png"><img src="/uploads/2014/02/20140223220314-1024x570.png" alt="20140223220314"></a></p><p>下载：<a href="/uploads/2014/02/guid.zip">guid</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSD TRIM功能的一些记录</title>
      <link href="/2014/02/11/ssd-trime58a9fe883bde79a84e4b880e4ba9be8aeb0e5bd95/"/>
      <url>/2014/02/11/ssd-trime58a9fe883bde79a84e4b880e4ba9be8aeb0e5bd95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如今SSD越来越普及了，本来就想了解下关于SSD的一些情况，正好工作中有机会接触这一块的东西，很幸运。这里先记录一些已知知识，方便以后自己查阅。</p><p>说到SSD，第一个想到的就是读写速度快。那个就要归功于其存储原理，关于SSD存储原理的文章很多，我这里简单通俗的描述一下：  </p><ol><li>SSD存储不同于机械硬盘，他没有机械硬盘所谓的扇区、柱面，磁头。查询逻辑地址上的数据没有机械上的寻址（没有马达）。SSD的存储介质是闪存。  </li><li>SSD存储数据被覆盖的时候不会马上覆盖原有数据，而是继续往之前没有写的闪存上写。因为闪存擦除次数非常有限，同一个地方小范围反复擦除会导致整个SSD的寿命缩短。  </li><li>SSD内部是有自己的GC（垃圾回收器），这个GC擦除不需要的数据以及调整需要的数据的位置，能帮助SSD进行擦除平衡。  </li></ol><p>而这里重点要说到的TRIM功能就是辅助GC更好工作的一环。从Windows 7开始，文件系统上已经集成了自动TRIM功能。但是早些时候的系统，例如Windows XP，就没有这样的功能了。所以手动TRIM工具就出现了。比如Intel的固态硬盘工具集，其中就包含了手动TRIM功能。也许，有人回想，SSD的高端用户团体怎么会还在使用XP呢？不幸的是还真有这样一群坚守XP的SSD用户。下面就记录一些关于执行TRIM要做的事情。</p><p>先决条件：  </p><ol><li>要执行TRIM，首先要确保自己的硬盘模式是AHCI的。  </li><li>然后，系统需要时XP SP2 RC2以上（我想就算是XP的用户，现在也应该都是SP3了吧）。  </li></ol><p>上面的第一条非常重要，因为目前世面上的大部分盗版盘和所有正版安装盘，都是没有带AHCI驱动的。也就是说，如果你的BIOS上把硬盘模式调整为AHCI，那你回没有任何意外看到一个蓝屏。少部分盗版系统盘会说明自己是支持AHCI的，否则，就需要在IDE/ATA模式下，安装系统，然后去网上找到你的BIOS所指定AHCI驱动，安装后在把BIOS调整回AHCI。</p><p>最后，来看看执行TRIM的一种思路：  </p><ol><li>判断系统版本，硬盘的控制器，SSD是否支持TRIM。  </li><li>创建多个1G的文件，直到占满所有磁盘空间。  </li><li>获得这些文件的基于卷的簇。  </li><li>将簇转换成基于卷的逻辑地址。  </li><li>将基于卷的逻辑地址转换成基于硬盘的逻辑地址。  </li><li>按照ATA文档，发送TRIM指令。  </li><li>删除所有创建的1G文件。  </li></ol><p>上面有几个和ATA相关的简单介绍下。首先是SSD是否支持TRIM的问题，需要发送DEVICE IDENTIFY指令，获得硬盘数据，其中WORD 169表示是否支持TRIM，如果是1就是支持了。其次，发生TRIM指令，实际上发送的是DATA SET MANAGEMENT指令，其中Features register设置为1，即为TRIM指令了。至于如何在没有驱动的情况下发生这些指令（这也是我要求系统版本要是XP SP2 RC2以上的原因），可以利用DeviceIOControl函数发送IOCTL_ATA_PASS_THROUGH来完成。</p><p>这些记录已经很详细了，那几百行的代码就没必要贴出来了。</p><p>另外TRIM还有一个思路，实现起来可以麻烦一些，简单说说吧：  </p><ol><li>首先获得NTFS的Bitmap，获得空闲的簇。  </li><li>转换空闲的簇到基于硬盘的逻辑地址。  </li><li>发送TRIM指令  </li></ol><p>之所以说这个比较麻烦，是因为他需要保证在进行TRIM的时候，NTFS不发生写操作。方法就是LOCK VOLUME，但不幸的是，系统盘是没法LOCK的，所以这就不得不写一个Native Application，放在开机的时候运行，也就是Check Disk运行的时机。这个思路的优点是：TRIM全面，精确，速度快。</p><p>差不多就是这些了，希望这个记录对自己和他人都有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一点有关Ntdll中提供的bitmap系列函数</title>
      <link href="/2014/01/18/e4b880e782b9e69c89e585b3ntdlle4b8ade68f90e4be9be79a84bitmape7b3bbe58897e587bde695b0/"/>
      <url>/2014/01/18/e4b880e782b9e69c89e585b3ntdlle4b8ade68f90e4be9be79a84bitmape7b3bbe58897e587bde695b0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们都知道STL中提供了一个bitset类，但是在我真正操作有关文件系统的时候，发现这个类提供的功能并不能满足我的需求。幸运的是Ntdll中提供了一套操作bitmap的API。于是我抽了点时间把这几个API总结了一下，写成了一个类。这个类只是简单的对Ntdll的bitmap相关API做很浅的封装，没啥好说的。要说的是这套bitmap的API用起来确实很方便。<br>这些API包括：<br>RtlInitializeBitMap<br>RtlFindClearBits<br>RtlFindClearBitsAndSet<br>RtlFindClearRuns<br>RtlFindLastBackwardRunClear<br>RtlFindLongestRunClear<br>RtlFindNextForwardRunClear<br>RtlFindSetBits<br>RtlFindSetBitsAndClear<br>RtlSetAllBits<br>RtlSetBits<br>RtlClearAllBits<br>RtlClearBits<br>RtlNumberOfClearBits<br>RtlNumberOfSetBits<br>RtlAreBitsClear<br>RtlAreBitsSet<br>以上这些，在MSDN上都能查到API的详细文档介绍。唯一不方便的就是使用的时候需要GetProcAddress一下。所以我为了自己以后使用方便才写了一个类。</p><p>在项目（<a href="https://github.com/0cch/bitmap">https://github.com/0cch/bitmap</a>）中，bitmap_class是封装类，整个工程是一个使用这套API，获得文件系统的bitmap，并且查找空闲簇的一个例子。</p><p><a href="/uploads/2014/01/2014-01-18_101801.png"><img src="/uploads/2014/01/2014-01-18_101801.png" alt="2014-01-18_101801"></a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>总结和展望：质量比较大点，就不容易被风吹动</title>
      <link href="/2013/12/31/e680bbe7bb93e5928ce5b195e69c9befbc9ae8b4a8e9878fe6af94e8be83e5a4a7e782b9efbc8ce5b0b1e4b88de5aeb9e69893e8a2abe9a38ee590b9e58aa8/"/>
      <url>/2013/12/31/e680bbe7bb93e5928ce5b195e69c9befbc9ae8b4a8e9878fe6af94e8be83e5a4a7e782b9efbc8ce5b0b1e4b88de5aeb9e69893e8a2abe9a38ee590b9e58aa8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>又到了一年一度的总结和展望。时间过得真快，2012年定计划的那会好想就发生在昨天。还能清晰的记得当时的计划，当然也是因为计划定的足够的简单。当然还是把个人的计划放在后面，先来总结下2013年的工作。这年的工作真是富有戏剧性，工作中做了一些网页前端的工作，这确实让我措手不及，不过既然组里有这样的需求，也只能硬着头皮上了，还好是这也并不算忙，不影响个人计划的进展。另一方面，公司拿我们部门和其他公司合并了，<br>换句话说，我们部门被裁了，只不过以一种漂亮的方式。就如同所有的接纳新员工的老大一样，新公司的leader会给你谈未来画大饼。只不过，对不起，我真的不看好这种抱团取暖的合并，所以，我选择离开。由于平时有一定的积累，所以找份靠谱的工作也并不是特别难的事情。能预感到新的工作会比较忙，不过我想，应该还是能hold住的。</p><p>当然，要说最放不下的，要数公司的健身房。掐指一算，已经坚持锻炼了16个月了！依稀记得12年是拼命跑25分钟能跑到4km多点，而13年已经能跑过5km了。一年的时间，让我在25分钟里能超越过去的自己两圈，“想想还有点小激动呢！”。另外肱二头肌和肱三头肌已经比较明显了，上臂粗了好多，穿短袖看起来MAN了好多，不过腹肌虽然能看出来，但还是不算特别明显。这里不得不提醒一下sysdbg的博主，“我督促你健身了16个月，你是不是应该请我吃金钱豹啊？！别客气，跪谢就免了，嗯！”。噢！说到这货，我还想到了一个事情，就是练字。现在字终于写的有点人样了，虽然写急了还是很丑，但是应该比以前好点了吧……大概……是这样。</p><p>我记得，13年的个人计划只有一个就是山寨sysinternals的工具。这次算是完成的比较好吧，工具集中大部分小工具都山寨了，只有个别界面特别复杂，功能特别强大的工具没有山寨。实在是没有动力写界面。另外，又一次把minikernel重写了一次，也围绕这个发布了不少的blog，但是这个minikernel还是缺少挺多的东西，比如很核心的多进程和多线程。一方面是突然遇到公司方面的事情打断了进度，另一个方面也是自己懒。</p><p>至于2014年的个人计划，还真不好说，还不知道新工作是个什么情况，但是我个人还是比较想写一个脚本语言以及完善这个minikernel的。另外继续健身，练字也是必须的。最近因为灌篮高手高清重置版播出了，也导致我又想没事抽出点时间打打球了。另外在13年，花了很多时间看dota2的视频，这个也是被sysdbg的博主吐槽了好久，最近也已经开始戒dota了，时间真是越来越不够用。<br>希望15年写总结的时候，能看到一个质量更大的自己吧，希望写的这些计划能完成75%以上。</p><p>最后，还是祝福家人，朋友，自己在新的一年里幸福安康，合家欢乐！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ShowIEDevTool —— 打开IE控件的开发人员工具</title>
      <link href="/2013/12/07/showiedevtool-e68993e5bc80iee68ea7e4bbb6e79a84e5bc80e58f91e4babae59198e5b7a5e585b7/"/>
      <url>/2013/12/07/showiedevtool-e68993e5bc80iee68ea7e4bbb6e79a84e5bc80e58f91e4babae59198e5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近在网上看到一大牛blog（<a href="http://blog.titilima.com/launch-f12-tools.html">http://blog.titilima.com/launch-f12-tools.html</a>），讨论的是在内嵌的IE窗口中，打开开发人员工具。文章写的很好，而且还提供了开源的工具，实在是业界良心。于是我臭不要脸的A了部分关键代码，弄了个命令行版工具。有兴趣的强烈推荐阅读上面的blog，以及其提供的开源工具的代码。</p><p>下载<a href="/uploads/2013/12/ShowIEDevTool.zip">ShowIEDevTool</a></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XPerfHelper —— XPerf的Windows命令行脚本生成工具</title>
      <link href="/2013/12/01/xperfhelper-xperfe79a84windowse591bde4bba4e8a18ce8849ae69cace7949fe68890e5b7a5e585b7/"/>
      <url>/2013/12/01/xperfhelper-xperfe79a84windowse591bde4bba4e8a18ce8849ae69cace7949fe68890e5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>使用过XPerf的应该都知道，写一个XPerf的命令行是多么的麻烦，如果不太熟悉，需要反复的查看帮助里的参数。所以一般情况下，大家会把命令写到一个cmd或者bat的脚本中，这样就可以双击来使用XPerf，只需要第一次费点心思写脚本罢了。但是我还是觉得，即使是只用写一次脚本，也还是挺麻烦的，于是写了这个小工具，生成cmd脚本文件。妈妈再也不用担心我的XPerf命令写错了。</p><p><a href="/uploads/2013/12/20131201221223.png"><img src="/uploads/2013/12/20131201221223.png" alt="20131201221223"></a></p><p>如上图所示，我们可以选择kernel flag和stackwalk，然后选择providers，点击OK，生成cmd文件即可。下面是一个生成的cmd的内容：</p><p><a href="/uploads/2013/12/20131201222315.png"><img src="/uploads/2013/12/20131201222315.png" alt="20131201222315"></a></p><p>下载<a href="/uploads/2013/12/XPerfHelper.zip">XPerfHelper</a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用ETW对程序进行监控和分析</title>
      <link href="/2013/11/17/e4bdbfe794a8etwe5afb9e7a88be5ba8fe8bf9be8a18ce79b91e68ea7e5928ce58886e69e90/"/>
      <url>/2013/11/17/e4bdbfe794a8etwe5afb9e7a88be5ba8fe8bf9be8a18ce79b91e68ea7e5928ce58886e69e90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ETW（Event Tracing for Windows）是Windows提供的对程序进行事件记录，跟踪，使用的机制。我们可以利用这个机制对程序进行调试和性能分析。从Windows Vista开始，ETW已经非常好的融合在Windows内核之中了，在Windows 7开始，这一个机制更加完善，几乎记录了Windows运行的每一个细节。我个人猜测，从Windows Vista开始到Windows 7直到现在的Windows 8，性能都在不断提高，ETW机制应该是功不可没的。</p><p>ETW是Windows提供的机制，我们要使用他还需要工具，这些工具我们可以自己开发，因为Windows提供了调用接口。当然，更惬意的选择就是直接使用Windows提供的工具集WPT（Windows Performance Toolkit）。利用WPT和SDK，我们可以将ETW融入到我们自己的程序中，帮助我们调试程序和提升性能。</p><p>以下是我们需要的工具：<br>SDK:  </p><ol><li>ECMangen.exe  </li><li>mc.exe  </li></ol><p>Windows:<br>WEVTUtil.exe  </p><p>WPT:  </p><ol><li>XPerf.exe  </li><li>XPerfView.exe  </li></ol><p>首先我们需要用SDK中的工具ECMangen，生成一个manifest文件，这个文件用来描述记录的事件，如图。<br><a href="/uploads/2013/11/20131117114336.png"><img src="/uploads/2013/11/20131117114336.png" alt="20131117114336"></a><br>这里，我们首先创建一个Provider，接下来创建一个Event，参数可以随便填下，就像上图所示。作为演示，这里一个Event就够了（FirstEvent）。<br>然后保存为0CChProvider.man。</p><p>接下来我们MC来生成一个头文件，一个资源文件和两个二进制文件。命令行如：<br>mc -um C:\etw\0CChProvider.man<br><a href="/uploads/2013/11/20131117114801.png"><img src="/uploads/2013/11/20131117114801.png" alt="20131117114801"></a></p><p>然后我们可以创建一个工程，加入这个头文件和资源文件。并且在代码中插入写事件的代码，例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../0CChProvider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">EventRegisterMy0CChProvider</span>();</span><br><span class="line">    <span class="built_in">EventWriteFirstEvent</span>(<span class="string">L&quot;Hello ETW World!&quot;</span>);</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">EventWriteFirstEvent</span>(<span class="string">L&quot;Bye ETW World!&quot;</span>);</span><br><span class="line">    <span class="built_in">EventUnregisterMy0CChProvider</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在这里，我们利用EventRegisterMy0CChProvider先注册自己的Provider，接下写事件才会发挥作用。记录事件后，我们需要反注册Provider。<br>好了，演示代码就这么一点，然后编译即可。</p><p>接下来我们需要注册这个Provider给系统，需要使用到系统自带的工具WEVTUtil.exe。<br>wevtutil im C:\etw\0CChProvider.man</p><p>注册成功后就可以利用XPerf开启ETW，然后运行程序，查看记录的事件了。</p><ol><li>xperf -start 0cch -on My0CChProvider:::’stack’</li><li>xperf -on base</li><li>Run 0CChProvider.exe</li><li>xperf -stop 0cch -stop -d d:\0cch.etl</li><li>xperf d:\0cch.etl</li></ol><p>XPerfView会生成分析数据如图：<br><a href="/uploads/2013/11/20131117115853.png"><img src="/uploads/2013/11/20131117115853.png" alt="20131117115853"></a></p><p><a href="/uploads/2013/11/20131117120007.png"><img src="/uploads/2013/11/20131117120007-1024x622.png" alt="20131117120007"></a></p><p>整体来说，想简单的使用ETW也就是这么简单，当然你也可以把他弄得很复杂，这里就不介绍了。话说<a href="http://sysdbg.com/">sysdbg</a>早就让我写点XPerf的东西，但是因为各种懒没写，刚好最近终于有空了，就先写了这么个简单的介绍，就当作一个开篇吧，话说某人的Blog好久没更新了呀。。。</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windbg script中获得调试环境的基本信息</title>
      <link href="/2013/11/01/windbg-scripte4b8ade88eb7e5be97e8b083e8af95e78eafe5a283e79a84e59fbae69cace4bfa1e681af/"/>
      <url>/2013/11/01/windbg-scripte4b8ade88eb7e5be97e8b083e8af95e78eafe5a283e79a84e59fbae69cace4bfa1e681af/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天继续来玩Windbg script。在写复杂的脚本的时候，可能需要根据调试的环境，指定不同的脚本代码来运行。而Windbg貌似没有提供很好的方式，让脚本得知调试环境。还好，我们可以用一些其他的方式获得这些信息，例如：写一个扩展程序来设置这些信息到Aliase上，<a href="https://github.com/0cch/0cchext">0cchext</a>就实现了这个功能。另外一个方式就是使用脚本自身来获得一些简单的信息，算是个windbg script中的小把戏吧。脚本如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$$ Initialize script environment</span><br><span class="line">$$ Author: nighxie </span><br><span class="line">$$ Blog: <span class="number">0</span>cch.net</span><br><span class="line">$$ @#NtMajorVersion @#NtMinorVersion - System version number.</span><br><span class="line">$$ @#DebugMode - <span class="number">0</span>:kd <span class="number">1</span>:lkd <span class="number">2</span>:user</span><br><span class="line"></span><br><span class="line">ad /q $&#123;/v:$sharedata&#125; </span><br><span class="line"></span><br><span class="line">.<span class="keyword">catch</span> &#123;</span><br><span class="line">    .foreach /pS <span class="number">2</span> ($&#123;/v:$addr&#125; &#123;!kuser&#125;) &#123;</span><br><span class="line">        aS $&#123;/v:$sharedata&#125; $&#123;$addr&#125;;</span><br><span class="line">        .leave;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.block &#123;</span><br><span class="line">    r @$t0=$&#123;$sharedata&#125;;</span><br><span class="line">    aS /x $&#123;/v:@#NtMajorVersion&#125; @@C++(((nt!_KUSER_SHARED_DATA *)@$t0)-&gt;NtMajorVersion);</span><br><span class="line">    aS /x $&#123;/v:@#NtMinorVersion&#125; @@C++(((nt!_KUSER_SHARED_DATA *)@$t0)-&gt;NtMinorVersion);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ad /q $&#123;/v:$sharedata&#125; </span><br><span class="line"></span><br><span class="line">.<span class="keyword">catch</span> &#123;</span><br><span class="line">    r @$t0 = <span class="number">0</span>;</span><br><span class="line">    .foreach ($&#123;/v:$addr&#125; &#123;lm1m m nt&#125;) &#123;</span><br><span class="line">        r @$t0 = $&#123;$addr&#125;;</span><br><span class="line">        .leave;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> ($<span class="built_in">vvalid</span>(@$t0, <span class="number">1</span>)) &#123;</span><br><span class="line">    aS $&#123;/v:@#DebugMode&#125; <span class="number">0</span>;</span><br><span class="line">     .foreach ($&#123;/v:$val&#125; &#123;.<span class="keyword">catch</span>&#123;? @eax&#125;&#125;) &#123;</span><br><span class="line">        .<span class="keyword">if</span> ($<span class="built_in">scmp</span>(<span class="string">&quot;$&#123;$val&#125;&quot;</span>, <span class="string">&quot;\&#x27;@eax\&#x27;&quot;</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">            aS $&#123;/v:@#DebugMode&#125; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="keyword">else</span> &#123;</span><br><span class="line">    aS $&#123;/v:@#DebugMode&#125; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windbg script的notepad++语法高亮配置文件</title>
      <link href="/2013/10/15/windbg-scripte79a84notepade8afade6b395e9ab98e4baaee9858de7bdaee69687e4bbb6/"/>
      <url>/2013/10/15/windbg-scripte79a84notepade8afade6b395e9ab98e4baaee9858de7bdaee69687e4bbb6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>经常写复杂的windbg脚本的程序员肯定知道，windbg脚本的宏替换的执行方式，让人非常的不舒服。另外windbg的脚本也没有一个好用的语法高亮编辑器，所以让脚本写起来更加痛苦。前者看来是已成定局，很难解决了。不过后者还是有机会改善的，闲暇之余，写了一个notepad++上的windbg脚本的语法高亮配置文件。以<a href="http://0cch.net/wordpress/?p=363">上一篇文章</a>中的windbg脚本为例，高亮效果如下图：</p><p><a href="/uploads/2013/10/20131015164715.png"><img src="/uploads/2013/10/20131015164715.png" alt="20131015164715"></a></p><p>导入方式也非常简单，点击[语言]菜单下的define your language，在弹出的对话框中点击导入按钮，导入配置文件即可。</p><p><a href="/uploads/2013/10/20131015164704.png"><img src="/uploads/2013/10/20131015164704.png" alt="20131015164704"></a></p><p>下载脚本<a href="/uploads/2013/10/wds.zip">wds</a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windbg内核调试查看窗口句柄信息的脚本</title>
      <link href="/2013/10/07/windbge58685e6a0b8e8b083e8af95e69fa5e79c8be7aa97e58fa3e58fa5e69f84e4bfa1e681afe79a84e8849ae69cac/"/>
      <url>/2013/10/07/windbge58685e6a0b8e8b083e8af95e69fa5e79c8be7aa97e58fa3e58fa5e69f84e4bfa1e681afe79a84e8849ae69cac/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>十一长假瞬间就结束了，整一周都在玩，也没有研究什么好玩的东西，这里就分享一个以前写的windbg脚本吧。通途是内核调试查看窗口句柄信息。用法很简单，例如 $$&gt;a&lt;hwnd.wds 000207B8。运行结果如下图：</p><p><a href="/uploads/2013/10/20131007195716.png"><img src="/uploads/2013/10/20131007195716.png" alt="20131007195716"></a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$$ Convert HWND to tagWnd</span><br><span class="line">$$ Author: nighxie </span><br><span class="line">$$ Blog: <span class="number">0</span>cch.net</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> ($&#123;/d:$arg1&#125;) &#123;</span><br><span class="line"></span><br><span class="line">    .<span class="keyword">if</span> ($&#123;/d:$arg2&#125;) &#123;</span><br><span class="line">            .<span class="keyword">if</span> ($&#123;$arg2&#125; == <span class="number">1</span>) &#123;</span><br><span class="line">                r $t0 = nt!PsActiveProcessHead</span><br><span class="line">                .<span class="keyword">for</span> (r $t1 = <span class="built_in">poi</span>(@$t0);(@$t1 != <span class="number">0</span>) &amp; (@$t1 != @$t0);r $t1 = <span class="built_in">poi</span>(@$t1)) &#123;</span><br><span class="line">                r? $t2 = #<span class="built_in">CONTAINING_RECORD</span>(@$t1, nt!_EPROCESS, ActiveProcessLinks);</span><br><span class="line">                as /x $&#123;/v:$ProcAddr&#125; @$t2;</span><br><span class="line">                as /ma $&#123;/v:$ImageName&#125; @@c++(&amp;@$t2-&gt;ImageFileName[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                .block &#123;</span><br><span class="line">                    $$ .echo $&#123;$ImageName&#125;</span><br><span class="line">                    .<span class="keyword">if</span> ($<span class="built_in">sicmp</span>(<span class="string">&quot;$&#123;$ImageName&#125;&quot;</span>, <span class="string">&quot;explorer.exe&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        .echo Found the process at $&#123;$ProcAddr&#125;;</span><br><span class="line">                        .process /p /r $&#123;$ProcAddr&#125;;</span><br><span class="line">                        ad $&#123;/v:$ImageName&#125;;</span><br><span class="line">                        ad $&#123;/v:$ProcAddr&#125;;</span><br><span class="line">                        .<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ad $&#123;/v:$ImageName&#125;;</span><br><span class="line">                ad $&#123;/v:$ProcAddr&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    r @$t1 = $&#123;$arg1&#125;;</span><br><span class="line">    r @$t0 = win32k!gSharedInfo;</span><br><span class="line">    .<span class="keyword">if</span> ((@$t1&amp;<span class="number">0xffff</span>) &lt; @@C++(((win32k!tagSHAREDINFO *)@$t0)-&gt;psi-&gt;cHandleEntries)) &#123;</span><br><span class="line">        r @$t0 = @@C++(((win32k!tagSHAREDINFO *)@$t0)-&gt;aheList);</span><br><span class="line">        r @$t0 = @@C++(@$t0+(@$t1&amp;<span class="number">0xffff</span>)*<span class="built_in"><span class="keyword">sizeof</span></span>(win32k!_HANDLEENTRY));</span><br><span class="line">        r @$t0 = <span class="built_in">poi</span>(@$t0);</span><br><span class="line">        .printf <span class="string">&quot;HWND: %p\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;head.h);</span><br><span class="line">        .printf /D <span class="string">&quot;tagWnd * @ %p\n&quot;</span>, @$t0;</span><br><span class="line">        .<span class="keyword">if</span> (@@C++(((win32k!tagWnd *)@$t0)-&gt;strName.Buffer) != <span class="number">0</span>) &#123;</span><br><span class="line">            .printf <span class="string">&quot;Window Name: %mu\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;strName.Buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        .printf /D <span class="string">&quot;tagCLS * @ pcls) win32k!tagCLS\&quot;&gt;%p\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;pcls);</span><br><span class="line">        .<span class="keyword">if</span> (@@C++(((win32k!tagWnd *)@$t0)-&gt;pcls-&gt;lpszAnsiClassName) != <span class="number">0</span>) &#123;</span><br><span class="line">            .printf <span class="string">&quot;Window Class Name: %ma\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;pcls-&gt;lpszAnsiClassName);</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">if</span> (@@C++(((win32k!tagWnd *)@$t0)-&gt;spwndNext) != <span class="number">0</span>) &#123;</span><br><span class="line">            .printf <span class="string">&quot;Next Wnd:     %p\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;spwndNext-&gt;head.h);</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">if</span> (@@C++(((win32k!tagWnd *)@$t0)-&gt;spwndPrev) != <span class="number">0</span>) &#123;</span><br><span class="line">            .printf <span class="string">&quot;Previous Wnd: %p\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;spwndPrev-&gt;head.h);</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">if</span> (@@C++(((win32k!tagWnd *)@$t0)-&gt;spwndParent) != <span class="number">0</span>) &#123;</span><br><span class="line">            .printf <span class="string">&quot;Parent Wnd:   %p\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;spwndParent-&gt;head.h);</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">if</span> (@@C++(((win32k!tagWnd *)@$t0)-&gt;spwndChild) != <span class="number">0</span>) &#123;</span><br><span class="line">            .printf <span class="string">&quot;Child Wnd:    %p\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;spwndChild-&gt;head.h);</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">if</span> (@@C++(((win32k!tagWnd *)@$t0)-&gt;spwndOwner) != <span class="number">0</span>) &#123;</span><br><span class="line">            .printf <span class="string">&quot;Own Wnd:      %p\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;spwndOwner-&gt;head.h);</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">if</span> (@@C++(((win32k!tagWnd *)@$t0)-&gt;lpfnWndProc) != <span class="number">0</span>) &#123;</span><br><span class="line">            .printf /D <span class="string">&quot;pfnWndProc:   head.pti-&gt;pEThread)-&gt;Tcb.Process);u @@C++(((win32k!tagWnd *)@$t0)-&gt;lpfnWndProc)\&quot;&gt;%p\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;lpfnWndProc);</span><br><span class="line">        &#125;</span><br><span class="line">        .printf <span class="string">&quot;Visiable: %d\n&quot;</span>, @@C++((((win32k!tagWnd *)@$t0)-&gt;style &amp; (<span class="number">1</span>&lt;&lt;<span class="number">28</span>)) != <span class="number">0</span>);</span><br><span class="line">        .printf <span class="string">&quot;Child:    %d\n&quot;</span>, @@C++((((win32k!tagWnd *)@$t0)-&gt;style &amp; (<span class="number">1</span>&lt;&lt;<span class="number">30</span>)) != <span class="number">0</span>);</span><br><span class="line">        .printf <span class="string">&quot;Minimized:%d\n&quot;</span>, @@C++((((win32k!tagWnd *)@$t0)-&gt;style &amp; (<span class="number">1</span>&lt;&lt;<span class="number">29</span>)) != <span class="number">0</span>);</span><br><span class="line">        .printf <span class="string">&quot;Disabled: %d\n&quot;</span>, @@C++((((win32k!tagWnd *)@$t0)-&gt;style &amp; (<span class="number">1</span>&lt;&lt;<span class="number">27</span>)) != <span class="number">0</span>);</span><br><span class="line">        .printf <span class="string">&quot;Window Rect &#123; %d, %d, %d, %d&#125;\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;rcWindow.left), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcWindow.top), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcWindow.right), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcWindow.bottom);</span><br><span class="line">        .printf <span class="string">&quot;Clent Rect  &#123; %d, %d, %d, %d&#125;\n&quot;</span>, @@C++(((win32k!tagWnd *)@$t0)-&gt;rcClient.left), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcClient.top), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcClient.right), @@C++(((win32k!tagWnd *)@$t0)-&gt;rcClient.bottom);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="keyword">else</span> &#123;</span><br><span class="line">        .printf <span class="string">&quot;HWND is out of range.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">.<span class="keyword">else</span> &#123;</span><br><span class="line">    .echo <span class="string">&quot;Usage $$&gt;a&lt;$&#123;$arg0&#125; HWND(HEX)&quot;</span></span><br><span class="line">    .echo <span class="string">&quot;e.g. $$&gt;a&lt;$&#123;$arg0&#125; 0x60962&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解析youku视频地址的python脚本</title>
      <link href="/2013/09/28/e8a7a3e69e90youkue8a786e9a291e59cb0e59d80e79a84pythone8849ae69cac/"/>
      <url>/2013/09/28/e8a7a3e69e90youkue8a786e9a291e59cb0e59d80e79a84pythone8849ae69cac/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>几个月前写的东西，偶然翻出来发现还能用，就贴出来吧。非专业python程序员，代码比较乱 :-(</p><p><a href="/uploads/2013/09/20130928134507.png"><img src="/uploads/2013/09/20130928134507.png" alt="20130928134507"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Created on 2013-3-6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: nightxie</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetKeyString</span>(<span class="params">seed</span>):</span></span><br><span class="line">    base_string = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/\\:._-1234567890&#x27;</span>;</span><br><span class="line">    target_string = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(base_string) != <span class="number">0</span> :</span><br><span class="line">        seed = (seed * <span class="number">211</span> + <span class="number">30031</span>) % <span class="number">65536</span>;</span><br><span class="line">        index = (seed / <span class="number">65536</span> * <span class="built_in">len</span>(base_string));</span><br><span class="line">        target_string += base_string[<span class="built_in">int</span>(index)];</span><br><span class="line">        base_string = base_string[:<span class="built_in">int</span>(index)] + base_string[<span class="built_in">int</span>(index)+<span class="number">1</span>:];</span><br><span class="line">    <span class="keyword">return</span> target_string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFildId</span>(<span class="params">daye_str, seed</span>):</span></span><br><span class="line"></span><br><span class="line">    new_list = daye_str.split(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    target_string = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    base_string = GetKeyString(seed);</span><br><span class="line">    length = <span class="built_in">len</span>(new_list);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> i &lt; length - <span class="number">1</span>:</span><br><span class="line">        index = <span class="built_in">int</span>(new_list[i]);</span><br><span class="line">        target_string += base_string[index];</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> target_string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFlvPath</span>(<span class="params">videoids, flv_type</span>):</span></span><br><span class="line">    url = <span class="string">&#x27;http://v.youku.com/player/getPlayList/VideoIDS/&#x27;</span> + videoids + <span class="string">&#x27;/timezone/+08/version/5/source/video&#x27;</span></span><br><span class="line">    req = urllib.request.Request(url);</span><br><span class="line">    req.add_header(<span class="string">&#x27;Referer&#x27;</span>, <span class="string">&#x27;http://static.youku.com/v1.0.0307/v/swf/player_yk.swf&#x27;</span>);</span><br><span class="line">    req.add_header(<span class="string">&#x27;User-Agent&#x27;</span>, <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.56 Safari/537.17&#x27;</span>);</span><br><span class="line">    play_list = urllib.request.urlopen(req).read().decode(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    play_list_data = json.loads(play_list)[<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>];</span><br><span class="line">    seed = play_list_data[<span class="string">&#x27;seed&#x27;</span>];</span><br><span class="line">    streamfileids = play_list_data[<span class="string">&#x27;streamfileids&#x27;</span>];</span><br><span class="line">    regs = play_list_data[<span class="string">&#x27;segs&#x27;</span>];</span><br><span class="line">    </span><br><span class="line">    type_fileid = streamfileids[flv_type];</span><br><span class="line">    type_list = regs[flv_type];</span><br><span class="line">    url_type = flv_type;</span><br><span class="line">    <span class="keyword">if</span> url_type == <span class="string">&#x27;hd2&#x27;</span>:</span><br><span class="line">        url_type = <span class="string">&#x27;flv&#x27;</span></span><br><span class="line">    </span><br><span class="line">    type_list_count = <span class="built_in">len</span>(type_list);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> i &lt; type_list_count :</span><br><span class="line">        fileid = GetFildId(type_fileid, seed);</span><br><span class="line">        fileid = fileid[:<span class="number">8</span>] + (<span class="string">&quot;%0.2X&quot;</span> % i) + fileid[<span class="number">10</span>:];</span><br><span class="line">        fileid += <span class="string">&#x27;?k=&#x27;</span>;</span><br><span class="line">        fileid += type_list[i][<span class="string">&#x27;k&#x27;</span>];</span><br><span class="line">        flv_path = <span class="string">&#x27;http://f.youku.com/player/getFlvPath/sid/00_00/st/&#x27;</span>+url_type+<span class="string">&#x27;/fileid/&#x27;</span> + fileid;</span><br><span class="line">        <span class="built_in">print</span>(flv_path);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetVideoIdsFromUrl</span>(<span class="params">url</span>):</span></span><br><span class="line">    url_object = urllib.parse.urlparse(url);</span><br><span class="line">    url_path = url_object.path;</span><br><span class="line">    <span class="keyword">return</span> url_path[<span class="number">11</span>:-<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFlvPathFromUrl</span>(<span class="params">url, video_type</span>):</span></span><br><span class="line">    video_ids = GetVideoIdsFromUrl(url);</span><br><span class="line">    GetFlvPath(video_ids, video_type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        GetFlvPathFromUrl(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;youku.py  &quot;</span>);</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Floppy Disk Controller编程</title>
      <link href="/2013/09/21/floppy-disk-controllere7bc96e7a88b/"/>
      <url>/2013/09/21/floppy-disk-controllere7bc96e7a88b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="/uploads/2013/09/N82077AA.jpg"><img src="/uploads/2013/09/N82077AA.jpg" alt="N82077AA"></a></p><p>看的没错，这篇文章将描述一些关于Floppy Disk Controller的编程知识。我们知道，在当今的计算机硬件体系中，软盘驱动器是一个已经完全被淘汰的设备，那么为什么还要有这样一篇文章？原因很简单，如果想构建自己的操作系统，必须有相应的存储介质，而软盘正是这样一个好的存储介质。他的容量虽然很小，但是却完全足够应付我们的内核程序，另一方面软盘驱动器的控制相对于之前我所介绍的硬盘的控制要简单的多，而且关于软盘驱动器控制的教程和文章在互联网上也非常的多（虽然绝大部分都是英文的）。基于以上几点，我认为还是有必要把自己学到的知识写下了分享。</p><p>Floppy Disk Controller，中文称为：软盘控制器，简称：FDC，是一个用来控制软盘驱动器的芯片。在1980年代到1990年代，软盘控制器普遍使用于个人电脑以及与IBM PC兼容的机型上，如 8272A、82078、82077SL以及82077AA，其中82077AA是最先进的一款芯片（1991年开始生产）。除了软盘控制器，软驱本身也在几十年的历史中留下了许多机型，如图所示：<br><a href="/uploads/2013/09/floppy_types.png"><img src="/uploads/2013/09/floppy_types.png" alt="floppy_types"></a><br>实际上，我从刚刚接触软盘到最后软盘被淘汰，只使用过3.5英寸1.44MB的软盘，其他型号完全没有接触过。</p><p>对于CPU还运行在实模式下的启动引导程序和内核程序，我们可以调用BIOS提供的函数来完成软盘的访问，其中中断号是13h（INT13h），功能号为2（AH=2）是读取操作，功能号为3（AH=3）时是写入操作。实模式下通过中断读写软盘的资料很多（包括中文资料），如果想了解更多的实模式下访问软盘的知识，可以上网google一下，我这里就不做详细的介绍了。</p><p>虽然调用中断访问软盘简单，但是我们不能让自己的内核总是跑在实模式下啊。所以我们需要写一个能跑在保护模式下的软驱驱动，要完成这样的驱动，就必须对FDC进行编程了。不过在此之前，我们需要知道，到底PC上有没有软驱。要获得这个信息，我们需要读取CMOS，然后解析读取的信息即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx, 70h</span><br><span class="line">mov al, 10h</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">mov dx, 71h</span><br><span class="line">in  al, dx</span><br><span class="line"></span><br><span class="line">mov f_b, al</span><br><span class="line">and f_b, 0fh</span><br><span class="line">shr al, 4</span><br><span class="line">mov f_a, al</span><br><span class="line"></span><br><span class="line">f_a db0h</span><br><span class="line">f_b db0h</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>要从CMOS中获得软盘信息，我们需要先给对应的端口设置正确的索引，然后再去数据端口读取数据。具体做法是设置0x70端口为0x10，然后读取0x71端口。读取到的信息都放在一个字节中，需要把字节分为两个部分，高四位是驱动器A的类型索引号，低四位是驱动器B的类型索引号。索引号与软盘类型的对应关系如下图所示：<br><a href="/uploads/2013/09/cmos_floppytype.png"><img src="/uploads/2013/09/cmos_floppytype.png" alt="cmos_floppytype"></a></p><p>在确认了软驱存在的情况下，接下来就可以对FDC进行编程了。先来看看FDC的几个基本知识。</p><p><strong>寻址方式</strong><br>软盘驱动器使用CHS寻址方式。软盘介质总是有两个头（面），但磁道数和每个磁道的扇区扇区数是不一定的。通常情况下，1.44mb的软盘，他有80个磁道和每个磁道有18个扇区。另外值得注意的是，磁道和磁头是从0开始计算，但是扇区是从1开始计数的。即，有效的磁道通常为0到79，磁头为0或1，而扇区号是1到18的。如果访问0号扇区，那么一定会引起访问错误的。</p><p><strong>数据传输方式</strong><br>和硬盘的数据传输方式一样，软盘也支持PIO和DMA两种数据传输方式。<br>软盘使用的通常是ISA DMA方式（这和 PCI BusMastering DMA完全是两码事）。使用DMA传输的方法，简单来说就是这是DMA的通道2，如传输的字节数以及对应的物理地址。物理地址必须是以64k为边界的。当然，还需要设置IRQ6，当数据传输结束的时候，控制器将发送一个IRQ6的中断。用DMA传输数据，这个过程是不需要占用CPU时间的，对于多任务的系统是比较好的选择。缺点是ISA DMA这种古老的DMA比PIO还要慢。<br>PIO数据传输既可以使用轮询，也能使用中断。使用PIO模式传输数据的速度比DMA传输快10％，但这会消耗CPU周期，是一个巨大的成本问题。然而，如果我们的操作系统或应用程序是单任务的，那么没有别的程序需要CPU，这样你就也可以使用PIO模式。使用PIO的要点是，在设置好了各种命令后，需要等待中断或者轮询状态结果，最后还需要使用IO的方式，读取数据，也就是这部分需要消耗额外的CPU周期。<br>值得注意的是，bochs并不支持PIO模式，使用PIO模式的时候bochs会报错，提示没有完全实现PIO模式。所以我在实验代码中也没有写PIO的代码。毕竟我的实验环境是bochs。</p><p><strong>ISA DMA</strong><br>ISA DMA全称Industry Standard Architecture Direct Memory Access，是一种古老的DMA方式，速度比PIO还要慢，但是编程相对于PCI BusMastering DMA要简单一点。这里我并不打算详细介绍ISA DMA，因为说明它需要的篇幅不亚于这篇。后面的代码中，在必要的地方我会加入一些解释。</p><p><strong>3种模式</strong><br>这三种模式是：PC-AT模式，PS/2模式，Mode 30模式。现在最有可能看到硬件上仍然运行模式是30模式。</p><p>FDC寄存器<br><a href="/uploads/2013/09/floppy_regs.png"><img src="/uploads/2013/09/floppy_regs.png" alt="floppy_regs"></a></p><p>如上图所示，上面的寄存器我们不会都用到，一般情况下大概只会用到一半的样子，其他的我们可以暂时不去理会。另外我在这里不会列出每个寄存器的详细参数，因为这些参数很多而且复杂，不仅单调乏味，而且容易让初学者望而却步。我采取的做法是，先列出控制FDC的代码，然后在需要讲解的地方详细的说明。</p><p><strong>实践</strong><br>下面就是一段控制FDC读取软盘数据的代码。需要说明的是这份代码为了保持简洁易学，它没有任何的错误检测，另外代码也假设了你已经初始化了PIC，并且设置好了IRQ6。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; MASM的宏应该不陌生吧，就不做解释了。</span><br><span class="line">outb macro port:req, b:req</span><br><span class="line">    mov dx, port</span><br><span class="line">    mov al, b</span><br><span class="line">    out dx, al</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">inb macro port:req</span><br><span class="line">    mov dx, port</span><br><span class="line">    in al, dx</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">wait_status macro</span><br><span class="line">    inb 3f4h</span><br><span class="line">@@:</span><br><span class="line">    test al, 80h</span><br><span class="line">    jz @B</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">; ISA DMA 初始化部分， 由于ISA DMA不是这篇文章的重点</span><br><span class="line">; 所以这里只说明大概的用途。</span><br><span class="line">outb 0dh, 0ffh      ; 重置DMA控制器</span><br><span class="line">outb 0ah, 6h        ; 选择设置2号DMA通道</span><br><span class="line">outb 0ch, 0ffh      ; 重置Flipflop寄存器</span><br><span class="line">outb 4h, 0h         ; 设置DMA的物理地址，需要设置两次</span><br><span class="line">outb 4h, 0f0h       ; 我这里设置的是0xf000</span><br><span class="line">outb 81h, 0h        ; 设置地址24bit的高8bit为0，也就是0x00f000</span><br><span class="line">outb 0ch, 0ffh      ; 重置Flipflop寄存器</span><br><span class="line">outb 5h, 0ffh       ; 设置物理内存大小，其大小为Length-1</span><br><span class="line">outb 5h, 0fh        ; 我这里的内存大小是0x1000，所以设置为0xfff</span><br><span class="line">outb 0ah, 2h        ; 选择清除2号DMA通道</span><br><span class="line"></span><br><span class="line">; FDC的初始化过程</span><br><span class="line">outb 3f2h, 0h       ; 1.重置数字输出寄存器</span><br><span class="line">outb 3f2h, 0ch</span><br><span class="line">call WaitIrq</span><br><span class="line"></span><br><span class="line">mov ecx, 4</span><br><span class="line">check_int:</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 8h       ; 发送8号命令，该命令清除控制器触发的中断</span><br><span class="line">wait_status         ; 并且返回结果，这里重复4次，是为了清除4个软驱的状态</span><br><span class="line">inb 3f5h</span><br><span class="line">wait_status</span><br><span class="line">inb 3f5h</span><br><span class="line">wait_status</span><br><span class="line">loop check_int</span><br><span class="line"></span><br><span class="line">outb 3f7h, 0h       ; 2.设置传输速度为500kb&#x2F;s</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 3h       ; 3.设置FDC里面三个时钟以及DMA。</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 0dfh</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 2h</span><br><span class="line"></span><br><span class="line">outb 3f2h, 1ch      ; 开启软驱电动机</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 7h       ; 发送校验命令</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 0h       ; 选择0号软驱</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 8h       ; 发送清楚中断命令，获得结果</span><br><span class="line">wait_status</span><br><span class="line">inb 3f5h</span><br><span class="line">wait_status</span><br><span class="line">inb 3f5h</span><br><span class="line">outb 3f2h, 4h       ; 关闭电动机</span><br><span class="line"></span><br><span class="line">; 接下来是软盘的读取操作</span><br><span class="line">outb 3f2h, 1ch      ; 开启电动机</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 0fh      ; 4.发送0f寻道命令</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 0h</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 0h</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 8h       ; 发送清楚中断命令，获得结果</span><br><span class="line">wait_status</span><br><span class="line">inb 3f5h</span><br><span class="line">wait_status</span><br><span class="line">inb 3f5h</span><br><span class="line"></span><br><span class="line">; 设置ISA DMA为读取</span><br><span class="line">outb 0ah, 6h</span><br><span class="line">outb 0bh, 46h</span><br><span class="line">outb 0ah, 2h</span><br><span class="line"></span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 0e6h     ; 5.发送读取扇区命令</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 0h       ; 设置磁头和驱动器号</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 0h       ; 设置磁道</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 0h       ; 设置磁头</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 1h       ; 设置扇区号</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 2h       ; 设置扇区大小</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 8h       ; 设置读取扇区数量</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 1bh      ; 设置磁盘为3.5英寸</span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 0ffh     ; 设置读取长度，总是0xff</span><br><span class="line"></span><br><span class="line">call WaitIrq</span><br><span class="line"></span><br><span class="line">mov ecx, 7</span><br><span class="line">loop_ret:</span><br><span class="line">wait_status</span><br><span class="line">inb 3f5h</span><br><span class="line">loop loop_ret</span><br><span class="line"></span><br><span class="line">wait_status</span><br><span class="line">outb 3f5h, 8h       ; 发送清楚中断命令，获得结果</span><br><span class="line">wait_status</span><br><span class="line">inb 3f5h</span><br><span class="line">wait_status</span><br><span class="line">inb 3f5h</span><br><span class="line">outb 3f2h, 4h       ; 关闭电动机</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>1.重置数字输出寄存器<br>这是一个只写寄存器，可以用来控制FDC，例如控制软驱电动机，重置控制器，选择目标软驱，设置数据模式，以下是他的详细参数<br>Bits 0-1<br>00 - 软驱 0<br>01 - 软驱 1<br>10 - 软驱 2<br>11 - 软驱 3<br>Bit 2 重置<br>0 - 重置控制器<br>1 - 开启控制器<br>Bit 3 模式<br>0 - IRQ 模式<br>1 - DMA 模式<br>Bits 4 - 7 电动机控制器 (软驱 0 - 3)<br>0 - 停止电动机<br>1 - 开启电动机  </p><p>我这里设置的是0Ch也就是说，选择了0号软驱，开启了控制器和DMA模式。</p><p>2.设置传输速度为500kb/s<br>这个寄存器只有前两位有效，下面两位不同的组合表达了不同的速度，如下表：<br>00 500 Kbps<br>10 250 Kbps<br>01 300 Kbps<br>11 1 Mbps  </p><p>3.设置FDC里面三个时钟以及DMA<br>三个时钟分别是步进速率时钟、磁头卸载时钟和磁头装入时钟。数据格式如下：<br>S S S S H H H H - S=步进速率时钟 H=磁头卸载时钟<br>H H H H H H H NDMA - H=磁头装入时钟 NDMA=0 (DMA模式) 或者 1 (非DMA模式)<br>实际上这个大家可以随意设置，我设置的是步进速率时钟=3ms, 磁头卸载时钟=240ms, 磁头装入时钟=16ms  </p><p>4.发送寻道命令进行寻道<br>寻道命令的参数是两个自己，分别代表磁头、柱面和驱动器号，格式如下<br>x x x x x HD DR1 DR0 - HD=磁头 DR1/DR0 = 驱动器<br>C C C C C C C C - C=柱面  </p><p>5.发送读取扇区命令<br>读取和写入命令一样，有8个参数和7个返回值！<br>第1个参数字节 = (磁头号 &lt;&lt; 2) | 驱动器号 (驱动器号必须是当前选择的驱动器)<br>第2个参数字节 = 柱面号<br>第3个参数字节 = 磁头号 (没错，重复了 = =)<br>第4个参数字节 = 开始的扇区号<br>第5个参数字节 = 2 (总是2，代表软盘扇区大小总是512字节)<br>第6个参数字节 = 操作扇区数<br>第7个参数字节 = 0x1b (软盘大小是3.5in)<br>第8个参数字节 = 0xff (总是0xff)<br>这里不关心返回值，如果有兴趣可以自己查找资料。  </p><p>读取就是这样，如果要写入安排，只需要更改命令即可，这里就不再赘述了。最后按照国际惯例，提供一些深入学习的链接：<br><a href="http://wiki.osdev.org/Floppy">http://wiki.osdev.org/Floppy</a><br><a href="http://en.wikipedia.org/wiki/Floppy">http://en.wikipedia.org/wiki/Floppy</a><br><a href="http://www.isdaman.com/alsos/hardware/fdc/floppy.htm">http://www.isdaman.com/alsos/hardware/fdc/floppy.htm</a><br><a href="http://www.osdever.net/documents/82077AA_FloppyControllerDatasheet.pdf?the_id=41">http://www.osdever.net/documents/82077AA_FloppyControllerDatasheet.pdf</a>  </p>]]></content>
      
      
      <categories>
          
          <category> MiniKernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Windbg Logexts监控程序API调用</title>
      <link href="/2013/09/14/e4bdbfe794a8windbg-logextse79b91e68ea7e7a88be5ba8fapie8b083e794a8/"/>
      <url>/2013/09/14/e4bdbfe794a8windbg-logextse79b91e68ea7e7a88be5ba8fapie8b083e794a8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在我们调试BUG和逆向程序的时候，往往需要监控一些API的调用。这个时候我们可以借助调试器和第三方工具完成这样的任务。例如调试器可以下断点查看栈状态得到相关信息，或者使用第三方工具如API Monitor可以方便的监控API的调用。不过，这篇文章中想说的是另一个工具，Windbg的扩展程序Logexts.dll。闲话少说，我们先看一看监控的效果如何吧。</p><p><a href="/uploads/2013/09/20130914230701.png"><img src="/uploads/2013/09/20130914230701.png" alt="20130914230701"></a></p><p>上图是Windbg输出的信息，再看看使用logviewer.exe查看的效果。</p><p><a href="/uploads/2013/09/20130914234812.png"><img src="/uploads/2013/09/20130914234812.png" alt="20130914234812"></a></p><p>怎么样，是不是相当的不错！那么下面我就来简单介绍一下，这个扩展的用法。</p><p>!logexts.logi<br>将Logger注入目标程序，初始化监控，但是并不开启它。</p><p>!logexts.loge<br>开启监控，如果之前没有调用logexts.logi，这个扩展命令会先初始化监控，然后启动。</p><p>!logexts.logd<br>停止监控。这个命令会摘掉所有的Hook，从而让程序自由运行。不过COM的Hook并不会被摘除。</p><p>!logexts.logo<br>显示或者修改输出选项，这里有三种输出方式：1.在调试器中显示，2.输出到一个文本文件，3.输出到lgv文件。其中lgv文件会包含更多的信息，我们可以使用LogViewer进行查看。</p><p>!logexts.logc<br>显示或者控制监控的API分类。</p><p>!logexts.logb<br>显示或者刷新输出缓存。由于如果在监控过程中发生异常，那么扩展可能无法将记录的日志写入文件中，这个时候我们就需要这个命令，手动的将缓存中的数据写入文件。</p><p>!logexts.logm<br>显示和创建模块的包含/排除列表。这可以帮助我们指定记录那些特定模块中的API调用。</p><p>上面图中我所使用的命令是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;!logexts.loge D:\  </span><br><span class="line">!logexts.logc d *  </span><br><span class="line">!logexts.logc e 15 16 19  </span><br><span class="line">!logexts.logo e *  </span><br><span class="line">!logexts.logm i notepad.exe</span><br></pre></td></tr></table></figure><p>其输出结果是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!logexts.loge D:\  </span><br><span class="line">Windows API Logging Extensions v3.01  </span><br><span class="line">Parsing the manifest files...  </span><br><span class="line">Location: C:\Program Files (x86)\Windows Kits\8.0\Debuggers\x64\winext\manifest\main.h  </span><br><span class="line">Parsing file &quot;main.h&quot; ...  </span><br><span class="line">Parsing file &quot;winerror.h&quot; ...  </span><br><span class="line">Parsing file &quot;kernel32.h&quot; ...  </span><br><span class="line">Parsing file &quot;debugging.h&quot; ...  </span><br><span class="line">Parsing file &quot;processes.h&quot; ...  </span><br><span class="line">Parsing file &quot;memory.h&quot; ...  </span><br><span class="line">Parsing file &quot;registry.h&quot; ...  </span><br><span class="line">Parsing file &quot;fileio.h&quot; ...  </span><br><span class="line">Parsing file &quot;strings.h&quot; ...  </span><br><span class="line">Parsing file &quot;user32.h&quot; ...  </span><br><span class="line">Parsing file &quot;clipboard.h&quot; ...  </span><br><span class="line">Parsing file &quot;hook.h&quot; ...  </span><br><span class="line">Parsing file &quot;gdi32.h&quot; ...  </span><br><span class="line">Parsing file &quot;winspool.h&quot; ...  </span><br><span class="line">Parsing file &quot;version.h&quot; ...  </span><br><span class="line">Parsing file &quot;winsock2.h&quot; ...  </span><br><span class="line">Parsing file &quot;advapi32.h&quot; ...  </span><br><span class="line">Parsing file &quot;uuids.h&quot; ...  </span><br><span class="line">Parsing file &quot;com.h&quot; ...  </span><br><span class="line">Parsing file &quot;shell.h&quot; ...  </span><br><span class="line">Parsing file &quot;ole32.h&quot; ...  </span><br><span class="line">Parsing file &quot;ddraw.h&quot; ...  </span><br><span class="line">Parsing file &quot;winmm.h&quot; ...  </span><br><span class="line">Parsing file &quot;avifile.h&quot; ...  </span><br><span class="line">Parsing file &quot;dplay.h&quot; ...  </span><br><span class="line">Parsing file &quot;d3d.h&quot; ...  </span><br><span class="line">Parsing file &quot;d3dtypes.h&quot; ...  </span><br><span class="line">Parsing file &quot;d3dcaps.h&quot; ...  </span><br><span class="line">Parsing file &quot;d3d8.h&quot; ...  </span><br><span class="line">Parsing file &quot;d3d8types.h&quot; ...  </span><br><span class="line">Parsing file &quot;d3d8caps.h&quot; ...  </span><br><span class="line">Parsing file &quot;dsound.h&quot; ...  </span><br><span class="line">Parsing completed.  </span><br><span class="line">Logexts injected. Output: &quot;D:\\LogExts\&quot;  </span><br><span class="line">Logging enabled.  </span><br><span class="line">0:000&gt; !logexts.logc d *  </span><br><span class="line">All categories disabled.  </span><br><span class="line">0:000&gt; !logexts.logc e 15 16 19  </span><br><span class="line">15 IOFunctions Enabled  </span><br><span class="line">16 MemoryManagementFunctions Enabled  </span><br><span class="line">19 ProcessesAndThreads Enabled  </span><br><span class="line">0:000&gt; !logexts.logo e *  </span><br><span class="line">Debugger Enabled  </span><br><span class="line">Text file Enabled  </span><br><span class="line">Verbose log Enabled  </span><br><span class="line">0:000&gt; !logexts.logm i notepad.exe  </span><br><span class="line">Included modules:  </span><br><span class="line">notepad.exe</span><br></pre></td></tr></table></figure><p>简单说明一下这些命令：<br>!logexts.loge D:\<br>设置log的保持路径，并且开启监控  </p><p>!logexts.logc d *<br>先关闭所有API分类的监控  </p><p>!logexts.logc e 15 16 19<br>然后设置我们想监控分类，这里是IOFunctions，MemoryManagementFunctions和ProcessesAndThreads。至于如何查询分类对于的id，可以直接输入!logexts.logc进行查看。</p><p>!logexts.logo e *<br>这里我开启了所有输出方式，注意：如果想要被监控的程序响应的更快，可以去掉Debugger的输出，因为显示花费的时间比较的多。</p><p>!logexts.logm i notepad.exe<br>最后当然是设置inclusion list了。</p><p>按下F5，让程序跑起来看看效果吧。先别着急惊叹，Logexts还有更惊艳的地方。那就是他的高度可配置性。如果你想监控他描述以外的API，那么你可以自己写这个API的“头文件”。这里用引号是因为，它并不是真正的头文件，只不过他的语法和C的头文件非常的相似。我们可以看一个例子：</p><p>创建%windbg_dir%\winext\manifest\Context.h<br>并且写入这些内容</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">category ActivationContext:</span><br><span class="line"><span class="keyword">module</span> KERNEL32.DLL:</span><br><span class="line"></span><br><span class="line"><span class="function">FailOnFalse <span class="title">ActivateActCtx</span><span class="params">(HANDLE hActCtx, [out] PULONG_PTR lpCookie)</span></span>;</span><br><span class="line"><span class="function">FailOnFalse <span class="title">DeactivateActCtx</span><span class="params">(DWORD dwFlags, ULONG_PTR upCookie)</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在%windbg_dir%\winext\manifest\main.h文件的最后加入一行 #include “Context.h”</p><p>保存后，重启调试程序，输入!logexts.logc，可以看了多出了ActivationContext这一项。现在就可以选择这一项分类来监控ActivateActCtx和DeactivateActCtx了。</p><p>最后，大家应该发现了这样一个问题，开启这个API监控还是比较麻烦的，需要输入好几条命令。为了更方便的使用这个功能，我写了一个脚本来解决这个问题，这样就可以用一行命令来开启监控。使用方法是：<br>Usage $$&gt;a&lt;logger.wds output_dir categories include_modules<br>e.g. $$&gt;a&lt;logger.wds “d:&quot; “15 16 19” “notepad.exe”  </p><p>下载<a href="/uploads/2013/09/logger.zip">logger</a></p><p>关于Logexts的更多详细信息请参考msdn：<a href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff560170(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/hardware/ff560170(v=vs.85).aspx</a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows7下控制单个进程音量的小技巧</title>
      <link href="/2013/09/10/windows7e4b88be68ea7e588b6e58d95e4b8aae8bf9be7a88be99fb3e9878fe79a84e5b08fe68a80e5b7a7/"/>
      <url>/2013/09/10/windows7e4b88be68ea7e588b6e58d95e4b8aae8bf9be7a88be99fb3e9878fe79a84e5b08fe68a80e5b7a7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="/uploads/2013/09/2013-09-10_200213.png"><img src="/uploads/2013/09/2013-09-10_200213.png" alt="2013-09-10_200213"></a></p><p>如上图所示，Windows7下有一个很有趣的功能，就是可以给单独的进程调节音量。出于好奇，在网上翻了下资料，原来这个功能要归功于Windows7上新的音频接口——Core Audio APIs。这套API是用COM写，各种接口也比较多。但是如果我们的目的只是控制单个进程的音量，那还是很简单的。接下来的代码就是控制进程音量的函数了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);</span><br><span class="line"><span class="keyword">const</span> IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);</span><br><span class="line"><span class="keyword">const</span> IID IID_IAudioSessionManager2 = __uuidof(IAudioSessionManager2);</span><br><span class="line"><span class="keyword">const</span> IID IID_IAudioSessionControl2 = __uuidof(IAudioSessionControl2);</span><br><span class="line"><span class="keyword">const</span> IID IID_ISimpleAudioVolume = __uuidof(ISimpleAudioVolume);</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetProcessVolume</span><span class="params">(ULONG target_pid, <span class="keyword">float</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CComPtr imm_dev_enumor;</span><br><span class="line"></span><br><span class="line">    HRESULT hr = imm_dev_enumor.<span class="built_in">CoCreateInstance</span>(</span><br><span class="line">        CLSID_MMDeviceEnumerator, <span class="literal">NULL</span>,</span><br><span class="line">        CLSCTX_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CComPtr imm_dev;</span><br><span class="line">    hr = imm_dev_enumor-&gt;<span class="built_in">GetDefaultAudioEndpoint</span>(eRender, eMultimedia, &amp;imm;_dev.p);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CComPtr session_mgr2;</span><br><span class="line">    hr = imm_dev-&gt;<span class="built_in">Activate</span>(IID_IAudioSessionManager2, CLSCTX_ALL, <span class="literal">NULL</span>, (<span class="keyword">void</span> **)&amp;session;_mgr2.p);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CComPtr session_enumor;</span><br><span class="line">    hr = session_mgr2-&gt;<span class="built_in">GetSessionEnumerator</span>(&amp;session;_enumor.p);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hr = session_enumor-&gt;<span class="built_in">GetCount</span>(&amp;count;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        CComPtr session_ctrl;</span><br><span class="line">        hr = session_enumor-&gt;<span class="built_in">GetSession</span>(i, &amp;session;_ctrl.p);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CComPtr session_ctrl2;</span><br><span class="line">        hr = session_ctrl-&gt;<span class="built_in">QueryInterface</span>(IID_IAudioSessionControl2, (<span class="keyword">void</span> **)&amp;session;_ctrl2.p);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ULONG pid;</span><br><span class="line">        hr = session_ctrl2-&gt;<span class="built_in">GetProcessId</span>(&amp;pid;);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid != target_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CComPtr simple_vol;</span><br><span class="line">        hr = session_ctrl2-&gt;<span class="built_in">QueryInterface</span>(IID_ISimpleAudioVolume, (<span class="keyword">void</span> **)&amp;simple;_vol.p);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        simple_vol-&gt;<span class="built_in">SetMasterVolume</span>(level, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用PCI IDE Controller读写硬盘 – 2</title>
      <link href="/2013/08/31/e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-2/"/>
      <url>/2013/08/31/e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="/uploads/2013/09/20130901011808.png"><img src="/uploads/2013/09/20130901011808.png" alt="20130901011808"></a></p><p>上一篇文章简单介绍了用PIO的方式读写硬盘数据，那么这篇文章就来介绍另一种数据传输的方式——DMA。</p><p>DMA全称是Direct memory access，以下依旧是wiki上的一段简短的介绍：<br>“直接存储器访问（Direct Memory Access，DMA）是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统存储器，而不需绕道中央处理器（CPU）。很多硬件的系统会使用DMA，包含硬盘控制器、绘图显卡、网卡和声卡。”</p><p>结合以上的描述和上一篇PIO的介绍，我们就可以发现DMA的优势，他最大的优势之一就是解放了CPU，让CPU不用重复的执行IO端口的操作读写数据。使用DMA的时候，CPU可以做其他的计算，读写数据的操作完全交由CPU外部的DMA芯片进行操作。当读写操作结束后CPU收到通知，然后再来处理读写之后的工作。DMA的另一个优势，就是速度快，不过这么说也不是完全正确的。因为古老的ISA DMA的速度只有4MB/s，现代CPU跑起PIO来，传输速度应该会比这个快。幸运的是，硬盘使用的DMA并不是ISA DMA，而是PCI DMA。PCI DMA的速度通常都超过了100MB/s，所以说速度也算是DMA的一个优势了吧。这里在顺便提一点，ISA DMA也不是完全没有用处的。软盘使用的DMA就是ISA DMA，虽然说软盘在现代的PC上已经消失了，但是如果要写自己的Mini Kernel，那么支持软盘以及ISA DMA还是很有必要的。</p><p>DMA的优势很明显，付出的代价就是编程起来相对复杂。那么下面就来介绍让IDE使用DMA传输数据的基础知识。</p><p><strong>物理区域描述符（Physical Region Descriptor）</strong><br><a href="/uploads/2013/09/20130828165621.jpg"><img src="/uploads/2013/09/20130828165621.jpg" alt="20130828165621"></a>进行数据传输的物理内存块都用物理区域描述符进行描述。当所有在物理区域描述符表中的物理区域描述符所指向的内存都被传输完成后，数据传输就会停止。每个物理区域描述符是8字节。前4个字节指定的是物理内存区域的地址。接下来的两个字节指定内存数量。最后一个字节的第7位表示此理区域描述符是该表中最后一个描述符。</p><p><strong>物理区域描述符表（Physical Region Descriptor Table）</strong><br>这张表中包含一定数量的物理区域描述符（PRD），描述符表必须是4字节对齐且不能跨越64K边界的内存。</p><p><strong>总线主控IDE寄存器（Bus Master IDE Register）</strong><br><a href="/uploads/2013/09/20130829115331.png"><img src="/uploads/2013/09/20130829115331.png" alt="20130829115331"></a></p><p>要获得总线主控IDE寄存器的基础地址，需要读取PCI配置空间IDE区域的0x20处的DWORD。由于这篇文章不会设计到如何读取PCI配置空间，所以这里的基址就采用bochs设定（0xC000）。后面代码部分也会直接硬编码。</p><p><strong>总线主控IDE命令寄存器（Bus Master IDE Command Register）</strong><br><a href="/uploads/2013/09/20130829120041.png"><img src="/uploads/2013/09/20130829120041.png" alt="20130829120041"></a></p><p>这里读写控制位是特别要注意的，刚开始容易理解错误。这里的读写是针对的设备，而不是CPU。也就是说这里的都，是指设备读取CPU指定的内存到自己的数据空间。而写是指将自己的数据空间的数据写到CPU指定的内存。所以这里的读写和我们对硬盘要做的读写是刚好相反的。</p><p><strong>总线主控IDE状态寄存器（Bus Master IDE Status Register）</strong><br><a href="/uploads/2013/09/20130829120248.png"><img src="/uploads/2013/09/20130829120248.png" alt="20130829120248"></a></p><p><strong>描述符指针寄存器（Descriptor Table Pointer Register）</strong><br>用于设置物理区域描述符表的地址</p><p>对于初学者理论知识不用了解的过细，最好还是在代码中边写边学习，还是一边堆代码，一边解释吧。<br>（关于下面代码的补充说明：由于使用DMA必须处理中断以获得DMA处理结束的信号，而配置中断又涉及到许多理论知识和额外代码（8259A &amp;IDT），所以下面的代码就不涉及配置中断了，我这里就假设CPU已经进入保护模式，但没有开启分页并且IDE的中断已经配置完毕了。以下代码依旧为了保持最简洁，忽略了状态和结果的检查，在试验中够用即可）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx, 0C000h ; 设置开始停止位为0，停止DMA</span><br><span class="line">mov al, 0h</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">mov dx, 0C002h ; 清除中断位和错误位，这里清除方式比较特别，设置1后清除</span><br><span class="line">mov al, 6h</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">; 配置描述符表，表地址为10000h，且只有一个描述符</span><br><span class="line">; 描述符描述的物理基址是20000h，大小为512字节，且设置了第7位，</span><br><span class="line">; 说明自己就是最后一个描述符</span><br><span class="line">mov dword ptr [10000h], 20000h</span><br><span class="line">mov dowrd ptr [10004h], 200h | 80000000h</span><br><span class="line">mov dx, 0C004h</span><br><span class="line">mov eax, 10000h</span><br><span class="line">out dx, eax</span><br><span class="line"></span><br><span class="line">mov dx, 3f6h   ; 这里不再设置nIEN，DMA需要中断</span><br><span class="line">mov al, 0h</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">mov dx, 1f1h   ; 下面代码基本上和PIO一致，</span><br><span class="line">mov al, 0      ; 详细注释请看上一篇文章</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">mov dx, 1f2h</span><br><span class="line">mov al, 1</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">mov dx, 1f3h</span><br><span class="line">mov al, 11h</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">mov dx, 1f4h</span><br><span class="line">mov al, 22h</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">mov dx, 1f5h</span><br><span class="line">mov al, 33h</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">mov dx, 1f6h</span><br><span class="line">mov al, 44h</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">mov dx, 1f7h   ; 设置读取扇区的命令C8h，不同于20h，这个是DMA读取扇区的命令</span><br><span class="line">mov al, C8h</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">mov dx, 0C000h ; 设置开始停止位为1，开始DMA，并且指定为读取硬盘操作</span><br><span class="line">mov al, 9h     ; （对硬盘而言是写出，所以设置bit3）</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">call wait_int  ; 等待中断</span><br><span class="line"></span><br><span class="line">mov dx, 0C000h ; 中断返回，设置开始停止位为0，停止DMA</span><br><span class="line">mov al, 0h     ; 如果一切都顺利，那么20000h开始的512个字节</span><br><span class="line">out dx, al     ; 就应该是读出的硬盘数据了</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>上面的代码主要分为以下这几步：  </p><ol><li>在系统内存中配置PRD Table。每个PRD是8个字节，其中包含着一个起始内存地址和一个内存大小传送，而且PRD必须是4字节对齐的。  </li><li>给PRD Table指针寄存器传入配置好的PRD Table的地址，设置读写控制位，清除中断和错误位。  </li><li>设置读写命令，包括读写的驱动器，逻辑地址等（这里基本上和PIO类似）。  </li><li>设置总线主控IDE命令寄存器的开始/停止位为1，控制器开始执行DMA操作。  </li><li>控制器DMA操作结束，IDE设备发起中断，收到中断后，设置开始/停止位为0（我们省略了读取状态寄存器来查看操作是否成功的步骤。）  </li></ol><p>如果只是从IDE方面来看，代码没有复杂多少，可惜的是他还需要配合其他计算机硬件，所以实际要用上的代码要比PIO多上了不少。最后还是给大家推荐一些深入理解DMA的资料吧。<br>ISA DMA：<a href="http://wiki.osdev.org/ISA_DMA">http://wiki.osdev.org/ISA_DMA</a><br>PCI DMA：<a href="http://wiki.osdev.org/ATA/ATAPI_using_DMA">http://wiki.osdev.org/ATA/ATAPI_using_DMA</a>  </p>]]></content>
      
      
      <categories>
          
          <category> MiniKernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用PCI IDE Controller读写硬盘 – 1</title>
      <link href="/2013/08/26/e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-1/"/>
      <url>/2013/08/26/e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="/uploads/2013/08/PIO_hd04.jpg"><img src="/uploads/2013/08/PIO_hd04.jpg" alt="PIO_hd04"></a></p><p>上一篇文章中提到了一些IDE基础的知识，并且知道了如何判断IDE的类型。接下来介绍IDE最基本的IO方法——PIO。</p><p>PIO是Programmed input/output的缩写，下面是一段wiki上对PIO的介绍：<br>“可编程输入输出（英语：PIO）是CPU与外围设备（如网卡、硬盘等）传输数据的一种方法。当 CPU 上执行的软件程序使用 I/O 地址空间来与输入/输出设备（I/O 设备）进行数据传输时，系统即进行了 PIO. 这和直接内存存取（DMA）恰好相反。</p><p>在 PC 上最常见的使用 PIO 的例子是 ATA 接口，但 ATA 接口也可以在 DMA 模式下工作。 PC 上的许多比较古老的设备也使用 PIO, 如串行端口、并行端口（在不使用 ECP 模式时）、PS/2 接口、MIDI 接口、内部时钟以及一些古老的网卡。”</p><p>实际上，在DMA出现之前，PIO是硬盘唯一的数据传输的方式。就算是现在，ATA的部分命令还必须使用PIO的方式获得数据，例如DEVICE IDENTIFY。PIO传输数据的思想简单直接，例如从硬盘都数据，只需要在硬盘准备好了之后，不断的读取特定端口就能将数据读出来了。例如 in eax, dx（dx里是数据端口号），这样每次就传输4个字节，也就是说如果需要传输512（一个扇区）的数据，需要128次IO。这样一方面数据传输的效率难以提高，另一方面还占用了CPU时间。所以被DMA淘汰也是有道理的。然而，他也有自身的优势，那就是编程起来简单方便。不像DMA那样，需要配置中断和其他一些事情。简单的对IDE下命令就可以达到数据传输的目的了。所以这也是我们入门的很好的切入口。</p><p>最后，在开始堆代码之前，我们必须了解硬盘的两种寻址模式：CHS(cylinders-heads-sectors，磁柱-磁头-扇区)寻址模式和LBA(Logical Block Address, 逻辑区块地址)寻址模式。<br>CHS寻址模式，区块必须以硬盘上某个磁柱、磁头、扇区的硬件位置所合成的地址来指定。<br>LBA寻址模式从0开始编号来定位区块，第一区块LBA=0，第二区块LBA=1，依此类推。  </p><p>前者的描述更偏向物理，理解起来需要转换，而后者更偏向思维逻辑，理解起来直接了当。既然LBA模式简单容易理解，所以下面的文章和代码所采用的寻址模式就默认是LBA28。所谓LBA28其实是LBA模式中的子模式，它可以寻址到128GB，与之对应的是LBA48，它的寻址范围可以达到128PB，这个对我们来说没啥意义，所以还是选用LBA28。另外CHS模式还需要解释硬盘机械方面的知识，前提太多不利于学习，就暂时搁下吧。</p><p>好了，介绍理论的知识不是这篇文章的目的，就让我们一边堆代码，一边讲解这些理论知识吧。下面就是一段读取硬盘数据的asm代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    mov dx, 3f6h    ; 1.设置nIEN</span><br><span class="line">    mov al, 2h</span><br><span class="line">    out dx, al</span><br><span class="line">    </span><br><span class="line">    mov dx, 1f1h    ; 2.设置FEATURES为0</span><br><span class="line">    mov al, 0</span><br><span class="line">    out dx, al</span><br><span class="line">        </span><br><span class="line">    mov dx, 1f2h    ; 3.设置读取的扇区数量，这里指定为1</span><br><span class="line">    mov al, 1</span><br><span class="line">    out dx, al</span><br><span class="line">        </span><br><span class="line">    mov dx, 1f3h    ; 4.设置读取地址的低八位</span><br><span class="line">    mov al, 11h</span><br><span class="line">    out dx, al</span><br><span class="line">        </span><br><span class="line">    mov dx, 1f4h    ; 5.设置读取地址的中八位</span><br><span class="line">    mov al, 22h</span><br><span class="line">    out dx, al</span><br><span class="line">        </span><br><span class="line">    mov dx, 1f5h    ; 6.设置读取地址的高八位</span><br><span class="line">    mov al, 33h</span><br><span class="line">    out dx, al</span><br><span class="line">    </span><br><span class="line">    mov dx, 1f6h    ; 7.设置LBA模式，目标驱动器，和地址的最高4位</span><br><span class="line">    mov al, 44h     ;   其中第6位（40h）是设置LBA模式，第4位设置主从驱动器，0为主驱动器</span><br><span class="line">    out dx, al      ;   后四位就是LBA最高位了，这里是4h，也就是说读取的地址是04332211h</span><br><span class="line">        </span><br><span class="line">    mov dx, 1f7h    ; 8.设置读取扇区的命令20h</span><br><span class="line">    mov al, 20h</span><br><span class="line">    out dx, al</span><br><span class="line">pri_stat:</span><br><span class="line">    in al, dx       ; 9.轮询状态寄存器，第3位（8）如果是设置状态，表明可以进行数据传输了。</span><br><span class="line">    test al, 8</span><br><span class="line">    jz pri_stat</span><br><span class="line">         </span><br><span class="line">    mov ecx, 512&#x2F;4  ; IO 128次！</span><br><span class="line">    mov edi, offset buffer  ; 设置buffer地址到edi</span><br><span class="line">    mov dx, 1f0h</span><br><span class="line">    rep insw        ; 10.循环128次从数据寄存器读取1个扇区的数据</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>上面的代码主要分为以下这几步：<br>1.我们现在不需要IRQs，所以我们这里要禁用它，以免发生不必要的问题。这里，我们设置CBR（Control Block Register）的第1位，也叫nIEN位，只要它处于设置的状态，那么IRQs就不会触发。<br>2.设置FEATURES寄存器<br>3.设置扇区数寄存器<br>4.设置LBA低8位<br>5.设置LBA中8位<br>6.设置LBA中高8位<br>7.设置LBA最高4位，以及驱动器，指明使用LBA模式<br>8.设置读扇区命令<br>9.轮询等待完成状态<br>10.循环128次读取1个扇区的数据（128*4=512 bytes）  </p><p>再看看写扇区有哪些不同呢？没错，只有最后几条指令有细微的差别。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    mov dx, 1f7h</span><br><span class="line">    mov al, 30h     ; 这里命令改为30h，写扇区</span><br><span class="line">    out dx, al</span><br><span class="line">pri_stat:</span><br><span class="line">    in al,dx</span><br><span class="line">    test al,8</span><br><span class="line">    jz pri_stat</span><br><span class="line">    </span><br><span class="line">    mov ecx, 512&#x2F;4</span><br><span class="line">    mov esi, offset buffer ; 设置buffer地址到esi</span><br><span class="line">    mov dx, 1f0h</span><br><span class="line">    rep outsd       ; 这里指令改为outsd</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>看起来还是很简单的吧！不过这也是当然的，因为我们没有做任何的排错和检验处理。不过这样的代码才是初学者最喜欢看到的吧，同样对于做操作系统实验也没多大问题。</p><p>最后，如果对CHS以及LBA和CHS的转换关系感兴趣，推荐翻阅wiki：<br><a href="http://en.wikipedia.org/wiki/Cylinder-head-sector">http://en.wikipedia.org/wiki/Cylinder-head-sector</a><br><a href="http://en.wikipedia.org/wiki/Logical_block_addressing#CHS_conversion">http://en.wikipedia.org/wiki/Logical_block_addressing#CHS_conversion</a>  </p><p>在下一篇的文章中，会介绍一些用PCI DMA的方式读写硬盘的知识。</p>]]></content>
      
      
      <categories>
          
          <category> MiniKernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用PCI IDE Controller读写硬盘 - 0</title>
      <link href="/2013/08/17/e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-0/"/>
      <url>/2013/08/17/e4bdbfe794a8pci-ide-controllere8afbbe58699e7a1ace79b98-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>依稀记得我一年半以前曾经写过一篇关于PIO读硬盘数据的文章，当时就提到了读写硬盘操作很复杂，完全可以拿来做一个系列来写。当时也是真有写出一个系列的冲动，不过不巧的是，由于那段时间换工作，新的工作和底层的关系不太大，也就没时间继续读相关文档来把这个系列写下来。我现在还很清楚的记得当时有关使用IDE接口读写硬盘的中文资料特别的少，虽然英文资料倒是挺全面，但是对于英语不好的我来说，看起来还是挺吃力的。一年半后，我又好奇的搜索的这方面的中文资料，结果依旧令人失望。于是，我就决定我把知道的IDE方面的知识写出来，一方面算是自己的一个学习笔记，另一方面也算是一种分享。我将这个系列定位为学习笔记，就是说，文章的很多地方都是自己的理解，不能保证所提到的知识都是正确的。所以如果这篇文章有幸被你看见，并且发现了问题，请使用email联系我。</p><h1 id="IDE介绍"><a href="#IDE介绍" class="headerlink" title="IDE介绍"></a>IDE介绍</h1><p><a href="/uploads/2013/08/hdd-sata-pata-ide-aussie-pc-fix.png"><img src="/uploads/2013/08/hdd-sata-pata-ide-aussie-pc-fix.png" alt="hdd-sata-pata-ide-aussie-pc-fix"></a></p><p>IDE是Integrated Drive Electronics的简称，wiki上翻译的中文是“集成驱动电子设备”。我们可以认为它是一种接口，可以管理控制IDE的驱动器，比如硬盘，光驱等等。事实上，现在所谓的ATA/ATAPI接口的第一个版本的名称就叫做IDE，所以现在人们通常认为IDE就是PATA。如果现在去买主板，我们会发现集成PATA/IDE的主板已经消失了，现在主流主板都是使用的SATA，这是一套新的接口。那么，我们干嘛要学习一个已经淘汰的技术呢？其实不然，虽然硬件的接口被淘汰了，但是IDE的驱动器的控制模式还是存在的。现在的BIOS设置中，通常有一种叫做“legacy mode”或者“IDE”的选项，开启这个选项，系统就能如同操作IDE/PATA一样操作SATA了。而对于我这有写迷你内核的人来说，学习IDE是非常好的，因为虚拟机bochs模拟的硬盘设备就是IDE/PATA的，另一方面，把迷你内核拿到真机上做实验的时候，开启“legacy mode”或者“IDE”也能够很顺利的进行实验。</p><p><a href="/uploads/2013/08/bios-sata-native-mode-ide-raid-ahci-ca184a.jpg"><img src="/uploads/2013/08/bios-sata-native-mode-ide-raid-ahci-ca184a.jpg" alt="bios-sata-native-mode-ide-raid-ahci-ca184a"></a></p><h1 id="IDE通道以及通道寄存器地址"><a href="#IDE通道以及通道寄存器地址" class="headerlink" title="IDE通道以及通道寄存器地址"></a>IDE通道以及通道寄存器地址</h1><p>IDE有2个通道，可以管理4个驱动器，分别是：<br>通道1：<br>第一主驱动器<br>第一从驱动器<br>通道2：<br>第二主驱动器<br>第二从驱动器  </p><p>每个通道都有两套用于控制其主从驱动器的寄存器，他们分别是 Control Block Registers 和 Command Block Registers。这些寄存器首先是有一个基础地址，然后通过按顺序可以获得整套寄存器地址，而寄存器的基础地址可以通过PCI Configuration Space来获得，更多情况下，我们不妨直接使用下面这张表来配置寄存器的基础地址。</p><p><a href="/uploads/2013/08/2013-08-18_142953.png"><img src="/uploads/2013/08/2013-08-18_142953.png" alt="2013-08-18_142953"></a></p><p>事实上，这个基础地址是根据PCI IDE Controller模式不同而确定的。Compatibility模式下，寄存器的基础地址是固定的，但是在Native-PCI模式下，这个就需要读取具体的配置信息了。不过，大部分情况下，用上述地址不会有什么问题，所以这里就略过读取PCI Configuration Space的步骤了。</p><p>现在既然知道了寄存器的Base Address，那么下一步就是获得每个寄存器的地址了，其实这也非常简单。</p><p>Command Block Registers<br>1F0 （170）（读取和写入）：数据寄存器<br>1F1 （171）（读）：错误寄存器<br>1F1 （171）（写入）：特性寄存器<br>1F2 （172）（读取和写入）：扇区数寄存器<br>1F3 （173）（读取和写入）：低LBA寄存器<br>1F4 （174）（读取和写入）：中LBA寄存器<br>1F5 （175）（读取和写入）：高LBA寄存器<br>1F6 （176）（读取和写入）：驱动器/磁头寄存器<br>1F7 （177）（读）：状态寄存器<br>1F7 （177）（写入）：命令寄存器  </p><p>Control Block Registers<br>3F6 （376）（读取）：备用状态寄存器<br>3F6 （376）（写入）：设备控制寄存器  </p><p>另外还有一组寄存器叫做Bus Master IDE Register，我们使用DMA进行数据传输的时候会用到这类寄存器。现在就不去了解了，以免东西太多，造成不必要的混乱。</p><p>判断驱动器类型</p><p>前面说了很多的理论上的东西，现在我们看看怎么运用它们判断驱动器类型，比如是PATA还是SATA。当然，在做判断它们的类型之前，我们需要检测驱动器是否存在。判断方法很简单，先选择驱动器，对扇区数寄存器（1F2）和低LBA寄存器（1F3）写两个非0的数字，然后进行读取。如果读出的内容和写入的相同，那么我们可以认为驱动存在。就拿第一主驱动器举个例子：<br>mov dx, 1f6h ; 驱动器寄存器<br>xor al, al ; 选择驱动器，如果al第4位是0，那么选择0号设备，否则选择1号设备<br>out dx, al  </p><p>mov dx, 1f2h<br>mov al, 55h ; 随意写一个数<br>out dx, al  </p><p>mov dx, 1f3h<br>mov al, aah<br>out dx, al  </p><p>mov dx, 1f2h<br>in al, dx ; 读取后比较<br>cmp al, 55h<br>jnz not_exist  </p><p>mov dx, 1f3h<br>in al, dx<br>cmp al, aah<br>jnz not_exist  </p><p>我用bochs测试的结果是，如果驱动器不存在，读出的数字总是0。接下来就可以获得驱动器的类型了，步骤是：1.选择驱动器（前面的操作以及做完这步了）2.软件复位驱动器。3.读取高LBA寄存器和中LBA寄存器。  </p><p>mov dx, 3f6h ; 选择设备控制寄存器<br>mov al, 4h ; 设置第二位，表示软件复位<br>out dx, al  </p><p>mov dx, 3f6h ; 选择设备控制寄存器<br>mov al, 0h<br>out dx, al  </p><p>mov dx, 1f4h<br>in al, dx<br>mov id1, al  </p><p>mov dx, 1f5h<br>in al, dx<br>mov id2, al  </p><p>当ID1和ID2为不同的数值的时候，表示的设备不同，如下表所示<br><a href="/uploads/2013/08/20130818152800.png"><img src="/uploads/2013/08/20130818152800.png" alt="20130818152800"></a><br>我在bochs实验的得到的结果是PATA，虽然模拟的设备比较老，但是这正是我想要的。  </p><p>这样，我们读写硬盘的第一步，环境检测已经完成了。这个系列的下一篇文章，我们就来了解下通过PIO的方式读写硬盘。  </p>]]></content>
      
      
      <categories>
          
          <category> MiniKernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用可编程间隔定时器(Programmable Interval Timer)编写系统时钟</title>
      <link href="/2013/08/04/e4bdbfe794a8e58fafe7bc96e7a88be997b4e99a94e5ae9ae697b6e599a8programmable-interval-timere7bc96e58699e7b3bbe7bb9fe697b6e9929f/"/>
      <url>/2013/08/04/e4bdbfe794a8e58fafe7bc96e7a88be997b4e99a94e5ae9ae697b6e599a8programmable-interval-timere7bc96e58699e7b3bbe7bb9fe697b6e9929f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>很久没有写关于MiniKernel的文章了，这周末看着有点时间，就写一点关于定时器的东西吧。</p><p><a href="/uploads/2013/08/8253.jpg"><img src="/uploads/2013/08/8253.jpg" alt="8253"></a></p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>可编程间隔定时器（PIT）芯片（也就是我们常说的8253/8254芯片），他包含了1个振荡器，1个预分频器和3个独立的分频器。每个分频器有一个输出，它是可以让定时器控制外部电路（例如，IRQ0）</p><p>其中PIT的振荡器的频率是1.193182 MHz。具体为什么是这么个奇怪的数字，是有一点历史的，但这些不是这篇文章的重点，有兴趣的可以Google一下。</p><p>分频器也比较容易理解，就是把高频分割为低频，一般来说就是使用一个计数器，当每次脉冲的时候，计数器的数值减少，当计数器数值为0的时候，在输出上产生一个脉冲，并且计数器复位，重新开始计数。</p><p>PIT定时器的准确度依赖于所使用的振荡器，一般来说，一天的浮动为+/- 1.73秒。不过这种浮动，对我们影响并不大，所以也不必过于在意。</p><p>PIT的输出通道一共有三个：通道0，直接连接到IRQ0，并且触发时钟中断（这个通道是我们写MiniKernel最重要的一个。）。通道1，貌似以前是定时刷新内存的，但是现在没什么用了。通道2是连接到PC扬声器的，目前我也没有研究过它的作用。</p><p>这里再重点介绍一下通道0：PIT通道0的输出是连接到PIC芯片上的（8259A，以后有空也可以写一篇简单的介绍），因此，它能生成一个IRQ0的中断。通常情况下，在开机时，BIOS会将通道0的计数器的值设置为65535或0（其中如果是0，硬件会自动转化为65536），这样，它的输出频率就是18.2065Hz。另外，之所以说通道0最重要，主要原因就是它是三个通道中，唯一一个能连接到IRQ的，对于编写系统时钟至关重要。</p><h2 id="编程相关"><a href="#编程相关" class="headerlink" title="编程相关"></a>编程相关</h2><p>PIT是使用以下IO端口进行控制：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I&#x2F;O 端口     用途</span><br><span class="line">0x40         通道0的数据端口</span><br><span class="line">0x41         通道1的数据端口</span><br><span class="line">0x42         通道2的数据端口</span><br><span class="line">0x43         控制字寄存器</span><br></pre></td></tr></table></figure><p>控制字寄存器的具体内容如下：</p><p><a href="/uploads/2013/08/8253cw.png"><img src="/uploads/2013/08/8253cw.png" alt="8253cw"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bits</span><br><span class="line">6 7选择通道：</span><br><span class="line">0 0 &#x3D;通道0</span><br><span class="line">0 1 &#x3D;通道1</span><br><span class="line">1 0 &#x3D;通道2</span><br><span class="line">1 1 &#x3D;回读命令（只有8254支持）</span><br><span class="line">4 5访问模式：</span><br><span class="line">0 0 &#x3D;锁存计数值命令</span><br><span class="line">0 1 &#x3D;访问模式：读写最低有效字节</span><br><span class="line">1 0 &#x3D;访问模式：读写最高有效字节</span><br><span class="line">1 1 &#x3D;访问模式：先读写最低有效字节，然后读写高位字节</span><br><span class="line">1-3工作模式：</span><br><span class="line">0 0 0 &#x3D;模式0（计数结束中断）</span><br><span class="line">0 0 1 &#x3D;模式1（硬件再触发单稳）</span><br><span class="line">0 1 0 &#x3D;模式2（速率发生器）</span><br><span class="line">0 1 1 &#x3D;模式3（方波发生器）</span><br><span class="line">1 0 0 &#x3D;模式4（软件触发闸门）</span><br><span class="line">1 0 1 &#x3D;模式5（硬件触发闸门）</span><br><span class="line">1 1 0 &#x3D;模式2（速率发生器，与010B相同）</span><br><span class="line">1 1 1 &#x3D;模式3（方波发生器，与011B相同）</span><br><span class="line">0 BCD &#x2F;二进制模式：0 &#x3D; 16位二进制数，1 &#x3D;四位BCD&lt;&#x2F;blockquote&gt;</span><br></pre></td></tr></table></figure><p>这里，我们要写系统时钟，那么就应该这样选择：</p><ol><li>选择通道，必须是通道0，那么bit 6 7 就分别为 0 0。  </li><li>由于我们的计数器是16位的，那么访问模式bit 4 5就应该选择1 1。  </li><li>数据模式，毫无疑问选择二进制模式。  </li><li>最后就是工作模式了，应该选择什么呢？这里我也不想把这些模式都讲的很清楚，因为那样就涉及到引脚和电平等等硬件知识。现在我们只需要知道0，1，4，5这些模式都可以触发中断，但是却不会自动复位。只有模式2和3会自动复位。所以模式2 3都是我们可以用来作为系统时钟的模式。那么1-3 bits可以为0 1 0或者0 1 1。</li></ol><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>现在假设，系统的时钟中断例程已经设置好了，并且设置好了PIC的IRQ0到这个例程。下面要做的事情就是，设置时钟中断的频率了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx, 1193180 &#x2F; 100 ; 没10ms触发一次中断</span><br><span class="line">mov al, 110110b ; 设置控制字寄存器，上面已经介绍过每个位的含意</span><br><span class="line">out 0x43, al</span><br><span class="line">mov ax, dx</span><br><span class="line">out 0x40, al   ;先设置低位的值</span><br><span class="line">xchg ah, al</span><br><span class="line">out 0x40, al   ;再设置高位的值</span><br></pre></td></tr></table></figure><p>总的来说8253 和 8254 是很有用的芯片。他们可以用在很多不同的设备，并用于很多不同的目的。不过就目前的PC来说，系统对他们的依赖已经不像以前那样严重了。随着科技的进步，APIC Timer已经可以取代他们。另外2005年，Intel和MS已经联合开发了新的高精度的定时器芯片High Precision Event Timer（HPET）。</p><p>虽然成熟的系统可能已经不用8253 和 8254了，但是对于我们自己的迷你内核来说，使用它们就完全足够了</p>]]></content>
      
      
      <categories>
          
          <category> MiniKernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于JsonCpp的中文编码问题</title>
      <link href="/2013/07/19/e585b3e4ba8ejsoncppe79a84e4b8ade69687e7bc96e7a081e997aee9a298/"/>
      <url>/2013/07/19/e585b3e4ba8ejsoncppe79a84e4b8ade69687e7bc96e7a081e997aee9a298/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近工作中用到了jsoncpp来解析json文件。但是遇到了一个这样的问题，如果json代码中有中文，并且用“\u594E\u6258\u65AF”这样的方式表示，那么jsoncpp解析的时候，就会把他转换成UTF-8。到这一步还是OK的，然后我就试图把这段中文写回文件，问题就来了，jsoncpp不会把中文转换为“\u594E\u6258\u65AF”这样的形式在存储，而是直接存储为UTF-8格式的文件。如图所示：</p><p><a href="/uploads/2013/07/20130719231900.png"><img src="/uploads/2013/07/20130719231900.png" alt="20130719231900"></a></p><p>而我恰好是需要这种经过编码的形式的字符串，而非直接给我中文。在网上搜了搜，貌似也没有很好的解决方案，只好自己修改jsoncpp的代码以满足这个需求了。<br>简单读了下jsoncpp的read和write的代码。jsoncpp在read的时候会调用codePointToUTF8这个函数把\uXXXX这个形式的代码转换成UTF-8，但是write的时候就没有这样的转换了，虽然不是很了解作者这么写的思路，但是修改的思路倒是有了。我的做法是把所有需要两个和两个以上字节表示一个字符的UTF-8字符串全部转换成\uXXXX这个形式。那么就需要写一个转换函数。<a href="http://en.wikipedia.org/wiki/UTF-8">http://en.wikipedia.org/wiki/UTF-8</a> 上很清楚的描述了这些转换关系，所以完全可以自己动手写一个这样的函数。以下是我自己的实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">UTF8TocodePoint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *c, <span class="keyword">unsigned</span> <span class="keyword">int</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((*c) &amp; <span class="number">0x80</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">*result = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(*c);</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (((*c) &amp; <span class="number">0xe0</span>) == <span class="number">0xc0</span>) &#123;</span><br><span class="line">*result = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;((((*c) &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">6</span>) | ((*(c + <span class="number">1</span>)) &amp; <span class="number">0x3f</span>));</span><br><span class="line">count = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (((*c) &amp; <span class="number">0xf0</span>) == <span class="number">0xe0</span>) &#123;</span><br><span class="line">*result = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;((((*c) &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">12</span>) | (((*(c + <span class="number">1</span>)) &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">6</span>) | (((*(c + <span class="number">2</span>)) &amp; <span class="number">0x3f</span>)));</span><br><span class="line">count = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (((*c) &amp; <span class="number">0xf8</span>) == <span class="number">0xf0</span>) &#123;</span><br><span class="line">*result = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;((((*c) &amp; <span class="number">0x7</span>) &lt;&lt; <span class="number">18</span>) | (((*(c + <span class="number">1</span>)) &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">12</span>) | (((*(c + <span class="number">2</span>)) &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">6</span>) | (((*(c + <span class="number">3</span>)) &amp; <span class="number">0x3f</span>)));</span><br><span class="line">count = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (((*c) &amp; <span class="number">0xfc</span>) == <span class="number">0xf8</span>) &#123;</span><br><span class="line">*result = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;((((*c) &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">24</span>) | (((*(c + <span class="number">1</span>)) &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">18</span>) | (((*(c + <span class="number">2</span>)) &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">12</span>) | (((*(c + <span class="number">3</span>)) &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">6</span>) | (((*(c + <span class="number">4</span>)) &amp; <span class="number">0x3f</span>)));</span><br><span class="line">count = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (((*c) &amp; <span class="number">0xfe</span>) == <span class="number">0xfc</span>) &#123;</span><br><span class="line">*result = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;((((*c) &amp; <span class="number">0x1</span>) &lt;&lt; <span class="number">30</span>) | (((*(c + <span class="number">1</span>)) &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">24</span>) | (((*(c + <span class="number">2</span>)) &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">18</span>) | (((*(c + <span class="number">3</span>)) &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">12</span>) | (((*(c + <span class="number">4</span>)) &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">6</span>) | (((*(c + <span class="number">5</span>)) &amp; <span class="number">0x3f</span>)));</span><br><span class="line">count = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>然后把这个函数的调用加入到valueToQuotedString中，将原始的代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">isControlCharacter</span>( *c ) )</span><br><span class="line">&#123;</span><br><span class="line">std::ostringstream oss;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;\\u&quot;</span> &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(*c);</span><br><span class="line">result += oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result += *c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">isControlCharacter</span>( *c ) )</span><br><span class="line">&#123;</span><br><span class="line">std::ostringstream oss;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;\\u&quot;</span> &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(*c);</span><br><span class="line">result += oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((*c) &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">c += <span class="built_in">UTF8TocodePoint</span>(c, &amp;num) - <span class="number">1</span>;</span><br><span class="line">std::ostringstream oss;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;\\u&quot;</span> &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num);</span><br><span class="line">result += oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result += *c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这样还没算结束，因为这个函数开头的地方还有一个判断，我们也需要修改一下，将原始代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strpbrk</span>(value, <span class="string">&quot;\&quot;\\\b\f\n\r\t&quot;</span>) == <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">containsControlCharacter</span>( value ))</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;\&quot;&quot;</span>) + value + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strpbrk</span>(value, <span class="string">&quot;\&quot;\\\b\f\n\r\t&quot;</span>) == <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">containsControlCharacter</span>( value ) &amp;&amp; !<span class="built_in">containsMultiByte</span>( value ))</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;\&quot;&quot;</span>) + value + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>containsMultiByte的实现是这样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">containsMultiByte</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* str )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> ( *str )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( ( *(str++) ) &amp; <span class="number">0x80</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>好了，万事俱备，现在试一试效果，结果如图：</p><p><a href="/uploads/2013/07/20130719232025.png"><img src="/uploads/2013/07/20130719232025.png" alt="20130719232025"></a></p><p>现在这个jsoncpp看起来已经满足了我的需求，但是不确定的是，不知道这样修改会不会引起其他问题。现在也只能说暂时不去管他，有问题再一步一步的修改吧。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调试挂死的Explorer</title>
      <link href="/2013/07/05/e8b083e8af95e68c82e6adbbe79a84explorer/"/>
      <url>/2013/07/05/e8b083e8af95e68c82e6adbbe79a84explorer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一个同事前几天告诉我说，他的explorer.exe总是挂死，不知道是什么情况导致的。于是我让他下次挂死的时候抓个dump我。抓Dump的工具很多，例如用Win7的TaskMgr，sysinternals的Procexp，或者Windbg本身。不过考虑到explorer挂死了，操作桌面起来不方便，所以最好选择能够自动检测挂死并且抓住dump的工具。这里比较推荐的是sysinternals的Procdump以及我开发的<a href="http://0cch.net/wordpress/?p=208">proc_dump_study</a>（带UI）。</p><p><a href="/uploads/2013/07/20130706003632.png"><img src="/uploads/2013/07/20130706003632.png" alt="20130706003632"></a></p><p>第二天，同事把explorer.exe挂死的Dump传给了我，200多MB。用Windbg打开Dump文件，第一反应就是看看有多少线程再说吧。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; ~</span><br><span class="line">. 0 Id: b14.b18 Suspend: 0 Teb: 7ffde000 Unfrozen</span><br><span class="line">1 Id: b14.b1c Suspend: 0 Teb: 7ffdd000 Unfrozen</span><br><span class="line">...</span><br><span class="line">54 Id: b14.1a94 Suspend: 0 Teb: 7ff75000 Unfrozen</span><br><span class="line">55 Id: b14.18c8 Suspend: 0 Teb: 7ff74000 Unfrozen</span><br></pre></td></tr></table></figure><p>56个线程，肯定不能依次看栈回溯。按照尝试判断，explorer界面挂死，肯定是刷新界面的线程挂死了。所以栈回溯里肯定有explorer的身影。于是找找哪个线程有explorer模块。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !findstack explorer!</span><br><span class="line">Thread 000, 2 frame(s) match</span><br><span class="line">* 04 001bf924 0087aa50 explorer!wWinMain+0x54a</span><br><span class="line">* 05 001bf9b8 75771154 explorer!_initterm_e+0x1b1</span><br><span class="line"></span><br><span class="line">Thread 003, 2 frame(s) match</span><br><span class="line">* 11 0324f714 008757a6 explorer!CTray::_MessageLoop+0x265</span><br><span class="line">* 12 0324f724 75b346bc explorer!CTray::MainThreadProc+0x8a</span><br><span class="line"></span><br><span class="line">Thread 008, 1 frame(s) match</span><br><span class="line">* 03 04a1fc0c 75b346bc explorer!CSoundWnd::s_ThreadProc+0x3a</span><br></pre></td></tr></table></figure><p>从上面的结果看来，3号线程最可疑，于是看看完整的堆栈情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:003&gt; kv</span><br><span class="line"># ChildEBP RetAddr Args to Child</span><br><span class="line">00 0324f508 76eb5aec 75236924 00000002 0324f55c ntdll!KiFastSystemCallRet (FPO: [0,0,0])</span><br><span class="line">01 0324f50c 75236924 00000002 0324f55c 00000001 ntdll!NtWaitForMultipleObjects+0xc (FPO: [5,0,0])</span><br><span class="line">02 0324f5a8 7576f10a 0324f55c 0324f5d0 00000000 KERNELBASE!WaitForMultipleObjectsEx+0x100 (FPO: [Non-Fpo])</span><br><span class="line">03 0324f5f0 75fa90be 00000002 7ffdf000 00000000 kernel32!WaitForMultipleObjectsExImplementation+0xe0 (FPO: [Non-Fpo])</span><br><span class="line">04 0324f644 73d51717 000002fc 0324f678 ffffffff user32!RealMsgWaitForMultipleObjectsEx+0x13c (FPO: [Non-Fpo])</span><br><span class="line">05 0324f664 73d517b8 000024ff ffffffff 00000000 duser!CoreSC::Wait+0x59 (FPO: [Non-Fpo])</span><br><span class="line">06 0324f68c 73d51757 000024ff 00000000 0324f6b8 duser!CoreSC::WaitMessage+0x54 (FPO: [Non-Fpo])</span><br><span class="line">07 0324f69c 75fa949f 000024ff 00000000 0324f68c duser!MphWaitMessageEx+0x2b (FPO: [Non-Fpo])</span><br><span class="line">08 0324f6b8 76eb60ce 0324f6d0 00000008 0324f7e8 user32!__ClientWaitMessageExMPH+0x1e (FPO: [Non-Fpo])</span><br><span class="line">09 0324f6d4 75fa93f3 00851dee 00000000 80000000 ntdll!KiUserCallbackDispatcher+0x2e (FPO: [0,0,0])</span><br><span class="line">0a 0324f6d8 00851dee 00000000 80000000 00901180 user32!NtUserWaitMessage+0xc (FPO: [0,0,0])</span><br><span class="line">0b 0324f714 008757a6 00000000 75b318f2 0324f7ac explorer!CTray::_MessageLoop+0x265 (FPO: [Non-Fpo])</span><br><span class="line">0c 0324f724 75b346bc 00901180 00000000 00000000 explorer!CTray::MainThreadProc+0x8a (FPO: [Non-Fpo])</span><br><span class="line">0d 0324f7ac 75771154 001bf810 0324f7f8 76ecb299 shlwapi!WrapperThreadProc+0x1b5 (FPO: [Non-Fpo])</span><br><span class="line">0e 0324f7b8 76ecb299 001bf810 75d00467 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])</span><br><span class="line">0f 0324f7f8 76ecb26c 75b345e9 001bf810 00000000 ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])</span><br><span class="line">10 0324f810 00000000 75b345e9 001bf810 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br></pre></td></tr></table></figure><p>可以看出线程正在调用WaitForMultipleObjectsEx等待两个内核对象。那么看看这两个内核对象是什么吧。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:003&gt; dp 0324f55c L2</span><br><span class="line">0324f55c 00000318 000002fc</span><br><span class="line">0:003&gt; !handle 00000318</span><br><span class="line">Handle 00000318</span><br><span class="line">Type Event</span><br><span class="line">0:003&gt; !handle 000002fc</span><br><span class="line">Handle 000002fc</span><br><span class="line">Type Event</span><br></pre></td></tr></table></figure><p>很不幸，两个内核对象都是Event，这样就没有什么可参考的价值了，因为我们没办法知道谁应该去设置两个event。那么好吧，从其他方面下手，看能不能发现问题。看看关键区的情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:003&gt; !cs -l</span><br><span class="line">-----------------------------------------</span><br><span class="line">DebugInfo &#x3D; 0x76f47540</span><br><span class="line">Critical section &#x3D; 0x76f47340 (ntdll!LdrpLoaderLock+0x0)</span><br><span class="line">LOCKED</span><br><span class="line">LockCount &#x3D; 0x6</span><br><span class="line">WaiterWoken &#x3D; No</span><br><span class="line">OwningThread &#x3D; 0x000013e0</span><br><span class="line">RecursionCount &#x3D; 0x1</span><br><span class="line">LockSemaphore &#x3D; 0x220</span><br><span class="line">SpinCount &#x3D; 0x00000000</span><br><span class="line">-----------------------------------------</span><br><span class="line">DebugInfo &#x3D; 0x002ac6e0</span><br><span class="line">Critical section &#x3D; 0x765ea0f0 (shell32!CMountPoint::_csDL+0x0)</span><br><span class="line">LOCKED</span><br><span class="line">LockCount &#x3D; 0x0</span><br><span class="line">WaiterWoken &#x3D; No</span><br><span class="line">OwningThread &#x3D; 0x000013e0</span><br><span class="line">RecursionCount &#x3D; 0x1</span><br><span class="line">LockSemaphore &#x3D; 0xA50</span><br><span class="line">SpinCount &#x3D; 0x00000000</span><br></pre></td></tr></table></figure><p>看到一个很可疑的情况了，两个cs都被一个线程占用，更可疑的是这个线程居然还占用了LdrpLoaderLock。这就很有可能是引起死锁的原因了。来看看这个线程的完整堆栈。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:053&gt; ~~[13e0]s</span><br><span class="line">eax&#x3D;06d02f00 ebx&#x3D;00000000 ecx&#x3D;03920000 edx&#x3D;06ce0000 esi&#x3D;000015ac edi&#x3D;00000000</span><br><span class="line">eip&#x3D;76eb6194 esp&#x3D;0b1ad1cc ebp&#x3D;0b1ad238 iopl&#x3D;0 nv up ei pl zr na pe nc</span><br><span class="line">cs&#x3D;001b ss&#x3D;0023 ds&#x3D;0023 es&#x3D;0023 fs&#x3D;003b gs&#x3D;0000 efl&#x3D;00000246</span><br><span class="line">ntdll!KiFastSystemCallRet:</span><br><span class="line">76eb6194 c3 ret</span><br><span class="line">0:053&gt; k</span><br><span class="line"># ChildEBP RetAddr</span><br><span class="line">00 0b1ad1c8 76eb5b0c ntdll!KiFastSystemCallRet</span><br><span class="line">01 0b1ad1cc 7523179c ntdll!ZwWaitForSingleObject+0xc</span><br><span class="line">02 0b1ad238 7576efe3 KERNELBASE!WaitForSingleObjectEx+0x98</span><br><span class="line">03 0b1ad250 7576ef92 kernel32!WaitForSingleObjectExImplementation+0x75</span><br><span class="line">04 0b1ad264 7622399a kernel32!WaitForSingleObject+0x12</span><br><span class="line">05 0b1ad294 7622299c shell32!CMountPoint::_InitLocalDrives+0xcd</span><br><span class="line">...</span><br><span class="line">14 0b1ad81c 762aa690 shell32!SHGetFolderLocation+0x121</span><br><span class="line">15 0b1ad838 0a5c0bf5 shell32!SHGetSpecialFolderLocation+0x17</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">16 0b1ae0bc 0a5bfceb HaoZipExt!DllUnregisterServer+0x1cd04</span><br><span class="line">17 0b1ae240 0a5e0200 HaoZipExt!DllUnregisterServer+0x1bdfa</span><br><span class="line">18 0b1ae284 0a5e02b9 HaoZipExt!DllUnregisterServer+0x3c30f</span><br><span class="line">19 0b1ae2ac 76ecfbdf HaoZipExt!DllUnregisterServer+0x3c3c8</span><br><span class="line">1a 0b1ae3a0 76ed008b ntdll!LdrpRunInitializeRoutines+0x26f</span><br><span class="line">1b 0b1ae50c 76ecf499 ntdll!LdrpLoadDll+0x4d1</span><br><span class="line">1c 0b1ae540 7523b96d ntdll!LdrLoadDll+0x92</span><br><span class="line">1d 0b1ae57c 7534a333 KERNELBASE!LoadLibraryExW+0x1d3</span><br><span class="line">1e 0b1ae598 7534a2b8 ole32!LoadLibraryWithLogging+0x16</span><br><span class="line">...</span><br><span class="line">39 0b1afbac 76241ee6 shell32!CShellExecute::_DoExecute+0x5a</span><br><span class="line">3a 0b1afbc0 75b346bc shell32!CShellExecute::s_ExecuteThreadProc+0x30</span><br><span class="line">3b 0b1afc48 75771154 shlwapi!WrapperThreadProc+0x1b5</span><br><span class="line">3c 0b1afc54 76ecb299 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">3d 0b1afc94 76ecb26c ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">3e 0b1afcac 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure><p>首先一眼就看到了一个非系统模块HaoZipExt。再扫一眼，发现他在LdrpLoaderLock的时候又去等待了某个内核对象。那么再来看看这个内核对象是什么吧。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:053&gt; kv L5</span><br><span class="line"># ChildEBP RetAddr Args to Child</span><br><span class="line">00 0b1ad1c8 76eb5b0c 7523179c 000015ac 00000000 ntdll!KiFastSystemCallRet (FPO: [0,0,0])</span><br><span class="line">01 0b1ad1cc 7523179c 000015ac 00000000 00000000 ntdll!ZwWaitForSingleObject+0xc (FPO: [3,0,0])</span><br><span class="line">02 0b1ad238 7576efe3 000015ac ffffffff 00000000 KERNELBASE!WaitForSingleObjectEx+0x98 (FPO: [Non-Fpo])</span><br><span class="line">03 0b1ad250 7576ef92 000015ac ffffffff 00000000 kernel32!WaitForSingleObjectExImplementation+0x75 (FPO: [Non-Fpo])</span><br><span class="line">04 0b1ad264 7622399a 000015ac ffffffff 00000000 kernel32!WaitForSingleObject+0x12 (FPO: [Non-Fpo])</span><br><span class="line">0:053&gt; !handle 000015ac f</span><br><span class="line">Handle 000015ac</span><br><span class="line">Type Thread</span><br><span class="line">Attributes 0</span><br><span class="line">GrantedAccess 0x1fffff:</span><br><span class="line">Delete,ReadControl,WriteDac,WriteOwner,Synch</span><br><span class="line">Terminate,Suspend,Alert,GetContext,SetContext,SetInfo,QueryInfo,SetToken,Impersonate,DirectImpersonate</span><br><span class="line">HandleCount 4</span><br><span class="line">PointerCount 7</span><br><span class="line">Name &lt;none&gt;</span><br><span class="line">Object specific information</span><br><span class="line">Thread Id b14.1a94</span><br><span class="line">Priority 10</span><br><span class="line">Base Priority 0</span><br></pre></td></tr></table></figure><p>原来他在等待1a94这个线程结束啊，那么这个1a94线程又在干嘛呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:054&gt; ~~[1a94]s</span><br><span class="line">eax&#x3D;0bbdfbb4 ebx&#x3D;00000000 ecx&#x3D;00000000 edx&#x3D;00000000 esi&#x3D;76f47340 edi&#x3D;00000000</span><br><span class="line">eip&#x3D;76eb6194 esp&#x3D;0bbdfa24 ebp&#x3D;0bbdfa88 iopl&#x3D;0 nv up ei pl nz ac pe cy</span><br><span class="line">cs&#x3D;001b ss&#x3D;0023 ds&#x3D;0023 es&#x3D;0023 fs&#x3D;003b gs&#x3D;0000 efl&#x3D;00000217</span><br><span class="line">ntdll!KiFastSystemCallRet:</span><br><span class="line">76eb6194 c3 ret</span><br><span class="line">0:054&gt; kv</span><br><span class="line"># ChildEBP RetAddr Args to Child</span><br><span class="line">00 0bbdfa20 76eb5b0c 76e9f98e 00000220 00000000 ntdll!KiFastSystemCallRet (FPO: [0,0,0])</span><br><span class="line">01 0bbdfa24 76e9f98e 00000220 00000000 00000000 ntdll!ZwWaitForSingleObject+0xc (FPO: [3,0,0])</span><br><span class="line">02 0bbdfa88 76e9f872 00000000 00000000 00000000 ntdll!RtlpWaitOnCriticalSection+0x13e (FPO: [Non-Fpo])</span><br><span class="line">03 0bbdfab0 76ecb31d 76f47340 7d4908db 7ff75000 ntdll!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])</span><br><span class="line">04 0bbdfb44 76ecb13c 0bbdfbb4 7d49080f 00000000 ntdll!LdrpInitializeThread+0xc6 (FPO: [Non-Fpo])</span><br><span class="line">05 0bbdfb90 76ecb169 0bbdfbb4 76e70000 00000000 ntdll!_LdrpInitialize+0x1ad (FPO: [Non-Fpo])</span><br><span class="line">06 0bbdfba0 00000000 0bbdfbb4 76e70000 00000000 ntdll!LdrInitializeThunk+0x10 (FPO: [Non-Fpo])</span><br></pre></td></tr></table></figure><p>原来这个线程在等待LdrpLoaderLock这个锁啊，真相大白了。这里理一下思路，线程13e0，创建后，调用Loadlibrary，装载HaoZipExt。这个时候HaoZipExt获得LdrpLoaderLock，但是HaoZipExt犯了编写DLL的大忌。在DLLMain里面做了一些不能预期的事情。HaoZipExt调用了SHGetSpecialFolderLocation，这个函数在内部会创建一个线程，运行一个叫做FirstHardwareEnumThreadProc 的子过程。这个线程起来之后，就会通知所用的DllMain，告诉他们DLL_THREAD_ATTACH的消息。但是告诉他们这个消息之前，首先要获得LdrpLoaderLock这个锁。但是LdrpLoaderLock这个锁正在被创建他的线程使用，而且还在等自己结束，就这样死锁了。这也是MSDN特别强调告诉我们，不要在DllMain里有过多自己不能预期的操作的原因。</p><p>那么看看这个罪魁祸首是什么模块吧。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:054&gt; lmvm HaoZipExt</span><br><span class="line">Browse full module list</span><br><span class="line">start end module name</span><br><span class="line">0a5a0000 0a605000 HaoZipExt (export symbols) HaoZipExt.dll</span><br><span class="line">Loaded symbol image file: HaoZipExt.dll</span><br><span class="line">Image path: C:\Program Files\HaoZip\HaoZipExt.dll</span><br><span class="line">Image name: HaoZipExt.dll</span><br><span class="line">Browse all global symbols functions data</span><br><span class="line">Timestamp: Wed Jul 25 17:16:06 2012 (500FB956)</span><br><span class="line">CheckSum: 0006C14B</span><br><span class="line">ImageSize: 00065000</span><br><span class="line">File version: 3.0.1.9002</span><br><span class="line">Product version: 3.0.1.9002</span><br><span class="line">File flags: 0 (Mask 3F)</span><br><span class="line">File OS: 40004 NT Win32</span><br><span class="line">File type: 2.0 Dll</span><br><span class="line">File date: 00000000.00000000</span><br><span class="line">Translations: 0804.04b0</span><br><span class="line">CompanyName: 瑞创网络</span><br><span class="line">ProductName: 2345好压（HaoZip）</span><br><span class="line">InternalName: HaoZipExt</span><br><span class="line">OriginalFilename: HaoZipExt.dll</span><br><span class="line">ProductVersion: 3.0</span><br><span class="line">FileVersion: 3.0.1.9002</span><br><span class="line">FileDescription: 2345好压-Windows扩展模块</span><br><span class="line">LegalCopyright: 版权所有(c) 2012 瑞创网络</span><br><span class="line">Comments: www.haozip.com</span><br></pre></td></tr></table></figure><p>知道问题后，我感觉这应该就是explorer挂死的原因，虽然没有100%的证据，但是至少也是一个造成死锁的程序，早卸载为妙，于是我告诉了同事，卸载了这个叫做好压的软件。之后几天，explorer运行正常，再也没有出现过挂死现象了。</p><p>最后总结HaoZipExt犯的错误<br>1.在DllMain里面的做了线程创建的操作。<br>2.跟挂死无关，只是吐槽一下他在DllMain里面调用了SHGetSpecialFolderLocation这个函数。因为这个函数已经不被支持，而且有可能在将来被废弃。以下是MSDN的原话：[SHGetSpecialFolderLocation is not supported and may be altered or unavailable in the future. Instead, useSHGetFolderLocation.]</p><p>感叹一下，写一个健壮的程序真的不是件容易的事啊。</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于WOW64的一点记录</title>
      <link href="/2013/06/30/e585b3e4ba8ewow64e79a84e4b880e782b9e8aeb0e5bd95/"/>
      <url>/2013/06/30/e585b3e4ba8ewow64e79a84e4b880e782b9e8aeb0e5bd95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>1.关于TEB的地址：32位的TEB地址在64位TEB地址加上0x2000的偏移处。验证如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; r @$teb</span><br><span class="line">$teb&#x3D;000000007efdb000</span><br><span class="line"></span><br><span class="line">0:000:x86&gt; dg @fs</span><br><span class="line">P Si Gr Pr Lo</span><br><span class="line">Sel Base Limit Type l ze an es ng Flags</span><br><span class="line">---- ----------------- ----------------- ---------- - -- -- -- -- --------</span><br><span class="line">0053 7efdd000 00000fff Data RW Ac 3 Bg By P Nl 000004f3</span><br><span class="line"></span><br><span class="line">0:000:x86&gt; ? 7efdd000 - 7efdb000</span><br><span class="line">Evaluate expression: 8192 &#x3D; 00002000</span><br></pre></td></tr></table></figure><p>2.从32位切换到到64位的时候，系统会保存32位的寄存器状态。这些状态保存在Teb-&gt;TlsShots[1]中。继续用Windbg验证：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; dt _teb @$teb -a5 TlsSlots</span><br><span class="line">ntdll!_TEB</span><br><span class="line">+0x1480 TlsSlots :</span><br><span class="line">[00] (null)</span><br><span class="line">[01] 0x00000000&#96;001cfd20 Void</span><br><span class="line">[02] (null)</span><br><span class="line">[03] 0x00000000&#96;001ca930 Void</span><br><span class="line">[04] (null)</span><br><span class="line"></span><br><span class="line">0:000&gt; !wow64exts.r</span><br><span class="line"></span><br><span class="line">No wow64 context address specified, dumping wow64 context from cpu area...</span><br><span class="line">Teb64 Address: 0x7efdb000, CpuArea Address: 0x1cfd20</span><br><span class="line"></span><br><span class="line">Context Address: 0x1cfd24</span><br><span class="line"></span><br><span class="line">eax&#x3D;00000000 ebx&#x3D;00000000 ecx&#x3D;00000000 edx&#x3D;00000000 esi&#x3D;77200094 edi&#x3D;00000000</span><br><span class="line">eip&#x3D;772000a6 esp&#x3D;000ee0ac ebp&#x3D;000ee150 iopl&#x3D;0 nv up ei pl zr na po nc</span><br><span class="line">cs&#x3D;0023 ss&#x3D;002b ds&#x3D;002b es&#x3D;002b fs&#x3D;0053 gs&#x3D;002b efl&#x3D;00000246</span><br></pre></td></tr></table></figure><p>3.从64位切换到到32位的时候,会保存64位的RSP，保持的地址是Teb-&gt;TlsShots[0]。切换回64位的时候，这个地址被清0。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; dt ntdll!_TEB @r12 -a5 TlsSlots</span><br><span class="line">+0x1480 TlsSlots :</span><br><span class="line">[00] 0x00000000&#96;001ce530 Void</span><br><span class="line">[01] 0x00000000&#96;001cfd20 Void</span><br><span class="line">[02] (null)</span><br><span class="line">[03] (null)</span><br><span class="line">[04] (null)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EtwLogView —— 实时查看ETW的工具</title>
      <link href="/2013/06/12/etwlogview-e5ae9ee697b6e69fa5e79c8betwe79a84e5b7a5e585b7/"/>
      <url>/2013/06/12/etwlogview-e5ae9ee697b6e69fa5e79c8betwe79a84e5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近玩XPerf玩的比较多，也经常和cradiator(<a href="http://sysdbg.com/">blog</a>)讨论xperf和etw的话题。上周吃饭的时候就讨论到，貌似没找到一款实时记录查看etw的工具。当时我的观点是，只是看etw的原始记录很难分析出什么东西，必须配合很细工具，例如xperfview。这样才能有效的发挥出etw的威力，所以实时工具用处不大。而cradiator认为，除了这些常规的用法外，如果能实时记录查看etw的信息，那么把etw当作平时的log输出方式也是不错的选择。这样的好处就是，不需要额外的加入log机制，使用etw就足够强大，其次如果遇上了问题，这些etw的记录又可以作为event，帮助xperfview的分析。然后这家伙就怂恿我写一个:-)</p><p>经过上面的一番介绍，应该就能知道EtwLogView的用处何在了。他是一个“实时”记录查看etw的工具。之所以用上了引号。是因为这个实时是有不确定性的。例如，如果一个provider输出了大量的事件信息。那么这个工具就会遇上麻烦，因为更新记录，和刷新界面的速度很可能跟不上provider的输出速度。这样，这个实时就大打折扣。不过就像cradiator所说的，只用来监控自己的事件，倒没什么问题。</p><p>现在EtwLogView是1.0版本，勉强算是可以先用着吧。</p><p>首先需要在Windows7系统和管理员权限运行工具，然后就可以创建Session，创建的时候需要选择Session的Provider。可以在List选择，也可以自己输入（必须为GUID格式）。如果想监视多个Provider，那么每个GUID之间需要用分号隔开。</p><p><a href="/uploads/2013/06/20130613010933.png"><img src="/uploads/2013/06/20130613010933.png" alt="20130613010933"></a></p><p><a href="/uploads/2013/06/20130613011032.png"><img src="/uploads/2013/06/20130613011032.png" alt="20130613011032"></a></p><p>另外，如果想更灵活的设置Session，可以使用xperf创建Session。然后打开EtwLogView，选择打开Session。在文本框中输入Session名，如果有多个Session需要监视，那么可以用分号隔开Session名。</p><p><a href="/uploads/2013/06/20130613011054.png"><img src="/uploads/2013/06/20130613011054.png" alt="20130613011054"></a></p><p>ETW输出的信息很多，我主要列出了12列，并且可以根据自己的需要选择显示的列。</p><p><a href="/uploads/2013/06/20130613011110.png"><img src="/uploads/2013/06/20130613011110.png" alt="20130613011110"></a></p><p>目前的功能就这么多，如果真的有的上再来看看能加上哪些功能吧。</p><p>下载<a href="/uploads/2013/06/EtwLogView.zip">EtwLogView</a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>几个有趣的未文档化Windbg的扩展命令</title>
      <link href="/2013/06/07/e587a0e4b8aae69c89e8b6a3e79a84e69caae69687e6a1a3e58c96windbge79a84e689a9e5b195e591bde4bba4/"/>
      <url>/2013/06/07/e587a0e4b8aae69c89e8b6a3e79a84e69caae69687e6a1a3e58c96windbge79a84e689a9e5b195e591bde4bba4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这里使用的是Windbg最新版本，版本号是6.2.9200，可以在Windows8的SDK中获得。</p><p>1.eflags 用更加友好的方式显示被设置的标志寄存器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; r efl</span><br><span class="line">efl&#x3D;00000246</span><br><span class="line"></span><br><span class="line">0:000&gt; !eflags</span><br><span class="line">BIT_1_RESERVED</span><br><span class="line">PARITY_FLAG</span><br><span class="line">ZERO_FLAG</span><br><span class="line">INTERRUPTS_ENABLED</span><br><span class="line"></span><br><span class="line">0:000&gt; r zf</span><br><span class="line">zf&#x3D;1</span><br><span class="line">0:000&gt; r if</span><br><span class="line">if&#x3D;1</span><br></pre></td></tr></table></figure><p>2.frame 用module!function的方式设置栈帧</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; kn L3</span><br><span class="line"># ChildEBP RetAddr</span><br><span class="line">00 0018df2c 7586d7db kernel32!CreateFileW</span><br><span class="line">01 0018e024 7586d9d1 apphelp!IdentifyCandidates+0x176</span><br><span class="line">02 0018e054 7586d87b apphelp!ApphelpQueryExe+0xb8</span><br><span class="line"></span><br><span class="line">0:000&gt; .frame</span><br><span class="line">00 0018df2c 7586d7db kernel32!CreateFileW</span><br><span class="line"></span><br><span class="line">0:000&gt; !frame apphelp!ApphelpQueryExe</span><br><span class="line">Frame Set to 0x00000002</span><br><span class="line"></span><br><span class="line">0:000&gt; .frame</span><br><span class="line">02 0018e054 7586d87b apphelp!ApphelpQueryExe+0xb8</span><br></pre></td></tr></table></figure><p>3.hashblob 计算指定内存的hash，hash方式包括md5和sha1</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !hashblob</span><br><span class="line">Not enough parameters 0</span><br><span class="line">!hashblob &lt;hash&gt; &lt;Start&gt; &lt;End&gt;</span><br><span class="line">&lt;hash&gt;: 1 for MD5</span><br><span class="line">&lt;hash&gt;: 2 for SHA1</span><br><span class="line"></span><br><span class="line">0:000&gt; !hashblob 1 001f0000 001f0100</span><br><span class="line">DCC4E0B6659F6887DEC24A9FF2D57DC8</span><br></pre></td></tr></table></figure><p>4.imports 列出指定模块的导入函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !imports notepad</span><br><span class="line"></span><br><span class="line">notepad notepad Imports from file: ADVAPI32.dll</span><br><span class="line">RegSetValueExW</span><br><span class="line">RegQueryValueExW</span><br><span class="line">...</span><br><span class="line">notepad Imports from file: KERNEL32.dll</span><br><span class="line">FindNLSString</span><br><span class="line">GlobalAlloc</span><br><span class="line">GlobalUnlock</span><br><span class="line">GlobalLock</span><br><span class="line">GetTimeFormatW</span><br><span class="line">GetDateFormatW</span><br><span class="line">GetLocalTime</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>5.inframe 找出指定地址所在的栈帧范围</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ChildEBP RetAddr</span><br><span class="line">0018df2c 7586d7db kernel32!CreateFileW</span><br><span class="line">0018e024 7586d9d1 apphelp!IdentifyCandidates+0x176</span><br><span class="line"></span><br><span class="line">0:000&gt; !inframe 0018df8c</span><br><span class="line">0018df8c 0 00001714 0018df34 &lt; 0018df8c &lt; 0018e02c</span><br><span class="line">Frame: 1</span><br></pre></td></tr></table></figure><p>6.inmodule 找出指定地址所在的模块</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !inmodule 7586d9d1</span><br><span class="line">0x7586d9d1: apphelp!ApphelpQueryExe</span><br></pre></td></tr></table></figure><p>7.url 用默认浏览器打开指定网页</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !url</span><br><span class="line">Please provide a valid URL (http:&#x2F;&#x2F;... or https:&#x2F;&#x2F;... )</span><br><span class="line">USAGE: !url &lt;url&gt;</span><br><span class="line"></span><br><span class="line">0:000&gt; !url http:&#x2F;&#x2F;0cch.net</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于DLL加载和运行的性能优化总结</title>
      <link href="/2013/05/19/e585b3e4ba8edlle58aa0e8bdbde5928ce8bf90e8a18ce680a7e883bde4bc98e58c96e680bbe7bb93/"/>
      <url>/2013/05/19/e585b3e4ba8edlle58aa0e8bdbde5928ce8bf90e8a18ce680a7e883bde4bc98e58c96e680bbe7bb93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文从三个方面总结了加快DLL加载和运行速度的方法，他们分别是：  </p><ol><li>使用Rebase和Bind。  </li><li>按序号的方式导入函数。  </li><li>使用预读取技术（chromium加载dll时使用了此项）。  </li></ol><p>首先，讨论一下使用Rebase和Bind，提高DLL加载和运行性能的方法。我们知道，在编译链接DLL的时候，连接器会给DLL一个加载基址，而这个加载基址对于DLL模块中的使用了硬编码地址的代码和数据是至关重要的。因为这些硬编码的地址都是连接器通过DLL加载基址计算出来的。</p><p>这样，当我们的DLL被加载到进程空间当中的时候，如果足够幸运的话，DLL正好被加载到连接器所指定的地址，那么那些硬编码的地址就是完全正确的，加载过程不需要其他额外的工作就能让DLL正确运行了。</p><p>但是，真实的情况并不是这么理想，因为我们的进程可能不得不加载许许多多DLL，这样就会导致，某些DLL预定的基址可能已经被其他DLL使用。因此，前者就不得不加载到其他地址。由此带来的影响也是显而易见的，硬编码的地址就会出错。为了不让这种错误发生，加载器也就不得不多做一些工作，就是重新矫正这些硬编码。这样，如果DLL里包含的硬编码地址越多，加载的速度就会越慢，从而导致DLL加载性能下降。</p><p>另一方面，由于DLL加载基址是不可预见的，所以DLL加载的时候，加载器会根据导入表搜索所有的导入函数，计算并且确定导入函数的正确地址。这个过程也会对DLL加载性能有一定影响。</p><p>微软已经考虑到了这个问题的优化方法，在SDK中为我们提供了Rebase和Bind工具。其中Rebase工具，可以合理安排进程中DLL的加载地址，并且修改到PE中，从而避免DLL加载时Rebase操作。这样，一旦我们确认了DLL的加载基址是不会发生改变，那么我们就可以使用Bind工具将导入表进行绑定，这样的好处就是加载器不需要在加载的时候去计算确定导入函数地址，因为这些地址以及被预设了。</p><p>需要注意的一点，即使你做了这么多的事情，也不能完全避免加载基址的冲突，例如使用ASLR的DLL，其加载的地址是会发生变化的。所以就不能保证Rebase和Bind的有效性。具体能优化多少性能，在不同的案例中可能结果不同，需要具体实验才能知道。</p><p>第二种优化DLL运行性能的方案就是使用序号而非名称的方式导入函数。这一点也就非常容易解释了，如果通过函数名确定导入函数地址，那么加载器就不得不对字符串进行比较，从而确定正确的函数地址，虽然DLL的导出表是按顺序字母排列的，并且查找方式也是二分查找，但是如果函数很多，这依然是个耗时的工作。例如，我机器上的MFC100.dll有14000多个导出函数，如果进程需要按照名称确定自己需要的函数是哪一个，那么工作量还是不小的吧。所以MFC100.dll很明智的使用了导出序号的方法，这样加载器计算导入函数的时候，就能够使用序号来确定函数地址了，也就是简单使用数组搜索，从而得到目标函数地址。</p><p>这种方法的优化效果同样也要根据具体情况而定，如果导入函数少，目标DLL导出的函数也非常少，那么这种优化应该是没有什么意义的。相反，如果需要导入函数很多，而且目标DLL也导出了很多函数，那么在想提高程序加载性能的时候，不妨试一试这个方案。</p><p>最后一个方法是Pre-Read技术，使用在chromium中的。这种方法的原理是将DLL预先存入系统缓存，从而减少Page Fault来达到提高性能的目的。这种优化主要针对的是进程冷启动加载DLL的情况。进程第一次启动的时候，加载所需的DLL，DLL会被MAP到内存空间，虽然如果查询这片MAP的内存，会发现确实是COMMIT状态。但是，实际上系统并没要保证这些内存在Working Set中。一般情况下，系统只会把你想要用到的内存加载到Working Set中，以节约物理内存。这样，当我们每次用到这个并没有对应的Working Set的虚拟内存的时候，就发生了Page Fault，系统这个时候才会把这些内存加载到Working Set。而Page Fault对性能的影响很是比较大的。所以Pre-Read技术就有了用武之地。</p><p>Chromium对Pre-Read实现的非常好，代码的具体位置是<a href="http://src.chromium.org/viewvc/chrome/trunk/src/chrome/app/image_pre_reader_win.cc">http://src.chromium.org/viewvc/chrome/trunk/src/chrome/app/image_pre_reader_win.cc</a> 。代码中，分别针对XP和XP以上的系统使用了不同的方法让系统缓存目标DLL。在XP以上的系统中，代码简单的通过ReadFile将文件读取到内存中，然后释放内存，关闭文件句柄，就可以达到缓存目标DLL的目的。而在XP系统下，做法有些不同，它使用LoadLibraryEx函数，将文件Load到内存空间，然后尝试对每个Page进行读取操作，已达到让数据载入Working Set的目的。</p><p>以上是我所知道的三种加载DLL的优化方法，也可能还有更多更好的方法，有兴趣的可以一起讨论下。不过无论什么性能优化方法，都必须建立在实际项目的基础上，并且有科学的依据和论证，切不可只从理论上下结论来优化程序，纸上谈兵，这样很可能适得其反，让性能变得更糟。（例如这个例子里所提到的，看上去不错的优化可能还不如什么都不做：<a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/12/17/317157.aspx">http://blogs.msdn.com/b/oldnewthing/archive/2004/12/17/317157.aspx</a>）。至于说，如何得到程序运行数据用于总结出有效的优化方案，这里强烈推荐一款神器XPerf。实际上，也是因为使用了XPerf，才让我对性能优化产生了浓厚的兴趣！</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gdi_handle_study —— 查看进程GDI资源情况的工具</title>
      <link href="/2013/05/04/gdi_handle_study-e69fa5e79c8be8bf9be7a88bgdie8b584e6ba90e68385e586b5e79a84e5b7a5e585b7/"/>
      <url>/2013/05/04/gdi_handle_study-e69fa5e79c8be8bf9be7a88bgdie8b584e6ba90e68385e586b5e79a84e5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>gdi_handle_study 是一个用于查看进程中gdi句柄资源的工具。可以用于监控gdi资源是否泄露，已经对gdi资源的使用情况。使用方法非常简单：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;blockquote&gt;usage: gdi_handle_study.exe [-c] [-v [-f &lt;filter&gt;]] [processname|pid]</span><br><span class="line">processname    List GDI handles loaded by process (partial name accepted)</span><br><span class="line">pid                   List GDI handles associated with the specified process id</span><br><span class="line">-c                    Show GDI count information.</span><br><span class="line">-v                    Show GDI handle information.</span><br><span class="line">-f                    Filter the GDI handle type.&lt;&#x2F;blockquote&gt;</span><br></pre></td></tr></table></figure><p>在不用任何参数的情况下，工具会显示所有进程的gdi资源使用概况，如图所示：<br><a href="/uploads/2013/05/20130504154700.png"><img src="/uploads/2013/05/20130504154700.png" alt="20130504154700"></a></p><p>值得注意的是，GDI Total和GDI All的区别在于，GDI Total统计出来的数量，是通过工具本身枚举可统计GDI资源后得出统计值，而GDI All是通过系统API直接获得的值，有些的情况下，GDI Total的值是小于GDI All的值的。这种情况可能因为某些GDI资源是系统保留的。另外一个要注意的是，如果要显示所有进程的gdi情况，需要有管理员权限运行该工具。</p><p>processname和pid参数能让我们指定需要查看的进程名或者进程ID。参数-c能查看更为详细的gdi资源的统计情况。如下图所示：<br><a href="/uploads/2013/05/20130504155533.png"><img src="/uploads/2013/05/20130504155533.png" alt="20130504155533"></a></p><p>从上图可以看出，qq这种DirectUI程序，用的Bitmap资源何其的多啊。。。</p><p>-v参数是用来查看更为详细的GDI资源信息，其中就包括额资源的句柄，资源的种类以及资源的内核对象地址。如图所示：<br><a href="/uploads/2013/05/20130504160314.png"><img src="/uploads/2013/05/20130504160314.png" alt="20130504160314"></a></p><p>最后工具还能利用-f filter，来查看想看到的资源情况，例如上图中，bitmap不是自己想看的资源，但是却占据了大量的视野。这个时候filter就能用上了。如图：<br><a href="/uploads/2013/05/20130504160837.png"><img src="/uploads/2013/05/20130504160837.png" alt="20130504160837"></a></p><p>上图就是利用filter，显示的Brush资源的详细情况了。</p><p>下载<a href="/uploads/2013/05/gdi_handle_study.zip">gdi_handle_study</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ProcMem —— 进程内存查看工具</title>
      <link href="/2013/04/21/procmem-e8bf9be7a88be58685e5ad98e69fa5e79c8be5b7a5e585b7/"/>
      <url>/2013/04/21/procmem-e8bf9be7a88be58685e5ad98e69fa5e79c8be5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ProcMem是一个进程内存的查看工具，他可以显示进程中的内存分配情况，以及内存大概的用途，并且Dump指定的内存模块。工具界面如下图</p><p><a href="/uploads/2013/04/20130421231145.png"><img src="/uploads/2013/04/20130421231145.png" alt="20130421231145"></a></p><p>ProcMem并不是实时监控目标进程的内存情况，而是对内存情况作了一次快照和统计，并且显示出来。所以想看到进程最新的内存状态，可以点击Refresh菜单。</p><p>工具上半部分就是显示的目标进程的内存分布情况，以及一些细节信息。这里必须要谈到一点，Windows的标准控件中没有TreeList，对我这个写100个程序99个没有界面的人来说，自绘这个东西差点没要了我的命。</p><p>工具的下半部分用来显示TreeList选中项的内存情况，十六进制表示。值得注意的是，这里只会显示选中内存头个PAGE_SIZE大小的内存情况。如果想查看该项内存的全部情况，可以使用Dump功能，把内存Dump下来，然后用WinHex这样的工具查看，这个简单的内存显示区，只是为了提供一个预览功能而已。</p><p>值得一提的是，菜单Find，不是用来查找下方十六进制内存显示的内容，而是用来查找TreeList中的项目。例如想找到有关ntdll的内存区域，可以在查找框中输入ntdll，这样就可以定位如图所示的项目了。</p><p>这个工具是我花了大半周的业余时间弄的，时间比较仓促，不可避免的可能会有些bug。如果你刚好用上了这个工具，而且发现了bug，不妨通过邮件联系我（邮箱地址见<a href="http://0cch.net/wordpress/?page_id=2">About Me</a>页面）。</p><p>下载<a href="/uploads/2013/04/ProcMem.zip">ProcMem</a>(包括32和64位版本)</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记VC6中STL的map的一处BUG</title>
      <link href="/2013/04/19/e8aeb0vc6e4b8adstle79a84mape79a84e4b880e5a484bug/"/>
      <url>/2013/04/19/e8aeb0vc6e4b8adstle79a84mape79a84e4b880e5a484bug/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天和同事一起调了一个vc6.0中stl的map的一个bug。</p><p>BUG的起因是，我们的项目中使用了stl的map类。而这个map类的对象被用在了不同的DLL模块中，在这样的条件写，BUG就产生了，一个模块内部map对象指针能正常工作，另一个模块内部就出了问题。起初我们就觉得很奇怪，很简单一份代码，怎么会出现访问无效内存的情况，我们还是通常的思路，先在自己身上找问题。调了一会发现，自己的代码确实没有错误。于是我们把目光转向了vc6的stl本身。</p><p>跟踪了一下stl的代码，发现错误发生在下面这段代码内部。</p><p><a href="/uploads/2013/04/20130419140128.png"><img src="/uploads/2013/04/20130419140128.png" alt="20130419140128"></a></p><p>在正常的模块中while (_x != _Nil)这个循环只经历了一次，就跳出循环了。而发生错误模块中第二次进入这个循环，也就在这次的循环中，出现了内存访问异常的情况。很明显就要看两次_x != _Nil比较的详细结果。刚开始我被误导了，以为_Nil就是一个为0的常量，把注意力留在_X上后来发现，正确和错误的模块中，_X值一直都是相同的。这才缓过神来，_Nil这个值有问题。</p><p>确实，这个不是一个0，更不是一个常量，他是一个静态指针变量。在map对象被创建的时候，生成了一个填充为0的结构体，并且把结构体指针存到了这个变量中。</p><p>真相大白了，由于在不同的模块中都是用了stl的map代码，这样map的代码就被编译了两份，同样每个模块中map的_Nil也存放在各自的模块地址范围内。这样就使得_Nil值是不相同的，如果在非创建这个map对象的模块中引用对象指针，并且调用map的函数。如果遇到了_Nil，就会引用此模块自己的_Nil，而不是创建对象模块的_Nil，如果这个模块没有初始化过map对象，那么这个模块的_Nil就是0，即使初始化过，两个模块的_Nil也没可能是同一个值。</p><p>新版stl中这个bug必然已经解决，简单来看看vs2010的stl</p><p><a href="/uploads/2013/04/20130419142503.png"><img src="/uploads/2013/04/20130419142503.png" alt="20130419142503"></a></p><p>循环中检查是否为空，用到了函数_Isnil这个，而这个函数查看了_Nodeptr结构中的_Isnil成员变量。判断空放在成员对象内部，这样在多模块之间调用该对象就不会有任何问题了。</p><p>话说，vc6的stl确实是bug一堆，很早之前，人们就喜欢用sgi-stl来代替vc6自带的stl了。</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件搜索工具everythings工作原理简介</title>
      <link href="/2013/04/08/e69687e4bbb6e6909ce7b4a2e5b7a5e585b7everythingse5b7a5e4bd9ce58e9fe79086e7ae80e4bb8b/"/>
      <url>/2013/04/08/e69687e4bbb6e6909ce7b4a2e5b7a5e585b7everythingse5b7a5e4bd9ce58e9fe79086e7ae80e4bb8b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>everythings是一个非常强大而且好用的文件搜索工具。他搜索文件的速度非常之快，基本上刚刚输入要查找的文件名，文件已经搜索了出来。这里就简单介绍一下他的工作原理。</p><p>有一点已经非常明显，everythings在查找工作开始之前会建立全盘文件索引的数据库，那么这个数据库必然就是搜索文件快速的最重要的原因。而这个数据库的建立的用时似乎非常之短，是普通方法下遍历整个卷所不能及的。</p><p>实际上，建立数据库的方法确实比较特殊。简单来说就是遍历目标卷NTFS文件系统的Master File Table（简称MFT）的记录，这也解释了为什么everythings只能工作在是NTFS的文件系统的卷上。MFT可以看成ntfs中文件的索引，MFT中的每条记录都是指向卷中的一个文件。遍历这个索引的速度可要比按照目录递归整个卷的速度要快得多了。不过可惜的是，Windows并没有提供能够直接访问MFT的API，除非你直接解析NTFS磁盘格式（参考<a href="http://0cch.net/wordpress/?p=117">这篇文章</a>）。而且就算让你直接遍历的MFT，要监控文件的变化并且写入数据库也是一个不好办的工作。不过可喜的是，微软提供了一种间接遍历MFT记录的方式，并且通过这样的方式可以监控卷上文件的变化，他就是Change Journal（<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363798(v=vs.85).aspx">官方文档</a>）。</p><p>Change Journal实际上是Windows 2000的NTFS文件系统就提供了的功能。其目的就是如同名字一样，记录文件改变的日志，方便NTFS文件系统对文件的恢复，这确实是个不错的特性。如何使用这个功能去遍历和监控MFT的记录，我这里就不做详细介绍了。因为有一片更加好的文章已经写的非常的清楚，我的demo也参考了他的很多代码。这篇文章叫做《<a href="http://www.microsoft.com/msj/0999/journal/journal.aspx">Keeping an Eye on Your NTFS Drives: the Windows 2000 Change Journal Explained</a>》是1999年9月份的msdn杂志发表的。</p><p>我这里假设你已经阅读了这篇文章。我们已经知道了遍历和监控MFT记录的方法，并且通过这个方法获得了每个文件的文件名，file reference和parent reference（可以理解为文件id和其父目录id）。那么这里就可以把这三个元素作为一条记录存储在我们制定的数据库中。</p><p>下面简单说下如何利用这个数据库，当需要查找文件的时候：<br>1.获得用户输入的文件名。<br>2.通过文件名A可以从数据库中筛选出一些记录，而这些记录中就包括了文件的parent reference。<br>3.通过parent reference再次查找数据库的file reference字段，获得对应的文件名B，这个文件名B就是文件A的父目录了。重复这一步直到根目录为止。<br>这样就能找到文件的详细路径了。  </p><p>我写demo的时候并没有考虑怎么构建这个数据库，直接用了sqlite。不过如果能自己设计一个专门为存储这些数据的小数据库，也应该有更高的效率吧。everythings的数据库就是经过bzip压缩的自定义的文件。</p><p>DEMO——构建文件索引数据库：<br><a href="/uploads/2013/04/20130409003609.png"><img src="/uploads/2013/04/20130409003609.png" alt="20130409003609"></a></p><p>DEMO——查找文件<br><a href="/uploads/2013/04/20130409003752.png"><img src="/uploads/2013/04/20130409003752.png" alt="20130409003752"></a></p><p>P.S 如果采用sqlite作为文件数据库的话，建立索引的插入数据操作一定要利用sqlite的事务机制，否则会在插入数据上花费很多时间。</p><p>P.S.2 everythings之所以需要管理员权限才能工作，是因为他需要打开本地卷的句柄，这个就需要管理员权限了。</p><p>最后说一点这种方法的不足吧。那就是这种方法对于有多个hardlinks的文件，只能枚举出一个路径。关于hardlink的介绍可以参考<a href="http://0cch.net/wordpress/?p=179">这篇文章</a>。由于这个不足，你在查找system32下的文件的时候，往往搜索不到，搜索到的又往往在其他目录，出现尤其多的应该是Winsxs目录了（而关于Winsxs可以看看<a href="http://sysdbg.com/index.php/2013/04/08/everything-you-never-wanted-to-know-about-winsxs/">这篇翻译</a>，翻译质量很不错）。例如我们搜索C盘下的notepad.exe，everythings搜索的结果是这样的：<br><a href="/uploads/2013/04/20130409021029.png"><img src="/uploads/2013/04/20130409021029.png" alt="20130409021029"></a></p><p>可以注意到并没有system32下notepad.exe的身影。我们的demo同样也会遇到这样的情况：<br><a href="/uploads/2013/04/20130409021252.png"><img src="/uploads/2013/04/20130409021252.png" alt="20130409021252"></a></p><p>下图显示的是同一个notepad.exe的4个存储位置。<br><a href="/uploads/2013/04/20130409021829.png"><img src="/uploads/2013/04/20130409021829.png" alt="20130409021829"></a></p><p>虽然everythings有这样的一个不足，但是瑕不掩瑜，他的的确确是一个非常非常优秀的工具！我这里探讨的也仅仅是他的大概原理。实际上这个工具如此优秀，必然是在很多细节上做的非常好才行的。强烈推荐大家使用！</p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>proc_dump_study —— 进程dump工具</title>
      <link href="/2013/04/06/proc_dump_study-e8bf9be7a88bdumpe5b7a5e585b7/"/>
      <url>/2013/04/06/proc_dump_study-e8bf9be7a88bdumpe5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>proc_dump_study是逆向sysinternals的Procdump的一个工具。在功能上几乎和procdump一模一样。有一点差距就是目前没有支持clr的异常，也就是procdump的-g参数。其他的usage基本上相同，这里也不细说了。想说的一点是，proc_dump_study和procdump一样，功能比较强大，参数也比较多。所以为了方便使用，我把用的比较多的功能总结了一下，写了一个带UI shell程序。这样就方便测试人员或者不想深入理解命令行程序的人员使用。</p><p><a href="/uploads/2013/04/20130404013936.png"><img src="/uploads/2013/04/20130404013936.png" alt="20130404013936"></a></p><p>简单介绍一下使用方法<br>1.选择要监控或者dump的进程，确定生成dump的文件位置。<br>2.选择dump类型，包括mini dump，full dump以及effective dump，dump的大小分别为小，大，中等。<br>3.选择是否监控进程的cpu使用率<br>4.选择是否监控进程的内存提交数量<br>5.选择是否监控进程窗口是否挂起<br>6.选择是否监控进程发生异常<br>7.选择是否监控进程推出<br>8.最后点击dump按钮  </p><p>这样，一旦监控的时候任何监控点达到要求，就会产生dump文件了。如果不需要监控任何进程窗口，程序会立刻dump进程。实际上直接使用proc_dump_study会有更多的功能可以使用，不过这个UI版本应该可以应付大多数的情况了吧。</p><p>下载<a href="/uploads/2013/04/proc_dump_ui.zip">proc_dump_ui</a></p><p>最后放一张测试图<br><a href="/uploads/2013/04/20130402230714.png"><img src="/uploads/2013/04/20130402230714.png" alt="20130402230714"></a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>find_links_study —— 仿FindLinks的文件硬链接查找工具</title>
      <link href="/2013/03/16/find_links_study-e4bbbffindlinkse79a84e69687e4bbb6e7a1ace993bee68ea5e69fa5e689bee5b7a5e585b7/"/>
      <url>/2013/03/16/find_links_study-e4bbbffindlinkse79a84e69687e4bbb6e7a1ace993bee68ea5e69fa5e689bee5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在上一篇讨论<a href="http://0cch.net/wordpress/?p=179">hardlink</a>的文章中，我在最后提到要写一个查找hardlinks的工具。正如上一篇文章中介绍这种工具的工作原理一样，他的代码比较简单。所以前几天find_links_study就已经写完了，只是一直没空发出来。这个工具的使用和FindLinks一模一样，这里也不多做介绍了。下图是工具的工作效果：</p><p><a href="/uploads/2013/03/20130316214417.png"><img src="/uploads/2013/03/20130316214417.png" alt="20130316214417"></a></p><p>从图中我们可以发现，原来我们在系统中看到的多个notepad文件实际上就是一个文件而已，只不过他利用了hardlink的技术，产生了多个路径罢了。我感觉hardlink还是一个非常实用的技术，具体用在哪大家可以发挥想象力。就我个人看来，在某些情况下，用hardlink来备份文件，倒是一种不错的选择。</p><p>下载<a href="/uploads/2013/03/find_links_study.zip">find_links_study</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用ntfs_study探寻hardlink的本质</title>
      <link href="/2013/03/12/e4bdbfe794a8ntfs_studye68ea2e5afbbhardlinke79a84e69cace8b4a8/"/>
      <url>/2013/03/12/e4bdbfe794a8ntfs_studye68ea2e5afbbhardlinke79a84e69cace8b4a8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在推出<a href="http://0cch.net/wordpress/?p=117">ntfs_study的博文</a>中，我谈到过要用一些例子来简单介绍这个工具的用法，本文就算是这个工具的使用介绍以及hardlink在ntfs文件系统底层的简单探讨。</p><p>MSDN中写到，hardlink是在文件系统中，用多个在同一个卷的路径表示同一个文件的方法。那么在ntfs格式中这些被link的文件是怎么存在的呢？下面进行一些简单的探讨。</p><p>首先，我们需要去创建hardlink的文件。<br><a href="/uploads/2013/03/20130312202150.png"><img src="/uploads/2013/03/20130312202150.png" alt="20130312202150"></a></p><p>图中，第一个命令，在target_file.txt的同目录下，创建了hardlink文件link_file.txt。第二个命令，在不同目录（otherdir）下创建了第二个hardlink文件，link_file_in_otherdir.txt。第三个命令返回了错误，原因是我试图在不同卷里面来创建hardlink文件。失败的原因文章后面会介绍。</p><p>现在，让我们用ntfs_study来查看ntfs对这三个文件的处理到底是怎么样的。<br><a href="/uploads/2013/03/20130312202324.png"><img src="/uploads/2013/03/20130312202324.png" alt="20130312202324"></a></p><p>在这张图中，我们可以清楚的看到，这三个文件的file reference，也就是在主文件表（MFT）的id都是一样的！有一点我们必须明白，一个文件的存在不是因为在目录里面显示了文件名，而是他在MFT中有自己的位置，另外文件名只是文件的一个属性而已，没什么特别的。这也就解释了，看似三个文件为什么会指向同一个文件，因为在目录的记录中，他们指向了同一个id。</p><p>为了更加深入的探讨这个问题，我们来看一看id为0xB4A6这个具体情况。首先看看他的file record的数据。</p><p><a href="/uploads/2013/03/20130312202509.png"><img src="/uploads/2013/03/20130312202509.png" alt="20130312202509"></a></p><p>这里可以看到hardlinks的值是4！看到这里，应该就感到奇怪了，我们明明只创建了两个hardlink的文件，为什么这里写的是4呢？实际上，对于ntfs的文件而已，文件名以及他们在那个目录，这些都是属性而已，没有本体和hardlink之分，也就是说，我们原始创建的target_file.txt对于文件本身，也是一个hardlink。那么这个问题还是没解决啊，就算加上本身，最多也就是3个hardlinks，但是这里明明写的是4个！</p><p>让我们更加具体的看一看到底是什么回事吧。</p><p><a href="/uploads/2013/03/20130312202536.png"><img src="/uploads/2013/03/20130312202536.png" alt="20130312202536"></a></p><p>首先，我们看到了这个文件的属性中，居然有4个文件名，其中有三个实际上我们已经能够猜到，他们应该分别是target_file，link_file和link_file_in_otherdir这三个名称，那么第四个又是什么呢？只能再进一步看了。</p><p><a href="/uploads/2013/03/20130312202616.png"><img src="/uploads/2013/03/20130312202616.png" alt="20130312202616"></a></p><p>看了这幅图，估计大家就明白了，这个是为了兼容8.3文件名而产生的一个hardlink，只不过在我们现在的系统上隐藏了这个文件hardlink而已。其他三个文件名，如我们刚刚所料，就是那三个文件的名字。</p><p>现在解释下为什么hardlink只能在同一个卷里了。原因很显而易见，hardlink实际上是依赖于ntfs的MFT的，而不同的卷，会有不同的MFT，所以不能在不同卷之间创建hardlink也是理所当然的。</p><p>SysinternalsSuite中有一个工具叫做findlinks，用来找到一个文件所有的hardlink。其中实现的方法在不同的系统中有所不同，在vista以下的系统中程序调用GetFileInformationByHandle获得文件的MFT id，然后查找整个卷的文件，打开他们获得句柄，再调用GetFileInformationByHandle得到这些文件的id，与之前的id进行比对。可以说，这是非常费时的。而在vista中，这个耗时的问题得到了解决，调用FindFirstFileNameW和FindNextFileNameW就能够文件所有的hardlinks了。</p><p>我也计划过两天写一个find_links_study。</p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>access_enum_study —— 仿AccessEnum的工具</title>
      <link href="/2013/03/09/access_enum_study-e4bbbfaccessenume79a84e5b7a5e585b7/"/>
      <url>/2013/03/09/access_enum_study-e4bbbfaccessenume79a84e5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>access_enum_study 是我逆向AccessEnum所写的程序。写这个逆向加上写这个程序大概用了1个多星期的时间吧。不过说实话，逆向算法还是比较麻烦的事情，所以这个程序里面有一些算法是我自己想的。不过果然不出我所料，效率比起Mark的正牌工具差了不少。这下，真的只能当作玩具玩玩了。</p><p><a href="/uploads/2013/03/20130309230748.png"><img src="/uploads/2013/03/20130309230748.png" alt="20130309230748"></a></p><p>下载<a href="/uploads/2013/03/access_enum_study.zip">access_enum_study</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ntfs_info_study —— 仿NtfsInfo工具</title>
      <link href="/2013/02/27/ntfs_info_study-e4bbbfntfsinfoe5b7a5e585b7/"/>
      <url>/2013/02/27/ntfs_info_study-e4bbbfntfsinfoe5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ntfs_info_study 这个工具可以显示ntfs卷的一些信息。主要也是学习NtfsInfo的功能，而仿造的一个小工具。ntfs_info_study能显示的信息包括卷大小，扇区数量，簇数量，扇区字节数，簇字节数，主文件表每条记录字节数以及主文件表的一些信息。当然它还可以显示部分NTFS系统文件的信息，例如：$Volume。</p><p>实际上ntfs_info_study稍微修复了NtfsInfo的一个问题。原来的NtfsInfo已经无法显示NTFS系统文件的信息了。原因是这个工具调用FindFirstFile这样的函数来查找NTFS系统文件。我不知道什么版本的Windows可以这么做，至少现在Windows 7上，这个方法是行不通的。所以在我从写的工具里，是先打开系统文件，然后查询文件信息，但是普通的CreateFile是打不开这些文件的，这里我的方法是调用OpenFileById。不过实际上，我还没找到正规而且完美显示所有NTFS系统文件的方法，因为部分系统文件在打开的时候会提示访问拒绝。</p><p>当然不正规的但是却比较完美的查看NTFS系统文件的方法也有，就是直接打开卷，解析NTFS文件系统数据结构。这个功能已经在<a href="http://0cch.net/wordpress/?p=117">ntfs_study</a>中实现了，具体可以移步这个<a href="http://0cch.net/wordpress/?p=117">链接</a>。</p><p><a href="/uploads/2013/02/20130227235402.png"><img src="/uploads/2013/02/20130227235402.png" alt="20130227235402"></a></p><p>以上是一副对比图，其他功能是一样的，唯一的区别就是最后一项中，ntfs_info_study能够显示部分NTFS系统文件信息。</p><blockquote><p>Usage: ntfs_info_study.exe <drive letter></p></blockquote><p>使用方法自然也不必说明了，有兴趣的各位可以下载玩玩。</p><p>下载<a href="/uploads/2013/02/ntfs_info_study.zip">ntfs_info_study</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pipe_list_study —— 仿PipeList的小工具</title>
      <link href="/2013/02/21/pipe_list_study-e4bbbfpipeliste79a84e5b08fe5b7a5e585b7/"/>
      <url>/2013/02/21/pipe_list_study-e4bbbfpipeliste79a84e5b08fe5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>昨天在家看完笑傲江湖,没事可做，看了sysinternals的一个很简单的小工具PipeList，然后逆了下，山寨了一个，并且加按照管道名筛选的功能。工具很简单，一共也就200行代码。使用方法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: pipe_list_study.exe [search_pipe_name]</span><br><span class="line"></span><br><span class="line">search_pipe_name  ---  List the pipes that has search_pipe_name in the pipe name string.</span><br><span class="line">                       Without this argument pipe_list_study will list all pipes.</span><br></pre></td></tr></table></figure><p><a href="/uploads/2013/02/20130221114347.png"><img src="/uploads/2013/02/20130221114347.png" alt="20130221114347"></a></p><p>下载<a href="/uploads/2013/02/pipe_list_study.zip">pipe_list_study</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>又是总结和展望：没有世界末日，生活还要继续</title>
      <link href="/2013/02/17/e6b2a1e69c89e4b896e7958ce69cabe697a5efbc8ce7949fe6b4bbe8bf98e8a681e7bba7e7bbad/"/>
      <url>/2013/02/17/e6b2a1e69c89e4b896e7958ce69cabe697a5efbc8ce7949fe6b4bbe8bf98e8a681e7bba7e7bbad/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天总算是有时间，有心情写一篇总结去年生活，展望今年的文章了。</p><p>过去的2012年对我来说并不是末日，恰恰相反，他更像是一个新的开始。年初加入新公司，感觉选择还是比较正确的。在新的公司工作，工作不算忙，考勤也比较人性化，环境也还不错。主要是新同事们都还不错，别的不说，侃大山的能力还是很让人钦佩的。所以工作之余也非常娱乐。他们负责娱，我负责乐就行了，哈哈哈哈。刚刚说到工作不算忙，说起来本人也确实在这个环境中挺酱油的，不过俺也不是偷懒，主要是工作上合适我的活不算多。我去小组之后，发现本来打打杀杀的软件，现在要做良民了，不过其实这个做产品的思路是正确的，我也落得点清闲，实在不错。</p><p>当然了，本人实际上不甘于清闲。没事的时候还是跟哥们研究了许多编译器和系统底层的机制。除此之外，今年最大的一个收获是把COM这套东西了解一下，这样不仅对今后的工作有所帮助，而且自己本身对代码应该如何写方面也有一些收获。了解了COM当然要了解ATL，因为ATL过于强大，大部分代码我也没有去读，现在而言主要停留在能合理的使用，对于这点我也比较满意，实际上没打算把ATL搞得太清楚。至于编译器，学的也不多，刚刚把语法分析那块弄得一知半解吧。系统底层倒是一直在研究，尤其是文件系统，注册表等。关于系统底层这些，可以看我去年发的几篇blog，都是一些研究后自己写的工具。包括ntfs文件系统学习工具，注册表格式学习工具，pdb的解析工具等等。</p><p>回头再看看去年定的目标。。。我只能说“呵呵”。。。没有一个完成的啊有木有！！！果然奇迹没有发生啊有木有！！！那么，我又要给今年定目标了。。。</p><p>1.写一个study系列的工具，可以从山寨sysinternals的工具开始做起。</p><p>没了，对！就这一条！！！我就不信这一条我也搞不定！！！！！</p><p>去年写了总结后，同学们说我生活上的写的太少了，好吧那我简单总结下生活上的开心事！最开心的是，哥开始健身了！！！每周固定和一哥们去三次健身房，每次25分钟跑4k多米，并且锻炼腹肌和肱二头肌。现在人感觉就像回到高中状态。更让人欣慰的事情是能看到一点点腹肌了！另外精神方面，更多的相信“念念不忘，必有回响”，也有称这个为宇宙神秘力量的，不是迷信，而是一种信念，是一种相信只要你不断努力，不断追求就一定能达到目标的执念。不过可惜，我一直念念不忘年会大奖，可惜大宇宙送了我两个字——“呵呵”。。。关于练字，总是断断续续，貌似没啥进步。关于英语，嗯，没了。关于更八卦的生活详情<del>呵呵</del>你们以为我会写么！</p><p>那么今年生活上的目标呢？！还是健身，练字，英语和嘿嘿~~~</p><p>最后还是送祝福时间：祝福我的家人，朋友和我自己，新春快乐，健康平安，家庭和睦温馨！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>proc_study —— 仿PsList的进程查看工具</title>
      <link href="/2013/02/04/proc_study-e4bbbfpsliste79a84e8bf9be7a88be69fa5e79c8be5b7a5e585b7/"/>
      <url>/2013/02/04/proc_study-e4bbbfpsliste79a84e8bf9be7a88be69fa5e79c8be5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>proc_study 是我通过逆向PsList而写出来的小工具，如果在本地查看进程，这个工具和pslist没有任何区别。因为实现查看进程的方式也是和pslist一模一样的。另一方面，他缺乏pslist的查看远程计算机的进程的功能。没有实现这个并不是不知道怎么实现，是我半天也没搭建出这样的一个远程环境，真够郁闷的。这个应该是年前的最后一个study系列的工具了。期待蛇年有时间山寨更多工具，嘿嘿~~~</p><p><a href="/uploads/2013/02/20130204204101.png"><img src="/uploads/2013/02/20130204204101.png" alt="20130204204101"></a></p><p>这个工具的使用方法和命令行参数可以直接参看PsList的。因为整个Usage我都是直接山寨过来的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: proc_study [-d][-m][-x][-t][name|pid]</span><br><span class="line">-d      Show thread detail.</span><br><span class="line">-m     Show memory detail.</span><br><span class="line">-x      Show processes, memory information and threads.</span><br><span class="line">-t       Show process tree.</span><br><span class="line">name Show information about processes that begin with the name</span><br><span class="line">specified.</span><br><span class="line">-e      Exact match the process name.</span><br><span class="line">pid Show information about specified process.</span><br><span class="line"></span><br><span class="line">All memory values are displayed in KB.</span><br><span class="line">Abbreviation key:</span><br><span class="line">Pri Priority</span><br><span class="line">Thd Number of Threads</span><br><span class="line">Hnd Number of Handles</span><br><span class="line">VM Virtual Memory</span><br><span class="line">WS Working Set</span><br><span class="line">Priv Private Virtual Memory</span><br><span class="line">Priv Pk Private Virtual Memory Peak</span><br><span class="line">Faults Page Faults</span><br><span class="line">NonP Non-Paged Pool</span><br><span class="line">Page Paged Pool</span><br><span class="line">Cswtch Context Switches</span><br></pre></td></tr></table></figure><p>下载<a href="/uploads/2013/02/proc_study.zip">proc_study</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hive_study —— 注册表文件格式解析工具</title>
      <link href="/2013/01/23/hive_study-e6b3a8e5868ce8a1a8e69687e4bbb6e6a0bce5bc8fe8a7a3e69e90e5b7a5e585b7/"/>
      <url>/2013/01/23/hive_study-e6b3a8e5868ce8a1a8e69687e4bbb6e6a0bce5bc8fe8a7a3e69e90e5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这几天又写了个小工具，刚下班就在这发了算了。</p><p>hive_study 是一个注册表文件格式解析工具。功能也比较的简单，主要是dump出注册表里面的数据信息。例如显示子项，子键，显示键值以及他们的安全描述符。当然了，还是那样，注册表的hive文件实际上是不可读的，因为内核独占他了。想要获得可以读的hive文件，可以用ntfsstudy把hive文件dump出来，然后去读这个新的hive文件。以下是他的Usage。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage : hive_study.exe -f hive_path [-options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">[-k key_path] Specifies key path (e.g.: -k &quot;ControlSet001\Control\Session Manager&quot;)</span><br><span class="line">[-v value_name] Specifies value name (e.g.: -v BootExecute)</span><br><span class="line">[-l] List subkeys information</span><br><span class="line">[-e] List values information</span><br><span class="line">[-s] Show key security description information</span><br><span class="line">[-w output_file] Dump attribute to a file</span><br></pre></td></tr></table></figure><p><a href="/uploads/2013/01/20130123181723.png"><img src="/uploads/2013/01/20130123181723.png" alt="20130123181723"></a></p><p>下载<a href="/uploads/2013/01/hive_study.zip">hive_study</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分享自己打造的BugReporter</title>
      <link href="/2013/01/20/e58886e4baabe887aae5b7b1e68993e980a0e79a84bugreporter/"/>
      <url>/2013/01/20/e58886e4baabe887aae5b7b1e68993e980a0e79a84bugreporter/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这份代码应该是将近一年前写的吧，应该是去年年初了。不像ntfsstudy和dia_study，这个工具应该比较的实用吧，实用场合可以比较多。所以也把源代码发出来。看工具名称基本上已经知道了是报告bug用的。其实这种工具倒是挺多的。不过我个人感觉自己写一个用起来顺手，而且代码量小，容易修改自定义。</p><p>工具代码有三个工程，分别是minidump_generator，dump_minidump，BugReporter。<br>minidump_generator是一个dll，当然也可以编译成静态库，他需要加入到你想使用BugReporter的工程里面。<br>dump_minidump是一个dump文件的解析库，他是BugReporter工程的依赖库。<br>BugReporter是一个窗口程序，在你融合了minidump_generator的程序崩溃的时候会弹出窗口。就像图中那样。  </p><p><a href="/uploads/2013/01/20130120193015.png"><img src="/uploads/2013/01/20130120193015.png" alt="20130120193015"></a></p><p>勾选send bug report并且点击ok，窗口里的完整log和dump文件会打包为zip文件储存，储存的地方可以由程序指定，也可以写注册表键值，reporter会去都键值然后存储到相应的位置。具体什么键值，看源代码吧。不完整和遗憾的地方也有，就是还没有http上传到提交dump收集服务器的代码。因为确实不会写php啥的。另外这个工程也用了不少开源代码，这里也感谢一下，其中包括反汇编引擎和ZIP代码。</p><p>下载源代码：<a href="/uploads/2013/01/BugReporter.zip">BugReporter</a></p><p>以下是完整的dump log：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SYSTEM INFORMATIONS</span><br><span class="line">---------------</span><br><span class="line">ProcessorArchitecture : x86</span><br><span class="line">Number Of Processors : 16</span><br><span class="line">OS Version : 6.1</span><br><span class="line">BuildNumber : 7600</span><br><span class="line">CSDVersion :</span><br><span class="line">Platform : Windows Server 2003, Windows XP, or Windows 2000</span><br><span class="line"></span><br><span class="line">EXCEPTION INFORMATIONS</span><br><span class="line">---------------</span><br><span class="line">Thread id : 5744</span><br><span class="line">ExceptionCode : c00000fd</span><br><span class="line">ExceptionFlags : 00000000</span><br><span class="line">ExceptionRecord : 0000000000000000</span><br><span class="line">ExceptionAddress : 0000000000dea637</span><br><span class="line">ExceptionInformation0 &#x3D; 0000000000000000</span><br><span class="line">ExceptionInformation1 &#x3D; 0000000000102000</span><br><span class="line">Thread Context :</span><br><span class="line">EAX &#x3D; 00102000 ECX &#x3D; 00102050 EDX &#x3D; 5eea2408 EBX &#x3D; 7efde000</span><br><span class="line">ESP &#x3D; 00103120 EBP &#x3D; 00103128 ESI &#x3D; 001ff9c8 EDI &#x3D; 00104210</span><br><span class="line">EFLAGS &#x3D; 00010206</span><br><span class="line"></span><br><span class="line">MODULE INFORMATIONS</span><br><span class="line">---------------</span><br><span class="line">Base Size Name FileVersion ProductVersion</span><br><span class="line">0000000000de0000 0001a000 D:\crashme\Debug\crashme.exe 0 0</span><br><span class="line">00000000772b0000 00180000 C:\Windows\SysWOW64\ntdll.dll 600011db040af 600011db040af</span><br><span class="line">0000000075ef0000 00100000 C:\Windows\SysWOW64\kernel32.dll 600011db04001 600011db04001</span><br><span class="line">00000000750f0000 00046000 C:\Windows\SysWOW64\KERNELBASE.dll 600011db04001 600011db04001</span><br><span class="line">000000005ed90000 00124000 C:\Windows\winsxs\x86_microsoft.vc90.debugcrt_1fc8b3b9a1e18e3b_9.0.30729.4148_none_2a4cbfc25558bcd3\msvcr90d.dll 9000078091034 9000078091034</span><br><span class="line">0000000074330000 000eb000 C:\Windows\System32\dbghelp.dll 600011db04001 600011db04001</span><br><span class="line">0000000076e00000 000ac000 C:\Windows\SysWOW64\msvcrt.dll 700001db04001 6000121be4001</span><br><span class="line">0000000076d10000 000f0000 C:\Windows\SysWOW64\rpcrt4.dll 600011db04001 600011db04001</span><br><span class="line">0000000074e20000 00060000 C:\Windows\SysWOW64\sspicli.dll 600011db04064 600011db04064</span><br><span class="line">0000000074e10000 0000c000 C:\Windows\SysWOW64\CRYPTBASE.dll 600011db04001 600011db04001</span><br><span class="line">00000000761e0000 00019000 C:\Windows\SysWOW64\sechost.dll 600011db04001 600011db04001</span><br><span class="line">00000000763e0000 000a0000 C:\Windows\SysWOW64\advapi32.dll 600011db04001 600011db04001</span><br><span class="line">000000006e810000 00025000 C:\Windows\System32\powrprof.dll 600011db04001 600011db04001</span><br><span class="line">00000000768e0000 0019d000 C:\Windows\SysWOW64\setupapi.dll 600011db04001 600011db04001</span><br><span class="line">0000000074f70000 00027000 C:\Windows\SysWOW64\cfgmgr32.dll 600011db04001 600011db04001</span><br><span class="line">0000000076c80000 00090000 C:\Windows\SysWOW64\gdi32.dll 600011db04001 600011db04001</span><br><span class="line">0000000076a80000 00100000 C:\Windows\SysWOW64\user32.dll 600011db04001 600011db04001</span><br><span class="line">0000000077280000 0000a000 C:\Windows\SysWOW64\lpk.dll 600011db04001 600011db04001</span><br><span class="line">0000000075140000 0009d000 C:\Windows\SysWOW64\usp10.dll 102721db04001 102721db04001</span><br><span class="line">0000000076150000 0008f000 C:\Windows\SysWOW64\oleaut32.dll 600011db04001 600011db04001</span><br><span class="line">0000000075ff0000 0015c000 C:\Windows\SysWOW64\ole32.dll 600011db04001 600011db04001</span><br><span class="line">0000000074fa0000 00012000 C:\Windows\SysWOW64\devobj.dll 600011db04001 600011db04001</span><br><span class="line">0000000074f10000 00060000 C:\Windows\System32\imm32.dll 600011db04001 600011db04001</span><br><span class="line">0000000075020000 000cc000 C:\Windows\SysWOW64\msctf.dll 600011db04001 600011db04001</span><br><span class="line">000000006fa00000 0003e000 C:\Program Files (x86)\Sophos\Sophos Anti-Virus\sophos_detoured.dll 900000000235f 9000000000000</span><br><span class="line">00000000763d0000 00005000 C:\Windows\SysWOW64\psapi.dll 600011db04001 600011db04001</span><br><span class="line"></span><br><span class="line">Crash IP Disasm :</span><br><span class="line">test dword ptr [eax], eax</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dia_study —— PDB查看工具</title>
      <link href="/2013/01/20/dia_study-pdbe69fa5e79c8be5b7a5e585b7/"/>
      <url>/2013/01/20/dia_study-pdbe69fa5e79c8be5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>没事在家翻代码，发现大半年前的一份代码，写的是一个调用DIA SDK查看PDB文件的小工具。仔细想想我觉得还有点用处，而且使用方式简单，所以现在就发到blog上来吧。</p><p>简单介绍一下这个小工具。它可以dump出pdb的函数和数据结构的信息。下面两张图分别dump的是数据结构和函数的信息。</p><p>图一中，命令行为 dia_study.exe -p xxx.pdb -n <em>processor</em> -t 其实 -p是指pdb路径，-n是要获得的符号（支持通配符），-t说明要看的是数据结构而不是函数。然后所有带有processor的数据结构就会dump出来了。</p><p><a href="/uploads/2013/01/20130120165712.png"><img src="/uploads/2013/01/20130120165712.png" alt="20130120165712"></a></p><p>图二中，命令行为 dia_study.exe -p xxx.pdb -n <em>processor</em> -f 唯一的区别就是-t变成了-f。指明要dump的是函数而非数据结构。</p><p><a href="/uploads/2013/01/20130120165737.png"><img src="/uploads/2013/01/20130120165737.png" alt="20130120165737"></a></p><p>ok，使用方式就是如此简单。注意一点，请自备vs2010的c runtime 以及 msdia100.dll（需要注册），否则程序无法运行。</p><p>下载 <a href="/uploads/2013/01/dia_study.zip">dia_study</a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NtfsStudy —— ntfs磁盘格式学习工具</title>
      <link href="/2013/01/19/ntfsstudy-ntfse7a381e79b98e6a0bce5bc8fe5ada6e4b9a0e5b7a5e585b7/"/>
      <url>/2013/01/19/ntfsstudy-ntfse7a381e79b98e6a0bce5bc8fe5ada6e4b9a0e5b7a5e585b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>经过将近一个月业余时间的开发，终于完成了NtfsStudy这个小工具的第一版。</p><p>简单介绍一下这个工具，NtfsStudy这个工具是我在学习Ntfs文件系统磁盘格式的时候，为了自己更加方便快捷的查看磁盘格式而开发的工具。可以说这个工具从开始写到现在发布，实际上也是一个学习ntfs的过程。我一边研究理解这个格式，一边把理解的东西写成代码，加入这个工具，然后再用这些功能去理解新的内容。反复这样做，这个工具就也不知不觉成型了。</p><p>NtfsStudy这个工具的主要功能是：枚举目录文件，查看和dump文件属性。这些功能都没用调用windows 文件操作类的API完成，而是依靠直接读取磁盘信息，并且解析磁盘信息来完成的。例如，如果尝试去复制注册表的系统hive文件，那是一定会被系统拒绝的，这个文件是系统读写独占的，但是通过这个工具就能绕过“ntfsstudy.exe -f c:\ -r e0a2 -w 3 d:\system.hiv”， 这个命令行的意思是把volume C上的引用数为0xe0a2文件中的3号属性的内容写到d:\system.hiv文件中。其实id为3的属性正好就是data属性，也就是文件本身的内容。这样就可以dump不能读的注册表hive文件了。下面是“ntfsstudy.exe -f c:\ -r e0a2 -d 8”的结果：</p><p><a href="/uploads/2013/01/ntfs_hive.png"><img src="/uploads/2013/01/ntfs_hive.png" alt="ntfs_hive"></a></p><p>更多的详细用法和例子等我有空会在blog里面写一些。</p><p>下面就是他的Usage，也是目前该工具具有的功能。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NtfsStudy v1.0 - Ntfs format study tool.</span><br><span class="line">Copyright (C) 2012-2013 nightxie</span><br><span class="line">0CCh - www.0cch.net</span><br><span class="line"></span><br><span class="line">Usage : NtfsStudy.exe [options] -f file_path_name</span><br><span class="line">-f file_path_name Specifies the target file path to parse.</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[-r file_reference]   Specifies the target file reference.</span><br><span class="line">NtfsStudy will parse the REFERENCE rather than the path which</span><br><span class="line">Specifies by -f. NtfsStudy will just use the path root.</span><br><span class="line">[-a] Show the file record information of the target file.</span><br><span class="line">[-l]   List the files in the directory.</span><br><span class="line">[-w attribute_id output_file_path] Write target attribute to a file.</span><br><span class="line">(The attribute size must less than 128mb)</span><br><span class="line">[-v attribute_type] Show detail attribute information specified by attribute_type.</span><br><span class="line">[-d attribute_type [start_offset range]] Show binary information specified by attribute_type.</span><br><span class="line">[-s secure_id] Show the security descriptor specified by secure_id.</span><br><span class="line">[-c] Show the attributes definition columns.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">About attribute type:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$STANDARD_INFORMATION         &#x3D; 1</span><br><span class="line">$ATTRIBUTE_LIST               &#x3D; 2</span><br><span class="line">$FILE_NAME                    &#x3D; 3</span><br><span class="line">$OBJECT_ID                    &#x3D; 4</span><br><span class="line">$SECURITY_DESCRIPTOR          &#x3D; 5</span><br><span class="line">$VOLUME_NAME                  &#x3D; 6</span><br><span class="line">$VOLUME_INFORMATION           &#x3D; 7</span><br><span class="line">$DATA                         &#x3D; 8</span><br><span class="line">$INDEX_ROOT                   &#x3D; 9</span><br><span class="line">$INDEX_ALLOCATION             &#x3D; 10</span><br><span class="line">$BITMAP                       &#x3D; 11</span><br><span class="line">$REPARSE_POINT                &#x3D; 12</span><br><span class="line">$EA_INFORMATION               &#x3D; 13</span><br><span class="line">$EA                           &#x3D; 14</span><br><span class="line">$LOGGED_UTILITY_STREAM        &#x3D; 16</span><br><span class="line"></span><br><span class="line">About secure id:</span><br><span class="line"></span><br><span class="line">To get the secure id of target file.</span><br><span class="line">Use &#39;-v 1&#39; command, secure id will displayed in STANDARD_INFORMATION.</span><br></pre></td></tr></table></figure><p>另外我还会继续完善这个工具。如果发现bug请与我联系。</p><p>下载<a href="/uploads/2013/01/NtfsStudy.zip">NtfsStudy</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设置线程名</title>
      <link href="/2013/01/12/e8aebee7bdaee7babfe7a88be5908d/"/>
      <url>/2013/01/12/e8aebee7bdaee7babfe7a88be5908d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>给线程命名的作用主要还是为了调试方便。其他的好处也没有了，至少我没想出来。这里说一下MS_VC_EXCEPTION这个异常，调试器（vs，windbg）默认情况下应该会在收到这个异常的时候，他会自动处理这个异常，具体操作应该是记录下线程对应的名称，然后将异常设置为Handle状态。什么意思呢？就是说，即使下面这段代码中的RaiseException不在try-except中，在调试器attach的情况下也能顺畅执行，调试器不会因为异常把执行中断下了，而是默默设置了线程名之后继续后面的代码。而下面的代码之所以要放在try-except中，是因为希望没有调试器的情况下，也能顺利执行不被中断。另外一点，windbg可以设置让这个异常中断下来（命令 sxe vcpp），而vs貌似没有这样的方法，可能是我vs调试器用的比较少，没找到吧。对于托管代码，设置这个就更简单了，详见 <a href="http://msdn.microsoft.com/en-us/library/581hfskb(v=vs.100).aspx">http://msdn.microsoft.com/en-us/library/581hfskb(v=vs.100).aspx</a></p><p><a href="/uploads/2013/01/QQ%E6%88%AA%E5%9B%BE20130112151544.png"><img src="/uploads/2013/01/QQ%E6%88%AA%E5%9B%BE20130112151544.png"></a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="keyword">const</span> DWORD MS_VC_EXCEPTION=<span class="number">0x406D1388</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push,8)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTHREADNAME_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD dwType; <span class="comment">// Must be 0x1000.</span></span><br><span class="line">    LPCSTR szName; <span class="comment">// Pointer to name (in user addr space).</span></span><br><span class="line">    DWORD dwThreadID; <span class="comment">// Thread ID (-1=caller thread).</span></span><br><span class="line">    DWORD dwFlags; <span class="comment">// Reserved for future use, must be zero.</span></span><br><span class="line">&#125; THREADNAME_INFO;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetThreadName</span><span class="params">( DWORD dwThreadID, <span class="keyword">char</span>* threadName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    THREADNAME_INFO info;</span><br><span class="line">    info.dwType = <span class="number">0x1000</span>;</span><br><span class="line">    info.szName = threadName;</span><br><span class="line">    info.dwThreadID = dwThreadID;</span><br><span class="line">    info.dwFlags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RaiseException</span>( MS_VC_EXCEPTION, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(info)/<span class="built_in"><span class="keyword">sizeof</span></span>(ULONG_PTR), (ULONG_PTR*)&amp;info; );</span><br><span class="line">    &#125;</span><br><span class="line">    __except(EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R3卸载任意消息钩子</title>
      <link href="/2012/12/26/r3e58db8e8bdbde4bbbbe6848fe6b688e681afe992a9e5ad90/"/>
      <url>/2012/12/26/r3e58db8e8bdbde4bbbbe6848fe6b688e681afe992a9e5ad90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是工作中遇到的一个问题。一个程序每次起来后会去挂鼠标键盘低级钩子，这类钩子恶心的地方是如果你用调试工具attach上去，鼠标键盘就会急剧的延时，就跟挂起差不多了，根本无法使用键盘鼠标。MSDN上面指明，设置LowLevelHooksTimeout可以帮助解决这个问题。但是无奈的是，似乎没起什么作用，渣英语，不知道是不是我的理解有误。</p><p>其他比较好的解决方案也有。比较好的一个就是用远程调试的方式，这种方式可以在hook存在的情况下调试程序，甚至调试hook的函数。另一个办法就是attach之前，卸载低级钩子。对于调试和钩子无关地方的时候，第二个选择也还是不错的。所以，Xuetr的卸载消息钩子的功能派上了用场。每次调试此程序之前，都先卸载钩子。但是还是有问题，我们都有这样的经验，在进行调试的时候经常需要restart程序，并且重新开始调试。这样可就恶心了，每次都要卸载一次钩子。于是，我就写了一个程序，循环查询低级鼠标键盘钩子，发现后立刻卸载，这样调试这个程序就会比较轻松了。</p><p>虽然说用驱动写这个功能看起来比较轻松，实际上R3实现也很简单。这里用到的关键之时是Desktop Heap会在GUI进程中映射到用户态内存上，这也就给了我们可乘之机。简单介绍一些Desktop Heap是什么。我们都知道一个桌面都有个Desktop Object的对象，而实际上美国Desktop Object都会有一个对应他的Desktop Heap。Desktop Heap主要存储用户交互对象（user interface objects），这其中就包括Window，Menu，Hook等等。既然Hook存储在Desktop heap，而且Desktop heap又刚好映射到R3内存，那么我们就可以顺利的读取他了。这里，可能会有一个疑问，怎么知道Hook存储在Desktop Heap，而不是Share Heap或者其他。实际上Windows的Win32k中有一个Handle Information Table，指明了每种Object的存储类型。</p><p>现在是已经知道了可以去读Hook对象，但是上哪去读就是要解决的问题了。这里就要提到老生常谈的Sharedinfo了。用户态的Sharedinfo获取方法很多，顺手就行。与上面问题相关的就是Sharedinfo里面会有一个Handle Entry Table，里面存储的就是包括Hook在内的User Object。Entry的结构如下（来自reactos）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HANDLEENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">PHEAD pHead;</span><br><span class="line">PVOID pOwner;</span><br><span class="line">BYTE bType;</span><br><span class="line">BYTE bFlags;</span><br><span class="line">WORD wUniq;</span><br><span class="line">&#125; HANDLEENTRY, *PHE, *PHANDLEENTRY;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>其中pHead指向Object，bType表示object类型。HOOK的bType是5。所以这里我们只需要在bType为5的时候继续下面的操作。</p><p>pHead肯定是指向的内核内存，所以我们无法直接访问HOOK的内部情况。我们需要找到这个Object映射到R3的内存地址才行。幸运的是这种关系也比较简单明了。在Teb-&gt;Win32ClientInfo.ulClientDelta就存放了对应的关系Delta值。计算方法如下</p><p>ObjectInR3 = HANDLEENTRY.pHead - Teb-&gt;Win32ClientInfo.ulClientDelta。</p><p><a href="/uploads/2012/12/20121226220202.png"><img src="/uploads/2012/12/20121226220202.png" alt="20121226220202"></a></p><p>这样也就得到了HOOK Object。接下来的事情就好办了，HOOK Object的第一项就是HHOOK。只需要UnhookWindowsHookEx((HHOOK)Hook-&gt;head.h);就能卸载钩子了。</p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于整型数符号位扩展的一点心得</title>
      <link href="/2012/11/13/e585b3e4ba8ee695b4e59e8be695b0e7aca6e58fb7e4bd8de689a9e5b195e79a84e4b880e782b9e5bf83e5be97/"/>
      <url>/2012/11/13/e585b3e4ba8ee695b4e59e8be695b0e7aca6e58fb7e4bd8de689a9e5b195e79a84e4b880e782b9e5bf83e5be97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近写的程序中遇到了整型数符号位扩展的小问题。稍稍看了下，写在这里备忘。</p><p>这里举个例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="keyword">long</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> q = i;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="keyword">long</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> q = i;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case 3</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0xffffffff</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> q = i;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case 4</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0xffffffff</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> q = i;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>那么这4肿情况中q都是多少呢？<br>实验结果是case 1 和 2，他们的q的值（这里都表示为无符号）0xffffffff<code>ffffffff，而case 3 和 4 中q的值为0x00000000</code>ffffffff。<br>看到这里，大概就能推测c++的转换策略。即以源操作数的类型为依据，对其进行扩展，然后赋值到目标操作数，他并不在乎目标的类型有无符号。</p><p>看了相关编译完成后的汇编代码可以确认这一点，case 1和2的汇编代码完全相同，而3和4也是一样。更具体一点来说。有符号的情况下调用了cdq对符号位进行扩展，然后将edx赋值到q的高位，而无符号的情况下，简单xor了寄存器，然后赋值到q的高位。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dbgLua，让lua脚本也能控制windbg进行调试(更新1.0.1.1)</title>
      <link href="/2012/08/15/dbgluaefbc8ce8aea9luae8849ae69cace4b99fe883bde68ea7e588b6windbge8bf9be8a18ce8b083e8af95/"/>
      <url>/2012/08/15/dbgluaefbc8ce8aea9luae8849ae69cace4b99fe883bde68ea7e588b6windbge8bf9be8a18ce8b083e8af95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>关于dbgLua：<br>这是一个让windbg支持lua脚步的扩展程序。写这个程序的主要目的是希望能简单的取代windbg本身的脚本。因为我确实不喜欢windbg那种形式的脚本。</p><p>使用方法：将dbgLua.dll拷贝到windbg的winext下，编写lua脚本。调试的时候，在输入框中输入“!dbgLua.run d:\sample.lua”其中“d:\sample.lua”是你的脚步路径。</p><p>以下是1.0.0.1版本所支持的lua函数（后续可能会慢慢添加更多，看需求了）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbgLua 1.0.1.1 API</span><br><span class="line"></span><br><span class="line">dprint 输出信息到windbg command窗口，例如dprint(&quot;hello&quot;)</span><br><span class="line">exec 执行一条windbg命令，例如exec(&quot;bp kernel32!CreateFileW&quot;)</span><br><span class="line">getreg 获得当前被调试对象的寄存器数据，例如eax_val &#x3D; getreg(&quot;eax&quot;)</span><br><span class="line">setreg 设置当前被调试对象的寄存器数据，例如setreg(&quot;eax&quot;, 123456)</span><br><span class="line">readbyte 读取当前被调试对象的内存器数据，大小1字节</span><br><span class="line">readword 同上，大小为2字节</span><br><span class="line">readdword 同上，大小为4字节，例如mem_val &#x3D; readxxxx(0x410000)</span><br><span class="line">writebyte 写入当前被调试对象的内存器数据，大小1自己</span><br><span class="line">writeword 同上，大小为2字节</span><br><span class="line">writedword 同上，大小为4字节，例如writexxxx(0x410000, 654321)</span><br><span class="line">readunicode 读取一个unicode字符串，例如str &#x3D; readunicode(0x410000)</span><br><span class="line">readascii 读取一个ascii字符串，例如str &#x3D; readascii(0x410000)</span><br><span class="line">wait 等待事件，例如exec(&quot;bp kernel32!CreateFileW;g&quot;);wait();</span><br><span class="line">evalmasm masm表达式求值，例如val &#x3D; evalmasm(&quot;11+2*3&quot;)</span><br><span class="line">evalcpp cpp表达式求值，例如val &#x3D; evalcpp(&quot;sizeof(char)&quot;)</span><br><span class="line">getmoduleinfo 通过模块名获得模块基址和大学，例如base,size &#x3D; getmoduleinfo(&quot;kernel32&quot;)</span><br><span class="line">search 二进制查找，例如found &#x3D; search(base, size, &quot;cc 89 75 fc eb &quot;)&lt;&#x2F;blockquote&gt;</span><br></pre></td></tr></table></figure><p>具体的结合这些函数进行调试的例子还没有准备好，等有机会了，我会准备好调试案例放到这里来。</p><p>另外这是一个初始版本，不保证没有bug，如果你在使用中发现了bug，或者有好的想法，例如添加什么函数功能，不妨联系我。</p><p>下载：</p><p><a href="/uploads/2012/08/dbgLua1.zip">dbgLua</a>(v1.0.1.1)</p><p><a href="/uploads/2012/08/dbgLua.zip">dbgLua</a>(v1.0.0.1)</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于判断文件是否存在最高效的函数</title>
      <link href="/2012/08/01/e585b3e4ba8ee588a4e696ade69687e4bbb6e698afe590a6e5ad98e59ca8e69c80e9ab98e69588e79a84e587bde695b0/"/>
      <url>/2012/08/01/e585b3e4ba8ee588a4e696ade69687e4bbb6e698afe590a6e5ad98e59ca8e69c80e9ab98e69588e79a84e587bde695b0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>判断文件存在方法有很多，例如CreateFile，FindFirstFile，GetFileAttributes，PathFileExists等等。但是哪一种更加高效呢？其实作为常识，可能都能判断出GetFileAttributes和PathFileExists会比较快（而实际上PathFileExists就是调用的GetFileAttributes）。</p><p>下面是google一份开源代码中提到的统计结果</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This is the fastest implementation I found. The results were:</span></span><br><span class="line"><span class="comment">// CreateFile 1783739 avg ticks/call</span></span><br><span class="line"><span class="comment">// FindFirstFile 634148 avg ticks/call</span></span><br><span class="line"><span class="comment">// GetFileAttributes 428714 avg ticks/call</span></span><br><span class="line"><span class="comment">// GetFileAttributesEx 396324 avg ticks/call&lt;/blockquote&gt;</span></span><br></pre></td></tr></table></figure><p>为什么会这样呢？大概了看了下，原因应该是这样的。</p><p>1.CreateFile会创建句柄，需要一个完整IO流程，所以需要的时间比如非常长。<br>2.FindFirstFile回去查询文件夹的文件，虽然不会真正的打开文件句柄，并且在文件已经被缓存的情况下，走的是fastio流程，所以查询时间大幅下降，但是操作略微繁琐，导致他不是最好的选择。<br>3. GetFileAttributes 和GetFileAttributesEx 也设置了QueryOnly标志，不需要获得真正的句柄，并且能够走fastio流程，也没有文件夹查询等工作，所以速度最快。  </p><p>那么为什么GetFileAttributesEx 会快那么一点点呢？因为这个函数少了一个获取BasicInformation，也就是少了一个fastio流程。所以速度更快。这样看来，自己实现一个PathFileExistsEx效率可以高过PathFileExists了。（其实没多大实际意义）</p><p>google就是这样做的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">File::Exists</span><span class="params">(<span class="keyword">const</span> TCHAR* file_name)</span> </span>&#123;</span><br><span class="line"><span class="built_in">ASSERT1</span>(file_name &amp;&amp; *file_name);</span><br><span class="line"><span class="built_in">ASSERT1</span>(<span class="built_in">lstrlen</span>(file_name) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This is the fastest implementation I found. The results were:</span></span><br><span class="line"><span class="comment">// CreateFile 1783739 avg ticks/call</span></span><br><span class="line"><span class="comment">// FindFirstFile 634148 avg ticks/call</span></span><br><span class="line"><span class="comment">// GetFileAttributes 428714 avg ticks/call</span></span><br><span class="line"><span class="comment">// GetFileAttributesEx 396324 avg ticks/call</span></span><br><span class="line">WIN32_FILE_ATTRIBUTE_DATA attrs = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> != ::<span class="built_in">GetFileAttributesEx</span>(file_name, ::GetFileExInfoStandard, &amp;attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PIO读IDE</title>
      <link href="/2012/02/12/pioe8afbbide/"/>
      <url>/2012/02/12/pioe8afbbide/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="/uploads/2012/02/read.jpg"><img src="/uploads/2012/02/read.jpg"></a></p><p>经过各种代码的东拼西凑、改来改去，总算是把PIO读取硬盘信息的代码“写”好了，上图是读取硬盘的前512字节的效果图。目前看来还是很挫，原因有两点：</p><p>1.只支持LBA48的读取方法，不支持CHS，LBA28，虽然这两个方法的读取范围很有限，但是感觉至少要把LBA28给支持了才行。<br>2.很郁闷的一点，这个读取代码读取成功了，但是IO后返回的状态值是错误的。不知道哪里出了问题，会不会是虚拟硬盘太小而不能用LBA48的问题呢？没有头绪。  </p><hr><p>补充1.通过IDENTIFY DEVICE命令发现，可能由于设置的虚拟硬盘比较小的原因，虚拟硬盘不支持48bit的地址。IDENTIFY DEVICE会通过PIO方式返回一个256字（512字节）的数据。其中第83个字的第10位表示是否支持48bit的地址。如下图（来自ATA官方手册AT Attachment with Packet Interface - 6）。<br><a href="/uploads/2012/02/48bitaddress.jpg"><img src="/uploads/2012/02/48bitaddress.jpg"></a><br>补充2.由于不支持LBA48，我还是实现了LBA28。不过这个只能访问128G的硬盘了。至于CHS目前还是不考虑实现。<br>补充3.PIO写的方式大概也是差不多的。准备慢慢实现，还有DMA读写硬盘也需要了解下。不过好消息是现在基本能看懂ATA的手册了。<br>补充4.MiniKernel的代码依然写得很挫，暂时不准备共享出来，因为共享出来也没啥用，想学写系统的也看不懂那种烂代码。<br>补充5.感觉读写硬盘是一个挺有意思地方，完全可以单独拿出来写一个系列的blog。只是有没有时间和懒不懒的问题。<br>补充6.补充5的最后一句是P话，时间肯定是有的，就是懒而已。。。  </p><p>一个月一篇文章。。。多一点都没有。。。我果然是个需要被监督的人。。。  </p>]]></content>
      
      
      <categories>
          
          <category> MiniKernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel </tag>
            
            <tag> IDE </tag>
            
            <tag> MiniKernel </tag>
            
            <tag> OS </tag>
            
            <tag> PIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结2011，展望2012</title>
      <link href="/2011/12/31/e680bbe7bb932011efbc8ce5b195e69c9b2012/"/>
      <url>/2011/12/31/e680bbe7bb932011efbc8ce5b195e69c9b2012/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>2011还是过去了，2012来了。觉得有点必要写点东西，总结一下过去，展望一下未来。如果要用几个词来总结我的2011，那应该是天真，失望，浮躁。可以说我对我的2011是比较不满意的。</p><p>天真，我自认为自己还算是个性情中人，所以很多事情对我来说就是讲得就是个胃口。我是很愿意把结识的人当作朋友处。但是，在工作中，有些“朋友”确实是建立在利益基础上的。如果把所有说过“我们是朋友”的人当作朋友，很有可能吃亏是自己。工作也是一样，代入太多感情色彩也是很天真的一种做法。为了讲胃口，有时候退一步，多干一些活。做的好当然没事，但是做的不尽如人意有时候给你带来的真的会是麻烦。</p><p>失望，在去年对一些人失望了，对工作的事情也失望，对自己也挺失望的。有些事情自己也不想拿出来说，也不想以后看到在想起，能快点忘记就忘记。但是对自己失望需要深刻的自我剖析检讨了。技术上提高真的不大，基本上都看不出自己做成了什么厉害的事情，决定的事情大部分没有坚持下来，空余的时间大部分花在娱乐上。</p><p>浮躁，一整年，都是浮躁的。买的书一本一本的增多，耐心看完的，甚至说看了一大半的都没几本。想学习的东西很多很多，但是没有一个耐心去学习的。给自己开的代码项目很多，也没见过几个写成的。做事情的思路大概是这样的：哎哟，这个东西挺好玩，去实现一个呗；恩，找点资料吧；我靠，资料不是很多嘛；晕，环境怎么这么难搭建；耐心点，慢慢来；好，环境搭建好了，可以开始了；哎，细节问题好多啊，一个人写这个真的大丈夫么；妈的，确实很难写，比想的难好多啊；不行了，弄不下去了；哎哟，弄这个意义大么；意义不是很多大吧，哎，还是弄点别的吧……</p><p>所以我觉得，我的2011基本上就是失败的。但是，我的字典里面没有后悔，因为后悔不能改变任何事情。而且不也不会激励自己明年一定要怎么样。因为貌似这种自我暗示已经被我免疫了。当然如果从过得怎么样的角度来看，我的2011还是相当精彩和快乐的。只不过说，这个人有点贱，快乐的事情总是记不住。</p><p>虽然说我现在已经不喜欢那些所谓的立志大湿，但是还是应该给自己一个2012的展望。怎么说呢？继续浮躁吧，想做的事情很多很多。</p><p>1.写完自己的mini kernel。</p><p>2.看完几本书，包括：nt 文件系统的后半部分，编译原理，算法导论。说实话，我还是感觉自己能看完其中两本就算不错了。</p><p>3.完善自己的BaseLib，加上自己实现各种算法。</p><p>4.实现一个简单的脚本语言。</p><p>5.最后多看两眼wrk吧。</p><p>看吧，我真的很浮躁很浮躁，如果明年的这个时候的总结（当然，前提是别2012-12-21就结束了），其中有三条圆满完成，我就觉得很奇迹了。</p><p>最后，无论怎么说，2011已经过去，过去的事情无论好坏都过去了。期待2012自己的改变吧。祝福我的家人，朋友和我自己，新年快乐，健康平安，家庭和睦温馨。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我本来不想写kernel，直到我的膝盖中了一箭</title>
      <link href="/2011/12/11/e68891e69cace69da5e4b88de683b3e58699kernelefbc8ce79bb4e588b0e68891e79a84e8869de79b96e4b8ade4ba86e4b880e7aead/"/>
      <url>/2011/12/11/e68891e69cace69da5e4b88de683b3e58699kernelefbc8ce79bb4e588b0e68891e79a84e8869de79b96e4b8ade4ba86e4b880e7aead/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近中箭体很火，我也凑个热闹。话说自从delete那篇文章过后，又有一个多月没写了。其实不是不想写，是不知道些什么才好。简单的东西不想写，难的东西写不出来。</p><p>正像标题写的，恩，我开始写kernel玩了。其实写一个简单，功能单一的kernel并不难。麻烦的只是搭建环境等等。kernel的编写资料也很多，但是可惜的是，绝大部分都是应用在linux环境。我是那种看到linux就头晕的人。所以还是坚持用windows和vc来开发kernel。令人惊喜的是grub能够帮助我们map kernel到内存中，所以boot loader这一步可以想放下。等kernel写了个大概再来写boot loader也不迟。</p><p>环境和工具：<br>环境正如我上面提到了windows xp 和 vs 2008。其他工具包括winimage，virtual pc，bochsdbg（+ IDA）。当然还有grub4dos。</p><p>要高效的起步，先要了解mulitBoot的一些知识。还有就是写一套能够在text mode下打印信息的函数，例如printf。这样在不用调试的情况下，就能了解一些信息。说实在的bochsdbg的调试功能真心不好用，但是加上IDA可能是一个比较好的做法。具备以上条件后，就可以开始kernel之旅了。</p><p><a href="/uploads/2011/12/20111211174748.png"><img src="/uploads/2011/12/20111211174748.png"></a></p><p>可以看出内存的基本状况已经可以从boot_info中获取了。接下来要做的事情也很明了。就是需要一个物理内存管理器，实现最基本的物理内存管理器也不算难，不过那就是下篇文章的事情了。现在的kernel大小为7168字节，慢慢玩，看我能坚持多久。</p>]]></content>
      
      
      <categories>
          
          <category> MiniKernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel </tag>
            
            <tag> Windows </tag>
            
            <tag> grub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么必须用delete[]释放数组</title>
      <link href="/2011/10/31/e4b8bae4bb80e4b988e5bf85e9a1bbe794a8deletee9878ae694bee695b0e7bb84/"/>
      <url>/2011/10/31/e4b8bae4bb80e4b988e5bf85e9a1bbe794a8deletee9878ae694bee695b0e7bb84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近不知哪来的好奇心，对C++产生了一些兴趣，要知道我通常情况下都是cpp文件中写c代码，c代码中嵌汇编。不过，在做了一些大点的项目之后，确确实实发现了，这种编码方式麻烦的一面。有时候甚至自己都难得维护以前写的东西。所以选择性看了google的c++编程规范，而且对scoped_ptr和auto_ptr的区别参数兴趣。然后我得出的结论是这两种实际上是其实差不多，只不过scoped_ptr拷贝构造函数和赋值构造函数都是私有的。这样就避免粗心大意的程序员调用他。其他的区别还真没看出来。</p><p>OK，这些都不是记录这篇tip的重点。重点在于boost，或者说是google的scoped_ptr代码里面实现了scoped_array。而要用在数组上使用智能指针，就必须用数组的智能指针类。而auto_ptr刚好没有数组部分，所以对于数组，就不能用auto_ptr了。（为什么不用vector？这也不是重点）</p><p>作为一个蹩脚的C++程序员，我这时候开始犯晕了。我们知道只能指针都是帮助程序员去释放资源，让程序员把精力放到更重要的地方。那么在我看来那么所需要做的就是析构的时候 delete 或者 delete[] 就行了。要知道，delete[] 就是调用的delete，他们只是单纯的释放内存。那么数组和非数组又有什么区别？</p><p>光想肯定不行，写两个例子。</p><p>首先是new 一个char数组，分别用delete和delete[]释放。结果表明，没有任何问题，而且不会产生内存泄露。坑爹么？NO，还没完，其实咱们最怀疑的一直都是数组对象，因为他们都有构造和析构函数。而char这样的系统内建类型，想象得出不会出什么问题。new一个对象数组，分别用delete和delete[] 释放。果然问题暴露了，delete的时候出了问题。</p><p>知其然，不足以满足好奇心。下面才是拿手的，精彩的要放在后面嘛。</p><p>先看测试代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123;cout &lt;&lt; <span class="string">&quot;start 1&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123;cout &lt;&lt; <span class="string">&quot;End 1&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A *a = <span class="keyword">new</span> A[<span class="number">10</span>]();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>编译后看到代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0040103D push 0Eh</span><br><span class="line">0040103F call operator new[] (403ED0h)</span><br></pre></td></tr></table></figure>  <p>注意到这里传入的大小时0Eh，也就是说申请分配14个字节大小的内存。但是我们知道C++标准中空类的大小应该是1字节。那么多出的dword我们就很容易想到他的用处，应该是记录数组大小的。事实也确实如此。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dword ptr [eax],0Ah</span><br></pre></td></tr></table></figure>  <p>这里明确交代，给分配内存的第一个dword传入10。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00401069 push offset A::~A (4011D0h)</span><br><span class="line">0040106E push offset A::A (401120h)</span><br><span class="line">00401073 push 0Ah</span><br><span class="line">00401075 push 1</span><br><span class="line">00401077 mov ecx,dword ptr [ebp-0F8h]</span><br><span class="line">0040107D add ecx,4</span><br><span class="line">00401080 push ecx</span><br><span class="line">00401081 call &#96;eh vector constructor iterator&#39; (40A010h)</span><br></pre></td></tr></table></figure>  <p>这里是调用构造函数，注意是vector版本的构造函数。参数分别是数组的this指针，sizeof(A)，数组数量，构造和析构函数。这样，在这个函数内部循环10次调用构造函数，构造完毕。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">004010BD mov eax,dword ptr [ebp-14h]</span><br><span class="line">004010C0 mov dword ptr [ebp-0E0h],eax</span><br><span class="line">004010C6 mov ecx,dword ptr [ebp-0E0h]</span><br><span class="line">004010CC mov dword ptr [ebp-0ECh],ecx</span><br><span class="line">004010D2 cmp dword ptr [ebp-0ECh],0</span><br><span class="line">004010D9 je main+0F0h (4010F0h)</span><br><span class="line">004010DB push 3</span><br><span class="line">004010DD mov ecx,dword ptr [ebp-0ECh]</span><br><span class="line">004010E3 call A::&#96;vector deleting destructor&#39; (401230h)</span><br></pre></td></tr></table></figure>  <p>这里是析构部分传入数组的this指针，传入flag(3)，调用析构函数。</p><p>继续看call之后的代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00401253 mov eax,dword ptr [ebp+8]</span><br><span class="line">00401256 and eax,2</span><br><span class="line">00401259 je A::&#96;vector deleting destructor&#39;+61h (401291h)</span><br><span class="line">0040125B push offset A::~A (4011D0h)</span><br><span class="line">00401260 mov eax,dword ptr [this]</span><br><span class="line">00401263 mov ecx,dword ptr [eax-4]</span><br><span class="line">00401266 push ecx</span><br><span class="line">00401267 push 1</span><br><span class="line">00401269 mov edx,dword ptr [this]</span><br><span class="line">0040126C push edx</span><br><span class="line">0040126D call &#96;eh vector destructor iterator&#39; (40A920h)</span><br><span class="line">00401272 mov eax,dword ptr [ebp+8]</span><br></pre></td></tr></table></figure><p>如果flag中位1是set，那么调用eh_vector_destructor_iterator调用每个析构函数。参数分别是this，sizeof(A)，数组个数（这里很明显是从eax-4中拿出来的）以及析构函数地址。</p><p>OK，明白了delete[]的做法，我们看看delete为什么失败。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">004010BD mov eax,dword ptr [ebp-14h]</span><br><span class="line">004010C0 mov dword ptr [ebp-0E0h],eax</span><br><span class="line">004010C6 mov ecx,dword ptr [ebp-0E0h]</span><br><span class="line">004010CC mov dword ptr [ebp-0ECh],ecx</span><br><span class="line">004010D2 cmp dword ptr [ebp-0ECh],0</span><br><span class="line">004010D9 je main+0F0h (4010F0h)</span><br><span class="line">004010DB push 1</span><br><span class="line">004010DD mov ecx,dword ptr [ebp-0ECh]</span><br><span class="line">004010E3 call A::&#96;scalar deleting destructor&#39; (4012D0h)</span><br></pre></td></tr></table></figure><p>这里调用的析构函数都不一样是一个scalar版本的函数。</p><p>继续看这个函数的关键部分</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">004012F3 mov ecx,dword ptr [this]</span><br><span class="line">004012F6 call A::~A (4011D0h)</span><br><span class="line">004012FB mov eax,dword ptr [ebp+8]</span><br><span class="line">004012FE and eax,1</span><br><span class="line">00401301 je A::&#96;scalar deleting destructor&#39;+3Fh (40130Fh)</span><br><span class="line">00401303 mov eax,dword ptr [this]</span><br><span class="line">00401306 push eax</span><br><span class="line">00401307 call operator delete (40A890h)</span><br></pre></td></tr></table></figure><p>这里很清楚的看到，只进行一次析构，然后就释放内存。所以我们看到的现象是只调用一次析构函数。那么为什么会崩溃呢？因为delete错了地址。看上面的对比的值，eax-4才是new返回的地址，所以delete的不应该是eax，而是eax-4。</p><p>真相大白？NO，还有一个问题，delete[] 和delete 内建类型真的成功了么？<br>看看我贴出的代码吧，这里不解释了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;delete[] version</span><br><span class="line">0040101E push 0Ah</span><br><span class="line">00401020 call operator new[] (4014C0h)</span><br><span class="line">00401025 add esp,4</span><br><span class="line">00401028 mov dword ptr [ebp-0E0h],eax</span><br><span class="line">0040102E mov eax,dword ptr [ebp-0E0h]</span><br><span class="line">00401034 mov dword ptr [a],eax</span><br><span class="line">00401037 mov eax,dword ptr [a]</span><br><span class="line">0040103A mov dword ptr [ebp-0D4h],eax</span><br><span class="line">00401040 mov ecx,dword ptr [ebp-0D4h]</span><br><span class="line">00401046 push ecx</span><br><span class="line">00401047 call operator delete[] (401600h) &#96;</span><br><span class="line"></span><br><span class="line">;delete version</span><br><span class="line">0040101E push 0Ah</span><br><span class="line">00401020 call operator new[] (4014C0h)</span><br><span class="line">00401025 add esp,4</span><br><span class="line">00401028 mov dword ptr [ebp-0E0h],eax</span><br><span class="line">0040102E mov eax,dword ptr [ebp-0E0h]</span><br><span class="line">00401034 mov dword ptr [a],eax</span><br><span class="line">00401037 mov eax,dword ptr [a]</span><br><span class="line">0040103A mov dword ptr [ebp-0D4h],eax</span><br><span class="line">00401040 mov ecx,dword ptr [ebp-0D4h]</span><br><span class="line">00401046 push ecx</span><br><span class="line">00401047 call operator delete (401600h)</span><br></pre></td></tr></table></figure><p>就像我刚刚所说的delete[]会调用delete。所以不会出任何问题。</p><p>如果汇编看的头疼的话，这里我写了两个函数的逆向代码（说了精彩的应该放在后面的）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">void A::&#x27;scalar deleting destructor&#x27;(unsigned int flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;~<span class="built_in">A</span>();</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="function">A::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void A::&#x27;vector deleting destructor&#x27;(unsigned int flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; <span class="number">2</span>) &#123;</span><br><span class="line">        count = *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)<span class="keyword">this</span> - <span class="number">4</span>);</span><br><span class="line">        &#x27;eh vector destructor iterator&#x27;(this, sizeof(A), count, A::~A);</span><br><span class="line">        <span class="keyword">if</span> (flags&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">A::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">((<span class="keyword">void</span> *)((<span class="keyword">int</span>)<span class="keyword">this</span> - <span class="number">4</span>))</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;~<span class="built_in">A</span>();</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">A::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>分析到这，终于明白。数组一定要用delete[]释放才安全。所以千万不要用auto_ptr作为数组的智能指针，不然会死的很惨。这里还要提一点，auto_ptr也不要用到容器里面去了，也是不允许的。非要这么做就用shared_ptr吧， C++0x已经在stl中加入的这部分。从vs2008 sp1开始支持。低版本的vs的话就去boost里面找吧。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Volume snapshot</title>
      <link href="/2011/10/30/volume-snapshot/"/>
      <url>/2011/10/30/volume-snapshot/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上个月说了，准备放一份基于卷磁盘快照代码。拖到现在也没有更新了，就把它放出来，留着也没啥用。本来就是为了做一个演示demo，没考虑效率和稳定性，只是提供一种思路，其实思路也很简单，有人已经把他完善的很好了。感觉博客更新确实慢，但是也没什么想写的，其实也写不出来什么。悲剧啊！</p><p>和我其他代码一样，这么代码同样没有注释。需要的讲究读读吧。那啥，最近昨天把google的代码规范看了看，确实有很多值得学习的地方。不过呢，有些地方可能个性使然，不太认同。不过风格的问题，其实也没什么。</p><p>最近还写了hive文件读解析的代码，还没完善，然后又转去看系统缓存那部分的东西了。有时间完善完善。还要完善了是自己写的一个ini文件解析的类。哎，都是一些自己造轮子的活。不过还挺有意思。</p><p>下载：<a href="/uploads/2011/10/SectorMon.zip">SectorMon</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> snapshot </tag>
            
            <tag> Volume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTSTATUS Lookup</title>
      <link href="/2011/09/17/ntstatus-lookup/"/>
      <url>/2011/09/17/ntstatus-lookup/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>磁盘快照写好了后，闲着无聊写了个nslookup，用来看驱动返回值解释的。写这个程序还先写了个nsstatus.h的解析工具。生成了一个超大的switch case。没啥技术含量。至于那个磁盘快照的代码，过段时间如果合适也可以共享出来。</p><p><a href="/uploads/2011/09/ntstatus.jpg"><img src="/uploads/2011/09/ntstatus.jpg"></a></p><p>1.0.0.2 更新：</p><p>1.增加程序初始化时，直接读取剪切板中的数据功能。<br>2.增加对输入的判断，支持“0x”前缀。</p><p>下载：<a href="/uploads/2011/09/nslookup1002.zip">nslookup</a></p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NTSTATUS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一份简陋的NTFS Parse代码</title>
      <link href="/2011/08/28/e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081/"/>
      <url>/2011/08/28/e4b880e4bbbde7ae80e9998be79a84ntfs-parsee4bba3e7a081/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>研究了近两周的NTFS文件格式，初步了解了一些NTFS基本属性的解析方法。<br>为了自己研究方便，写了点简单的解析代码。发出来以方便需要的人。<br>话说这份代码的解析类只是属于demo阶段，而且没有注释。不过代码写的还算清晰。  </p><p>参考资料方面，我是转了一份NTFS 3G的文档，这份文档把NTFS的基本特点写的比较清晰了。值得一看</p><p><a href="http://0cch.net/ntfsdoc/">http://0cch.net/ntfsdoc/</a></p><p>代码：<a href="/uploads/2011/08/NtfsParse.zip">NtfsParse</a></p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NTFS </tag>
            
            <tag> Kernel </tag>
            
            <tag> System </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactOS-Freeldr磁盘及文件管理2</title>
      <link href="/2011/06/10/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862/"/>
      <url>/2011/06/10/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e790862/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ArcOpen的大体流程我们看过了。大致分为这几步</p><ol><li><p>函数会尝试找到文件所在分区的设备句柄，如果还没有对应的句柄。那么使用DEVICE.FuncTable中的Open函数打开设备，并为这个设备分配句柄。</p></li><li><p>打开设备后条用XxxMount识别分区格式，识别成功返回另外的FuncTable，存储到设备的FileData.FileFuncTable域。</p></li><li><p>为文件分配一个句柄，在对应的FileData.DeviceId为上面创建设备句柄，FileData.FuncTable为设备的FileData.FileFuncTable。</p></li><li><p>最后调用文件的FileData.FuncTable.Open函数打开文件。</p></li></ol><p><strong>挂载分区时做了什么</strong></p><p>之前我们忽略了XxxMount函数。现在来读读比较简单的FatMount (freeldr\freeldr\fs\fat.c)。</p><ol><li><em>const</em> DEVVTBL***** FatMount**(<strong>ULONG DeviceId</strong>)**</li><li><strong>{</strong></li><li><strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.****.</strong></li><li>// 生成一个FAT_VOLUME_INFO结构</li><li>Volume <strong>=</strong> MmHeapAlloc**(<strong><em>sizeof</em></strong>(<strong>FAT_VOLUME_INFO</strong>)<strong><strong>)</strong></strong>;**</li><li><em>if</em> <strong>(****!<strong>Volume</strong>)</strong></li><li><em>return</em> <em>NULL</em><strong>;</strong></li><li><em>RtlZeroMemory</em><strong>(<strong>Volume, <em>sizeof</em></strong>(<strong>FAT_VOLUME_INFO</strong>)<strong><strong>)</strong></strong>;</strong></li><li>// 读第一个扇区</li><li>Position**.<strong>HighPart <strong>=</strong> 0</strong>;**</li><li>Position**.<strong>LowPart <strong>=</strong> 0</strong>;**</li><li>ret <strong>=</strong> ArcSeek**(*<em>DeviceId, <strong>&amp;<strong>Position, SeekAbsolute</strong>)</strong>*</em>;**</li><li><em>if</em> <strong>(<strong>ret <strong>!****=</strong> ESUCCESS</strong>)</strong></li><li><strong>{</strong></li><li>MmHeapFree**(<strong>Volume</strong>)****;**</li><li><em>return</em> <em>NULL</em><strong>;</strong></li><li><strong>}</strong></li><li>ret <strong>=</strong> ArcRead**(<strong>DeviceId, Buffer, <em>sizeof</em></strong>(<strong>Buffer</strong>)**, <strong>&amp;<strong>Count</strong>)****;</strong></li><li><em>if</em> <strong>(<strong>ret <strong>!****=</strong> ESUCCESS <strong>|****|</strong> Count <strong>!****=</strong> <em>sizeof</em></strong>(<strong>Buffer</strong>)****)</strong></li><li><strong>{</strong></li><li>MmHeapFree**(<strong>Volume</strong>)****;**</li><li><em>return</em> <em>NULL</em><strong>;</strong></li><li><strong>}</strong></li><li>// 判断是否有fat分区标志</li><li><em>if</em> <strong>(<strong><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector</strong>-</strong></strong>&gt;<strong>FileSystemType, “FAT12 “, 8</strong>)</strong> <strong>&amp;****&amp;</strong></li><li><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector</strong>-****&gt;<strong>FileSystemType, “FAT16 “, 8</strong>)</strong> <strong>&amp;****&amp;</strong></li><li><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSector32</strong>-****&gt;<strong>FileSystemType, “FAT32 “, 8</strong>)</strong> <strong>&amp;****&amp;</strong></li><li><strong>!<strong>RtlEqualMemory</strong>(<strong>BootSectorX</strong>-<strong><strong>&gt;<strong>FileSystemType, “FATX”, 4</strong>)</strong></strong>)</strong></li><li><strong>{</strong></li><li>MmHeapFree**(<strong>Volume</strong>)****;**</li><li><em>return</em> <em>NULL</em><strong>;</strong></li><li><strong>}</strong></li><li>// 获得分区大小等信息</li><li>ret <strong>=</strong> ArcGetFileInformation**(*<em>DeviceId, <strong>&amp;<strong>FileInformation</strong>)</strong>*</em>;**</li><li><em>if</em> <strong>(<strong>ret <strong>!****=</strong> ESUCCESS</strong>)</strong></li><li><strong>{</strong></li><li>MmHeapFree**(<strong>Volume</strong>)****;**</li><li><em>return</em> <em>NULL</em><strong>;</strong></li><li><strong>}</strong></li><li>SectorCount**.<strong>HighPart <strong>=</strong> FileInformation</strong>.<strong>EndingAddress</strong>.<strong>HighPart</strong>;**</li><li>SectorCount**.<strong>LowPart <strong>=</strong> FileInformation</strong>.<strong>EndingAddress</strong>.<strong>LowPart</strong>;**</li><li>SectorCount**.<strong>QuadPart <strong>/****=</strong> SECTOR_SIZE</strong>;**</li><li>Volume**-****&gt;<strong>DeviceId <strong>=</strong> DeviceId</strong>;**</li><li>// 打开分区</li><li><em>if</em> <strong>(<strong><strong>!<strong>FatOpenVolume</strong>(<strong>Volume, BootSector, SectorCount</strong>.<strong>QuadPart</strong>)</strong></strong>)</strong></li><li><strong>{</strong></li><li>MmHeapFree**(<strong>Volume</strong>)****;**</li><li><em>return</em> <em>NULL</em><strong>;</strong></li><li><strong>}</strong></li><li>// 存储FAT_VOLUME_INFO结构</li><li>FatVolumes**[<strong>DeviceId</strong>]** <strong>=</strong> Volume**;**</li><li>// 返回fat文件读写的FuncTable</li><li><em>return</em> <strong>&amp;<strong>FatFuncTable</strong>;</strong></li><li><strong>}</strong></li><li>**           </li></ol><p>**</p><p>函数中的DeviceId是设备的句柄。</p><p>生成FAT_VOLUME_INFO结构。这个结构里面存储了FAT分区的基本信息。包括扇区大小，每个簇的扇区数等等。</p><ol><li><em>typedef</em> <em>struct</em> _FAT_VOLUME_INFO </li><li><strong>{</strong></li><li>ULONG BytesPerSector**;** /* Number of bytes per sector */</li><li>ULONG SectorsPerCluster**;** /* Number of sectors per cluster */</li><li>ULONG FatSectorStart**;** /* Starting sector of 1st FAT table */</li><li>ULONG ActiveFatSectorStart**;** /* Starting sector of active FAT table */</li><li>ULONG NumberOfFats**;** /* Number of FAT tables */</li><li>ULONG SectorsPerFat**;** /* Sectors per FAT table */</li><li>ULONG RootDirSectorStart**;** /* Starting sector of the root directory (non-fat32) */</li><li>ULONG RootDirSectors**;** /* Number of sectors of the root directory (non-fat32) */</li><li>ULONG RootDirStartCluster**;** /* Starting cluster number of the root directory (fat32 only) */</li><li>ULONG DataSectorStart**;** /* Starting sector of the data area */</li><li>ULONG FatType**;** /* FAT12, FAT16, FAT32, FATX16 or FATX32 */</li><li>ULONG DeviceId**;**</li><li><strong>}</strong> FAT_VOLUME_INFO**;**</li><li>**             </li></ol><p>**</p><p>  读取第一个山区，判断是否有fat标志。如果没有直接返回，挂载失败。之后使用ArcGetFileInformation获得分区大小。ArcGetFileInformation里面调用了FileData.FuncTable.GetFileInformation。因为当前DeviceId是设备句柄，所以他实际调用的是DiskGetFileInformation(freeldr\freeldr\arch\i386\hardware.c)。这个函数很简单，通过FileInformation返回分区开始和结束的地址，这里就不列出了。     </p><p>这里的代码用FileInformation**.**EndingAddress / SECTOR_SIZE计算出了该分区的扇区数SectorCount。这里应该BUG。因为EndingAddress是分区结束地址，真的扇区数应该是 (分区开始地址 - EndingAddress ) / SECTOR_SIZE。好在SectorCount只是判断fat分区的一个依据，而且一般C盘计算出的SectorCount误差不会很大，影响不大。</p><p>最后执行FatOpenVolume真正执行分区的挂载、初始化。初始化结束后将生成的Volume放到fat.c维护的全局数组FatVolumes里，之后对fat分区进行操作（读写）时，通过设备的DeviceId就可以找到对应的FAT_VOLUME_INFO结构。</p><p>最后函数返回FatFuncTable函数数组</p><ol><li><em>const</em> DEVVTBL FatFuncTable <strong>=</strong></li><li><strong>{</strong></li><li>FatClose, </li><li>FatGetFileInformation, </li><li>FatOpen, </li><li>FatRead, </li><li>FatSeek, </li><li>L”fastfat”, </li><li><strong>}****;</strong></li><li></li></ol><p>用户可以通过这些函数就读写改fat分区啦。</p><p>那么FatOpenVolume都干了什么呢。</p><p>这个函数简单来说就是根据分区内容填写了Volume结构，已经算是一个分区的具体实现细节了，和整体架构无关，不多说了。这个函数在freeldr\freeldr\fs\fat.c中。</p><p><strong><strong>打开文件时做了什么</strong></strong></p><p>上一篇文章中还有一个地方没说，就是打开设备并创建完文件的句柄后，ArcOpen调用了文件对应的FileData.FuncTable.Open。对于fat分区而言这个函数是FatOpen(freeldr\freeldr\fs\fat.c). 这个函数也是和分区结构有关的了，有一点比较重要就是函数最后调用了FsSetDeviceSpecific把一个和文件相关的内部结构与文件句柄相关联。以后使用FatRead对文件句柄进行读操作时直接就可以获得这个结构啦。</p><ol><li>LONG FatOpen**(<strong>CHAR***</strong> Path, OPENMODE OpenMode, ULONG***** FileId**)**</li><li><strong>{</strong></li><li><strong>.<strong><strong>.</strong></strong>.<strong><strong>.</strong></strong>.****.</strong></li><li></li><li>// 根据文件的FileId获得文件所在的设备句柄FileData.DeviceId, 从而获得FatMount时生成的Volume结构。</li><li>DeviceId <strong>=</strong> FsGetDeviceId**(<em><strong><strong><strong>FileId</strong>)</strong></strong>;</em>*</li><li>FatVolume <strong>=</strong> FatVolumes**[<strong>DeviceId</strong>]****;**</li><li>// 从DeviceId设备中读取并查询fat表，判断path表示的文件是否存在</li><li><em>RtlZeroMemory</em><strong>(<strong><strong>&amp;<strong>TempFileInfo, <em>sizeof</em></strong>(<strong>TempFileInfo</strong>)****)</strong></strong>;</strong></li><li>ret <strong>=</strong> FatLookupFile**(*<em>FatVolume, Path, DeviceId, <strong>&amp;<strong>TempFileInfo</strong>)</strong>*</em>;**</li><li><em>if</em> <strong>(<strong>ret <strong>!****=</strong> ESUCCESS</strong>)</strong></li><li><em>return</em> ENOENT**;**</li><li>// 判断是否是目录</li><li>IsDirectory <strong>=</strong> <strong>(<strong>TempFileInfo</strong>.<strong>Attributes <strong>&amp;</strong> ATTR_DIRECTORY</strong>)</strong> <strong>!****=</strong> 0**;**</li><li><em>if</em> <strong>(<strong>IsDirectory <strong>&amp;****&amp;</strong> OpenMode <strong>!****=</strong> OpenDirectory</strong>)</strong></li><li><em>return</em> EISDIR**;**</li><li><em>else</em> <em>if</em> <strong>(<strong>**!*<em>IsDirectory <strong>&amp;</strong>*</em>&amp;** OpenMode <strong>!</strong></strong>=** OpenReadOnly**)</strong></li><li><em>return</em> ENOTDIR**;**</li><li>// 生成FAT_FILE_INFO结构，里面存放了文件的信息(开始的扇区等)</li><li>FileHandle <strong>=</strong> MmHeapAlloc**(<strong><em>sizeof</em></strong>(<strong>FAT_FILE_INFO</strong>)<strong><strong>)</strong></strong>;**</li><li><em>if</em> <strong>(****!<strong>FileHandle</strong>)</strong></li><li><em>return</em> ENOMEM**;**</li><li>RtlCopyMemory**(*<em>FileHandle, <strong>&amp;<strong>TempFileInfo, <em>sizeof</em></strong>(<strong>FAT_FILE_INFO</strong>)****)*</strong></em>;**</li><li>FileHandle**-****&gt;<strong>Volume <strong>=</strong> FatVolume</strong>;**</li><li>// 把这个结构和文件对应的FileData.Specific关联。之后进行FatRead等操作时可以直接获得这个结构了</li><li>FsSetDeviceSpecific**(<em><strong><strong><strong>FileId, FileHandle</strong>)</strong></strong>;</em>*</li><li><em>return</em> ESUCCESS**;**</li><li><strong>}</strong></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ReactOS-Freeldr磁盘及文件管理</title>
      <link href="/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086/"/>
      <url>/2011/06/02/reactos-freeldre7a381e79b98e58f8ae69687e4bbb6e7aea1e79086/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Freeldr提供了对fat12、fat32、fatx、ntfs等文件系统的只读功能。这部分代码主要集中在boot\freeldr\freeldr\fs\fs.c文件中。<br>首先计算机加电后会把mbr读取到物理内存的0x7c00位置，mbr搜索活动分区并加载活动分区根目录下的Freeldr.sys文件。加载后跳入Freeldr入口start。Freeldr进行32为初始化后跳入主初始化函数BootMain(boot\freeldr\freeldr\Freeldr.c)中。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">BootMain</span><span class="params">(LPSTR CmdLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">MachInit</span>(CmdLine);</span><br><span class="line"><span class="built_in">FsInit</span>();</span><br><span class="line">......</span><br><span class="line"><span class="built_in">RunLoader</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>BootMain会对硬件(MachInit)和文件系统(FsInit)进行检测和初始化。所有准备工作进行完毕后就会调用RunLoader进行系统的加载工作。<br>Fs初始化和DEVICE、FILEDATA结构<br>下面看一下文件系统的初始化 FsInit(boot\freeldr\freeldr\fs\fs.c)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FsInit</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ULONG i;</span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(FileData, <span class="built_in"><span class="keyword">sizeof</span></span>(FileData));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FDS; i++)</span><br><span class="line">FileData[i].DeviceId = (ULONG)<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">InitializeListHead</span>(&amp;DeviceListHead);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>FsInit初始化FileData数组。和一个和磁盘分区相关的链表DeviceListHead。<br>首先fs.c维护了一个MAX_FDS(60)大小的数组 static FILEDATA FileData[MAX_FDS];  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDEVVTBL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ARC_CLOSE Close;</span><br><span class="line">ARC_GET_FILE_INFORMATION GetFileInformation;</span><br><span class="line">ARC_OPEN Open;</span><br><span class="line">ARC_READ Read;</span><br><span class="line">ARC_SEEK Seek;</span><br><span class="line">LPCWSTR ServiceName;</span><br><span class="line">&#125; DEVVTBL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagFILEDATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ULONG DeviceId;            <span class="comment">// 文件所在磁盘的磁盘文件句柄, 同样也是FileData的索引</span></span><br><span class="line">ULONG ReferenceCount;       <span class="comment">// 引用计数</span></span><br><span class="line"><span class="keyword">const</span> DEVVTBL* FuncTable;    <span class="comment">// 对文件进行读写的指针</span></span><br><span class="line"><span class="keyword">const</span> DEVVTBL* FileFuncTable; <span class="comment">// 对文件进行读写的函数数组</span></span><br><span class="line">VOID* Specific;             <span class="comment">// 文件系统自定义指针</span></span><br><span class="line">&#125; FILEDATA;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>每一个成功打开的文件会返回一个文件句柄，这个句柄实际上就是FileData数组的索引。所以每个打开的文件都有一个对应的FileData。这个结构就类似windows中的FILE_OBJECT<br>FileData中DeviceId是文件所在磁盘的句柄。这个句柄同样也是FileData数组的索引，通过这个句柄可以找到”磁盘文件”，对”磁盘文件”的读写就是直接对相应的磁盘或磁盘分区的读写。类似Windows中直接对磁盘分区进行CreateFile返回的句柄。”磁盘文件”的DeviceId没有意义。<br>ReferenceCount是该文件的引用计数。<br>FuncTable这是一个函数数组指针，里面存放了对文件进行读写、SEEK等操作的函数指针。<br>FileFuncTable只对”磁盘文件”有意义。当Freeldr确定了磁盘文件对应的分区的分区格式后，会把与分区格式相关的函数指针数组放到这个字段里面。如Fat12分区”磁盘文件”的FileFuncTable字段存放的就是FatFuncTable指针。<br>Specific存放于文件有关的结构。磁盘文件就是DISKCONTEXT指针，fat12下的文件就是FAT_FILE_INFO指针 等等。<br>之后是DeviceListHead，这是DEVICE结构的链表头  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDEVICE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LIST_ENTRY ListEntry;        <span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">const</span> DEVVTBL* FuncTable;    <span class="comment">// 操作该分区的函数表</span></span><br><span class="line">CHAR* Prefix;              <span class="comment">// 分区对应的ArcName</span></span><br><span class="line">ULONG DeviceId;            <span class="comment">// FILEDATA中该分区对应的句柄</span></span><br><span class="line">ULONG ReferenceCount;      <span class="comment">// 引用计数</span></span><br><span class="line">&#125; DEVICE;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>用户电脑中的每一个硬盘和硬盘中的每一分区都对应了一个DEVICE结构。<br>FuncTable里面存放了对该分区进行读写等操作的指针，对于硬盘而言这个数组就是DiskVtbl。<br>Prefix是该分区或硬盘的ArcName。(如multi(0)disk(0)rdisk(0)partition(0))。Freeldr中的文件路径都是Arc形式的路径。而且0号分区代表整个硬盘，真正的分区从1号开始。如multi(0)disk(0)rdisk(0)partition(0)便代表第0块硬盘本身。multi(0)disk(0)rdisk(0)partition(1)代表第0块硬盘的第0个分区。<br>通过DeviceId字段可以找到该DEVICE的文件句柄。这个字段和FILEDATA相互配合，使系统可以遍历DEVICE结构快速找到某个分区的文件句柄。<br>DEVICE(磁盘及分区)的检测<br>上面说到Freeldr操作的路径都是存储在DEVICE结构中的ArcPath。那么这些DEVICE是怎么来的呢？<br>首先我们看一下DEVICE的注册函数，FsRegisterDevice(boot\freeldr\freeldr\fs\fs.c)  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FsRegisterDevice</span><span class="params">(CHAR* Prefix, <span class="keyword">const</span> DEVVTBL* FuncTable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DEVICE* pNewEntry;</span><br><span class="line">ULONG dwLength;</span><br><span class="line">dwLength = <span class="built_in">strlen</span>(Prefix) + <span class="number">1</span>;</span><br><span class="line">pNewEntry = <span class="built_in">MmHeapAlloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DEVICE) + dwLength);</span><br><span class="line"><span class="keyword">if</span> (!pNewEntry)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">pNewEntry-&gt;FuncTable = FuncTable;</span><br><span class="line">pNewEntry-&gt;ReferenceCount = <span class="number">0</span>;</span><br><span class="line">pNewEntry-&gt;Prefix = (CHAR*)(pNewEntry + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(pNewEntry-&gt;Prefix, Prefix, dwLength);</span><br><span class="line"><span class="built_in">InsertHeadList</span>(&amp;DeviceListHead, &amp;pNewEntry-&gt;ListEntry);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这么函数非常简单。Prefix就是Arc路径，FuncTable是操作这个分区（磁盘）对应的函数数组。FsRegisterDevice生成了一个DEVICE结构，把ArcName和FuncTable复制进去。之后连入了DeviceListHead链表。<br>那么又是谁调用的FsRegisterDevice呢？是DetectBiosDisks(boot\freeldr\freeldr\arch\i386\hardware.c)函数。虽然这一部分已经不属于FS的范畴，还是在这里简单讲一下便于理解。这里我略去了不必要的代码。<br>DetectBiosDisks的调用顺序是 RunLoader -&gt; MachHwDetect (PcHwDetect)-&gt; DetectISABios -&gt; DetectBiosDisks</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> VOID</span><br><span class="line"><span class="built_in">DetectBiosDisks</span>(PCONFIGURATION_COMPONENT_DATA BusKey)</span><br><span class="line">&#123;</span><br><span class="line">BOOLEAN BootDriveReported = FALSE;</span><br><span class="line">ULONG i;</span><br><span class="line">ULONG DiskCount = <span class="built_in">GetDiskCount</span>(BusKey);</span><br><span class="line">CHAR BootPath[<span class="number">512</span>];</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DiskCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">ULONG Size;</span><br><span class="line">CHAR Identifier[<span class="number">20</span>];</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (BootDrive == <span class="number">0x80</span> + i)</span><br><span class="line">BootDriveReported = TRUE;</span><br><span class="line"><span class="comment">/* Get disk values */</span></span><br><span class="line"><span class="built_in">GetHarddiskIdentifier</span>(Identifier, <span class="number">0x80</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>首先使用GetDiskCount从Freeldr注册表的System键中读取硬盘总数。System键的初始化在DetectSystem(freeldr\freeldr\arch\i386\hardware.c)中，一会儿再看。<br>于是进入一个for循环，为每个硬盘调用GetHarddiskIdentifier函数。在BIOS中硬盘号是从0x80开始的，所以GetHarddiskIdentifier的硬盘号加了0x80。<br>GetHarddiskIdentifier的作用是为制定硬盘生成一个唯一的ID，并通过Identifier参数返回。但这个函数名起得并不好，因为生成ID其实只是这个函数的功能之一。另外的一大功能是检测硬盘，并且为硬盘本身和硬盘分区调用FsRegisterDevice函数进行注册。通过这个注册后硬盘才能真正被文件系统识别。<br>freeldr\freeldr\arch\i386\hardware.c中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> VOID</span><br><span class="line"><span class="built_in">GetHarddiskIdentifier</span>(PCHAR Identifier,</span><br><span class="line">ULONG DriveNumber)</span><br><span class="line">&#123;</span><br><span class="line">PMASTER_BOOT_RECORD Mbr;</span><br><span class="line">ULONG *Buffer;</span><br><span class="line">ULONG i;</span><br><span class="line">ULONG Checksum;</span><br><span class="line">ULONG Signature;</span><br><span class="line">CHAR ArcName[<span class="number">256</span>];</span><br><span class="line">PARTITION_TABLE_ENTRY PartitionTableEntry;</span><br><span class="line"><span class="comment">/* Read the MBR */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">MachDiskReadLogicalSectors</span>(DriveNumber, <span class="number">0ULL</span>, <span class="number">1</span>, (PVOID)DISKREADBUFFER))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DPRINTM</span>(DPRINT_HWDETECT, <span class="string">&quot;Reading MBR failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Buffer = (ULONG*)DISKREADBUFFER;</span><br><span class="line">Mbr = (PMASTER_BOOT_RECORD)DISKREADBUFFER;</span><br><span class="line">Signature = Mbr-&gt;Signature;</span><br><span class="line"><span class="built_in">DPRINTM</span>(DPRINT_HWDETECT, <span class="string">&quot;Signature: %x\n&quot;</span>, Signature);</span><br><span class="line"><span class="comment">/* Calculate the MBR checksum */</span></span><br><span class="line">Checksum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Checksum += Buffer[i];</span><br><span class="line">&#125;</span><br><span class="line">Checksum = ~Checksum + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">DPRINTM</span>(DPRINT_HWDETECT, <span class="string">&quot;Checksum: %x\n&quot;</span>, Checksum);</span><br><span class="line"><span class="comment">/* Fill out the ARC disk block */</span></span><br><span class="line">reactos_arc_disk_info[reactos_disk_count].Signature = Signature;</span><br><span class="line">reactos_arc_disk_info[reactos_disk_count].CheckSum = Checksum;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)&quot;</span>, reactos_disk_count);</span><br><span class="line"><span class="built_in">strcpy</span>(reactos_arc_strings[reactos_disk_count], ArcName);</span><br><span class="line">reactos_arc_disk_info[reactos_disk_count].ArcName =</span><br><span class="line">reactos_arc_strings[reactos_disk_count];</span><br><span class="line">reactos_disk_count++;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)partition(0)&quot;</span>, DriveNumber - <span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">FsRegisterDevice</span>(ArcName, &amp;DiskVtbl);</span><br><span class="line"><span class="comment">/* Add partitions */</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">DiskReportError</span>(FALSE);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">DiskGetPartitionEntry</span>(DriveNumber, i, &amp;PartitionTableEntry))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (PartitionTableEntry.SystemIndicator != PARTITION_ENTRY_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)partition(%lu)&quot;</span>, DriveNumber - <span class="number">0x80</span>, i);</span><br><span class="line"><span class="built_in">FsRegisterDevice</span>(ArcName, &amp;DiskVtbl);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DiskReportError</span>(TRUE);</span><br><span class="line"><span class="comment">/* Convert checksum and signature to identifier string */</span></span><br><span class="line">Identifier[<span class="number">0</span>] = Hex[(Checksum &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">1</span>] = Hex[(Checksum &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">2</span>] = Hex[(Checksum &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">3</span>] = Hex[(Checksum &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">4</span>] = Hex[(Checksum &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">5</span>] = Hex[(Checksum &gt;&gt; <span class="number">8</span> ) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">6</span>] = Hex[(Checksum &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">7</span>] = Hex[Checksum &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">8</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">Identifier[<span class="number">9</span>] = Hex[(Signature &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">10</span>] = Hex[(Signature &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">11</span>] = Hex[(Signature &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">12</span>] = Hex[(Signature &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">13</span>] = Hex[(Signature &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">14</span>] = Hex[(Signature &gt;&gt; <span class="number">8</span> ) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">15</span>] = Hex[(Signature &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">16</span>] = Hex[Signature &amp; <span class="number">0x0F</span>];</span><br><span class="line">Identifier[<span class="number">17</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">Identifier[<span class="number">18</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">Identifier[<span class="number">19</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>函数首先使用MachDiskReadLogicalSectors读取指定硬盘的MBR。对于PC机而言MachDiskReadLogicalSectors使用int 13h中断实现对硬盘的读操作。里面包括了16、32位代码的互转，和本节内容无关，以后再做说明。<br>MBR结构为。详细信息可以参考(<a href="http://en.wikipedia.org/wiki/Master_boot_record">http://en.wikipedia.org/wiki/Master_boot_record</a>)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MASTER_BOOT_RECORD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">UCHAR        MasterBootRecordCodeAndData[<span class="number">0x1b8</span>];   <span class="comment">/* 0x000 */</span></span><br><span class="line">ULONG        Signature;          <span class="comment">/* 0x1B8 */</span></span><br><span class="line">USHORT        Reserved;          <span class="comment">/* 0x1BC */</span></span><br><span class="line">PARTITION_TABLE_ENTRY   PartitionTable[<span class="number">4</span>];        <span class="comment">/* 0x1BE */</span></span><br><span class="line">USHORT        MasterBootRecordMagic;        <span class="comment">/* 0x1FE */</span></span><br><span class="line">&#125; MASTER_BOOT_RECORD, *PMASTER_BOOT_RECORD;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>GetHarddiskIdentifier在获取了Signature、计算了Checksum后 。<br>sprintf(ArcName, “multi(0)disk(0)rdisk(%lu)partition(0)”, DriveNumber - 0x80);<br>FsRegisterDevice(ArcName, &amp;DiskVtbl);<br>生成对应硬盘的ArcName，使用FsRegisterDevice注册这块硬盘，这个函数我们已经看过。注意这里Partition为0，所以0号分区实际表示硬盘本身。<br>之后</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">DiskGetPartitionEntry</span>(DriveNumber, i, &amp;PartitionTableEntry))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (PartitionTableEntry.SystemIndicator != PARTITION_ENTRY_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(ArcName, <span class="string">&quot;multi(0)disk(0)rdisk(%lu)partition(%lu)&quot;</span>, DriveNumber - <span class="number">0x80</span>, i);</span><br><span class="line"><span class="built_in">FsRegisterDevice</span>(ArcName, &amp;DiskVtbl);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>DiskGetParititionEntry将会解析DriveNumber对应磁盘的分区表，填充第i个分区的信息到PartitionTableEntry结构。如果分区存在则使用FsRegisterDevice注册分区。<br>使用刚才计算的CheckSum和Signature组合一个ID返回给调用者。其实这个ID没有被使用过。。。<br>最后看一下调用FsRegisterDevice时的第二个参数DiskVtbl  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> DEVVTBL DiskVtbl = &#123;</span><br><span class="line">DiskClose,</span><br><span class="line">DiskGetFileInformation,</span><br><span class="line">DiskOpen,</span><br><span class="line">DiskRead,</span><br><span class="line">DiskSeek,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这里面包含了对磁盘扇区读写的全部函数。我们之后再介绍。<br>至此硬盘的及硬盘分区的注册完成。<br>执行完DetectBiosDisks后，DeviceListHead里面就存放了当前计算机所有的磁盘和分区对应的DEVICE结构。<br>文件系统的识别和文件的打开<br>这时Fs模块已经知道的硬盘数量，分区信息。下面来看看一个文件的打开流程。<br>首先，Freeldr使用的是Arc路径，IDE硬盘以multi(0)disk(0)rdisk(n)开头，文件也是以Arc路径表示的。打开文件的函数在Freeldr\Freeldr\fs\fs.c中。这函数比较长，我们分段阅读。<br>Freeldr\Freeldr\fs\fs.c</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">ArcOpen</span><span class="params">(CHAR* Path, OPENMODE OpenMode, ULONG* FileId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">*FileId = MAX_FDS;</span><br><span class="line"><span class="comment">/* Search last &#x27;)&#x27;, which delimits device and path */</span></span><br><span class="line">FileName = <span class="built_in">strrchr</span>(Path, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!FileName)</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line">FileName++;</span><br><span class="line"><span class="comment">/* Count number of &quot;()&quot;, which needs to be replaced by &quot;(0)&quot; */</span></span><br><span class="line">dwCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (p = Path; p != FileName; p++)</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">&#x27;(&#x27;</span> &amp;&amp; *(p + <span class="number">1</span>) == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">dwCount++;</span><br><span class="line"><span class="comment">/* Duplicate device name, and replace &quot;()&quot; by &quot;(0)&quot; (if required) */</span></span><br><span class="line">dwLength = FileName - Path + dwCount;</span><br><span class="line"><span class="keyword">if</span> (dwCount != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">DeviceName = <span class="built_in">MmHeapAlloc</span>(FileName - Path + dwCount);</span><br><span class="line"><span class="keyword">if</span> (!DeviceName)</span><br><span class="line"><span class="keyword">return</span> ENOMEM;</span><br><span class="line"><span class="keyword">for</span> (p = Path, q = DeviceName; p != FileName; p++)</span><br><span class="line">&#123;</span><br><span class="line">*q++ = *p;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">&#x27;(&#x27;</span> &amp;&amp; *(p + <span class="number">1</span>) == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">*q++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">DeviceName = Path;</span><br><span class="line">......</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这个函数有三个参数Path是文件名的Arc路径，如multi(0)disk(0)rdisk(0)partition(1)Freeldr.sys就表示C盘中的Freeldr.sys文件。<br>OpenMode是打开模式(OpenReadOnly、OpenReadWrite等)。<br>如果打开成功，文件句柄将通过FileId参数返回。<br>首先这一部分代码分理出Arc磁盘路径中的”()”替换成”(0)”并存入DeviceName中，如multi()disk()rdisk()partition(1)Freeldr.sys处理后，DeviceName将指向multi(0)disk(0)rdisk(0)partition(1)。注意这个DeviceName是不以NULL结尾的。。。这是个很蛋疼的设计。<br>FileName会指向Arc路径中的文件名部分，上面的例子将是Freeldr.sys。<br>文件打开分为两步，第一步是开个文件所在的设备、创建设备的句柄。第二部才是打开文件本身。<br>这里是第一步打开设备的代码。  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">pEntry = DeviceListHead.Flink;</span><br><span class="line"><span class="keyword">while</span> (pEntry != &amp;DeviceListHead)</span><br><span class="line">&#123;</span><br><span class="line">pDevice = <span class="built_in">CONTAINING_RECORD</span>(pEntry, DEVICE, ListEntry);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(pDevice-&gt;Prefix, DeviceName, dwLength) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* OK, device found. It is already opened? */</span></span><br><span class="line"><span class="keyword">if</span> (pDevice-&gt;ReferenceCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Search some room for the device */</span></span><br><span class="line"><span class="keyword">for</span> (DeviceId = <span class="number">0</span>; DeviceId &lt; MAX_FDS; DeviceId++)</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FuncTable)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (DeviceId == MAX_FDS)</span><br><span class="line"><span class="keyword">return</span> EMFILE;</span><br><span class="line"><span class="comment">/* Try to open the device */</span></span><br><span class="line">FileData[DeviceId].FuncTable = pDevice-&gt;FuncTable;</span><br><span class="line">ret = pDevice-&gt;FuncTable-&gt;<span class="built_in">Open</span>(pDevice-&gt;Prefix, DeviceOpenMode, &amp;DeviceId);</span><br><span class="line"><span class="keyword">if</span> (ret != ESUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!*FileName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Done, caller wanted to open the raw device */</span></span><br><span class="line">*FileId = DeviceId;</span><br><span class="line">pDevice-&gt;ReferenceCount++;</span><br><span class="line"><span class="keyword">return</span> ESUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Try to detect the file system */</span></span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">FatMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">NtfsMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">Ext2Mount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Error, unable to detect file system */</span></span><br><span class="line">pDevice-&gt;FuncTable-&gt;<span class="built_in">Close</span>(DeviceId);</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">pDevice-&gt;DeviceId = DeviceId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">DeviceId = pDevice-&gt;DeviceId;</span><br><span class="line">&#125;</span><br><span class="line">pDevice-&gt;ReferenceCount++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pEntry = pEntry-&gt;Flink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pEntry == &amp;DeviceListHead)</span><br><span class="line"><span class="keyword">return</span> ENODEV;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>一个循环，遍历DEVICE链表，找到DEVICE-&gt;Prefix (磁盘、分区的Arc路径，上一节说过)和刚刚分解出来的DeviceName相等的节点。如果没有则函数直接失败。<br>找到DEVICE节点后判断DEVICE-&gt;ReferenceCount是否为0。这个代表该DEVICE被打开的次数，如果ReferenceCount不为0，说明DEVICE已经被打开。那个直接从Device-&gt;DeviceId中获得设备的文件句柄。可以看出无论打开一个设备多少次，只会有ReferenceCount的变化，而句柄都是相同的。所以如果设备打开两次，SEEK时会相互影响。读写之前最好重新调用SEEK函数。<br>当DEVICE-&gt;ReferenceCount为0时是Freeldr需要调用进行打开和文件系统的识别。我们仔细读读。  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Search some room for the device */</span></span><br><span class="line"><span class="keyword">for</span> (DeviceId = <span class="number">0</span>; DeviceId &lt; MAX_FDS; DeviceId++)</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FuncTable)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (DeviceId == MAX_FDS)</span><br><span class="line"><span class="keyword">return</span> EMFILE;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>首先在FileData数组中找到空闲项，数组的索引即将成为设备句柄。  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Try to open the device */</span></span><br><span class="line">FileData[DeviceId].FuncTable = pDevice-&gt;FuncTable;</span><br><span class="line">ret = pDevice-&gt;FuncTable-&gt;<span class="built_in">Open</span>(pDevice-&gt;Prefix, DeviceOpenMode, &amp;DeviceId);</span><br><span class="line"><span class="keyword">if</span> (ret != ESUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!*FileName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Done, caller wanted to open the raw device */</span></span><br><span class="line">*FileId = DeviceId;</span><br><span class="line">pDevice-&gt;ReferenceCount++;</span><br><span class="line"><span class="keyword">return</span> ESUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>之后把DEVICE中存储的设别操作函数数组FuncTable赋值给对应FileData中的FuncTable。之后对该句柄的读写操作将直接传递给FileData.FuncTable中的函数。<br>调用FuncTable-&gt;Open打开设备。上面我们看过这个函数实际是freeldr\freeldr\arch\i386\hardware.c中的DiskOpen。<br>打开成功后，如果FileName（需要打开的文件名）为空，说明这次请求只打开设备，于是直接返回设备的句柄。<br>如果不为空，则下面开始识别分区格式，打开文件的操作。<br>在继续读ArcOpen函数前我们先看看DiskOpen在打开设备时都做了什么。  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ArcOpen -&gt; <span class="built_in">DiskOpen</span> (freeldr\freeldr\arch\i386\hardware.c)</span><br><span class="line"><span class="function"><span class="keyword">static</span> LONG <span class="title">DiskOpen</span><span class="params">(CHAR* Path, OPENMODE OpenMode, ULONG* FileId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DissectArcPath</span>(Path, FileName, &amp;DriveNumber, &amp;DrivePartition))</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line"><span class="keyword">if</span> (DrivePartition == <span class="number">0xff</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* This is a CD-ROM device */</span></span><br><span class="line">SectorSize = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SectorSize = <span class="number">512</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DrivePartition != <span class="number">0xff</span> &amp;&amp; DrivePartition != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DiskGetPartitionEntry</span>(DriveNumber, DrivePartition, &amp;PartitionTableEntry))</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line">SectorOffset = PartitionTableEntry.SectorCountBeforePartition;</span><br><span class="line">SectorCount = PartitionTableEntry.PartitionSectorCount;</span><br><span class="line">&#125;</span><br><span class="line">Context = <span class="built_in">MmHeapAlloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DISKCONTEXT));</span><br><span class="line"><span class="keyword">if</span> (!Context)</span><br><span class="line"><span class="keyword">return</span> ENOMEM;</span><br><span class="line">Context-&gt;DriveNumber = DriveNumber;</span><br><span class="line">Context-&gt;SectorSize = SectorSize;</span><br><span class="line">Context-&gt;SectorOffset = SectorOffset;</span><br><span class="line">Context-&gt;SectorCount = SectorCount;</span><br><span class="line">Context-&gt;SectorNumber = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">FsSetDeviceSpecific</span>(*FileId, Context);</span><br><span class="line"><span class="keyword">return</span> ESUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这个函数非常简单，使用DissectArcPath根据设备的Arc路径分解出文件名FileName、BIOS驱动器号DriveNumber、和分区号DrivePartition（第0个分区的编号是1，0代表整个硬盘）<br>之后确定扇区大小，分区开始的扇区号、分区扇区数等信息，存入DISKCONTEXT结构。使用FsSetDeviceSpecific和FildId相关联。<br>还记得FILEDATA的结构么？FsSetDeviceSpecific就是填充里面的Specific指针 ：）  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FsSetDeviceSpecific</span><span class="params">(ULONG FileId, VOID* Specific)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (FileId &gt;= MAX_FDS || !FileData[FileId].FuncTable)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">FileData[FileId].Specific = Specific;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>实际上DiskOpen的作用就是获得该设备（分区）的基本信息——BIOS驱动器号、扇区大小、开始扇区号、扇区数量和当前读写指针（SectorNumber）。生成DISKCONTENT结构使用FsSetDeviceSpecific和FileID绑定。<br>现在我们回到ArcOpen函数，希望你还记得 ：）  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Try to detect the file system */</span></span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">FatMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">NtfsMount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">FileData[DeviceId].FileFuncTable = <span class="built_in">Ext2Mount</span>(DeviceId);</span><br><span class="line"><span class="keyword">if</span> (!FileData[DeviceId].FileFuncTable)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Error, unable to detect file system */</span></span><br><span class="line">pDevice-&gt;FuncTable-&gt;<span class="built_in">Close</span>(DeviceId);</span><br><span class="line">FileData[DeviceId].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">pDevice-&gt;DeviceId = DeviceId;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>现在FileData[DeviceId]已经代表刚刚打开的设备了，开始挂载分区。啥叫挂载分区，就是让文件系统提供个接口，能让我们操作分区里面的文件。而这个接口就是个DEVVTBL指针，和直接操作硬盘的接口一样，只不过这次这个可以操作文件了。如果分区识别成功，XxxMount函数将会返回另外一个DEVVTBL指针数组，这个指针赋值给设备对象的FileFuncTable成员。使用这个指针数组就可以在文件级别操作了。比如打开freeldr.sys文件就可以调用FileData[DeviceId].FileFuncTable-&gt;open函数。FileFuncTable和FuncTable是不同的哦！ ：）<br>注意FileFuncTable其实是不直接使用的，这个指针的作用是为之后打开的文件对应的FileData.FileTable赋值。于是操作文件和操作磁盘都是用对应的FileData.FileTable，实现形式上的统一。而且这种架构还可以轻易的实现将一个文件虚拟成为一个分区，只要为文件对象调用XxxMount并且给FileFuncTable域赋值就可以了，非常易于扩展。Freeldr并没有实现这种功能，文件的FileData.FileFuncTable没有使用～<br>下面我们就来看看第二步，打开文件<br>首先为文件找一个空闲的FileData  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_FDS; i++)</span><br><span class="line"><span class="keyword">if</span> (!FileData[i].FuncTable)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i == MAX_FDS)</span><br><span class="line"><span class="keyword">return</span> EMFILE;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>跳过文件名开始的 “&quot; 字符  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*FileName == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">FileName++;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>我们前面说的，为FileData.FuncTable赋值。FileData.DeviceId是文件所在分区的句柄。FuncTable内部函数将通过这个句柄调用读写分区内容，为用户提供文件的读写接口。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FileData[i].FuncTable = FileData[DeviceId].FileFuncTable;</span><br><span class="line">FileData[i].DeviceId = DeviceId;</span><br><span class="line">*FileId = i;</span><br><span class="line">ret = FileData[i].FuncTable-&gt;<span class="built_in">Open</span>(FileName, OpenMode, FileId);</span><br><span class="line"><span class="keyword">if</span> (ret != ESUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">FileData[i].FuncTable = <span class="literal">NULL</span>;</span><br><span class="line">*FileId = MAX_FDS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>至此打开文件的操作结束。这里略去了XxxMount和文件的Open函数。以后再说。 ：）  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于文件ShareAccess</title>
      <link href="/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/"/>
      <url>/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我是真心太懒了，虽然平时也在研究一些东西，但是总是理解了就算了，没有把他们记录下来的想法。虽然不记录下来也不至于会忘记，但是人的记忆总是有限的我也不敢保证记忆完全不错。好不容易说服自己写点东西，就从今天看的那点东西写起吧。</p><p>（吐槽：我尽量把以后的文章写得详细以至于啰嗦，免得以后自己又看不懂了。）</p><p>什么是ShareAccess。我们做一个简单的实验，进入系统目录(一般就是C:\Windows)。在C:\Windows\system32\config中，复制一个SYSTEM文件，然后把文件粘贴到另一个地方。如果我们的系统正常，那么我们看到肯定是一个错误框。（图1）“无法复制 system: 文件正在被另一个人或程序使用。关闭任何可能使用这个文件的程序，重新试一次。”无论懂不懂编程，这样一个令人蛋疼的错误框应该会看过无数次吧。这里我就不解释Windows为什么要这么做，假设所有读者都是了解其中的原因了。这篇文章想介绍的是，Windows怎么做到“访问拒绝”的。简单的来说就是当一个进程打开该文件的时候ShareAccess中没有ShareRead属性，所以其他的进程无法访问他。</p><p><a href="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-51-31.png"><img src="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-51-31-300x225.png"></a></p><p>（图1）</p><p>在我们平时打开文件中（CreateFile）总是需要我们传入一个dwShareMode的参数。它有三个值分别是FILE_SHARE_DELETE，FILE_SHARE_READ，FILE_SHARE_WRITE。如果一个打开一个文件的时候，没有传入了FILE_SHARE_READ，那么如果有另一段代码对文件用FILE_READ_DATA权限打开的时候一定返回的是一个失败。其他两个SHARE也是一样。那么是不是设置了FILE_SHARE_READ，其他代码用FILE_READ_DATA权限打开该文件都会成功呢？答案是不一定，主要要看在这段代码CreateFile的dwShareMode。如果也设置的FILE_SHARE_READ，那么打开文件就会成功，否则返回一个SHARE错误。</p><p>（吐槽：上面说了一堆，还是没进入正题，貌似有点太详细了。接下来才是重头戏。）</p><p>来看看NTFS文件系统是怎么来Check权限的。<br>每个文件打开的时候系统会为文件分配一个FILE_OBJECT（文件对象）。在这里我们主要关注的是以下几个域。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nt!_FILE_OBJECT</span><br><span class="line">...</span><br><span class="line">+0x00c FsContext        : Ptr32 Void</span><br><span class="line">...</span><br><span class="line">+0x026 ReadAccess       : UChar</span><br><span class="line">+0x027 WriteAccess      : UChar</span><br><span class="line">+0x028 DeleteAccess     : UChar</span><br><span class="line">+0x029 SharedRead       : UChar</span><br><span class="line">+0x02a SharedWrite      : UChar</span><br><span class="line">+0x02b SharedDelete     : UChar</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>熟悉NTFS文件系统的同学都知道FsContext实际上是对应着一个SCB。SCB的数据结构是未公开的，所以只有逆向或者通过其他途径获得。而这篇文章只需要关注的是SCB的SHARE_ACCESS。SHARE_ACCESS在SCB的0x60的偏移处，这个和NT的SCB有些不同。SHARE_ACCESS的数据结构是这样</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SHARE_ACCESS</span> &#123;</span></span><br><span class="line">ULONG OpenCount;</span><br><span class="line">ULONG Readers;</span><br><span class="line">ULONG Writers;</span><br><span class="line">ULONG Deleters;</span><br><span class="line">ULONG SharedRead;</span><br><span class="line">ULONG SharedWrite;</span><br><span class="line">ULONG SharedDelete;</span><br><span class="line">&#125; SHARE_ACCESS, *PSHARE_ACCESS;</span><br></pre></td></tr></table></figure><p>这个就是这篇文章的关键。</p><p>当一个文件被打开的时候，系统会初始化这个数据结构。根据CreateFile的权限设置来填充这个结构。<br>比如DesiredAccess中设置了FILE_READ_DATA，那么Readers，OpenCount就会增加1，如果在此同时设置了ShareMode为FILE_SHARE_READ，那么SharedRead也会加1。同时FILE_OBJECT的ReadAccess和SharedRead会被设置为TRUE。那么在文件被关闭的时候，如果FILE_OBJECT的ReadAccess和SharedRead为TRUE，那么SHARE_ACCESS的Readers，OpenCount，SharedRead就会减1。</p><p>在进程准备去打开一个已经打开的文件时，文件系统会做一系列的检查，包括文件权限（比如如果是只读文件，你却想要写权限，这样就会失败），安全描述符，以及共享权限（ShareAccess）。假设前面两个都符合要求，那么就到了共享权限的检查了。</p><p>还是以刚才那个SYSTEM文件为例，他打开的权限是FILE_READ_DATA，FILE_WRITE_DATA，DELETE。那么SHARE_ACCESS的OpenCount，Readers，Writers，Deleters都为1，而完全没有Share的意图，所以其他的域都是0。</p><p>当有另外一段代码去试图用FILE_READ_DATA权限打开这个文件的时候，那么文件系统就会去检查第一个打开这个文件的操作共享权限。这时的OpenCount是1，SharedRead是0，他会发现SharedRead小于OpenCount，那么他认为这个文件并没有SHARE_READ，所以参数检查返回失败，你会得到一个共享错误。这就是为什么我们复制粘贴SYSTEM文件的时候会失败。</p><p>原因分析到这里就结束了。但是我就这样满足了么？显然我没那么容易满足滴~</p><p>我想做的就是复制出这个SYSTEM文件，实际上网上已经有很多做法，什么底层磁盘解析读取数据，句柄复制大法。而我这次是修改底层SCB的ShareAccess来达到复制的目的。如果读懂了上面的原理，看下面这段代码就很轻松了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kfile File;</span><br><span class="line">ns = File.<span class="built_in">Create</span>(FILENAME, FILE_OPEN, FILE_READ_ATTRIBUTES, <span class="number">0</span>);</span><br><span class="line">FileObj = File.<span class="built_in">GetObject</span>();</span><br><span class="line">ShareAccess = (SHARE_ACCESS *)((ULONG)FileObj-&gt;FsContext + Offset);</span><br><span class="line">ShareAccess-&gt;SharedRead = ShareAccess-&gt;Readers;</span><br><span class="line">File.<span class="built_in">Release</span>();</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>OK，编写好测试代码，生成一个驱动。运行即可。接下来就是见证奇迹的时刻了。还是用同样的方法复制看看，完全没有问题了。（图2）</p><p><a href="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-53-40.png"><img src="/uploads/2011/05/Windows-XP-Professional-2011-05-23-01-53-40-300x225.png"></a></p><p>（图2）</p><p>（吐槽：好久没写这么长的文章，写的我都崩溃了。说到写文章，我发现现在我如果拿起笔去写字，经常会发生提笔忘字的情况！！！天啊！！！）</p>]]></content>
      
      
      <categories>
          
          <category> NTInternals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> File System </tag>
            
            <tag> NTInternals </tag>
            
            <tag> NTFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让程序等待调试器附加</title>
      <link href="/2011/04/01/e8aea9e7a88be5ba8fe7ad89e5be85e8b083e8af95e599a8e99984e58aa0/"/>
      <url>/2011/04/01/e8aea9e7a88be5ba8fe7ad89e5be85e8b083e8af95e599a8e99984e58aa0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>有的时候出于一些目的，我们会希望程序等待调试器Attach上去以后才开始继续往前跑。例如，我们写了一堆console程序，同时又有个shell去调用这些console，而这个时候我们却想去调试shell运行起来的这个console。当然Windbg本身就有调试debugee子进程的功能，但是身为懒人，这种方式太麻烦。我还是更愿意加入几行代码解决这个问题。</p><p>要解决这个问题，原理上很简单。无非是程序运行初期不断的去检测本进程是否被调试，如果是就把自己断下来，如果不是继续等待。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WaitDebuggerAttach</span><span class="params">(DWORD Second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD CurSec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((!<span class="built_in">IsDebuggerPresent</span>()) &amp;&amp; (CurSec &lt; Second)) &#123;</span><br><span class="line">        </span><br><span class="line">        CurSec++;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsDebuggerPresent</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        __asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这个函数可以指定等待时间，如果Debugger Attach上去了，那么就断下来方便调试，否则会超时，正常执行。<br>这里我是用的IsDebuggerPresent这个API来获得进程的调试状态。实际上检测自己调试状态的方法很多，只不过这个用起来最方便而已。比如可以用测试断点异常的方法来检测自己的调试状态。  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckForDebugger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __try </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugBreak</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    __except(<span class="built_in">GetExceptionCode</span>() == EXCEPTION_BREAKPOINT ? </span><br><span class="line">             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No debugger is attached, so return FALSE </span></span><br><span class="line">        <span class="comment">// and continue.</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>本Blog的第一篇文章总算是出炉了~~~我太懒了哇~</p>]]></content>
      
      
      <categories>
          
          <category> Debugging </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello world!</title>
      <link href="/2011/02/28/hello-world/"/>
      <url>/2011/02/28/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>); </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
